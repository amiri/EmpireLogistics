#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/FatPacker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER';
  package App::FatPacker;
  
  use strict;
  use warnings FATAL => 'all';
  use 5.008001;
  use Getopt::Long;
  use Cwd qw(cwd);
  use File::Find qw(find);
  use File::Spec::Functions qw(
    catdir splitpath splitdir catpath rel2abs abs2rel
  );
  use File::Spec::Unix;
  use File::Copy qw(copy);
  use File::Path qw(mkpath rmtree);
  use B qw(perlstring);
  
  our $VERSION = '0.010001'; # 0.10.1
  
  $VERSION = eval $VERSION;
  
  sub call_parser {
    my $self = shift;
    my ($args, $options) = @_;
  
    local *ARGV = [ @{$args} ];
    $self->{option_parser}->getoptions(@$options);
  
    return [ @ARGV ];
  }
  
  sub lines_of {
    map +(chomp,$_)[1], do { local @ARGV = ($_[0]); <> };
  }
  
  sub stripspace {
    my ($text) = @_;
    $text =~ /^(\s+)/ && $text =~ s/^$1//mg;
    $text;
  }
  
  sub import {
    $_[1] && $_[1] eq '-run_script'
      and return shift->new->run_script;
  }
  
  sub new {
    bless {
      option_parser => Getopt::Long::Parser->new(
        config => [ qw(require_order pass_through bundling no_auto_abbrev) ]
      ),
    }, $_[0];
  }
  
  sub run_script {
    my ($self, $args) = @_;
    my @args = $args ? @$args : @ARGV;
    (my $cmd = shift @args || 'help') =~ s/-/_/g;
  
    if (my $meth = $self->can("script_command_${cmd}")) {
      $self->$meth(\@args);
    } else {
      die "No such command ${cmd}";
    }
  }
  
  sub script_command_help {
    print "Try `perldoc fatpack` for how to use me\n";
  }
  
  sub script_command_pack {
    my ($self, $args) = @_;
  
    my @modules = split /\r?\n/, $self->trace(args => $args);
    my @packlists = $self->packlists_containing(\@modules);
  
    my $base = catdir(cwd, 'fatlib');
    $self->packlists_to_tree($base, \@packlists);
  
    my $file = shift @$args;
    print $self->fatpack_file($file);
  }
  
  sub script_command_trace {
    my ($self, $args) = @_;
  
    $args = $self->call_parser($args => [
      'to=s' => \my $file,
      'to-stderr' => \my $to_stderr,
      'use=s' => \my @additional_use
    ]);
  
    die "Can't use to and to-stderr on same call" if $file && $to_stderr;
  
    $file ||= 'fatpacker.trace';
  
    if (!$to_stderr and -e $file) {
      unlink $file or die "Couldn't remove old trace file: $!";
    }
    my $arg = do {
      if ($to_stderr) {
        ">&STDERR"
      } elsif ($file) {
        ">>${file}"
      }
    };
  
    $self->trace(
      use => \@additional_use,
      args => $args,
      output => $arg,
    );
  }
  
  sub trace {
    my ($self, %opts) = @_;
  
    my $output = $opts{output};
    my $trace_opts = join ',', $output||'>&STDOUT', @{$opts{use}||[]};
  
    local $ENV{PERL5OPT} = join ' ',
      ($ENV{PERL5OPT}||()), '-MApp::FatPacker::Trace='.$trace_opts;
  
    my @args = @{$opts{args}||[]};
  
    if ($output) {
      # user specified output target, JFDI
      system $^X, @args;
      return;
    } else {
      # no output target specified, slurp
      open my $out_fh, "$^X @args |";
      return do { local $/; <$out_fh> };
    }
  }
  
  sub script_command_packlists_for {
    my ($self, $args) = @_;
    foreach my $pl ($self->packlists_containing($args)) {
      print "${pl}\n";
    }
  }
  
  sub packlists_containing {
    my ($self, $targets) = @_;
    my @targets = @$targets;
    {
      local @INC = ('lib', @INC);
      foreach my $t (@targets) {
        require $t;
      }
    }
    my @search = grep -d $_, map catdir($_, 'auto'), @INC;
    my %pack_rev;
    find({
      no_chdir => 1,
      wanted => sub {
        return unless /[\\\/]\.packlist$/ && -f $_;
        $pack_rev{$_} = $File::Find::name for lines_of $File::Find::name;
      },
    }, @search);
    my %found; @found{map +($pack_rev{Cwd::abs_path($INC{$_})}||()), @targets} = ();
    sort keys %found;
  }
  
  sub script_command_tree {
    my ($self, $args) = @_;
    my $base = catdir(cwd,'fatlib');
    $self->packlists_to_tree($base, $args);
  }
  
  sub packlists_to_tree {
    my ($self, $where, $packlists) = @_;
    rmtree $where;
    mkpath $where;
    foreach my $pl (@$packlists) {
      my ($vol, $dirs, $file) = splitpath $pl;
      my @dir_parts = splitdir $dirs;
      my $pack_base;
      PART: foreach my $p (0 .. $#dir_parts) {
        if ($dir_parts[$p] eq 'auto') {
          # $p-2 since it's <wanted path>/$Config{archname}/auto
          $pack_base = catpath $vol, catdir @dir_parts[0..$p-2];
          last PART;
        }
      }
      die "Couldn't figure out base path of packlist ${pl}" unless $pack_base;
      foreach my $source (lines_of $pl) {
        # there is presumably a better way to do "is this under this base?"
        # but if so, it's not obvious to me in File::Spec
        next unless substr($source,0,length $pack_base) eq $pack_base;
        my $target = rel2abs( abs2rel($source, $pack_base), $where );
        my $target_dir = catpath((splitpath $target)[0,1]);
        mkpath $target_dir;
        copy $source => $target;
      }
    }
  }
  
  sub script_command_file {
    my ($self, $args) = @_;
    my $file = shift @$args;
    print $self->fatpack_file($file);
  }
  
  sub fatpack_file {
    my ($self, $file) = @_;
  
    my $shebang = "";
    my $script = "";
    if ( defined $file and -r $file ) {
      ($shebang, $script) = $self->load_main_script($file);
    }
  
    my @dirs = $self->collect_dirs();
    my %files;
    $self->collect_files($_, \%files) for @dirs;
  
    return join "\n", $shebang, $self->fatpack_code(\%files), $script;
  }
  
  # This method can be overload in sub classes
  # For example to skip POD
  sub load_file {
    my ($self, $file) = @_;
    my $content = do {
      local (@ARGV, $/) = ($file);
      <>
    };
    close ARGV;
    return $content;
  }
  
  sub collect_dirs {
    my ($self) = @_;
    my $cwd = cwd;
    return grep -d, map rel2abs($_, $cwd), ('lib','fatlib');
  }
  
  sub collect_files {
    my ($self, $dir, $files) = @_;
    find(sub {
      return unless -f $_;
      !/\.pm$/ and warn "File ${File::Find::name} isn't a .pm file - can't pack this -- if you hoped we were going to, things may not be what you expected later\n" and return;
      $files->{File::Spec::Unix->abs2rel($File::Find::name,$dir)} =
        $self->load_file($File::Find::name);
    }, $dir);
  }
  
  sub load_main_script {
    my ($self, $file) = @_;
    open my $fh, "<", $file or die("Can't read $file: $!");
    my $shebang = <$fh>;
    my $script = join "", <$fh>;
    close $fh;
    unless ( index($shebang, '#!') == 0 ) {
      $script = $shebang . $script;
      $shebang = "";
    }
    return ($shebang, $script);
  }
  
  sub fatpack_start {
    return stripspace <<'  END_START';
      # This chunk of stuff was generated by App::FatPacker. To find the original
      # file's code, look for the end of this BEGIN block or the string 'FATPACK'
      BEGIN {
      my %fatpacked;
    END_START
  }
  
  sub fatpack_end {
    return stripspace <<'  END_END';
      s/^  //mg for values %fatpacked;
  
      my $class = 'FatPacked::'.(0+\%fatpacked);
      no strict 'refs';
      *{"${class}::files"} = sub { keys %{$_[0]} };
  
      if ($] < 5.008) {
        *{"${class}::INC"} = sub {
           if (my $fat = $_[0]{$_[1]}) {
             return sub {
               return 0 unless length $fat;
               $fat =~ s/^([^\n]*\n?)//;
               $_ = $1;
               return 1;
             };
           }
           return;
        };
      }
  
      else {
        *{"${class}::INC"} = sub {
          if (my $fat = $_[0]{$_[1]}) {
            open my $fh, '<', \$fat
              or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
            return $fh;
          }
          return;
        };
      }
  
      unshift @INC, bless \%fatpacked, $class;
    } # END OF FATPACK CODE
    END_END
  }
  
  sub fatpack_code {
    my ($self, $files) = @_;
    my @segments = map {
      (my $stub = $_) =~ s/\.pm$//;
      my $name = uc join '_', split '/', $stub;
      my $data = $files->{$_}; $data =~ s/^/  /mg; $data =~ s/(?<!\n)\z/\n/;
      '$fatpacked{'.perlstring($_).qq!} = '#line '.(1+__LINE__).' "'.__FILE__."\\"\\n".<<'${name}';\n!
      .qq!${data}${name}\n!;
    } sort keys %$files;
  
    return join "\n", $self->fatpack_start, @segments, $self->fatpack_end;
  }
  
  =encoding UTF-8
  
  =head1 NAME
  
  App::FatPacker - pack your dependencies onto your script file
  
  =head1 SYNOPSIS
  
    $ fatpack pack myscript.pl >myscript.packed.pl
  
  Or, with more step-by-step control:
  
    $ fatpack trace myscript.pl
    $ fatpack packlists-for `cat fatpacker.trace` >packlists
    $ fatpack tree `cat packlists`
    $ fatpack file myscript.pl >myscript.packed.pl
  
  See the documentation for the L<fatpack> script itself for more information.
  
  The programmatic API for this code is not yet fully decided, hence the 0.x
  release version. Expect that to be cleaned up for 1.0.
  
  =head1 SEE ALSO
  
  L<article for Perl Advent 2012|http://www.perladvent.org/2012/2012-12-14.html>
  
  =head1 SUPPORT
  
  Your current best avenue is to come annoy mst on #toolchain on
  irc.perl.org. There should be a non-IRC means of support by 1.0.
  
  =head1 AUTHOR
  
  Matt S. Trout (mst) <mst@shadowcat.co.uk>
  
  =head2 CONTRIBUTORS
  
  miyagawa - Tatsuhiko Miyagawa (cpan:MIYAGAWA) <miyagawa@bulknews.net>
  
  tokuhirom - MATSUNO★Tokuhiro (cpan:TOKUHIROM) <tokuhirom@gmail.com>
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  gugod - 劉康民 (cpan:GUGOD) <gugod@cpan.org>
  
  t0m - Tomas Doran (cpan:BOBTFISH) <bobtfish@bobtfish.net>
  
  sawyer - Sawyer X (cpan:XSAWYERX) <xsawyerx@cpan.org>
  
  ether - Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  dolmen - Olivier Mengué (cpan:DOLMEN) <dolmen@cpan.org>
  
  djerius - Diab Jerius (cpan:DJERIUS) <djerius@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG> <haarg@haarg.org>
  
  Many more people are probably owed thanks for ideas. Yet
  another doc nit to fix.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the App::FatPacker L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
  
  1;
  
APP_FATPACKER

$fatpacked{"App/FatPacker/Trace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_FATPACKER_TRACE';
  package App::FatPacker::Trace;
  
  use strict;
  use warnings FATAL => 'all';
  use B ();
  
  my $trace_file;
  my %initial_inc;
  
  sub import {
    my (undef, $file, @extras) = @_;
  
    $trace_file = $file || '>>fatpacker.trace';
    # For filtering out our own deps later.
    # (Not strictly required as these are core only and won't have packlists, but 
    # looks neater.)
    %initial_inc = %INC;
  
    # Use any extra modules specified
    eval "use $_" for @extras;
  
    B::minus_c;
  }
  
  CHECK {
    return unless $trace_file; # not imported
  
    open my $trace, $trace_file
        or die "Couldn't open $trace_file to trace to: $!";
  
    for my $inc (keys %INC) {
      next if exists $initial_inc{$inc};
      print $trace "$inc\n";
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  App::FatPacker::Trace - Tracing module usage using compilation checking
  
  =head1 SYNOPSIS
  
      # open STDERR for writing
      # will be like: open my $fh, '>', '&STDERR'...
      perl -MApp::FatPacker::Trace=>&STDERR myscript.pl
  
      # open a file for writing
      # will be like: open my $fh, '>>', 'fatpacker.trace'
      perl -MApp::FatPacker::Trace=>>fatpacker.trace myscript.pl
  
  =head1 DESCRIPTION
  
  This module allows tracing the modules being used by your code. It does that
  using clever trickery using the C<import> method, the C<CHECK> block and
  L<B>'s C<minus_c> function.
  
  When App::FatPacker::Trace is being used, the import() method will call
  C<B::minus_c> in order to set up the global compilation-only flag perl
  (the interpreter) has. This will prevent any other code from being run.
  
  Then in the C<CHECK> block which is reached at the end of the compilation
  phase (see L<perlmod>), it will gather all modules that have been loaded,
  using C<%INC>, and will write it to a file or to STDERR, determined by
  parameters sent to the C<import> method.
  
  =head1 METHODS
  
  =head2 import
  
  This method gets run when you just load L<App::FatPacker::Trace>. It will
  note the current C<%INC> and will set up the output to be written to, and
  raise the compilation-only flag, which will prevent anything from being
  run past that point. This flag cannot be unset, so this is most easily run
  from the command line as such:
  
      perl -MApp::FatPacker::Trace [...]
  
  You can control the parameters to the import using an equal sign, as such:
  
      # send the parameter "hello"
      perl -MApp::FatPacker::Trace=hello [...]
  
      # send the parameter ">&STDERR"
      perl -MApp::FatPacker::Trace=>&STDERR [...]
  
  The import method accepts a first parameter telling it which output to open
  and how. These are both sent in a single parameter.
  
      # append to mytrace.txt
      perl -MApp::FatPacker::Trace=>>mytrace.txt myscript.pl
  
      # write to STDERR
      perl -MApp::FatPacker::Trace=>&STDERR myscript.pl
  
  The import method accepts additional parameters of extra modules to load.
  It will then add these modules to the trace. This is helpful if you want
  to explicitly indicate additional modules to trace, even if they aren't
  used in your script. Perhaps you're conditionally using them, perhaps
  they're for additional features, perhaps they're loaded lazily, whatever
  the reason.
  
      # Add Moo to the trace, even if you don't trace it in myscript.pl
      perl -MApp::FatPacker::Trace=>&STDERR,Moo myscript.pl
  
APP_FATPACKER_TRACE

$fatpacked{"App/cpanminus.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANMINUS';
  package App::cpanminus;
  our $VERSION = "1.7001";
  
  =encoding utf8
  
  =head1 NAME
  
  App::cpanminus - get, unpack, build and install modules from CPAN
  
  =head1 SYNOPSIS
  
      cpanm Module
  
  Run C<cpanm -h> or C<perldoc cpanm> for more options.
  
  =head1 DESCRIPTION
  
  cpanminus is a script to get, unpack, build and install modules from
  CPAN and does nothing else.
  
  It's dependency free (can bootstrap itself), requires zero
  configuration, and stands alone. When running, it requires only 10MB
  of RAM.
  
  =head1 INSTALLATION
  
  There are several ways to install cpanminus to your system.
  
  =head2 Package management system
  
  There are Debian packages, RPMs, FreeBSD ports, and packages for other
  operation systems available. If you want to use the package management system,
  search for cpanminus and use the appropriate command to install. This makes it
  easy to install C<cpanm> to your system without thinking about where to
  install, and later upgrade.
  
  =head2 Installing to system perl
  
  You can also use the latest cpanminus to install cpanminus itself:
  
      curl -L http://cpanmin.us | perl - --sudo App::cpanminus
  
  This will install C<cpanm> to your bin directory like
  C</usr/local/bin> (unless you configured C<INSTALL_BASE> with
  L<local::lib>), so you probably need the C<--sudo> option.
  
  =head2 Installing to local perl (perlbrew)
  
  If you have perl in your home directory, which is the case if you use
  tools like L<perlbrew>, you don't need the C<--sudo> option, since
  you're most likely to have a write permission to the perl's library
  path. You can just do:
  
      curl -L http://cpanmin.us | perl - App::cpanminus
  
  to install the C<cpanm> executable to the perl's bin path, like
  C<~/perl5/perlbrew/bin/cpanm>.
  
  =head2 Downloading the standalone executable
  
  You can also copy the standalone executable to whatever location you'd like.
  
      cd ~/bin
      curl -LO http://xrl.us/cpanm
      chmod +x cpanm
      # edit shebang if you don't have /usr/bin/env
  
  This just works, but be sure to grab the new version manually when you
  upgrade because C<--self-upgrade> might not work for this.
  
  =head1 DEPENDENCIES
  
  perl 5.8 or later.
  
  =over 4
  
  =item *
  
  'tar' executable (bsdtar or GNU tar version 1.22 are recommended) or Archive::Tar to unpack files.
  
  =item *
  
  C compiler, if you want to build XS modules.
  
  =item *
  
  make
  
  =item *
  
  Module::Build (core in 5.10)
  
  =back
  
  =head1 QUESTIONS
  
  =head2 Another CPAN installer?
  
  OK, the first motivation was this: the CPAN shell runs out of memory (or swaps
  heavily and gets really slow) on Slicehost/linode's most affordable plan with
  only 256MB RAM. Should I pay more to install perl modules from CPAN? I don't
  think so.
  
  =head2 But why a new client?
  
  First of all, let me be clear that CPAN and CPANPLUS are great tools
  I've used for I<literally> years (you know how many modules I have on
  CPAN, right?). I really respect their efforts of maintaining the most
  important tools in the CPAN toolchain ecosystem.
  
  However, for less experienced users (mostly from outside the Perl community),
  or even really experienced Perl developers who know how to shoot themselves in
  their feet, setting up the CPAN toolchain often feels like yak shaving,
  especially when all they want to do is just install some modules and start
  writing code.
  
  =head2 Zero-conf? How does this module get/parse/update the CPAN index?
  
  It queries the CPAN Meta DB site at L<http://cpanmetadb.plackperl.org/>.
  The site is updated at least every hour to reflect the latest changes
  from fast syncing mirrors. The script then also falls back to query the
  module at L<http://metacpan.org/> using its wonderful API.
  
  Upon calling these API hosts, cpanm (1.6004 or later) will send the
  local perl versions to the server in User-Agent string by default. You
  can turn it off with C<--no-report-perl-version> option. Read more
  about the option with L<cpanm>, and read more about the privacy policy
  about this data collection at L<http://cpanmetadb.plackperl.org/#privacy>
  
  Fetched files are unpacked in C<~/.cpanm> and automatically cleaned up
  periodically.  You can configure the location of this with the
  C<PERL_CPANM_HOME> environment variable.
  
  =head2 Where does this install modules to? Do I need root access?
  
  It installs to wherever ExtUtils::MakeMaker and Module::Build are
  configured to (via C<PERL_MM_OPT> and C<PERL_MB_OPT>). So if you're
  using local::lib, then it installs to your local perl5
  directory. Otherwise it installs to the site_perl directory that
  belongs to your perl.
  
  cpanminus at a boot time checks whether you have configured
  local::lib, or have the permission to install modules to the site_perl
  directory.  If neither, it automatically sets up local::lib compatible
  installation path in a C<perl5> directory under your home
  directory. To avoid this, run the script as the root user, with
  C<--sudo> option or with C<--local-lib> option.
  
  =head2 cpanminus can't install the module XYZ. Is it a bug?
  
  It is more likely a problem with the distribution itself. cpanminus
  doesn't support or is known to have issues with distributions like as
  follows:
  
  =over 4
  
  =item *
  
  Tests that require input from STDIN.
  
  =item *
  
  Tests that might fail when C<AUTOMATED_TESTING> is enabled.
  
  =item *
  
  Modules that have invalid numeric values as VERSION (such as C<1.1a>)
  
  =back
  
  These failures can be reported back to the author of the module so
  that they can fix it accordingly, rather than me.
  
  =head2 Does cpanm support the feature XYZ of L<CPAN> and L<CPANPLUS>?
  
  Most likely not. Here are the things that cpanm doesn't do by
  itself. And it's a feature - you got that from the name I<minus>,
  right?
  
  If you need these features, use L<CPAN>, L<CPANPLUS> or the standalone
  tools that are mentioned.
  
  =over 4
  
  =item *
  
  CPAN testers reporting. See L<App::cpanminus::reporter>
  
  =item *
  
  Building RPM packages from CPAN modules
  
  =item *
  
  Listing the outdated modules that needs upgrading. See L<App::cpanoutdated>
  
  =item *
  
  Showing the changes of the modules you're about to upgrade. See L<cpan-listchanges>
  
  =item *
  
  Patching CPAN modules with distroprefs.
  
  =back
  
  See L<cpanm> or C<cpanm -h> to see what cpanminus I<can> do :)
  
  =head1 COPYRIGHT
  
  Copyright 2010- Tatsuhiko Miyagawa
  
  The standalone executable contains the following modules embedded.
  
  =over 4
  
  =item L<CPAN::DistnameInfo> Copyright 2003 Graham Barr
  
  =item L<Parse::CPAN::Meta> Copyright 2006-2009 Adam Kennedy
  
  =item L<local::lib> Copyright 2007-2009 Matt S Trout
  
  =item L<HTTP::Tiny> Copyright 2011 Christian Hansen
  
  =item L<Module::Metadata> Copyright 2001-2006 Ken Williams. 2010 Matt S Trout
  
  =item L<version> Copyright 2004-2010 John Peacock
  
  =item L<JSON::PP> Copyright 2007-2011 by Makamaka Hannyaharamitu
  
  =item L<CPAN::Meta>, L<CPAN::Meta::Requirements> Copyright (c) 2010 by David Golden and Ricardo Signes
  
  =item L<CPAN::Meta::YAML> Copyright 2010 Adam Kennedy
  
  =item L<File::pushd> Copyright 2012 David Golden
  
  =back
  
  =head1 LICENSE
  
  This software is licensed under the same terms as Perl.
  
  =head1 CREDITS
  
  =head2 CONTRIBUTORS
  
  Patches and code improvements were contributed by:
  
  Goro Fuji, Kazuhiro Osawa, Tokuhiro Matsuno, Kenichi Ishigaki, Ian
  Wells, Pedro Melo, Masayoshi Sekimura, Matt S Trout (mst), squeeky,
  horus and Ingy dot Net.
  
  =head2 ACKNOWLEDGEMENTS
  
  Bug reports, suggestions and feedbacks were sent by, or general
  acknowledgement goes to:
  
  Jesse Vincent, David Golden, Andreas Koenig, Jos Boumans, Chris
  Williams, Adam Kennedy, Audrey Tang, J. Shirley, Chris Prather, Jesse
  Luehrs, Marcus Ramberg, Shawn M Moore, chocolateboy, Chirs Nehren,
  Jonathan Rockway, Leon Brocard, Simon Elliott, Ricardo Signes, AEvar
  Arnfjord Bjarmason, Eric Wilhelm, Florian Ragwitz and xaicron.
  
  =head1 COMMUNITY
  
  =over 4
  
  =item L<http://github.com/miyagawa/cpanminus> - source code repository, issue tracker
  
  =item L<irc://irc.perl.org/#toolchain> - discussions about Perl toolchain. I'm there.
  
  =back
  
  =head1 NO WARRANTY
  
  This software is provided "as-is," without any express or implied
  warranty. In no event shall the author be held liable for any damages
  arising from the use of the software.
  
  =head1 SEE ALSO
  
  L<CPAN> L<CPANPLUS> L<pip>
  
  =cut
  
  1;
APP_CPANMINUS

$fatpacked{"App/cpanminus/fatscript.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPANMINUS_FATSCRIPT';
  package App::cpanminus::fatscript;
  #
  # You want to install cpanminus? Run the following command and it will
  # install itself for you. You might want to run it as a root with sudo
  # if you want to install to places like /usr/local/bin.
  #
  #   % curl -L http://cpanmin.us | perl - App::cpanminus
  #
  # If you don't have curl but wget, replace `curl -L` with `wget -O -`.
  #
  # For more details about this program, visit http://search.cpan.org/dist/App-cpanminus
  
  our $VERSION = "1.6928";
  # DO NOT EDIT -- this is an auto generated file
  
  # This chunk of stuff was generated by App::FatPacker. To find the original
  # file's code, look for the end of this BEGIN block or the string 'FATPACK'
  BEGIN {
  my %fatpacked;
  
  $fatpacked{"App/cpanminus.pm"} = <<'APP_CPANMINUS';
    package App::cpanminus;
    our $VERSION = "1.7001";
    
    =encoding utf8
    
    =head1 NAME
    
    App::cpanminus - get, unpack, build and install modules from CPAN
    
    =head1 SYNOPSIS
    
        cpanm Module
    
    Run C<cpanm -h> or C<perldoc cpanm> for more options.
    
    =head1 DESCRIPTION
    
    cpanminus is a script to get, unpack, build and install modules from
    CPAN and does nothing else.
    
    It's dependency free (can bootstrap itself), requires zero
    configuration, and stands alone. When running, it requires only 10MB
    of RAM.
    
    =head1 INSTALLATION
    
    There are several ways to install cpanminus to your system.
    
    =head2 Package management system
    
    There are Debian packages, RPMs, FreeBSD ports, and packages for other
    operation systems available. If you want to use the package management system,
    search for cpanminus and use the appropriate command to install. This makes it
    easy to install C<cpanm> to your system without thinking about where to
    install, and later upgrade.
    
    =head2 Installing to system perl
    
    You can also use the latest cpanminus to install cpanminus itself:
    
        curl -L http://cpanmin.us | perl - --sudo App::cpanminus
    
    This will install C<cpanm> to your bin directory like
    C</usr/local/bin> (unless you configured C<INSTALL_BASE> with
    L<local::lib>), so you probably need the C<--sudo> option.
    
    =head2 Installing to local perl (perlbrew)
    
    If you have perl in your home directory, which is the case if you use
    tools like L<perlbrew>, you don't need the C<--sudo> option, since
    you're most likely to have a write permission to the perl's library
    path. You can just do:
    
        curl -L http://cpanmin.us | perl - App::cpanminus
    
    to install the C<cpanm> executable to the perl's bin path, like
    C<~/perl5/perlbrew/bin/cpanm>.
    
    =head2 Downloading the standalone executable
    
    You can also copy the standalone executable to whatever location you'd like.
    
        cd ~/bin
        curl -LO http://xrl.us/cpanm
        chmod +x cpanm
        # edit shebang if you don't have /usr/bin/env
    
    This just works, but be sure to grab the new version manually when you
    upgrade because C<--self-upgrade> might not work for this.
    
    =head1 DEPENDENCIES
    
    perl 5.8 or later.
    
    =over 4
    
    =item *
    
    'tar' executable (bsdtar or GNU tar version 1.22 are recommended) or Archive::Tar to unpack files.
    
    =item *
    
    C compiler, if you want to build XS modules.
    
    =item *
    
    make
    
    =item *
    
    Module::Build (core in 5.10)
    
    =back
    
    =head1 QUESTIONS
    
    =head2 Another CPAN installer?
    
    OK, the first motivation was this: the CPAN shell runs out of memory (or swaps
    heavily and gets really slow) on Slicehost/linode's most affordable plan with
    only 256MB RAM. Should I pay more to install perl modules from CPAN? I don't
    think so.
    
    =head2 But why a new client?
    
    First of all, let me be clear that CPAN and CPANPLUS are great tools
    I've used for I<literally> years (you know how many modules I have on
    CPAN, right?). I really respect their efforts of maintaining the most
    important tools in the CPAN toolchain ecosystem.
    
    However, for less experienced users (mostly from outside the Perl community),
    or even really experienced Perl developers who know how to shoot themselves in
    their feet, setting up the CPAN toolchain often feels like yak shaving,
    especially when all they want to do is just install some modules and start
    writing code.
    
    =head2 Zero-conf? How does this module get/parse/update the CPAN index?
    
    It queries the CPAN Meta DB site at L<http://cpanmetadb.plackperl.org/>.
    The site is updated at least every hour to reflect the latest changes
    from fast syncing mirrors. The script then also falls back to query the
    module at L<http://metacpan.org/> using its wonderful API.
    
    Upon calling these API hosts, cpanm (1.6004 or later) will send the
    local perl versions to the server in User-Agent string by default. You
    can turn it off with C<--no-report-perl-version> option. Read more
    about the option with L<cpanm>, and read more about the privacy policy
    about this data collection at L<http://cpanmetadb.plackperl.org/#privacy>
    
    Fetched files are unpacked in C<~/.cpanm> and automatically cleaned up
    periodically.  You can configure the location of this with the
    C<PERL_CPANM_HOME> environment variable.
    
    =head2 Where does this install modules to? Do I need root access?
    
    It installs to wherever ExtUtils::MakeMaker and Module::Build are
    configured to (via C<PERL_MM_OPT> and C<PERL_MB_OPT>). So if you're
    using local::lib, then it installs to your local perl5
    directory. Otherwise it installs to the site_perl directory that
    belongs to your perl.
    
    cpanminus at a boot time checks whether you have configured
    local::lib, or have the permission to install modules to the site_perl
    directory.  If neither, it automatically sets up local::lib compatible
    installation path in a C<perl5> directory under your home
    directory. To avoid this, run the script as the root user, with
    C<--sudo> option or with C<--local-lib> option.
    
    =head2 cpanminus can't install the module XYZ. Is it a bug?
    
    It is more likely a problem with the distribution itself. cpanminus
    doesn't support or is known to have issues with distributions like as
    follows:
    
    =over 4
    
    =item *
    
    Tests that require input from STDIN.
    
    =item *
    
    Tests that might fail when C<AUTOMATED_TESTING> is enabled.
    
    =item *
    
    Modules that have invalid numeric values as VERSION (such as C<1.1a>)
    
    =back
    
    These failures can be reported back to the author of the module so
    that they can fix it accordingly, rather than me.
    
    =head2 Does cpanm support the feature XYZ of L<CPAN> and L<CPANPLUS>?
    
    Most likely not. Here are the things that cpanm doesn't do by
    itself. And it's a feature - you got that from the name I<minus>,
    right?
    
    If you need these features, use L<CPAN>, L<CPANPLUS> or the standalone
    tools that are mentioned.
    
    =over 4
    
    =item *
    
    CPAN testers reporting. See L<App::cpanminus::reporter>
    
    =item *
    
    Building RPM packages from CPAN modules
    
    =item *
    
    Listing the outdated modules that needs upgrading. See L<App::cpanoutdated>
    
    =item *
    
    Showing the changes of the modules you're about to upgrade. See L<cpan-listchanges>
    
    =item *
    
    Patching CPAN modules with distroprefs.
    
    =back
    
    See L<cpanm> or C<cpanm -h> to see what cpanminus I<can> do :)
    
    =head1 COPYRIGHT
    
    Copyright 2010- Tatsuhiko Miyagawa
    
    The standalone executable contains the following modules embedded.
    
    =over 4
    
    =item L<CPAN::DistnameInfo> Copyright 2003 Graham Barr
    
    =item L<Parse::CPAN::Meta> Copyright 2006-2009 Adam Kennedy
    
    =item L<local::lib> Copyright 2007-2009 Matt S Trout
    
    =item L<HTTP::Tiny> Copyright 2011 Christian Hansen
    
    =item L<Module::Metadata> Copyright 2001-2006 Ken Williams. 2010 Matt S Trout
    
    =item L<version> Copyright 2004-2010 John Peacock
    
    =item L<JSON::PP> Copyright 2007-2011 by Makamaka Hannyaharamitu
    
    =item L<CPAN::Meta>, L<CPAN::Meta::Requirements> Copyright (c) 2010 by David Golden and Ricardo Signes
    
    =item L<CPAN::Meta::YAML> Copyright 2010 Adam Kennedy
    
    =item L<File::pushd> Copyright 2012 David Golden
    
    =back
    
    =head1 LICENSE
    
    This software is licensed under the same terms as Perl.
    
    =head1 CREDITS
    
    =head2 CONTRIBUTORS
    
    Patches and code improvements were contributed by:
    
    Goro Fuji, Kazuhiro Osawa, Tokuhiro Matsuno, Kenichi Ishigaki, Ian
    Wells, Pedro Melo, Masayoshi Sekimura, Matt S Trout (mst), squeeky,
    horus and Ingy dot Net.
    
    =head2 ACKNOWLEDGEMENTS
    
    Bug reports, suggestions and feedbacks were sent by, or general
    acknowledgement goes to:
    
    Jesse Vincent, David Golden, Andreas Koenig, Jos Boumans, Chris
    Williams, Adam Kennedy, Audrey Tang, J. Shirley, Chris Prather, Jesse
    Luehrs, Marcus Ramberg, Shawn M Moore, chocolateboy, Chirs Nehren,
    Jonathan Rockway, Leon Brocard, Simon Elliott, Ricardo Signes, AEvar
    Arnfjord Bjarmason, Eric Wilhelm, Florian Ragwitz and xaicron.
    
    =head1 COMMUNITY
    
    =over 4
    
    =item L<http://github.com/miyagawa/cpanminus> - source code repository, issue tracker
    
    =item L<irc://irc.perl.org/#toolchain> - discussions about Perl toolchain. I'm there.
    
    =back
    
    =head1 NO WARRANTY
    
    This software is provided "as-is," without any express or implied
    warranty. In no event shall the author be held liable for any damages
    arising from the use of the software.
    
    =head1 SEE ALSO
    
    L<CPAN> L<CPANPLUS> L<pip>
    
    =cut
    
    1;
  APP_CPANMINUS
  
  $fatpacked{"App/cpanminus/CPANVersion.pm"} = <<'APP_CPANMINUS_CPANVERSION';
    package App::cpanminus::CPANVersion;
    # copy of CPAN::Version since it's not core on older 5.8
    
    use strict;
    #use vars qw($VERSION);
    #$VERSION = "5.5001";
    
    # CPAN::Version::vcmp courtesy Jost Krieger
    sub vcmp {
        my($self,$l,$r) = @_;
        local($^W) = 0;
        #CPAN->debug("l[$l] r[$r]") if $CPAN::DEBUG;
    
        return 0 if $l eq $r; # short circuit for quicker success
    
        for ($l,$r) {
            s/_//g;
        }
        #CPAN->debug("l[$l] r[$r]") if $CPAN::DEBUG;
        for ($l,$r) {
            next unless tr/.// > 1 || /^v/;
            s/^v?/v/;
            1 while s/\.0+(\d)/.$1/; # remove leading zeroes per group
        }
        #CPAN->debug("l[$l] r[$r]") if $CPAN::DEBUG;
        if ($l=~/^v/ <=> $r=~/^v/) {
            for ($l,$r) {
                next if /^v/;
                $_ = $self->float2vv($_);
            }
        }
        #CPAN->debug("l[$l] r[$r]") if $CPAN::DEBUG;
        my $lvstring = "v0";
        my $rvstring = "v0";
        if ($] >= 5.006
         && $l =~ /^v/
         && $r =~ /^v/) {
            $lvstring = $self->vstring($l);
            $rvstring = $self->vstring($r);
            #CPAN->debug(sprintf "lv[%vd] rv[%vd]", $lvstring, $rvstring) if $CPAN::DEBUG;
        }
    
        return (
                ($l ne "undef") <=> ($r ne "undef")
                ||
                $lvstring cmp $rvstring
                ||
                $l <=> $r
                ||
                $l cmp $r
        );
    }
    
    sub vgt {
        my($self,$l,$r) = @_;
        $self->vcmp($l,$r) > 0;
    }
    
    sub vlt {
        my($self,$l,$r) = @_;
        $self->vcmp($l,$r) < 0;
    }
    
    sub vge {
        my($self,$l,$r) = @_;
        $self->vcmp($l,$r) >= 0;
    }
    
    sub vle {
        my($self,$l,$r) = @_;
        $self->vcmp($l,$r) <= 0;
    }
    
    sub vstring {
        my($self,$n) = @_;
        $n =~ s/^v// or die "CPAN::Version::vstring() called with invalid arg [$n]";
        pack "U*", split /\./, $n;
    }
    
    # vv => visible vstring
    sub float2vv {
        my($self,$n) = @_;
        my($rev) = int($n);
        $rev ||= 0;
        my($mantissa) = $n =~ /\.(\d{1,12})/; # limit to 12 digits to limit
                                              # architecture influence
        $mantissa ||= 0;
        $mantissa .= "0" while length($mantissa)%3;
        my $ret = "v" . $rev;
        while ($mantissa) {
            $mantissa =~ s/(\d{1,3})// or
                die "Panic: length>0 but not a digit? mantissa[$mantissa]";
            $ret .= ".".int($1);
        }
        # warn "n[$n]ret[$ret]";
        $ret =~ s/(\.0)+/.0/; # v1.0.0 => v1.0
        $ret;
    }
    
    sub readable {
        my($self,$n) = @_;
        $n =~ /^([\w\-\+\.]+)/;
    
        return $1 if defined $1 && length($1)>0;
        # if the first user reaches version v43, he will be treated as "+".
        # We'll have to decide about a new rule here then, depending on what
        # will be the prevailing versioning behavior then.
    
        if ($] < 5.006) { # or whenever v-strings were introduced
            # we get them wrong anyway, whatever we do, because 5.005 will
            # have already interpreted 0.2.4 to be "0.24". So even if he
            # indexer sends us something like "v0.2.4" we compare wrongly.
    
            # And if they say v1.2, then the old perl takes it as "v12"
    
    #        if (defined $CPAN::Frontend) {
    #            $CPAN::Frontend->mywarn("Suspicious version string seen [$n]\n");
    #        } else {
                warn("Suspicious version string seen [$n]\n");
    #        }
            return $n;
        }
        my $better = sprintf "v%vd", $n;
        #CPAN->debug("n[$n] better[$better]") if $CPAN::DEBUG;
        return $better;
    }
    
    1;
    
    __END__
  APP_CPANMINUS_CPANVERSION
  
  $fatpacked{"App/cpanminus/Dependency.pm"} = <<'APP_CPANMINUS_DEPENDENCY';
    package App::cpanminus::Dependency;
    use strict;
    use CPAN::Meta::Requirements;
    
    sub from_prereqs {
        my($class, $prereq, $phases, $types) = @_;
    
        my @deps;
    
        for my $type (@$types) {
            my $req = CPAN::Meta::Requirements->new;
            $req->add_requirements($prereq->requirements_for($_, $type))
              for @$phases;
    
            push @deps, $class->from_versions($req->as_string_hash, $type);
        }
    
        return @deps;
    }
    
    sub from_versions {
        my($class, $versions, $type) = @_;
    
        my @deps;
        while (my($module, $version) = each %$versions) {
            push @deps, $class->new($module, $version, $type)
        }
    
        @deps;
    }
    
    sub new {
        my($class, $module, $version, $type) = @_;
    
        bless {
            module => $module,
            version => $version,
            type => $type || 'requires',
        }, $class;
    }
    
    sub module  { $_[0]->{module} }
    sub version { $_[0]->{version} }
    sub type    { $_[0]->{type} }
    
    sub is_requirement {
        $_[0]->{type} eq 'requires';
    }
    
    1;
  APP_CPANMINUS_DEPENDENCY
  
  $fatpacked{"App/cpanminus/ParsePM.pm"} = <<'APP_CPANMINUS_PARSEPM';
    package App::cpanminus::ParsePM;
    # fork of Parse::PMFile, use JSON::PP instead of JSON
    
    use strict;
    use warnings;
    use Safe;
    use JSON::PP;
    use Dumpvalue;
    #use CPAN::Version;
    use version ();
    use File::Spec ();
    use File::Temp ();
    use POSIX ':sys_wait_h';
    use App::cpanminus::CPANVersion;
    
    our $VERSION = '0.04';
    our $VERBOSE = 0;
    our $ALLOW_DEV_VERSION = 0;
    
    sub new {
        my ($class, $meta) = @_;
        bless {META_CONTENT => $meta}, $class;
    }
    
    # from PAUSE::pmfile::examine_fio
    sub parse {
        my ($self, $pmfile) = @_;
    
        $pmfile =~ s|\\|/|g;
    
        my($filemtime) = (stat $pmfile)[9];
        $self->{MTIME} = $filemtime;
        $self->{PMFILE} = $pmfile;
    
        unless ($self->_version_from_meta_ok) {
            $self->{VERSION} = $self->_parse_version;
            if ($self->{VERSION} =~ /^\{.*\}$/) {
                # JSON error message
            } elsif ($self->{VERSION} =~ /[_\s]/ && !$ALLOW_DEV_VERSION){   # ignore developer releases and "You suck!"
                return;
            }
        }
    
        my($ppp) = $self->_packages_per_pmfile;
        my @keys_ppp = $self->_filter_ppps(sort keys %$ppp);
        $self->_verbose(1,"Will check keys_ppp[@keys_ppp]\n");
    
        #
        # Immediately after each package (pmfile) examined contact
        # the database
        #
    
        my ($package);
      DBPACK: foreach $package (@keys_ppp) {
            # this part is taken from PAUSE::package::examine_pkg
            if ($package !~ /^\w[\w\:\']*\w?\z/
                ||
                $package !~ /\w\z/
                ||
                $package =~ /:/ && $package !~ /::/
                ||
                $package =~ /\w:\w/
                ||
                $package =~ /:::/
            ){
                $self->_verbose(1,"Package[$package] did not pass the ultimate sanity check");
                delete $ppp->{$package};
                next;
            }
    
            # Can't do perm_check() here.
    
            my $pp = $ppp->{$package};
            if ($pp->{version} && $pp->{version} =~ /^\{.*\}$/) { # JSON parser error
                my $err = JSON::PP::decode_json($pp->{version});
                if ($err->{openerr}) {
                    $self->_verbose(1,
                                  qq{Parse::PMFile was not able to
            read the file. It issued the following error: C< $err->{r} >},
                                  );
                } else {
                    $self->_verbose(1, 
                                  qq{Parse::PMFile was not able to
            parse the following line in that file: C< $err->{line} >
    
            Note: the indexer is running in a Safe compartement and cannot
            provide the full functionality of perl in the VERSION line. It
            is trying hard, but sometime it fails. As a workaround, please
            consider writing a META.yml that contains a 'provides'
            attribute or contact the CPAN admins to investigate (yet
            another) workaround against "Safe" limitations.)},
    
                                  );
                }
                delete $ppp->{$package};
                next;
            }
    
            # Sanity checks
    
            for (
                $package,
                $pp->{version},
            ) {
                if (!defined || /^\s*$/ || /\s/){  # for whatever reason I come here
                    delete $ppp->{$package};
                    next;            # don't screw up 02packages
                }
            }
        }                       # end foreach package
    
        return $ppp;
    }
    
    # from PAUSE::pmfile;
    sub _parse_version {
        my $self = shift;
    
        use strict;
    
        my $pmfile = $self->{PMFILE};
        my $tmpfile = File::Spec->catfile(File::Spec->tmpdir, "ParsePMFile$$" . rand(1000));
    
        my $pmcp = $pmfile;
        for ($pmcp) {
            s/([^\\](\\\\)*)@/$1\\@/g; # thanks to Raphael Manfredi for the
            # solution to escape @s and \
        }
        my($v);
        {
    
            package main; # seems necessary
    
            # XXX: do we need to fork as PAUSE does?
            # or, is alarm() just fine?
            my $pid = fork();
            die "Can't fork: $!" unless defined $pid;
            if ($pid) {
                waitpid($pid, 0);
                if (open my $fh, '<', $tmpfile) {
                    $v = <$fh>;
                }
            } else {
                # XXX Limit Resources too
    
                my($comp) = Safe->new("_pause::mldistwatch");
                my $eval = qq{
                  local(\$^W) = 0;
                  App::cpanminus::ParsePM::_parse_version_safely("$pmcp");
                  };
                $comp->permit("entereval"); # for MBARBON/Module-Info-0.30.tar.gz
                $comp->share("*App::cpanminus::ParsePM::_parse_version_safely");
                $comp->share("*version::new");
                $comp->share("*version::numify");
                $comp->share_from('main', ['*version::',
                                            '*Exporter::',
                                            '*DynaLoader::']);
                $comp->share_from('version', ['&qv']);
                # $comp->permit("require"); # no strict!
                $comp->deny(qw/enteriter iter unstack goto/); # minimum protection against Acme::BadExample
                {
                    no strict;
                    $v = $comp->reval($eval);
                }
                if ($@){ # still in the child process, out of Safe::reval
                    my $err = $@;
                    # warn ">>>>>>>err[$err]<<<<<<<<";
                    if (ref $err) {
                        if ($err->{line} =~ /[\$*]([\w\:\']*)\bVERSION\b.*?\=(.*)/) {
                            # $v = $comp->reval($2);
                            local *qv = \&version::qv; # equiv. of $comp->share_from('version', ['&qv']);
                            $v = eval "$2";
                        }
                        if ($@) {
                            $self->_verbose(1, sprintf("reval failed: err[%s] for eval[%s]",
                                          JSON::PP::encode_json($err),
                                          $eval,
                                        ));
                            $v = JSON::PP::encode_json($err);
                        }
                    } else {
                        $v = JSON::PP::encode_json({ openerr => $err });
                    }
                }
                if (defined $v) {
                    $v = $v->numify if ref($v) eq 'version';
                } else {
                    $v = "";
                }
                open my $fh, '>:utf8', $tmpfile;
                print $fh $v;
                exit 0;
            }
        }
        unlink $tmpfile if -e $tmpfile;
    
        return $self->_normalize_version($v);
    }
    
    # from PAUSE::pmfile;
    sub _packages_per_pmfile {
        my $self = shift;
    
        my $ppp = {};
        my $pmfile = $self->{PMFILE};
        my $filemtime = $self->{MTIME};
        my $version = $self->{VERSION};
    
        $DB::single++;
        open my $fh, "<", "$pmfile" or return $ppp;
    
        local $/ = "\n";
        my $inpod = 0;
    
      PLINE: while (<$fh>) {
            chomp;
            my($pline) = $_;
            $inpod = $pline =~ /^=(?!cut)/ ? 1 :
                $pline =~ /^=cut/ ? 0 : $inpod;
            next if $inpod;
            next if substr($pline,0,4) eq "=cut";
    
            $pline =~ s/\#.*//;
            next if $pline =~ /^\s*$/;
            if ($pline =~ /\b__(?:END|DATA)__\b/
                and $pmfile !~ /\.PL$/   # PL files may well have code after __DATA__
                ){
                last PLINE;
            }
    
            my $pkg;
            my $strict_version;
    
            if (
                $pline =~ m{
                          # (.*) # takes too much time if $pline is long
                          \bpackage\s+
                          ([\w\:\']+)
                          \s*
                          (?: $ | [\}\;] | \s+($version::STRICT) )
                        }x) {
                $pkg = $1;
                $strict_version = $2;
                if ($pkg eq "DB"){
                    # XXX if pumpkin and perl make him comaintainer! I
                    # think I always made the pumpkins comaint on DB
                    # without further ado (?)
                    next PLINE;
                }
            }
    
            if ($pkg) {
                # Found something
    
                # from package
                $pkg =~ s/\'/::/;
                next PLINE unless $pkg =~ /^[A-Za-z]/;
                next PLINE unless $pkg =~ /\w$/;
                next PLINE if $pkg eq "main";
                # Perl::Critic::Policy::TestingAndDebugging::ProhibitShebangWarningsArg
                # database for modid in mods, package in packages, package in perms
                # alter table mods modify modid varchar(128) binary NOT NULL default '';
                # alter table packages modify package varchar(128) binary NOT NULL default '';
                next PLINE if length($pkg) > 128;
                #restriction
                $ppp->{$pkg}{parsed}++;
                $ppp->{$pkg}{infile} = $pmfile;
                if ($self->_simile($pmfile,$pkg)) {
                    $ppp->{$pkg}{simile} = $pmfile;
                    if ($self->_version_from_meta_ok) {
                        my $provides = $self->{META_CONTENT}{provides};
                        if (exists $provides->{$pkg}) {
                            if (exists $provides->{$pkg}{version}) {
                                my $v = $provides->{$pkg}{version};
                                if ($v =~ /[_\s]/ && !$ALLOW_DEV_VERSION){   # ignore developer releases and "You suck!"
                                    next PLINE;
                                } else {
                                    $ppp->{$pkg}{version} = $self->_normalize_version($v);
                                }
                            } else {
                                $ppp->{$pkg}{version} = "undef";
                            }
                        }
                    } else {
                        if (defined $strict_version){
                            $ppp->{$pkg}{version} = $strict_version ;
                        } else {
                            $ppp->{$pkg}{version} = defined $version ? $version : "";
                        }
                        no warnings;
                        if ($version eq 'undef') {
                            $ppp->{$pkg}{version} = $version unless defined $ppp->{$pkg}{version};
                        } else {
                            $ppp->{$pkg}{version} =
                                $version
                                    if $version
                                        > $ppp->{$pkg}{version} ||
                                            $version
                                                gt $ppp->{$pkg}{version};
                        }
                    }
                } else {        # not simile
                    #### it comes later, it would be nonsense
                    #### to set to "undef". MM_Unix gives us
                    #### the best we can reasonably consider
                    $ppp->{$pkg}{version} =
                        $version
                            unless defined $ppp->{$pkg}{version} &&
                                length($ppp->{$pkg}{version});
                }
                $ppp->{$pkg}{filemtime} = $filemtime;
            } else {
                # $self->_verbose(2,"no pkg found");
            }
        }
    
        $fh->close;
        $ppp;
    }
    
    # from PAUSE::pmfile;
    {
        no strict;
        sub _parse_version_safely {
            my($parsefile) = @_;
            my $result;
            local *FH;
            local $/ = "\n";
            open(FH,$parsefile) or die "Could not open '$parsefile': $!";
            my $inpod = 0;
            while (<FH>) {
                $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
                next if $inpod || /^\s*#/;
                # last if /\b__(?:END|DATA)__\b/; # fails on quoted __END__ but this is rare
                chop;
                # next unless /\$(([\w\:\']*)\bVERSION)\b.*\=/;
                next unless /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
                my $current_parsed_line = $_;
                my $eval = qq{
              package #
                  ExtUtils::MakeMaker::_version;
    
              local $1$2;
              \$$2=undef; do {
                  $_
              }; \$$2
          };
                local $^W = 0;
                local $SIG{__WARN__} = sub {};
                $result = eval($eval);
                # warn "current_parsed_line[$current_parsed_line]\$\@[$@]";
                if ($@ or !defined $result){
                    die +{
                          eval => $eval,
                          line => $current_parsed_line,
                          file => $parsefile,
                          err => $@,
                          };
                }
                last;
            } #;
            close FH;
    
            $result = "undef" unless defined $result;
            return $result;
        }
    }
    
    # from PAUSE::pmfile;
    sub _filter_ppps {
        my($self,@ppps) = @_;
        my @res;
    
        # very similar code is in PAUSE::dist::filter_pms
      MANI: for my $ppp ( @ppps ) {
            if ($self->{META_CONTENT}){
                my $no_index = $self->{META_CONTENT}{no_index}
                                || $self->{META_CONTENT}{private}; # backward compat
                if (ref($no_index) eq 'HASH') {
                    my %map = (
                                package => qr{\z},
                                namespace => qr{::},
                              );
                    for my $k (qw(package namespace)) {
                        next unless my $v = $no_index->{$k};
                        my $rest = $map{$k};
                        if (ref $v eq "ARRAY") {
                            for my $ve (@$v) {
                                $ve =~ s|::$||;
                                if ($ppp =~ /^$ve$rest/){
                                    $self->_verbose(1,"Skipping ppp[$ppp] due to ve[$ve]");
                                    next MANI;
                                } else {
                                    $self->_verbose(1,"NOT skipping ppp[$ppp] due to ve[$ve]");
                                }
                            }
                        } else {
                            $v =~ s|::$||;
                            if ($ppp =~ /^$v$rest/){
                                $self->_verbose(1,"Skipping ppp[$ppp] due to v[$v]");
                                next MANI;
                            } else {
                                $self->_verbose(1,"NOT skipping ppp[$ppp] due to v[$v]");
                            }
                        }
                    }
                } else {
                    $self->_verbose(1,"No keyword 'no_index' or 'private' in META_CONTENT");
                }
            } else {
                # $self->_verbose(1,"no META_CONTENT"); # too noisy
            }
            push @res, $ppp;
        }
        $self->_verbose(1,"Result of filter_ppps: res[@res]");
        @res;
    }
    
    # from PAUSE::pmfile;
    sub _simile {
        my($self,$file,$package) = @_;
        # MakeMaker gives them the chance to have the file Simple.pm in
        # this directory but have the package HTML::Simple in it.
        # Afaik, they wouldn't be able to do so with deeper nested packages
        $file =~ s|.*/||;
        $file =~ s|\.pm(?:\.PL)?||;
        my $ret = $package =~ m/\b\Q$file\E$/;
        $ret ||= 0;
        unless ($ret) {
            # Apache::mod_perl_guide stuffs it into Version.pm
            $ret = 1 if lc $file eq 'version';
        }
        $self->_verbose(1,"Result of simile(): file[$file] package[$package] ret[$ret]\n");
        $ret;
    }
    
    # from PAUSE::pmfile
    sub _normalize_version {
        my($self,$v) = @_;
        $v = "undef" unless defined $v;
        my $dv = Dumpvalue->new;
        my $sdv = $dv->stringify($v,1); # second argument prevents ticks
        $self->_verbose(1,"Result of normalize_version: sdv[$sdv]\n");
    
        return $v if $v eq "undef";
        return $v if $v =~ /^\{.*\}$/; # JSON object
        $v =~ s/^\s+//;
        $v =~ s/\s+\z//;
        if ($v =~ /_/) {
            # XXX should pass something like EDEVELOPERRELEASE up e.g.
            # SIXTEASE/XML-Entities-0.0306.tar.gz had nothing but one
            # such modules and the mesage was not helpful that "nothing
            # was found".
            return $v ;
        }
        # may warn "Integer overflow"
        my $vv = eval { no warnings; version->new($v)->numify };
        if ($@) {
            # warn "$v: $@";
            return "undef";
        }
        if ($vv eq $v) {
            # the boring 3.14
        } else {
            my $forced = $self->_force_numeric($v);
            if ($forced eq $vv) {
            } elsif ($forced =~ /^v(.+)/) {
                # rare case where a v1.0.23 slipped in (JANL/w3mir-1.0.10.tar.gz)
                $vv = version->new($1)->numify;
            } else {
                # warn "Unequal forced[$forced] and vv[$vv]";
                if ($forced == $vv) {
                    # the trailing zeroes would cause unnecessary havoc
                    $vv = $forced;
                }
            }
        }
        return $vv;
    }
    
    # from PAUSE::pmfile;
    sub _force_numeric {
        my($self,$v) = @_;
        $v = App::cpanminus::CPANVersion->readable($v);
    
        if (
            $v =~
            /^(\+?)(\d*)(\.(\d*))?/ &&
            # "$2$4" ne ''
            (
              defined $2 && length $2
              ||
              defined $4 && length $4
            )
            ) {
            my $two = defined $2 ? $2 : "";
            my $three = defined $3 ? $3 : "";
            $v = "$two$three";
        }
        # no else branch! We simply say, everything else is a string.
        $v;
    }
    
    # from PAUSE::dist
    sub _version_from_meta_ok {
      my($self) = @_;
      return $self->{VERSION_FROM_META_OK} if exists $self->{VERSION_FROM_META_OK};
      my $c = $self->{META_CONTENT};
    
      # If there's no provides hash, we can't get our module versions from the
      # provides hash! -- rjbs, 2012-03-31
      return($self->{VERSION_FROM_META_OK} = 0) unless $c->{provides};
    
      # Some versions of Module::Build geneated an empty provides hash.  If we're
      # *not* looking at a Module::Build-generated metafile, then it's okay.
      my ($mb_v) = (defined $c->{generated_by} ? $c->{generated_by} : '') =~ /Module::Build version ([\d\.]+)/;
      return($self->{VERSION_FROM_META_OK} = 1) unless $mb_v;
    
      # ??? I don't know why this is here.
      return($self->{VERSION_FROM_META_OK} = 1) if $mb_v eq '0.250.0';
    
      if ($mb_v >= 0.19 && $mb_v < 0.26 && ! keys %{$c->{provides}}) {
          # RSAVAGE/Javascript-SHA1-1.01.tgz had an empty provides hash. Ron
          # did not find the reason why this happened, but let's not go
          # overboard, 0.26 seems a good threshold from the statistics: there
          # are not many empty provides hashes from 0.26 up.
          return($self->{VERSION_FROM_META_OK} = 0);
      }
    
      # We're not in the suspect range of M::B versions.  It's good to go.
      return($self->{VERSION_FROM_META_OK} = 1);
    }
    
    sub _verbose {
        my($self,$level,@what) = @_;
        warn @what if $level <= $VERBOSE;
    }
    
    1;
    
    __END__
  APP_CPANMINUS_PARSEPM
  
  $fatpacked{"App/cpanminus/script.pm"} = <<'APP_CPANMINUS_SCRIPT';
    package App::cpanminus::script;
    use strict;
    use Config;
    use Cwd ();
    use App::cpanminus;
    use File::Basename ();
    use File::Find ();
    use File::Path ();
    use File::Spec ();
    use File::Copy ();
    use File::Temp ();
    use Getopt::Long ();
    use Parse::CPAN::Meta;
    use Symbol ();
    use String::ShellQuote ();
    use version ();
    
    use aliased 'App::cpanminus::Dependency';
    
    use constant WIN32 => $^O eq 'MSWin32';
    use constant SUNOS => $^O eq 'solaris';
    use constant CAN_SYMLINK => eval { symlink("", ""); 1 };
    
    our $VERSION = $App::cpanminus::VERSION;
    
    if ($INC{"App/FatPacker/Trace.pm"}) {
        require JSON::PP;
        require CPAN::Meta::YAML;
        require CPAN::Meta::Prereqs;
        require version::vpp;
        require File::pushd;
    }
    
    my $quote = WIN32 ? q/"/ : q/'/;
    
    sub agent {
        my $self = shift;
        my $agent = "cpanminus/$VERSION";
        $agent .= " perl/$]" if $self->{report_perl_version};
        $agent;
    }
    
    sub determine_home {
        my $class = shift;
    
        my $homedir = $ENV{HOME}
          || eval { require File::HomeDir; File::HomeDir->my_home }
          || join('', @ENV{qw(HOMEDRIVE HOMEPATH)}); # Win32
    
        if (WIN32) {
            require Win32; # no fatpack
            $homedir = Win32::GetShortPathName($homedir);
        }
    
        return "$homedir/.cpanm";
    }
    
    sub new {
        my $class = shift;
    
        bless {
            home => $class->determine_home,
            cmd  => 'install',
            seen => {},
            notest => undef,
            test_only => undef,
            installdeps => undef,
            force => undef,
            sudo => undef,
            make  => undef,
            verbose => undef,
            quiet => undef,
            interactive => undef,
            log => undef,
            mirrors => [],
            mirror_only => undef,
            mirror_index => undef,
            cpanmetadb => "http://cpanmetadb.plackperl.org/v1.0/",
            perl => $^X,
            argv => [],
            local_lib => undef,
            self_contained => undef,
            prompt_timeout => 0,
            prompt => undef,
            configure_timeout => 60,
            build_timeout => 3600,
            test_timeout => 1800,
            try_lwp => 1,
            try_wget => 1,
            try_curl => 1,
            uninstall_shadows => ($] < 5.012),
            skip_installed => 1,
            skip_satisfied => 0,
            auto_cleanup => 7, # days
            pod2man => 1,
            installed_dists => 0,
            install_types => ['requires'],
            with_develop => 0,
            showdeps => 0,
            scandeps => 0,
            scandeps_tree => [],
            format   => 'tree',
            save_dists => undef,
            skip_configure => 0,
            verify => 0,
            report_perl_version => 1,
            build_args => {},
            features => {},
            pure_perl => 0,
            cpanfile_path => 'cpanfile',
            @_,
        }, $class;
    }
    
    sub env {
        my($self, $key) = @_;
        $ENV{"PERL_CPANM_" . $key};
    }
    
    sub install_type_handlers {
        my $self = shift;
    
        my @handlers;
        for my $type (qw( recommends suggests )) {
            push @handlers, "with-$type" => sub {
                my %uniq;
                $self->{install_types} = [ grep !$uniq{$_}++, @{$self->{install_types}}, $type ];
            };
            push @handlers, "without-$type" => sub {
                $self->{install_types} = [ grep $_ ne $type, @{$self->{install_types}} ];
            };
        }
    
        @handlers;
    }
    
    sub build_args_handlers {
        my $self = shift;
    
        my @handlers;
        for my $phase (qw( configure build test install )) {
            push @handlers, "$phase-args=s" => \($self->{build_args}{$phase});
        }
    
        @handlers;
    }
    
    sub parse_options {
        my $self = shift;
    
        local @ARGV = @{$self->{argv}};
        push @ARGV, grep length, split /\s+/, $self->env('OPT');
        push @ARGV, @_;
    
        Getopt::Long::Configure("bundling");
        Getopt::Long::GetOptions(
            'f|force'   => sub { $self->{skip_installed} = 0; $self->{force} = 1 },
            'n|notest!' => \$self->{notest},
            'test-only' => sub { $self->{notest} = 0; $self->{skip_installed} = 0; $self->{test_only} = 1 },
            'S|sudo!'   => \$self->{sudo},
            'v|verbose' => \$self->{verbose},
            'verify!'   => \$self->{verify},
            'q|quiet!'  => \$self->{quiet},
            'h|help'    => sub { $self->{action} = 'show_help' },
            'V|version' => sub { $self->{action} = 'show_version' },
            'perl=s'    => \$self->{perl},
            'l|local-lib=s' => sub { $self->{local_lib} = $self->maybe_abs($_[1]) },
            'L|local-lib-contained=s' => sub {
                $self->{local_lib} = $self->maybe_abs($_[1]);
                $self->{self_contained} = 1;
                $self->{pod2man} = undef;
            },
            'self-contained!' => \$self->{self_contained},
            'mirror=s@' => $self->{mirrors},
            'mirror-only!' => \$self->{mirror_only},
            'mirror-index=s'  => \$self->{mirror_index},
            'cpanmetadb=s'    => \$self->{cpanmetadb},
            'cascade-search!' => \$self->{cascade_search},
            'prompt!'   => \$self->{prompt},
            'installdeps' => \$self->{installdeps},
            'skip-installed!' => \$self->{skip_installed},
            'skip-satisfied!' => \$self->{skip_satisfied},
            'reinstall'    => sub { $self->{skip_installed} = 0 },
            'interactive!' => \$self->{interactive},
            'i|install'    => sub { $self->{cmd} = 'install' },
            'info'         => sub { $self->{cmd} = 'info' },
            'look'         => sub { $self->{cmd} = 'look'; $self->{skip_installed} = 0 },
            'U|uninstall'  => sub { $self->{cmd} = 'uninstall' },
            'self-upgrade' => sub { $self->{action} = 'self_upgrade' },
            'uninst-shadows!'  => \$self->{uninstall_shadows},
            'lwp!'    => \$self->{try_lwp},
            'wget!'   => \$self->{try_wget},
            'curl!'   => \$self->{try_curl},
            'auto-cleanup=s' => \$self->{auto_cleanup},
            'man-pages!' => \$self->{pod2man},
            'scandeps'   => \$self->{scandeps},
            'showdeps'   => sub { $self->{showdeps} = 1; $self->{skip_installed} = 0 },
            'format=s'   => \$self->{format},
            'save-dists=s' => sub {
                $self->{save_dists} = $self->maybe_abs($_[1]);
            },
            'skip-configure!' => \$self->{skip_configure},
            'dev!'       => \$self->{dev_release},
            'metacpan!'  => \$self->{metacpan},
            'report-perl-version!' => \$self->{report_perl_version},
            'configure-timeout=i' => \$self->{configure_timeout},
            'build-timeout=i' => \$self->{build_timeout},
            'test-timeout=i' => \$self->{test_timeout},
            'with-develop' => \$self->{with_develop},
            'without-develop' => sub { $self->{with_develop} = 0 },
            'with-feature=s' => sub { $self->{features}{$_[1]} = 1 },
            'without-feature=s' => sub { $self->{features}{$_[1]} = 0 },
            'with-all-features' => sub { $self->{features}{__all} = 1 },
            'pp|pureperl!' => \$self->{pure_perl},
            "cpanfile=s" => \$self->{cpanfile_path},
            $self->install_type_handlers,
            $self->build_args_handlers,
        );
    
        if (!@ARGV && $0 ne '-' && !-t STDIN){ # e.g. # cpanm < author/requires.cpanm
            push @ARGV, $self->load_argv_from_fh(\*STDIN);
            $self->{load_from_stdin} = 1;
        }
    
        $self->{argv} = \@ARGV;
    }
    
    sub check_upgrade {
        my $self = shift;
        my $install_base = $ENV{PERL_LOCAL_LIB_ROOT} ? $self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}) : $Config{installsitebin};
        if ($0 eq '-') {
            # run from curl, that's fine
            return;
        } elsif ($0 !~ /^$install_base/) {
            if ($0 =~ m!perlbrew/bin!) {
                die <<DIE;
    It appears your cpanm executable was installed via `perlbrew install-cpanm`.
    cpanm --self-upgrade won't upgrade the version of cpanm you're running.
    
    Run the following command to get it upgraded.
    
      perlbrew install-cpanm
    
    DIE
            } else {
                die <<DIE;
    You are running cpanm from the path where your current perl won't install executables to.
    Because of that, cpanm --self-upgrade won't upgrade the version of cpanm you're running.
    
      cpanm path   : $0
      Install path : $Config{installsitebin}
    
    It means you either installed cpanm globally with system perl, or use distro packages such
    as rpm or apt-get, and you have to use them again to upgrade cpanm.
    DIE
            }
        }
    }
    
    sub check_libs {
        my $self = shift;
        return if $self->{_checked}++;
    
        $self->bootstrap_local_lib;
        if (@{$self->{bootstrap_deps} || []}) {
            local $self->{notest} = 1; # test failure in bootstrap should be tolerated
            local $self->{scandeps} = 0;
            $self->install_deps(Cwd::cwd, 0, @{$self->{bootstrap_deps}});
        }
    }
    
    sub setup_verify {
        my $self = shift;
    
        my $has_modules = eval { require Module::Signature; require Digest::SHA; 1 };
        $self->{cpansign} = $self->which('cpansign');
    
        unless ($has_modules && $self->{cpansign}) {
            warn "WARNING: Module::Signature and Digest::SHA is required for distribution verifications.\n";
            $self->{verify} = 0;
        }
    }
    
    sub parse_module_args {
        my($self, $module) = @_;
    
        # Plack@1.2 -> Plack~"==1.2"
        # BUT don't expand @ in git URLs
        $module =~ s/^([A-Za-z0-9_:]+)@([v\d\._]+)$/$1~== $2/;
    
        # Plack~1.20, DBI~"> 1.0, <= 2.0"
        if ($module =~ /\~[v\d\._,\!<>= ]+$/) {
            return split /\~/, $module, 2;
        } else {
            return $module, undef;
        }
    }
    
    sub _exit {
        my($self, $code) = @_;
        die App::cpanminus::CommandExit->new($code);
    }
    
    sub doit {
        my $self = shift;
    
        my $code;
        eval {
            $code = ($self->_doit == 0);
        }; if (my $e = $@) {
            if (ref $e eq 'App::cpanminus::CommandExit') {
                $code = $e->code;
            } else {
                warn $e;
                $code = 1;
            }
        }
    
        return $code;
    }
    
    sub _doit {
        my $self = shift;
    
        $self->setup_home;
        $self->init_tools;
        $self->setup_verify if $self->{verify};
    
        if (my $action = $self->{action}) {
            $self->$action() and return 1;
        }
    
        $self->show_help(1)
            unless @{$self->{argv}} or $self->{load_from_stdin};
    
        $self->configure_mirrors;
    
        my $cwd = Cwd::cwd;
    
        my @fail;
        for my $module (@{$self->{argv}}) {
            if ($module =~ s/\.pm$//i) {
                my ($volume, $dirs, $file) = File::Spec->splitpath($module);
                $module = join '::', grep { $_ } File::Spec->splitdir($dirs), $file;
            }
    
            ($module, my $version) = $self->parse_module_args($module);
    
            $self->chdir($cwd);
            if ($self->{cmd} eq 'uninstall') {
                $self->uninstall_module($module)
                  or push @fail, $module;
            } else {
                $self->install_module($module, 0, $version)
                    or push @fail, $module;
            }
        }
    
        if ($self->{base} && $self->{auto_cleanup}) {
            $self->cleanup_workdirs;
        }
    
        if ($self->{installed_dists}) {
            my $dists = $self->{installed_dists} > 1 ? "distributions" : "distribution";
            $self->diag("$self->{installed_dists} $dists installed\n", 1);
        }
    
        if ($self->{scandeps}) {
            $self->dump_scandeps();
        }
        # Workaround for older File::Temp's
        # where creating a tempdir with an implicit $PWD
        # causes tempdir non-cleanup if $PWD changes
        # as paths are stored internally without being resolved
        # absolutely.
        # https://rt.cpan.org/Public/Bug/Display.html?id=44924
        $self->chdir($cwd);
    
        return !@fail;
    }
    
    sub setup_home {
        my $self = shift;
    
        $self->{home} = $self->env('HOME') if $self->env('HOME');
    
        unless (_writable($self->{home})) {
            die "Can't write to cpanm home '$self->{home}': You should fix it with chown/chmod first.\n";
        }
    
        $self->{base} = "$self->{home}/work/" . time . ".$$";
        File::Path::mkpath([ $self->{base} ], 0, 0777);
    
        # native path because we use shell redirect
        $self->{log} = File::Spec->catfile($self->{base}, "build.log");
        my $final_log = "$self->{home}/build.log";
    
        { open my $out, ">$self->{log}" or die "$self->{log}: $!" }
    
        if (CAN_SYMLINK) {
            my $build_link = "$self->{home}/latest-build";
            unlink $build_link;
            symlink $self->{base}, $build_link;
    
            unlink $final_log;
            symlink $self->{log}, $final_log;
        } else {
            my $log = $self->{log}; my $home = $self->{home};
            $self->{at_exit} = sub {
                my $self = shift;
                my $temp_log = "$home/build.log." . time . ".$$";
                File::Copy::copy($log, $temp_log)
                    && unlink($final_log)
                    && rename($temp_log, $final_log);
            }
        }
    
        $self->chat("cpanm (App::cpanminus) $VERSION on perl $] built for $Config{archname}\n" .
                    "Work directory is $self->{base}\n");
    }
    
    sub package_index_for {
        my ($self, $mirror) = @_;
        return $self->source_for($mirror) . "/02packages.details.txt";
    }
    
    sub generate_mirror_index {
        my ($self, $mirror) = @_;
        my $file = $self->package_index_for($mirror);
        my $gz_file = $file . '.gz';
        my $index_mtime = (stat $gz_file)[9];
    
        unless (-e $file && (stat $file)[9] >= $index_mtime) {
            $self->chat("Uncompressing index file...\n");
            if (eval {require Compress::Zlib}) {
                my $gz = Compress::Zlib::gzopen($gz_file, "rb")
                    or do { $self->diag_fail("$Compress::Zlib::gzerrno opening compressed index"); return};
                open my $fh, '>', $file
                    or do { $self->diag_fail("$! opening uncompressed index for write"); return };
                my $buffer;
                while (my $status = $gz->gzread($buffer)) {
                    if ($status < 0) {
                        $self->diag_fail($gz->gzerror . " reading compressed index");
                        return;
                    }
                    print $fh $buffer;
                }
            } else {
                if (system("gunzip -c $gz_file > $file")) {
                    $self->diag_fail("Cannot uncompress -- please install gunzip or Compress::Zlib");
                    return;
                }
            }
            utime $index_mtime, $index_mtime, $file;
        }
        return 1;
    }
    
    sub search_mirror_index {
        my ($self, $mirror, $module, $version) = @_;
        $self->search_mirror_index_file($self->package_index_for($mirror), $module, $version);
    }
    
    sub search_mirror_index_file {
        my($self, $file, $module, $version) = @_;
    
        open my $fh, '<', $file or return;
        my $found;
        while (<$fh>) {
            if (m!^\Q$module\E\s+([\w\.]+)\s+(\S*)!m) {
                $found = $self->cpan_module($module, $2, $1);
                last;
            }
        }
    
        return $found unless $self->{cascade_search};
    
        if ($found) {
            if ($self->satisfy_version($module, $found->{module_version}, $version)) {
                return $found;
            } else {
                $self->chat("Found $module $found->{module_version} which doesn't satisfy $version.\n");
            }
        }
    
        return;
    }
    
    sub with_version_range {
        my($self, $version) = @_;
        defined($version) && $version =~ /[<>=]/;
    }
    
    sub encode_json {
        my($self, $data) = @_;
        require JSON::PP;
    
        my $json = JSON::PP::encode_json($data);
        $json =~ s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;
        $json;
    }
    
    # TODO extract this as a module?
    sub version_to_query {
        my($self, $module, $version) = @_;
    
        require CPAN::Meta::Requirements;
    
        my $requirements = CPAN::Meta::Requirements->new;
        $requirements->add_string_requirement($module, $version || '0');
    
        my $req = $requirements->requirements_for_module($module);
    
        if ($req =~ s/^==\s*//) {
            return {
                term => { 'module.version' => $req },
            };
        } elsif ($req !~ /\s/) {
            return {
                range => { 'module.version_numified' => { 'gte' => $self->numify_ver($req) } },
            };
        } else {
            my %ops = qw(< lt <= lte > gt >= gte);
            my(%range, @exclusion);
            my @requirements = split /,\s*/, $req;
            for my $r (@requirements) {
                if ($r =~ s/^([<>]=?)\s*//) {
                    $range{$ops{$1}} = $self->numify_ver($r);
                } elsif ($r =~ s/\!=\s*//) {
                    push @exclusion, $self->numify_ver($r);
                }
            }
    
            my @filters= (
                { range => { 'module.version_numified' => \%range } },
            );
    
            if (@exclusion) {
                push @filters, {
                    not => { or => [ map { +{ term => { 'module.version_numified' => $self->numify_ver($_) } } } @exclusion ] },
                };
            }
    
            return @filters;
        }
    }
    
    sub numify_ver {
        my($self, $ver) = @_;
        version->new($ver)->numify;
    }
    
    sub maturity_filter {
        my($self, $module, $version) = @_;
    
        my @filters;
    
        # TODO: dev release should be enabled per dist
        if (!$self->with_version_range($version) or $self->{dev_release}) {
            # backpan'ed dev release are considered "cancelled"
            push @filters, { not => { term => { status => 'backpan' } } };
        }
    
        unless ($self->{dev_release} or $version =~ /==/) {
            push @filters, { term => { maturity => 'released' } };
        }
    
        return @filters;
    }
    
    sub by_version {
        my %s = qw( latest 3  cpan 2  backpan 1 );
        $b->{_score} <=> $a->{_score} ||                             # version: higher version that satisfies the query
        $s{ $b->{fields}{status} } <=> $s{ $a->{fields}{status} };   # prefer non-BackPAN dist
    }
    
    sub by_first_come {
        $a->{fields}{date} cmp $b->{fields}{date};                   # first one wins, if all are in BackPAN/CPAN
    }
    
    sub by_date {
        $b->{fields}{date} cmp $a->{fields}{date};                   # prefer new uploads, when searching for dev
    }
    
    sub find_best_match {
        my($self, $match, $version) = @_;
        return unless $match && @{$match->{hits}{hits} || []};
        my @hits = $self->{dev_release}
            ? sort { by_version || by_date } @{$match->{hits}{hits}}
            : sort { by_version || by_first_come } @{$match->{hits}{hits}};
        $hits[0]->{fields};
    }
    
    sub search_metacpan {
        my($self, $module, $version) = @_;
    
        require JSON::PP;
    
        $self->chat("Searching $module ($version) on metacpan ...\n");
    
        my $metacpan_uri = 'http://api.metacpan.org/v0';
    
        my @filter = $self->maturity_filter($module, $version);
    
        my $query = { filtered => {
            (@filter ? (filter => { and => \@filter }) : ()),
            query => { nested => {
                score_mode => 'max',
                path => 'module',
                query => { custom_score => {
                    metacpan_script => "score_version_numified",
                    query => { constant_score => {
                        filter => { and => [
                            { term => { 'module.authorized' => JSON::PP::true() } },
                            { term => { 'module.indexed' => JSON::PP::true() } },
                            { term => { 'module.name' => $module } },
                            $self->version_to_query($module, $version),
                        ] }
                    } },
                } },
            } },
        } };
    
        my $module_uri = "$metacpan_uri/file/_search?source=";
        $module_uri .= $self->encode_json({
            query => $query,
            fields => [ 'date', 'release', 'module', 'status' ],
        });
    
        my($release, $module_version);
    
        my $module_json = $self->get($module_uri);
        my $module_meta = eval { JSON::PP::decode_json($module_json) };
        my $match = $self->find_best_match($module_meta);
        if ($match) {
            $release = $match->{release};
            my $module_matched = (grep { $_->{name} eq $module } @{$match->{module}})[0];
            $module_version = $module_matched->{version};
        }
    
        unless ($release) {
            $self->chat("! Could not find a release matching $module ($version) on MetaCPAN.\n");
            return;
        }
    
        my $dist_uri = "$metacpan_uri/release/_search?source=";
        $dist_uri .= $self->encode_json({
            filter => {
                term => { 'release.name' => $release },
            },
            fields => [ 'download_url', 'stat', 'status' ],
        });
    
        my $dist_json = $self->get($dist_uri);
        my $dist_meta = eval { JSON::PP::decode_json($dist_json) };
    
        if ($dist_meta) {
            $dist_meta = $dist_meta->{hits}{hits}[0]{fields};
        }
        if ($dist_meta && $dist_meta->{download_url}) {
            (my $distfile = $dist_meta->{download_url}) =~ s!.+/authors/id/!!;
            local $self->{mirrors} = $self->{mirrors};
            if ($dist_meta->{status} eq 'backpan') {
                $self->{mirrors} = [ 'http://backpan.perl.org' ];
            } elsif ($dist_meta->{stat}{mtime} > time()-24*60*60) {
                $self->{mirrors} = [ 'http://cpan.metacpan.org' ];
            }
            return $self->cpan_module($module, $distfile, $module_version);
        }
    
        $self->diag_fail("Finding $module on metacpan failed.");
        return;
    }
    
    sub search_database {
        my($self, $module, $version) = @_;
    
        my $found;
        my $range = ($self->with_version_range($version) || $self->{dev_release});
    
        if ($range or $self->{metacpan}) {
            $found = $self->search_metacpan($module, $version)   and return $found;
            $found = $self->search_cpanmetadb($module, $version) and return $found;
        } else {
            $found = $self->search_cpanmetadb($module, $version) and return $found;
            $found = $self->search_metacpan($module, $version)   and return $found;
        }
    }
    
    sub search_cpanmetadb {
        my($self, $module, $version) = @_;
    
        $self->chat("Searching $module on cpanmetadb ...\n");
    
        (my $uri = $self->{cpanmetadb}) =~ s{/?$}{/package/$module};
        my $yaml = $self->get($uri);
        my $meta = $self->parse_meta_string($yaml);
        if ($meta && $meta->{distfile}) {
            return $self->cpan_module($module, $meta->{distfile}, $meta->{version});
        }
    
        $self->diag_fail("Finding $module on cpanmetadb failed.");
        return;
    }
    
    sub search_module {
        my($self, $module, $version) = @_;
    
        if ($self->{mirror_index}) {
            $self->mask_output( chat => "Searching $module on mirror index $self->{mirror_index} ...\n" );
            my $pkg = $self->search_mirror_index_file($self->{mirror_index}, $module, $version);
            return $pkg if $pkg;
    
            unless ($self->{cascade_search}) {
               $self->mask_output( diag_fail => "Finding $module ($version) on mirror index $self->{mirror_index} failed." );
               return;
            }
        }
    
        unless ($self->{mirror_only}) {
            my $found = $self->search_database($module, $version);
            return $found if $found;
        }
    
        MIRROR: for my $mirror (@{ $self->{mirrors} }) {
            $self->mask_output( chat => "Searching $module on mirror $mirror ...\n" );
            my $name = '02packages.details.txt.gz';
            my $uri  = "$mirror/modules/$name";
            my $gz_file = $self->package_index_for($mirror) . '.gz';
    
            unless ($self->{pkgs}{$uri}) {
                $self->mask_output( chat => "Downloading index file $uri ...\n" );
                $self->mirror($uri, $gz_file);
                $self->generate_mirror_index($mirror) or next MIRROR;
                $self->{pkgs}{$uri} = "!!retrieved!!";
            }
    
            my $pkg = $self->search_mirror_index($mirror, $module, $version);
            return $pkg if $pkg;
    
            $self->mask_output( diag_fail => "Finding $module ($version) on mirror $mirror failed." );
        }
    
        return;
    }
    
    sub source_for {
        my($self, $mirror) = @_;
        $mirror =~ s/[^\w\.\-]+/%/g;
    
        my $dir = "$self->{home}/sources/$mirror";
        File::Path::mkpath([ $dir ], 0, 0777);
    
        return $dir;
    }
    
    sub load_argv_from_fh {
        my($self, $fh) = @_;
    
        my @argv;
        while(defined(my $line = <$fh>)){
            chomp $line;
            $line =~ s/#.+$//; # comment
            $line =~ s/^\s+//; # trim spaces
            $line =~ s/\s+$//; # trim spaces
    
            push @argv, split ' ', $line if $line;
        }
        return @argv;
    }
    
    sub show_version {
        my $self = shift;
    
        print "cpanm (App::cpanminus) version $VERSION ($0)\n";
        print "perl version $] ($^X)\n\n";
    
        print "  \%Config:\n";
        for my $key (qw( archname installsitelib installsitebin installman1dir installman3dir
                         sitelibexp archlibexp privlibexp )) {
            print "    $key=$Config{$key}\n";
        }
    
        print "  \%ENV:\n";
        for my $key (grep /^PERL/, sort keys %ENV) {
            print "    $key=$ENV{$key}\n";
        }
    
        print "  \@INC:\n";
        for my $inc (@INC) {
            print "    $inc\n" unless ref($inc) eq 'CODE';
        }
    
        return 1;
    }
    
    sub show_help {
        my $self = shift;
    
        if ($_[0]) {
            print <<USAGE;
    Usage: cpanm [options] Module [...]
    
    Try `cpanm --help` or `man cpanm` for more options.
    USAGE
            $self->_exit(1);
        }
    
        print <<HELP;
    Usage: cpanm [options] Module [...]
    
    Options:
      -v,--verbose              Turns on chatty output
      -q,--quiet                Turns off the most output
      --interactive             Turns on interactive configure (required for Task:: modules)
      -f,--force                force install
      -n,--notest               Do not run unit tests
      --test-only               Run tests only, do not install
      -S,--sudo                 sudo to run install commands
      --installdeps             Only install dependencies
      --showdeps                Only display direct dependencies
      --reinstall               Reinstall the distribution even if you already have the latest version installed
      --mirror                  Specify the base URL for the mirror (e.g. http://cpan.cpantesters.org/)
      --mirror-only             Use the mirror's index file instead of the CPAN Meta DB
      --prompt                  Prompt when configure/build/test fails
      -l,--local-lib            Specify the install base to install modules
      -L,--local-lib-contained  Specify the install base to install all non-core modules
      --self-contained          Install all non-core modules, even if they're already installed.
      --auto-cleanup            Number of days that cpanm's work directories expire in. Defaults to 7
    
    Commands:
      --self-upgrade            upgrades itself
      --info                    Displays distribution info on CPAN
      --look                    Opens the distribution with your SHELL
      -U,--uninstall            Uninstalls the modules (EXPERIMENTAL)
      -V,--version              Displays software version
    
    Examples:
    
      cpanm Test::More                                          # install Test::More
      cpanm MIYAGAWA/Plack-0.99_05.tar.gz                       # full distribution path
      cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz           # install from URL
      cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz            # install from a local file
      cpanm --interactive Task::Kensho                          # Configure interactively
      cpanm .                                                   # install from local directory
      cpanm --installdeps .                                     # install all the deps for the current directory
      cpanm -L extlib Plack                                     # install Plack and all non-core deps into extlib
      cpanm --mirror http://cpan.cpantesters.org/ DBI           # use the fast-syncing mirror
    
    You can also specify the default options in PERL_CPANM_OPT environment variable in the shell rc:
    
      export PERL_CPANM_OPT="--prompt --reinstall -l ~/perl --mirror http://cpan.cpantesters.org"
    
    Type `man cpanm` or `perldoc cpanm` for the more detailed explanation of the options.
    
    HELP
    
        return 1;
    }
    
    sub _writable {
        my $dir = shift;
        my @dir = File::Spec->splitdir($dir);
        while (@dir) {
            $dir = File::Spec->catdir(@dir);
            if (-e $dir) {
                return -w _;
            }
            pop @dir;
        }
    
        return;
    }
    
    sub maybe_abs {
        my($self, $lib) = @_;
        if ($lib eq '_' or $lib =~ /^~/ or File::Spec->file_name_is_absolute($lib)) {
            return $lib;
        } else {
            return File::Spec->canonpath(File::Spec->catdir(Cwd::cwd(), $lib));
        }
    }
    
    sub local_lib_target {
        my($self, $root) = @_;
        (grep { $_ ne '' } split /\Q$Config{path_sep}/, $root)[-1];
    }
    
    sub bootstrap_local_lib {
        my $self = shift;
    
        # If -l is specified, use that.
        if ($self->{local_lib}) {
            return $self->setup_local_lib($self->{local_lib});
        }
    
        # PERL_LOCAL_LIB_ROOT is defined. Run as local::lib mode without overwriting ENV
        if ($ENV{PERL_LOCAL_LIB_ROOT} && $ENV{PERL_MM_OPT}) {
            return $self->setup_local_lib($self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}), 1);
        }
    
        # root, locally-installed perl or --sudo: don't care about install_base
        return if $self->{sudo} or (_writable($Config{installsitelib}) and _writable($Config{installsitebin}));
    
        # local::lib is configured in the shell -- yay
        if ($ENV{PERL_MM_OPT} and ($ENV{MODULEBUILDRC} or $ENV{PERL_MB_OPT})) {
            $self->bootstrap_local_lib_deps;
            return;
        }
    
        $self->setup_local_lib;
    
        $self->diag(<<DIAG, 1);
    !
    ! Can't write to $Config{installsitelib} and $Config{installsitebin}: Installing modules to $ENV{HOME}/perl5
    ! To turn off this warning, you have to do one of the following:
    !   - run me as a root or with --sudo option (to install to $Config{installsitelib} and $Config{installsitebin})
    !   - Configure local::lib your existing local::lib in this shell to set PERL_MM_OPT etc.
    !   - Install local::lib by running the following commands
    !
    !         cpanm --local-lib=~/perl5 local::lib && eval \$(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
    !
    DIAG
        sleep 2;
    }
    
    sub _core_only_inc {
        my($self, $base) = @_;
        require local::lib;
        (
            local::lib->resolve_path(local::lib->install_base_perl_path($base)),
            local::lib->resolve_path(local::lib->install_base_arch_path($base)),
            @Config{qw(privlibexp archlibexp)},
        );
    }
    
    sub _diff {
        my($self, $old, $new) = @_;
    
        my @diff;
        my %old = map { $_ => 1 } @$old;
        for my $n (@$new) {
            push @diff, $n unless exists $old{$n};
        }
    
        @diff;
    }
    
    sub _setup_local_lib_env {
        my($self, $base) = @_;
    
        $self->diag(<<WARN, 1) if $base =~ /\s/;
    WARNING: Your lib directory name ($base) contains a space in it. It's known to cause issues with perl builder tools such as local::lib and MakeMaker. You're recommended to rename your directory.
    WARN
    
        local $SIG{__WARN__} = sub { }; # catch 'Attempting to write ...'
        local::lib->setup_env_hash_for($base, 0);
    }
    
    sub setup_local_lib {
        my($self, $base, $no_env) = @_;
        $base = undef if $base eq '_';
    
        require local::lib;
        {
            local $0 = 'cpanm'; # so curl/wget | perl works
            $base ||= "~/perl5";
            $base = local::lib->resolve_path($base);
            if ($self->{self_contained}) {
                my @inc = $self->_core_only_inc($base);
                $self->{search_inc} = [ @inc ];
            } else {
                $self->{search_inc} = [
                    local::lib->install_base_arch_path($base),
                    local::lib->install_base_perl_path($base),
                    @INC,
                ];
            }
            $self->_setup_local_lib_env($base) unless $no_env;
            $self->{local_lib} = $base;
        }
    
        $self->bootstrap_local_lib_deps;
    }
    
    sub bootstrap_local_lib_deps {
        my $self = shift;
        push @{$self->{bootstrap_deps}},
            Dependency->new('ExtUtils::MakeMaker' => 6.31),
            Dependency->new('ExtUtils::Install'   => 1.46);
    }
    
    sub prompt_bool {
        my($self, $mess, $def) = @_;
    
        my $val = $self->prompt($mess, $def);
        return lc $val eq 'y';
    }
    
    sub prompt {
        my($self, $mess, $def) = @_;
    
        my $isa_tty = -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT)) ;
        my $dispdef = defined $def ? "[$def] " : " ";
        $def = defined $def ? $def : "";
    
        if (!$self->{prompt} || (!$isa_tty && eof STDIN)) {
            return $def;
        }
    
        local $|=1;
        local $\;
        my $ans;
        eval {
            local $SIG{ALRM} = sub { undef $ans; die "alarm\n" };
            print STDOUT "$mess $dispdef";
            alarm $self->{prompt_timeout} if $self->{prompt_timeout};
            $ans = <STDIN>;
            alarm 0;
        };
        if ( defined $ans ) {
            chomp $ans;
        } else { # user hit ctrl-D or alarm timeout
            print STDOUT "\n";
        }
    
        return (!defined $ans || $ans eq '') ? $def : $ans;
    }
    
    sub diag_ok {
        my($self, $msg) = @_;
        chomp $msg;
        $msg ||= "OK";
        if ($self->{in_progress}) {
            $self->_diag("$msg\n");
            $self->{in_progress} = 0;
        }
        $self->log("-> $msg\n");
    }
    
    sub diag_fail {
        my($self, $msg, $always) = @_;
        chomp $msg;
        if ($self->{in_progress}) {
            $self->_diag("FAIL\n");
            $self->{in_progress} = 0;
        }
    
        if ($msg) {
            $self->_diag("! $msg\n", $always, 1);
            $self->log("-> FAIL $msg\n");
        }
    }
    
    sub diag_progress {
        my($self, $msg) = @_;
        chomp $msg;
        $self->{in_progress} = 1;
        $self->_diag("$msg ... ");
        $self->log("$msg\n");
    }
    
    sub _diag {
        my($self, $msg, $always, $error) = @_;
        my $fh = $error ? *STDERR : *STDOUT;
        print {$fh} $msg if $always or $self->{verbose} or !$self->{quiet};
    }
    
    sub diag {
        my($self, $msg, $always) = @_;
        $self->_diag($msg, $always);
        $self->log($msg);
    }
    
    sub chat {
        my $self = shift;
        print STDERR @_ if $self->{verbose};
        $self->log(@_);
    }
    
    sub mask_output {
        my $self = shift;
        my $method = shift;
        $self->$method( $self->mask_uri_passwords(@_) );
    }
    
    sub log {
        my $self = shift;
        open my $out, ">>$self->{log}";
        print $out @_;
    }
    
    sub run {
        my($self, $cmd) = @_;
    
        if (WIN32) {
            $cmd = $self->shell_quote(@$cmd) if ref $cmd eq 'ARRAY';
            unless ($self->{verbose}) {
                $cmd .= " >> " . $self->shell_quote($self->{log}) . " 2>&1";
            }
            !system $cmd;
        } else {
            my $pid = fork;
            if ($pid) {
                waitpid $pid, 0;
                return !$?;
            } else {
                $self->run_exec($cmd);
            }
        }
    }
    
    sub run_exec {
        my($self, $cmd) = @_;
    
        if (ref $cmd eq 'ARRAY') {
            unless ($self->{verbose}) {
                open my $logfh, ">>", $self->{log};
                open STDERR, '>&', $logfh;
                open STDOUT, '>&', $logfh;
                close $logfh;
            }
            exec @$cmd;
        } else {
            unless ($self->{verbose}) {
                $cmd .= " >> " . $self->shell_quote($self->{log}) . " 2>&1";
            }
            exec $cmd;
        }
    }
    
    sub run_timeout {
        my($self, $cmd, $timeout) = @_;
        return $self->run($cmd) if WIN32 || $self->{verbose} || !$timeout;
    
        my $pid = fork;
        if ($pid) {
            eval {
                local $SIG{ALRM} = sub { die "alarm\n" };
                alarm $timeout;
                waitpid $pid, 0;
                alarm 0;
            };
            if ($@ && $@ eq "alarm\n") {
                $self->diag_fail("Timed out (> ${timeout}s). Use --verbose to retry.");
                local $SIG{TERM} = 'IGNORE';
                kill TERM => 0;
                waitpid $pid, 0;
                return;
            }
            return !$?;
        } elsif ($pid == 0) {
            $self->run_exec($cmd);
        } else {
            $self->chat("! fork failed: falling back to system()\n");
            $self->run($cmd);
        }
    }
    
    sub append_args {
        my($self, $cmd, $phase) = @_;
    
        if (my $args = $self->{build_args}{$phase}) {
            $cmd = join ' ', $self->shell_quote(@$cmd), $args;
        }
    
        $cmd;
    }
    
    sub configure {
        my($self, $cmd, $depth) = @_;
    
        # trick AutoInstall
        local $ENV{PERL5_CPAN_IS_RUNNING} = local $ENV{PERL5_CPANPLUS_IS_RUNNING} = $$;
    
        # e.g. skip CPAN configuration on local::lib
        local $ENV{PERL5_CPANM_IS_RUNNING} = $$;
    
        my $use_default = !$self->{interactive};
        local $ENV{PERL_MM_USE_DEFAULT} = $use_default;
    
        local $ENV{PERL_MM_OPT} = $ENV{PERL_MM_OPT};
        local $ENV{PERL_MB_OPT} = $ENV{PERL_MB_OPT};
    
        # skip man page generation
        unless ($self->{pod2man}) {
            $ENV{PERL_MM_OPT} .= " INSTALLMAN1DIR=none INSTALLMAN3DIR=none";
            $ENV{PERL_MB_OPT} .= " --config installman1dir= --config installsiteman1dir= --config installman3dir= --config installsiteman3dir=";
        }
    
        # Lancaster Consensus
        if ($self->{pure_perl}) {
            $ENV{PERL_MM_OPT} .= " PUREPERL_ONLY=1";
            $ENV{PERL_MB_OPT} .= " --pureperl-only";
        }
    
        $cmd = $self->append_args($cmd, 'configure') if $depth == 0;
    
        local $self->{verbose} = $self->{verbose} || $self->{interactive};
        $self->run_timeout($cmd, $self->{configure_timeout});
    }
    
    sub build {
        my($self, $cmd, $distname, $depth) = @_;
    
        local $ENV{PERL_MM_USE_DEFAULT} = !$self->{interactive};
    
        $cmd = $self->append_args($cmd, 'build') if $depth == 0;
    
        return 1 if $self->run_timeout($cmd, $self->{build_timeout});
        while (1) {
            my $ans = lc $self->prompt("Building $distname failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?", "s");
            return                                       if $ans eq 's';
            return $self->build($cmd, $distname, $depth) if $ans eq 'r';
            $self->show_build_log                        if $ans eq 'e';
            $self->look                                  if $ans eq 'l';
        }
    }
    
    sub test {
        my($self, $cmd, $distname, $depth) = @_;
        return 1 if $self->{notest};
    
        # https://rt.cpan.org/Ticket/Display.html?id=48965#txn-1013385
        local $ENV{PERL_MM_USE_DEFAULT} = !$self->{interactive};
    
        # https://github.com/Perl-Toolchain-Gang/toolchain-site/blob/master/lancaster-consensus.md
        local $ENV{NONINTERACTIVE_TESTING} = !$self->{interactive};
    
        $cmd = $self->append_args($cmd, 'test') if $depth == 0;
    
        return 1 if $self->run_timeout($cmd, $self->{test_timeout});
        if ($self->{force}) {
            $self->diag_fail("Testing $distname failed but installing it anyway.");
            return 1;
        } else {
            $self->diag_fail;
            while (1) {
                my $ans = lc $self->prompt("Testing $distname failed.\nYou can s)kip, r)etry, f)orce install, e)xamine build log, or l)ook ?", "s");
                return                                      if $ans eq 's';
                return $self->test($cmd, $distname, $depth) if $ans eq 'r';
                return 1                                    if $ans eq 'f';
                $self->show_build_log                       if $ans eq 'e';
                $self->look                                 if $ans eq 'l';
            }
        }
    }
    
    sub install {
        my($self, $cmd, $uninst_opts, $depth) = @_;
    
        if ($depth == 0 && $self->{test_only}) {
            return 1;
        }
    
        if ($self->{sudo}) {
            unshift @$cmd, "sudo";
        }
    
        if ($self->{uninstall_shadows} && !$ENV{PERL_MM_OPT}) {
            push @$cmd, @$uninst_opts;
        }
    
        $cmd = $self->append_args($cmd, 'install') if $depth == 0;
    
        $self->run($cmd);
    }
    
    sub look {
        my $self = shift;
    
        my $shell = $ENV{SHELL};
        $shell  ||= $ENV{COMSPEC} if WIN32;
        if ($shell) {
            my $cwd = Cwd::cwd;
            $self->diag("Entering $cwd with $shell\n");
            system $shell;
        } else {
            $self->diag_fail("You don't seem to have a SHELL :/");
        }
    }
    
    sub show_build_log {
        my $self = shift;
    
        my @pagers = (
            $ENV{PAGER},
            (WIN32 ? () : ('less')),
            'more'
        );
        my $pager;
        while (@pagers) {
            $pager = shift @pagers;
            next unless $pager;
            $pager = $self->which($pager);
            next unless $pager;
            last;
        }
    
        if ($pager) {
            # win32 'more' doesn't allow "more build.log", the < is required
            system("$pager < $self->{log}");
        }
        else {
            $self->diag_fail("You don't seem to have a PAGER :/");
        }
    }
    
    sub chdir {
        my $self = shift;
        Cwd::chdir(File::Spec->canonpath($_[0])) or die "$_[0]: $!";
    }
    
    sub configure_mirrors {
        my $self = shift;
        unless (@{$self->{mirrors}}) {
            $self->{mirrors} = [ 'http://www.cpan.org' ];
        }
        for (@{$self->{mirrors}}) {
            s!^/!file:///!;
            s!/$!!;
        }
    }
    
    sub self_upgrade {
        my $self = shift;
        $self->check_upgrade;
        $self->{argv} = [ 'App::cpanminus' ];
        return; # continue
    }
    
    sub install_module {
        my($self, $module, $depth, $version) = @_;
    
        $self->check_libs;
    
        if ($self->{seen}{$module}++) {
            # TODO: circular dependencies
            $self->chat("Already tried $module. Skipping.\n");
            return 1;
        }
    
        if ($self->{skip_satisfied}) {
            my($ok, $local) = $self->check_module($module, $version || 0);
            if ($ok) {
                $self->diag("You have $module ($local)\n", 1);
                return 1;
            }
        }
    
        my $dist = $self->resolve_name($module, $version);
        unless ($dist) {
            my $what = $module . ($version ? " ($version)" : "");
            $self->diag_fail("Couldn't find module or a distribution $what", 1);
            return;
        }
    
        if ($dist->{distvname} && $self->{seen}{$dist->{distvname}}++) {
            $self->chat("Already tried $dist->{distvname}. Skipping.\n");
            return 1;
        }
    
        if ($self->{cmd} eq 'info') {
            print $self->format_dist($dist), "\n";
            return 1;
        }
    
        $dist->{depth} = $depth; # ugly hack
    
        if ($dist->{module}) {
            unless ($self->satisfy_version($dist->{module}, $dist->{module_version}, $version)) {
                $self->diag("Found $dist->{module} $dist->{module_version} which doesn't satisfy $version.\n", 1);
                return;
            }
    
            # If a version is requested, it has to be the exact same version, otherwise, check as if
            # it is the minimum version you need.
            my $cmp = $version ? "==" : "";
            my $requirement = $dist->{module_version} ? "$cmp$dist->{module_version}" : 0;
            my($ok, $local) = $self->check_module($dist->{module}, $requirement);
            if ($self->{skip_installed} && $ok) {
                $self->diag("$dist->{module} is up to date. ($local)\n", 1);
                return 1;
            }
        }
    
        if ($dist->{dist} eq 'perl'){
            $self->diag("skipping $dist->{pathname}\n");
            return 1;
        }
    
        $self->diag("--> Working on $module\n");
    
        $dist->{dir} ||= $self->fetch_module($dist);
    
        unless ($dist->{dir}) {
            $self->diag_fail("Failed to fetch distribution $dist->{distvname}", 1);
            return;
        }
    
        $self->chat("Entering $dist->{dir}\n");
        $self->chdir($self->{base});
        $self->chdir($dist->{dir});
    
        if ($self->{cmd} eq 'look') {
            $self->look;
            return 1;
        }
    
        return $self->build_stuff($module, $dist, $depth);
    }
    
    sub uninstall_search_path {
        my $self = shift;
    
        $self->{local_lib}
            ? (local::lib->install_base_arch_path($self->{local_lib}),
               local::lib->install_base_perl_path($self->{local_lib}))
            : @Config{qw(installsitearch installsitelib)};
    }
    
    sub uninstall_module {
        my ($self, $module) = @_;
    
        $self->check_libs;
    
        my @inc = $self->uninstall_search_path;
    
        my($metadata, $packlist) = $self->packlists_containing($module, \@inc);
        unless ($packlist) {
            $self->diag_fail(<<DIAG, 1);
    $module is not found in the following directories and can't be uninstalled.
    
    @{[ join("  \n", map "  $_", @inc) ]}
    
    DIAG
            return;
        }
    
        my @uninst_files = $self->uninstall_target($metadata, $packlist);
    
        $self->ask_permission($module, \@uninst_files) or return;
        $self->uninstall_files(@uninst_files, $packlist);
    
        $self->diag("Successfully uninstalled $module\n", 1);
    
        return 1;
    }
    
    sub packlists_containing {
        my($self, $module, $inc) = @_;
    
        require Module::Metadata;
        my $metadata = Module::Metadata->new_from_module($module, inc => $inc)
            or return;
    
        my $packlist;
        my $wanted = sub {
            return unless $_ eq '.packlist' && -f $_;
            for my $file ($self->unpack_packlist($File::Find::name)) {
                $packlist ||= $File::Find::name if $file eq $metadata->filename;
            }
        };
    
        {
            require File::pushd;
            my $pushd = File::pushd::pushd();
            my @search = grep -d $_, map File::Spec->catdir($_, 'auto'), @$inc;
            File::Find::find($wanted, @search);
        }
    
        return $metadata, $packlist;
    }
    
    sub uninstall_target {
        my($self, $metadata, $packlist) = @_;
    
        # If the module has a shadow install, or uses local::lib, then you can't just remove
        # all files in .packlist since it might have shadows in there
        if ($self->has_shadow_install($metadata) or $self->{local_lib}) {
            grep $self->should_unlink($_), $self->unpack_packlist($packlist);
        } else {
            $self->unpack_packlist($packlist);
        }
    }
    
    sub has_shadow_install {
        my($self, $metadata) = @_;
    
        # check if you have the module in site_perl *and* perl
        my @shadow = grep defined, map Module::Metadata->new_from_module($metadata->name, inc => [$_]), @INC;
        @shadow >= 2;
    }
    
    sub should_unlink {
        my($self, $file) = @_;
    
        # If local::lib is used, everything under the directory can be safely removed
        # Otherwise, bin and man files might be shared with the shadows i.e. site_perl vs perl
        # This is not 100% safe to keep the script there hoping to work with older version of .pm
        # files in the shadow, but there's nothing you can do about it.
        if ($self->{local_lib}) {
            $file =~ /^\Q$self->{local_lib}\E/;
        } else {
            !(grep $file =~ /^\Q$_\E/, @Config{qw(installbin installscript installman1dir installman3dir)});
        }
    }
    
    sub ask_permission {
        my ($self, $module, $files) = @_;
    
        $self->diag("$module contains the following files:\n\n");
        for my $file (@$files) {
            $self->diag("  $file\n");
        }
        $self->diag("\n");
    
        return 'force uninstall' if $self->{force};
        local $self->{prompt} = 1;
        return $self->prompt_bool("Are you sure you want to uninstall $module?", 'y');
    }
    
    sub unpack_packlist {
        my ($self, $packlist) = @_;
        open my $fh, '<', $packlist or die "$packlist: $!";
        map { chomp; $_ } <$fh>;
    }
    
    sub uninstall_files {
        my ($self, @files) = @_;
    
        $self->diag("\n");
    
        for my $file (@files) {
            $self->diag("Unlink: $file\n");
            unlink $file or $self->diag_fail("$!: $file");
        }
    
        $self->diag("\n");
    
        return 1;
    }
    
    sub format_dist {
        my($self, $dist) = @_;
    
        # TODO support --dist-format?
        return "$dist->{cpanid}/$dist->{filename}";
    }
    
    sub trim {
        local $_ = shift;
        tr/\n/ /d;
        s/^\s*|\s*$//g;
        $_;
    }
    
    sub fetch_module {
        my($self, $dist) = @_;
    
        $self->chdir($self->{base});
    
        for my $uri (@{$dist->{uris}}) {
            $self->mask_output( diag_progress => "Fetching $uri" );
    
            # Ugh, $dist->{filename} can contain sub directory
            my $filename = $dist->{filename} || $uri;
            my $name = File::Basename::basename($filename);
    
            my $cancelled;
            my $fetch = sub {
                my $file;
                eval {
                    local $SIG{INT} = sub { $cancelled = 1; die "SIGINT\n" };
                    $self->mirror($uri, $name);
                    $file = $name if -e $name;
                };
                $self->diag("ERROR: " . trim("$@") . "\n", 1) if $@ && $@ ne "SIGINT\n";
                return $file;
            };
    
            my($try, $file);
            while ($try++ < 3) {
                $file = $fetch->();
                last if $cancelled or $file;
                $self->diag_fail("Download $uri failed. Retrying ... ");
            }
    
            if ($cancelled) {
                $self->diag_fail("Download cancelled.");
                return;
            }
    
            unless ($file) {
                $self->diag_fail("Failed to download $uri");
                next;
            }
    
            $self->diag_ok;
            $dist->{local_path} = File::Spec->rel2abs($name);
    
            my $dir = $self->unpack($file, $uri, $dist);
            next unless $dir; # unpack failed
    
            if (my $save = $self->{save_dists}) {
                # Only distros retrieved from CPAN have a pathname set
                my $path = $dist->{pathname} ? "$save/authors/id/$dist->{pathname}"
                                             : "$save/vendor/$file";
                $self->chat("Copying $name to $path\n");
                File::Path::mkpath([ File::Basename::dirname($path) ], 0, 0777);
                File::Copy::copy($file, $path) or warn $!;
            }
    
            return $dist, $dir;
        }
    }
    
    sub unpack {
        my($self, $file, $uri, $dist) = @_;
    
        if ($self->{verify}) {
            $self->verify_archive($file, $uri, $dist) or return;
        }
    
        $self->chat("Unpacking $file\n");
        my $dir = $file =~ /\.zip/i ? $self->unzip($file) : $self->untar($file);
        unless ($dir) {
            $self->diag_fail("Failed to unpack $file: no directory");
        }
        return $dir;
    }
    
    sub verify_checksums_signature {
        my($self, $chk_file) = @_;
    
        require Module::Signature; # no fatpack
    
        $self->chat("Verifying the signature of CHECKSUMS\n");
    
        my $rv = eval {
            local $SIG{__WARN__} = sub {}; # suppress warnings
            my $v = Module::Signature::_verify($chk_file);
            $v == Module::Signature::SIGNATURE_OK();
        };
        if ($rv) {
            $self->chat("Verified OK!\n");
        } else {
            $self->diag_fail("Verifying CHECKSUMS signature failed: $rv\n");
            return;
        }
    
        return 1;
    }
    
    sub verify_archive {
        my($self, $file, $uri, $dist) = @_;
    
        unless ($dist->{cpanid}) {
            $self->chat("Archive '$file' does not seem to be from PAUSE. Skip verification.\n");
        }
    
        (my $mirror = $uri) =~ s!/authors/id.*$!!;
    
        (my $chksum_uri = $uri) =~ s!/[^/]*$!/CHECKSUMS!;
        my $chk_file = $self->source_for($mirror) . "/$dist->{cpanid}.CHECKSUMS";
        $self->mask_output( diag_progress => "Fetching $chksum_uri" );
        $self->mirror($chksum_uri, $chk_file);
    
        unless (-e $chk_file) {
            $self->diag_fail("Fetching $chksum_uri failed.\n");
            return;
        }
    
        $self->diag_ok;
        $self->verify_checksums_signature($chk_file) or return;
        $self->verify_checksum($file, $chk_file);
    }
    
    sub verify_checksum {
        my($self, $file, $chk_file) = @_;
    
        $self->chat("Verifying the SHA1 for $file\n");
    
        open my $fh, "<$chk_file" or die "$chk_file: $!";
        my $data = join '', <$fh>;
        $data =~ s/\015?\012/\n/g;
    
        require Safe; # no fatpack
        my $chksum = Safe->new->reval($data);
    
        if (!ref $chksum or ref $chksum ne 'HASH') {
            $self->diag_fail("! Checksum file downloaded from $chk_file is broken.\n");
            return;
        }
    
        if (my $sha = $chksum->{$file}{sha256}) {
            my $hex = $self->sha1_for($file);
            if ($hex eq $sha) {
                $self->chat("Checksum for $file: Verified!\n");
            } else {
                $self->diag_fail("Checksum mismatch for $file\n");
                return;
            }
        } else {
            $self->chat("Checksum for $file not found in CHECKSUMS.\n");
            return;
        }
    }
    
    sub sha1_for {
        my($self, $file) = @_;
    
        require Digest::SHA; # no fatpack
    
        open my $fh, "<", $file or die "$file: $!";
        my $dg = Digest::SHA->new(256);
        my($data);
        while (read($fh, $data, 4096)) {
            $dg->add($data);
        }
    
        return $dg->hexdigest;
    }
    
    sub verify_signature {
        my($self, $dist) = @_;
    
        $self->diag_progress("Verifying the SIGNATURE file");
        my $out = `$self->{cpansign} -v --skip 2>&1`;
        $self->log($out);
    
        if ($out =~ /Signature verified OK/) {
            $self->diag_ok("Verified OK");
            return 1;
        } else {
            $self->diag_fail("SIGNATURE verificaion for $dist->{filename} failed\n");
            return;
        }
    }
    
    sub resolve_name {
        my($self, $module, $version) = @_;
    
        # URL
        if ($module =~ /^(ftp|https?|file):/) {
            if ($module =~ m!authors/id/(.*)!) {
                return $self->cpan_dist($1, $module);
            } else {
                return { uris => [ $module ] };
            }
        }
    
        # Directory
        if ($module =~ m!^[\./]! && -d $module) {
            return {
                source => 'local',
                dir => Cwd::abs_path($module),
            };
        }
    
        # File
        if (-f $module) {
            return {
                source => 'local',
                uris => [ "file://" . Cwd::abs_path($module) ],
            };
        }
    
        # Git
        if ($module =~ /(?:^git:|\.git(?:@.+)?$)/) {
            return $self->git_uri($module);
        }
    
        # cpan URI
        if ($module =~ s!^cpan:///distfile/!!) {
            return $self->cpan_dist($module);
        }
    
        # PAUSEID/foo
        # P/PA/PAUSEID/foo
        if ($module =~ m!^(?:[A-Z]/[A-Z]{2}/)?([A-Z]{2}[\-A-Z0-9]*/.*)$!) {
            return $self->cpan_dist($1);
        }
    
        # Module name
        return $self->search_module($module, $version);
    }
    
    sub cpan_module {
        my($self, $module, $dist, $version) = @_;
    
        my $dist = $self->cpan_dist($dist);
        $dist->{module} = $module;
        $dist->{module_version} = $version if $version && $version ne 'undef';
    
        return $dist;
    }
    
    sub cpan_dist {
        my($self, $dist, $url) = @_;
    
        $dist =~ s!^([A-Z]{2})!substr($1,0,1)."/".substr($1,0,2)."/".$1!e;
    
        require CPAN::DistnameInfo;
        my $d = CPAN::DistnameInfo->new($dist);
    
        if ($url) {
            $url = [ $url ] unless ref $url eq 'ARRAY';
        } else {
            my $id = $d->cpanid;
            my $fn = substr($id, 0, 1) . "/" . substr($id, 0, 2) . "/" . $id . "/" . $d->filename;
    
            my @mirrors = @{$self->{mirrors}};
            my @urls    = map "$_/authors/id/$fn", @mirrors;
    
            $url = \@urls,
        }
    
        return {
            $d->properties,
            source  => 'cpan',
            uris    => $url,
        };
    }
    
    sub git_uri {
        my ($self, $uri) = @_;
    
        # similar to http://www.pip-installer.org/en/latest/logic.html#vcs-support
        # git URL has to end with .git when you need to use pin @ commit/tag/branch
    
        ($uri, my $commitish) = split /(?<=\.git)@/i, $uri, 2;
    
        my $dir = File::Temp::tempdir(CLEANUP => 1);
    
        $self->mask_output( diag_progress => "Cloning $uri" );
        $self->run([ 'git', 'clone', $uri, $dir ]);
    
        unless (-e "$dir/.git") {
            $self->diag_fail("Failed cloning git repository $uri", 1);
            return;
        }
    
        if ($commitish) {
            require File::pushd;
            my $dir = File::pushd::pushd($dir);
    
            unless ($self->run([ 'git', 'checkout', $commitish ])) {
                $self->diag_fail("Failed to checkout '$commitish' in git repository $uri\n");
                return;
            }
        }
    
        $self->diag_ok;
    
        return {
            source => 'local',
            dir    => $dir,
        };
    }
    
    sub setup_module_build_patch {
        my $self = shift;
    
        open my $out, ">$self->{base}/ModuleBuildSkipMan.pm" or die $!;
        print $out <<EOF;
    package ModuleBuildSkipMan;
    CHECK {
      if (%Module::Build::) {
        no warnings 'redefine';
        *Module::Build::Base::ACTION_manpages = sub {};
        *Module::Build::Base::ACTION_docs     = sub {};
      }
    }
    1;
    EOF
    }
    
    sub core_version_for {
        my($self, $module) = @_;
    
        require Module::CoreList; # no fatpack
        unless (exists $Module::CoreList::version{$]+0}) {
            die sprintf("Module::CoreList %s (loaded from %s) doesn't seem to have entries for perl $]. " .
                        "You're strongly recommended to upgrade Module::CoreList from CPAN.\n",
                        $Module::CoreList::VERSION, $INC{"Module/CoreList.pm"});
        }
    
        unless (exists $Module::CoreList::version{$]+0}{$module}) {
            return -1;
        }
    
        return $Module::CoreList::version{$]+0}{$module};
    }
    
    
    sub check_module {
        my($self, $mod, $want_ver) = @_;
    
        require Module::Metadata;
        my $meta = Module::Metadata->new_from_module($mod, inc => $self->{search_inc})
            or return 0, undef;
    
        my $version = $meta->version;
    
        # When -L is in use, the version loaded from 'perl' library path
        # might be newer than (or actually wasn't core at) the version
        # that is shipped with the current perl
        if ($self->{self_contained} && $self->loaded_from_perl_lib($meta)) {
            $version = $self->core_version_for($mod);
            return 0, undef if $version && $version == -1;
        }
    
        $self->{local_versions}{$mod} = $version;
    
        if ($self->is_deprecated($meta)){
            return 0, $version;
        } elsif ($self->satisfy_version($mod, $version, $want_ver)) {
            return 1, ($version || 'undef');
        } else {
            return 0, $version;
        }
    }
    
    sub satisfy_version {
        my($self, $mod, $version, $want_ver) = @_;
    
        $want_ver = '0' unless defined($want_ver) && length($want_ver);
    
        require CPAN::Meta::Requirements;
        my $requirements = CPAN::Meta::Requirements->new;
        $requirements->add_string_requirement($mod, $want_ver);
        $requirements->accepts_module($mod, $version);
    }
    
    sub unsatisfy_how {
        my($self, $ver, $want_ver) = @_;
    
        if ($want_ver =~ /^[v0-9\.\_]+$/) {
            return "$ver < $want_ver";
        } else {
            return "$ver doesn't satisfy $want_ver";
        }
    }
    
    sub is_deprecated {
        my($self, $meta) = @_;
    
        my $deprecated = eval {
            require Module::CoreList; # no fatpack
            Module::CoreList::is_deprecated($meta->{module});
        };
    
        return $deprecated && $self->loaded_from_perl_lib($meta);
    }
    
    sub loaded_from_perl_lib {
        my($self, $meta) = @_;
    
        require Config;
        for my $dir (qw(archlibexp privlibexp)) {
            my $confdir = $Config{$dir};
            if ($confdir eq substr($meta->filename, 0, length($confdir))) {
                return 1;
            }
        }
    
        return;
    }
    
    sub should_install {
        my($self, $mod, $ver) = @_;
    
        $self->chat("Checking if you have $mod $ver ... ");
        my($ok, $local) = $self->check_module($mod, $ver);
    
        if ($ok)       { $self->chat("Yes ($local)\n") }
        elsif ($local) { $self->chat("No (" . $self->unsatisfy_how($local, $ver) . ")\n") }
        else           { $self->chat("No\n") }
    
        return $mod unless $ok;
        return;
    }
    
    sub check_perl_version {
        my($self, $version) = @_;
        require CPAN::Meta::Requirements;
        my $req = CPAN::Meta::Requirements->from_string_hash({ perl => $version });
        $req->accepts_module(perl => $]);
    }
    
    sub install_deps {
        my($self, $dir, $depth, @deps) = @_;
    
        my(@install, %seen, @fail);
        for my $dep (@deps) {
            next if $seen{$dep->module};
            if ($dep->module eq 'perl') {
                if ($dep->is_requirement && !$self->check_perl_version($dep->version)) {
                    $self->diag("Needs perl @{[$dep->version]}, you have $]\n");
                    push @fail, 'perl';
                }
            } elsif ($self->should_install($dep->module, $dep->version)) {
                push @install, $dep;
                $seen{$dep->module} = 1;
            }
        }
    
        if (@install) {
            $self->diag("==> Found dependencies: " . join(", ",  map $_->module, @install) . "\n");
        }
    
        for my $dep (@install) {
            $self->install_module($dep->module, $depth + 1, $dep->version);
        }
    
        $self->chdir($self->{base});
        $self->chdir($dir) if $dir;
    
        if ($self->{scandeps}) {
            return 1; # Don't check if dependencies are installed, since with --scandeps they aren't
        }
        my @not_ok = $self->unsatisfied_deps(@deps);
        if (@not_ok) {
            return 0, \@not_ok;
        } else {
            return 1;
        }
    }
    
    sub unsatisfied_deps {
        my($self, @deps) = @_;
    
        require CPAN::Meta::Check;
        require CPAN::Meta::Requirements;
    
        my $reqs = CPAN::Meta::Requirements->new;
        for my $dep (grep $_->is_requirement, @deps) {
            $reqs->add_string_requirement($dep->module => $dep->version || '0');
        }
    
        my $ret = CPAN::Meta::Check::check_requirements($reqs, 'requires', $self->{search_inc});
        grep defined, values %$ret;
    }
    
    sub install_deps_bailout {
        my($self, $target, $dir, $depth, @deps) = @_;
    
        my($ok, $fail) = $self->install_deps($dir, $depth, @deps);
        if (!$ok) {
            $self->diag_fail("Installing the dependencies failed: " . join(", ", @$fail), 1);
            unless ($self->prompt_bool("Do you want to continue building $target anyway?", "n")) {
                $self->diag_fail("Bailing out the installation for $target.", 1);
                return;
            }
        }
    
        return 1;
    }
    
    sub build_stuff {
        my($self, $stuff, $dist, $depth) = @_;
    
        if ($self->{verify} && -e 'SIGNATURE') {
            $self->verify_signature($dist) or return;
        }
    
        require CPAN::Meta;
    
        my($meta_file) = grep -f, qw(META.json META.yml);
        if ($meta_file) {
            $self->chat("Checking configure dependencies from $meta_file\n");
            $dist->{cpanmeta} = eval { CPAN::Meta->load_file($meta_file) };
        } elsif ($dist->{dist} && $dist->{version}) {
            $self->chat("META.yml/json not found. Creating skeleton for it.\n");
            $dist->{cpanmeta} = CPAN::Meta->new({ name => $dist->{dist}, version => $dist->{version} });
        }
    
        $dist->{meta} = $dist->{cpanmeta} ? $dist->{cpanmeta}->as_struct : {};
    
        my @config_deps;
    
        if ($dist->{cpanmeta}) {
            push @config_deps, Dependency->from_prereqs(
                $dist->{cpanmeta}->effective_prereqs, ['configure'], $self->{install_types},
            );
        } else {
            push @config_deps, Dependency->from_versions(
                $dist->{meta}{configure_requires} || {}, 'configure',
            );
        }
    
        # workaround for bad M::B based dists with no configure_requires
        # https://github.com/miyagawa/cpanminus/issues/273
        if (-e 'Build.PL' && !$self->should_use_mm($dist->{dist})) {
            push @config_deps, Dependency->from_versions(
                { 'Module::Build' => '0.36' }, 'configure',
            );
        }
    
        my $target = $dist->{meta}{name} ? "$dist->{meta}{name}-$dist->{meta}{version}" : $dist->{dir};
    
        $self->install_deps_bailout($target, $dist->{dir}, $depth, @config_deps)
            or return;
    
        $self->diag_progress("Configuring $target");
    
        my $configure_state = $self->configure_this($dist, $depth);
        $self->diag_ok($configure_state->{configured_ok} ? "OK" : "N/A");
    
        $dist->{provides} = $self->extract_packages($dist->{cpanmeta}, ".")
            if $dist->{cpanmeta} && $dist->{source} eq 'cpan';
    
        # install direct 'test' dependencies for --installdeps, even with --notest
        my $root_target = (($self->{installdeps} or $self->{showdeps}) and $depth == 0);
        $dist->{want_phases} = $self->{notest} && !$root_target
                             ? [qw( build runtime )] : [qw( build test runtime )];
    
        push @{$dist->{want_phases}}, 'develop' if $self->{with_develop} && $depth == 0;
    
        my @deps = $self->find_prereqs($dist);
        my $module_name = $self->find_module_name($configure_state) || $dist->{meta}{name};
        $module_name =~ s/-/::/g;
    
        if ($self->{showdeps}) {
            for my $dep (@config_deps, @deps) {
                print $dep->module, ($dep->version ? ("~".$dep->version) : ""), "\n";
            }
            return 1;
        }
    
        my $distname = $dist->{meta}{name} ? "$dist->{meta}{name}-$dist->{meta}{version}" : $stuff;
    
        my $walkup;
        if ($self->{scandeps}) {
            $walkup = $self->scandeps_append_child($dist);
        }
    
        $self->install_deps_bailout($distname, $dist->{dir}, $depth, @deps)
            or return;
    
        if ($self->{scandeps}) {
            unless ($configure_state->{configured_ok}) {
                my $diag = <<DIAG;
    ! Configuring $distname failed. See $self->{log} for details.
    ! You might have to install the following modules first to get --scandeps working correctly.
    DIAG
                if (@config_deps) {
                    my @tree = @{$self->{scandeps_tree}};
                    $diag .= "!\n" . join("", map "! * $_->[0]{module}\n", @tree[0..$#tree-1]) if @tree;
                }
                $self->diag("!\n$diag!\n", 1);
            }
            $walkup->();
            return 1;
        }
    
        if ($self->{installdeps} && $depth == 0) {
            if ($configure_state->{configured_ok}) {
                $self->diag("<== Installed dependencies for $stuff. Finishing.\n");
                return 1;
            } else {
                $self->diag("! Configuring $distname failed. See $self->{log} for details.\n", 1);
                return;
            }
        }
    
        my $installed;
        if ($configure_state->{use_module_build} && -e 'Build' && -f _) {
            $self->diag_progress("Building " . ($self->{notest} ? "" : "and testing ") . $distname);
            $self->build([ $self->{perl}, "./Build" ], $distname, $depth) &&
            $self->test([ $self->{perl}, "./Build", "test" ], $distname, $depth) &&
            $self->install([ $self->{perl}, "./Build", "install" ], [ "--uninst", 1 ], $depth) &&
            $installed++;
        } elsif ($self->{make} && -e 'Makefile') {
            $self->diag_progress("Building " . ($self->{notest} ? "" : "and testing ") . $distname);
            $self->build([ $self->{make} ], $distname, $depth) &&
            $self->test([ $self->{make}, "test" ], $distname, $depth) &&
            $self->install([ $self->{make}, "install" ], [ "UNINST=1" ], $depth) &&
            $installed++;
        } else {
            my $why;
            my $configure_failed = $configure_state->{configured} && !$configure_state->{configured_ok};
            if ($configure_failed) { $why = "Configure failed for $distname." }
            elsif ($self->{make})  { $why = "The distribution doesn't have a proper Makefile.PL/Build.PL" }
            else                   { $why = "Can't configure the distribution. You probably need to have 'make'." }
    
            $self->diag_fail("$why See $self->{log} for details.", 1);
            return;
        }
    
        if ($installed && $self->{test_only}) {
            $self->diag_ok;
            $self->diag("Successfully tested $distname\n", 1);
        } elsif ($installed) {
            my $local   = $self->{local_versions}{$dist->{module} || ''};
            my $version = $dist->{module_version} || $dist->{meta}{version} || $dist->{version};
            my $reinstall = $local && ($local eq $version);
            my $action  = $local && !$reinstall
                        ? $self->numify_ver($version) < $self->numify_ver($local)
                            ? "downgraded"
                            : "upgraded"
                        : undef;
    
            my $how = $reinstall ? "reinstalled $distname"
                    : $local     ? "installed $distname ($action from $local)"
                                 : "installed $distname" ;
            my $msg = "Successfully $how";
            $self->diag_ok;
            $self->diag("$msg\n", 1);
            $self->{installed_dists}++;
            $self->save_meta($stuff, $dist, $module_name, \@config_deps, \@deps);
            return 1;
        } else {
            my $what = $self->{test_only} ? "Testing" : "Installing";
            $self->diag_fail("$what $stuff failed. See $self->{log} for details. Retry with --force to force install it.", 1);
            return;
        }
    }
    
    sub perl_requirements {
        my($self, @requires) = @_;
    
        my @perl;
        for my $requires (grep defined, @requires) {
            if (exists $requires->{perl}) {
                push @perl, Dependency->new(perl => $requires->{perl});
            }
        }
    
        return @perl;
    }
    
    sub should_use_mm {
        my($self, $dist) = @_;
    
        # Module::Build deps should use MakeMaker because that causes circular deps and fail
        # Otherwise we should prefer Build.PL
        my %should_use_mm = map { $_ => 1 } qw( version ExtUtils-ParseXS ExtUtils-Install ExtUtils-Manifest );
    
        $should_use_mm{$dist};
    }
    
    sub configure_this {
        my($self, $dist, $depth) = @_;
    
        if (-e $self->{cpanfile_path} && $self->{installdeps} && $depth == 0) {
            require Module::CPANfile;
            $dist->{cpanfile} = eval { Module::CPANfile->load($self->{cpanfile_path}) };
            $self->diag_fail($@, 1) if $@;
            return {
                configured       => 1,
                configured_ok    => !!$dist->{cpanfile},
                use_module_build => 0,
            };
        }
    
        if ($self->{skip_configure}) {
            my $eumm = -e 'Makefile';
            my $mb   = -e 'Build' && -f _;
            return {
                configured => 1,
                configured_ok => $eumm || $mb,
                use_module_build => $mb,
            };
        }
    
        my $state = {};
    
        my $try_eumm = sub {
            if (-e 'Makefile.PL') {
                $self->chat("Running Makefile.PL\n");
    
                # NOTE: according to Devel::CheckLib, most XS modules exit
                # with 0 even if header files are missing, to avoid receiving
                # tons of FAIL reports in such cases. So exit code can't be
                # trusted if it went well.
                if ($self->configure([ $self->{perl}, "Makefile.PL" ], $depth)) {
                    $state->{configured_ok} = -e 'Makefile';
                }
                $state->{configured}++;
            }
        };
    
        my $try_mb = sub {
            if (-e 'Build.PL') {
                $self->chat("Running Build.PL\n");
                if ($self->configure([ $self->{perl}, "Build.PL" ], $depth)) {
                    $state->{configured_ok} = -e 'Build' && -f _;
                }
                $state->{use_module_build}++;
                $state->{configured}++;
            }
        };
    
        my @try;
        if ($dist->{dist} && $self->should_use_mm($dist->{dist})) {
            @try = ($try_eumm, $try_mb);
        } else {
            @try = ($try_mb, $try_eumm);
        }
    
        for my $try (@try) {
            $try->();
            last if $state->{configured_ok};
        }
    
        unless ($state->{configured_ok}) {
            while (1) {
                my $ans = lc $self->prompt("Configuring $dist->{dist} failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?", "s");
                last                                        if $ans eq 's';
                return $self->configure_this($dist, $depth) if $ans eq 'r';
                $self->show_build_log                       if $ans eq 'e';
                $self->look                                 if $ans eq 'l';
            }
        }
    
        return $state;
    }
    
    sub find_module_name {
        my($self, $state) = @_;
    
        return unless $state->{configured_ok};
    
        if ($state->{use_module_build} &&
            -e "_build/build_params") {
            my $params = do { open my $in, "_build/build_params"; $self->safe_eval(join "", <$in>) };
            return eval { $params->[2]{module_name} } || undef;
        } elsif (-e "Makefile") {
            open my $mf, "Makefile";
            while (<$mf>) {
                if (/^\#\s+NAME\s+=>\s+(.*)/) {
                    return $self->safe_eval($1);
                }
            }
        }
    
        return;
    }
    
    sub list_files {
        my $self = shift;
    
        if (-e 'MANIFEST') {
            require ExtUtils::Manifest;
            my $manifest = eval { ExtUtils::Manifest::manifind() } || {};
            return sort { lc $a cmp lc $b } keys %$manifest;
        } else {
            require File::Find;
            my @files;
            my $finder = sub {
                my $name = $File::Find::name;
                $name =~ s!\.[/\\]!!;
                push @files, $name;
            };
            File::Find::find($finder, ".");
            return sort { lc $a cmp lc $b } @files;
        }
    }
    
    sub extract_packages {
        my($self, $meta, $dir) = @_;
    
        my $try = sub {
            my $file = shift;
            return 1 unless $meta->{no_index};
            return 0 if grep { $file =~ m!^$_/! } @{$meta->{no_index}{directory} || []};
            return 0 if grep { $file eq $_ } @{$meta->{no_index}{file} || []};
            return 1;
        };
    
        require App::cpanminus::ParsePM;
    
        my @files = grep { /\.pm(?:\.PL)?$/ && $try->($_) } $self->list_files;
    
        my $provides = {};
    
        for my $file (@files) {
            my $parser = App::cpanminus::ParsePM->new($meta);
            my $packages = $parser->parse($file);
    
            while (my($package, $meta) = each %$packages) {
                $provides->{$package} ||= {
                    file => $meta->{infile},
                    ($meta->{version} eq 'undef') ? () : (version => $meta->{version}),
                };
            }
        }
    
        return $provides;
    }
    
    sub save_meta {
        my($self, $module, $dist, $module_name, $config_deps, $build_deps) = @_;
    
        return unless $dist->{distvname} && $dist->{source} eq 'cpan';
    
        my $base = ($ENV{PERL_MM_OPT} || '') =~ /INSTALL_BASE=/
            ? ($self->install_base($ENV{PERL_MM_OPT}) . "/lib/perl5") : $Config{sitelibexp};
    
        my $provides = $dist->{provides};
    
        File::Path::mkpath("blib/meta", 0, 0777);
    
        my $local = {
            name => $module_name,
            target => $module,
            version => exists $provides->{$module_name}
                ? ($provides->{$module_name}{version} || $dist->{version}) : $dist->{version},
            dist => $dist->{distvname},
            pathname => $dist->{pathname},
            provides => $provides,
        };
    
        require JSON::PP;
        open my $fh, ">", "blib/meta/install.json" or die $!;
        print $fh JSON::PP::encode_json($local);
    
        # Existence of MYMETA.* Depends on EUMM/M::B versions and CPAN::Meta
        if (-e "MYMETA.json") {
            File::Copy::copy("MYMETA.json", "blib/meta/MYMETA.json");
        }
    
        my @cmd = (
            ($self->{sudo} ? 'sudo' : ()),
            $^X,
            '-MExtUtils::Install=install',
            '-e',
            qq[install({ 'blib/meta' => '$base/$Config{archname}/.meta/$dist->{distvname}' })],
        );
        $self->run(\@cmd);
    }
    
    sub _merge_hashref {
        my($self, @hashrefs) = @_;
    
        my %hash;
        for my $h (@hashrefs) {
            %hash = (%hash, %$h);
        }
    
        return \%hash;
    }
    
    sub install_base {
        my($self, $mm_opt) = @_;
        $mm_opt =~ /INSTALL_BASE=(\S+)/ and return $1;
        die "Your PERL_MM_OPT doesn't contain INSTALL_BASE";
    }
    
    sub safe_eval {
        my($self, $code) = @_;
        eval $code;
    }
    
    sub configure_features {
        my($self, $dist, @features) = @_;
        map $_->identifier, grep { $self->effective_feature($dist, $_) } @features;
    }
    
    sub effective_feature {
        my($self, $dist, $feature) = @_;
    
        if ($dist->{depth} == 0) {
            my $value = $self->{features}{$feature->identifier};
            return $value if defined $value;
            return 1 if $self->{features}{__all};
        }
    
        if ($self->{interactive}) {
            require CPAN::Meta::Requirements;
    
            $self->diag("[@{[ $feature->description ]}]\n", 1);
    
            my $req = CPAN::Meta::Requirements->new;
            for my $phase (@{$dist->{want_phases}}) {
                for my $type (@{$self->{install_types}}) {
                    $req->add_requirements($feature->prereqs->requirements_for($phase, $type));
                }
            }
    
            my $reqs = $req->as_string_hash;
            my @missing;
            for my $module (keys %$reqs) {
                if ($self->should_install($module, $req->{$module})) {
                    push @missing, $module;
                }
            }
    
            if (@missing) {
                my $howmany = @missing;
                $self->diag("==> Found missing dependencies: " . join(", ", @missing) . "\n", 1);
                local $self->{prompt} = 1;
                return $self->prompt_bool("Install the $howmany optional module(s)?", "y");
            }
        }
    
        return;
    }
    
    sub find_prereqs {
        my($self, $dist) = @_;
    
        my @deps = $self->extract_meta_prereqs($dist);
    
        if ($dist->{module} =~ /^Bundle::/i) {
            push @deps, $self->bundle_deps($dist);
        }
    
        return @deps;
    }
    
    sub extract_meta_prereqs {
        my($self, $dist) = @_;
    
        if ($dist->{cpanfile}) {
            my @features = $self->configure_features($dist, $dist->{cpanfile}->features);
            my $prereqs = $dist->{cpanfile}->prereqs_with(@features);
            return Dependency->from_prereqs($prereqs, $dist->{want_phases}, $self->{install_types});
        }
    
        my $meta = $dist->{meta};
    
        my @deps;
        if (-e "MYMETA.json") {
            require JSON::PP;
            $self->chat("Checking dependencies from MYMETA.json ...\n");
            my $json = do { open my $in, "<MYMETA.json"; local $/; <$in> };
            my $mymeta = JSON::PP::decode_json($json);
            if ($mymeta) {
                $meta->{$_} = $mymeta->{$_} for qw(name version);
                return $self->extract_prereqs($mymeta, $dist);
            }
        }
    
        if (-e 'MYMETA.yml') {
            $self->chat("Checking dependencies from MYMETA.yml ...\n");
            my $mymeta = $self->parse_meta('MYMETA.yml');
            if ($mymeta) {
                $meta->{$_} = $mymeta->{$_} for qw(name version);
                return $self->extract_prereqs($mymeta, $dist);
            }
        }
    
        if (-e '_build/prereqs') {
            $self->chat("Checking dependencies from _build/prereqs ...\n");
            my $prereqs = do { open my $in, "_build/prereqs"; $self->safe_eval(join "", <$in>) };
            @deps = $self->extract_prereqs({ name => $meta->{name}, version => $meta->{version}, %$prereqs }, $dist);
        } elsif (-e 'Makefile') {
            $self->chat("Finding PREREQ from Makefile ...\n");
            open my $mf, "Makefile";
            while (<$mf>) {
                if (/^\#\s+PREREQ_PM => \{\s*(.*?)\s*\}/) {
                    my @all;
                    my @pairs = split ', ', $1;
                    for (@pairs) {
                        my ($pkg, $v) = split '=>', $_;
                        push @all, [ $pkg, $v ];
                    }
                    my $list = join ", ", map { "'$_->[0]' => $_->[1]" } @all;
                    my $prereq = $self->safe_eval("no strict; +{ $list }");
                    push @deps, Dependency->from_versions($prereq) if $prereq;
                    last;
                }
            }
        }
    
        return @deps;
    }
    
    sub bundle_deps {
        my($self, $dist) = @_;
    
        my @files;
        File::Find::find({
            wanted => sub { push @files, File::Spec->rel2abs($_) if /\.pm/i },
            no_chdir => 1,
        }, '.');
    
        my @deps;
    
        for my $file (@files) {
            open my $pod, "<", $file or next;
            my $in_contents;
            while (<$pod>) {
                if (/^=head\d\s+CONTENTS/) {
                    $in_contents = 1;
                } elsif (/^=/) {
                    $in_contents = 0;
                } elsif ($in_contents) {
                    /^(\S+)\s*(\S+)?/
                        and push @deps, Dependency->new($1, $self->maybe_version($2));
                }
            }
        }
    
        return @deps;
    }
    
    sub maybe_version {
        my($self, $string) = @_;
        return $string && $string =~ /^\.?\d/ ? $string : undef;
    }
    
    sub extract_prereqs {
        my($self, $metadata, $dist) = @_;
    
        require CPAN::Meta;
        my $meta = CPAN::Meta->new($metadata, { lazy_validation => 1 });
        my @features = $self->configure_features($dist, $meta->features);
    
        return Dependency->from_prereqs($meta->effective_prereqs(\@features), $dist->{want_phases}, $self->{install_types});
    }
    
    sub cleanup_workdirs {
        my $self = shift;
    
        my $expire = time - 24 * 60 * 60 * $self->{auto_cleanup};
        my @targets;
    
        opendir my $dh, "$self->{home}/work";
        while (my $e = readdir $dh) {
            next if $e !~ /^(\d+)\.\d+$/; # {UNIX time}.{PID}
            my $time = $1;
            if ($time < $expire) {
                push @targets, "$self->{home}/work/$e";
            }
        }
    
        if (@targets) {
            if (@targets >= 64) {
                $self->diag("Expiring " . scalar(@targets) . " work directories. This might take long...\n");
            } else {
                $self->chat("Expiring " . scalar(@targets) . " work directories.\n");
            }
            File::Path::rmtree(\@targets, 0, 0); # safe = 0, since blib usually doesn't have write bits
        }
    }
    
    sub scandeps_append_child {
        my($self, $dist) = @_;
    
        my $new_node = [ $dist, [] ];
    
        my $curr_node = $self->{scandeps_current} || [ undef, $self->{scandeps_tree} ];
        push @{$curr_node->[1]}, $new_node;
    
        $self->{scandeps_current} = $new_node;
    
        return sub { $self->{scandeps_current} = $curr_node };
    }
    
    sub dump_scandeps {
        my $self = shift;
    
        if ($self->{format} eq 'tree') {
            $self->walk_down(sub {
                my($dist, $depth) = @_;
                if ($depth == 0) {
                    print "$dist->{distvname}\n";
                } else {
                    print " " x ($depth - 1);
                    print "\\_ $dist->{distvname}\n";
                }
            }, 1);
        } elsif ($self->{format} =~ /^dists?$/) {
            $self->walk_down(sub {
                my($dist, $depth) = @_;
                print $self->format_dist($dist), "\n";
            }, 0);
        } elsif ($self->{format} eq 'json') {
            require JSON::PP;
            print JSON::PP::encode_json($self->{scandeps_tree});
        } elsif ($self->{format} eq 'yaml') {
            require YAML; # no fatpack
            print YAML::Dump($self->{scandeps_tree});
        } else {
            $self->diag("Unknown format: $self->{format}\n");
        }
    }
    
    sub walk_down {
        my($self, $cb, $pre) = @_;
        $self->_do_walk_down($self->{scandeps_tree}, $cb, 0, $pre);
    }
    
    sub _do_walk_down {
        my($self, $children, $cb, $depth, $pre) = @_;
    
        # DFS - $pre determines when we call the callback
        for my $node (@$children) {
            $cb->($node->[0], $depth) if $pre;
            $self->_do_walk_down($node->[1], $cb, $depth + 1, $pre);
            $cb->($node->[0], $depth) unless $pre;
        }
    }
    
    sub DESTROY {
        my $self = shift;
        $self->{at_exit}->($self) if $self->{at_exit};
    }
    
    # Utils
    
    sub shell_quote {
        my($self, @stuff) = @_;
        if (WIN32) {
            join ' ', map { /^${quote}.+${quote}$/ ? $_ : ($quote . $_ . $quote) } @stuff;
        } else {
            String::ShellQuote::shell_quote_best_effort(@stuff);
        }
    }
    
    sub which {
        my($self, $name) = @_;
        return $name if File::Spec->file_name_is_absolute($name) && -x $name;
        my $exe_ext = $Config{_exe};
        for my $dir (File::Spec->path) {
            my $fullpath = File::Spec->catfile($dir, $name);
            if (-x $fullpath || -x ($fullpath .= $exe_ext)) {
                if ($fullpath =~ /\s/) {
                    $fullpath = $self->shell_quote($fullpath);
                }
                return $fullpath;
            }
        }
        return;
    }
    
    sub get {
        my($self, $uri) = @_;
        if ($uri =~ /^file:/) {
            $self->file_get($uri);
        } else {
            $self->{_backends}{get}->(@_);
        }
    }
    
    sub mirror {
        my($self, $uri, $local) = @_;
        if ($uri =~ /^file:/) {
            $self->file_mirror($uri, $local);
        } else {
            $self->{_backends}{mirror}->(@_);
        }
    }
    
    sub untar    { $_[0]->{_backends}{untar}->(@_) };
    sub unzip    { $_[0]->{_backends}{unzip}->(@_) };
    
    sub uri_to_file {
        my($self, $uri) = @_;
    
        # file:///path/to/file -> /path/to/file
        # file://C:/path       -> C:/path
        if ($uri =~ s!file:/+!!) {
            $uri = "/$uri" unless $uri =~ m![a-zA-Z]:!;
        }
    
        return $uri;
    }
    
    sub file_get {
        my($self, $uri) = @_;
        my $file = $self->uri_to_file($uri);
        open my $fh, "<$file" or return;
        join '', <$fh>;
    }
    
    sub file_mirror {
        my($self, $uri, $path) = @_;
        my $file = $self->uri_to_file($uri);
        File::Copy::copy($file, $path);
    }
    
    sub has_working_lwp {
        my($self, $mirrors) = @_;
        my $https = grep /^https:/, @$mirrors;
        eval {
            require LWP::UserAgent; # no fatpack
            LWP::UserAgent->VERSION(5.802);
            require LWP::Protocol::https if $https; # no fatpack
            1;
        };
    }
    
    sub init_tools {
        my $self = shift;
    
        return if $self->{initialized}++;
    
        if ($self->{make} = $self->which($Config{make})) {
            $self->chat("You have make $self->{make}\n");
        }
    
        # use --no-lwp if they have a broken LWP, to upgrade LWP
        if ($self->{try_lwp} && $self->has_working_lwp($self->{mirrors})) {
            $self->chat("You have LWP $LWP::VERSION\n");
            my $ua = sub {
                LWP::UserAgent->new(
                    parse_head => 0,
                    env_proxy => 1,
                    agent => $self->agent,
                    timeout => 30,
                    @_,
                );
            };
            $self->{_backends}{get} = sub {
                my $self = shift;
                my $res = $ua->()->request(HTTP::Request->new(GET => $_[0]));
                return unless $res->is_success;
                return $res->decoded_content;
            };
            $self->{_backends}{mirror} = sub {
                my $self = shift;
                my $res = $ua->()->mirror(@_);
                die $res->content if $res->code == 501;
                $res->code;
            };
        } elsif ($self->{try_wget} and my $wget = $self->which('wget')) {
            $self->chat("You have $wget\n");
            my @common = (
                '--user-agent', $self->agent,
                '--retry-connrefused',
                ($self->{verbose} ? () : ('-q')),
            );
            $self->{_backends}{get} = sub {
                my($self, $uri) = @_;
                $self->safeexec( my $fh, $wget, $uri, @common, '-O', '-' ) or die "wget $uri: $!";
                local $/;
                <$fh>;
            };
            $self->{_backends}{mirror} = sub {
                my($self, $uri, $path) = @_;
                $self->safeexec( my $fh, $wget, $uri, @common, '-O', $path ) or die "wget $uri: $!";
                local $/;
                <$fh>;
            };
        } elsif ($self->{try_curl} and my $curl = $self->which('curl')) {
            $self->chat("You have $curl\n");
            my @common = (
                '--location',
                '--user-agent', $self->agent,
                ($self->{verbose} ? () : '-s'),
            );
            $self->{_backends}{get} = sub {
                my($self, $uri) = @_;
                $self->safeexec( my $fh, $curl, @common, $uri ) or die "curl $uri: $!";
                local $/;
                <$fh>;
            };
            $self->{_backends}{mirror} = sub {
                my($self, $uri, $path) = @_;
                $self->safeexec( my $fh, $curl, @common, $uri, '-#', '-o', $path ) or die "curl $uri: $!";
                local $/;
                <$fh>;
            };
        } else {
            require HTTP::Tiny;
            $self->chat("Falling back to HTTP::Tiny $HTTP::Tiny::VERSION\n");
            my %common = (
                agent => $self->agent,
            );
            $self->{_backends}{get} = sub {
                my $self = shift;
                my $res = HTTP::Tiny->new(%common)->get($_[0]);
                return unless $res->{success};
                return $res->{content};
            };
            $self->{_backends}{mirror} = sub {
                my $self = shift;
                my $res = HTTP::Tiny->new(%common)->mirror(@_);
                return $res->{status};
            };
        }
    
        my $tar = $self->which('tar');
        my $tar_ver;
        my $maybe_bad_tar = sub { WIN32 || SUNOS || (($tar_ver = `$tar --version 2>/dev/null`) =~ /GNU.*1\.13/i) };
    
        if ($tar && !$maybe_bad_tar->()) {
            chomp $tar_ver;
            $self->chat("You have $tar: $tar_ver\n");
            $self->{_backends}{untar} = sub {
                my($self, $tarfile) = @_;
    
                my $xf = ($self->{verbose} ? 'v' : '')."xf";
                my $ar = $tarfile =~ /bz2$/ ? 'j' : 'z';
    
                my($root, @others) = `$tar ${ar}tf $tarfile`
                    or return undef;
    
                FILE: {
                    chomp $root;
                    $root =~ s!^\./!!;
                    $root =~ s{^(.+?)/.*$}{$1};
    
                    if (!length($root)) {
                        # archive had ./ as the first entry, so try again
                        $root = shift(@others);
                        redo FILE if $root;
                    }
                }
    
                system "$tar $ar$xf $tarfile";
                return $root if -d $root;
    
                $self->diag_fail("Bad archive: $tarfile");
                return undef;
            }
        } elsif (    $tar
                 and my $gzip = $self->which('gzip')
                 and my $bzip2 = $self->which('bzip2')) {
            $self->chat("You have $tar, $gzip and $bzip2\n");
            $self->{_backends}{untar} = sub {
                my($self, $tarfile) = @_;
    
                my $x  = "x" . ($self->{verbose} ? 'v' : '') . "f -";
                my $ar = $tarfile =~ /bz2$/ ? $bzip2 : $gzip;
    
                my($root, @others) = `$ar -dc $tarfile | $tar tf -`
                    or return undef;
    
                FILE: {
                    chomp $root;
                    $root =~ s!^\./!!;
                    $root =~ s{^(.+?)/.*$}{$1};
    
                    if (!length($root)) {
                        # archive had ./ as the first entry, so try again
                        $root = shift(@others);
                        redo FILE if $root;
                    }
                }
    
                system "$ar -dc $tarfile | $tar $x";
                return $root if -d $root;
    
                $self->diag_fail("Bad archive: $tarfile");
                return undef;
            }
        } elsif (eval { require Archive::Tar }) { # uses too much memory!
            $self->chat("Falling back to Archive::Tar $Archive::Tar::VERSION\n");
            $self->{_backends}{untar} = sub {
                my $self = shift;
                my $t = Archive::Tar->new($_[0]);
                my($root, @others) = $t->list_files;
                FILE: {
                    $root =~ s!^\./!!;
                    $root =~ s{^(.+?)/.*$}{$1};
    
                    if (!length($root)) {
                        # archive had ./ as the first entry, so try again
                        $root = shift(@others);
                        redo FILE if $root;
                    }
                }
                $t->extract;
                return -d $root ? $root : undef;
            };
        } else {
            $self->{_backends}{untar} = sub {
                die "Failed to extract $_[1] - You need to have tar or Archive::Tar installed.\n";
            };
        }
    
        if (my $unzip = $self->which('unzip')) {
            $self->chat("You have $unzip\n");
            $self->{_backends}{unzip} = sub {
                my($self, $zipfile) = @_;
    
                my $opt = $self->{verbose} ? '' : '-q';
                my(undef, $root, @others) = `$unzip -t $zipfile`
                    or return undef;
    
                chomp $root;
                $root =~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1};
    
                system "$unzip $opt $zipfile";
                return $root if -d $root;
    
                $self->diag_fail("Bad archive: [$root] $zipfile");
                return undef;
            }
        } else {
            $self->{_backends}{unzip} = sub {
                eval { require Archive::Zip }
                    or  die "Failed to extract $_[1] - You need to have unzip or Archive::Zip installed.\n";
                my($self, $file) = @_;
                my $zip = Archive::Zip->new();
                my $status;
                $status = $zip->read($file);
                $self->diag_fail("Read of file[$file] failed")
                    if $status != Archive::Zip::AZ_OK();
                my @members = $zip->members();
                for my $member ( @members ) {
                    my $af = $member->fileName();
                    next if ($af =~ m!^(/|\.\./)!);
                    $status = $member->extractToFileNamed( $af );
                    $self->diag_fail("Extracting of file[$af] from zipfile[$file failed")
                        if $status != Archive::Zip::AZ_OK();
                }
    
                my ($root) = $zip->membersMatching( qr<^[^/]+/$> );
                $root &&= $root->fileName;
                return -d $root ? $root : undef;
            };
        }
    }
    
    sub safeexec {
        my $self = shift;
        my $rdr = $_[0] ||= Symbol::gensym();
    
        if (WIN32) {
            my $cmd = $self->shell_quote(@_[1..$#_]);
            return open( $rdr, "$cmd |" );
        }
    
        if ( my $pid = open( $rdr, '-|' ) ) {
            return $pid;
        }
        elsif ( defined $pid ) {
            exec( @_[ 1 .. $#_ ] );
            exit 1;
        }
        else {
            return;
        }
    }
    
    sub mask_uri_passwords {
        my($self, @strings) = @_;
        s{ (https?://) ([^:/]+) : [^@/]+ @ }{$1$2:*password*@}gx for @strings;
        return @strings;
    }
    
    sub parse_meta {
        my($self, $file) = @_;
        return eval { Parse::CPAN::Meta->load_file($file) };
    }
    
    sub parse_meta_string {
        my($self, $yaml) = @_;
        return eval { Parse::CPAN::Meta->load_yaml_string($yaml) };
    }
    
    package App::cpanminus::CommandExit;
    sub new {
        bless { code => $_[1] }, $_[0];
    }
    
    sub code { $_[0]->{code} }
    
    1;
  APP_CPANMINUS_SCRIPT
  
  $fatpacked{"CPAN/DistnameInfo.pm"} = <<'CPAN_DISTNAMEINFO';
    
    package CPAN::DistnameInfo;
    
    $VERSION = "0.12";
    use strict;
    
    sub distname_info {
      my $file = shift or return;
    
      my ($dist, $version) = $file =~ /^
        ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
         (?:
    	[A-Za-z](?=[^A-Za-z]|$)
    	|
    	\d(?=-)
         )(?<![._-][vV])
        )+)(.*)
      $/xs or return ($file,undef,undef);
    
      if ($dist =~ /-undef\z/ and ! length $version) {
        $dist =~ s/-undef\z//;
      }
    
      # Remove potential -withoutworldwriteables suffix
      $version =~ s/-withoutworldwriteables$//;
    
      if ($version =~ /^(-[Vv].*)-(\d.*)/) {
       
        # Catch names like Unicode-Collate-Standard-V3_1_1-0.1
        # where the V3_1_1 is part of the distname
        $dist .= $1;
        $version = $2;
      }
    
      if ($version =~ /(.+_.*)-(\d.*)/) {
          # Catch names like Task-Deprecations5_14-1.00.tar.gz where the 5_14 is
          # part of the distname. However, names like libao-perl_0.03-1.tar.gz
          # should still have 0.03-1 as their version.
          $dist .= $1;
          $version = $2;
      }
    
      # Normalize the Dist.pm-1.23 convention which CGI.pm and
      # a few others use.
      $dist =~ s{\.pm$}{};
    
      $version = $1
        if !length $version and $dist =~ s/-(\d+\w)$//;
    
      $version = $1 . $version
        if $version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;
    
      if ($version =~ /\d\.\d/) {
        $version =~ s/^[-_.]+//;
      }
      else {
        $version =~ s/^[-_]+//;
      }
    
      my $dev;
      if (length $version) {
        if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/) {
          $dev = 1 if (($1 > 6 and $1 & 1) or ($2 and $2 >= 50)) or $3;
        }
        elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/) {
          $dev = 1;
        }
      }
      else {
        $version = undef;
      }
    
      ($dist, $version, $dev);
    }
    
    sub new {
      my $class = shift;
      my $distfile = shift;
    
      $distfile =~ s,//+,/,g;
    
      my %info = ( pathname => $distfile );
    
      ($info{filename} = $distfile) =~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,,
        and $info{cpanid} = $6;
    
      if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i) { # support more ?
        $info{distvname} = $1;
        $info{extension} = $2;
      }
    
      @info{qw(dist version beta)} = distname_info($info{distvname});
      $info{maturity} = delete $info{beta} ? 'developer' : 'released';
    
      return bless \%info, $class;
    }
    
    sub dist      { shift->{dist} }
    sub version   { shift->{version} }
    sub maturity  { shift->{maturity} }
    sub filename  { shift->{filename} }
    sub cpanid    { shift->{cpanid} }
    sub distvname { shift->{distvname} }
    sub extension { shift->{extension} }
    sub pathname  { shift->{pathname} }
    
    sub properties { %{ $_[0] } }
    
    1;
    
    __END__
    
    =head1 NAME
    
    CPAN::DistnameInfo - Extract distribution name and version from a distribution filename
    
    =head1 SYNOPSIS
    
      my $pathname = "authors/id/G/GB/GBARR/CPAN-DistnameInfo-0.02.tar.gz";
    
      my $d = CPAN::DistnameInfo->new($pathname);
    
      my $dist      = $d->dist;      # "CPAN-DistnameInfo"
      my $version   = $d->version;   # "0.02"
      my $maturity  = $d->maturity;  # "released"
      my $filename  = $d->filename;  # "CPAN-DistnameInfo-0.02.tar.gz"
      my $cpanid    = $d->cpanid;    # "GBARR"
      my $distvname = $d->distvname; # "CPAN-DistnameInfo-0.02"
      my $extension = $d->extension; # "tar.gz"
      my $pathname  = $d->pathname;  # "authors/id/G/GB/GBARR/..."
    
      my %prop = $d->properties;
    
    =head1 DESCRIPTION
    
    Many online services that are centered around CPAN attempt to
    associate multiple uploads by extracting a distribution name from
    the filename of the upload. For most distributions this is easy as
    they have used ExtUtils::MakeMaker or Module::Build to create the
    distribution, which results in a uniform name. But sadly not all
    uploads are created in this way.
    
    C<CPAN::DistnameInfo> uses heuristics that have been learnt by
    L<http://search.cpan.org/> to extract the distribution name and
    version from filenames and also report if the version is to be
    treated as a developer release
    
    The constructor takes a single pathname, returning an object with the following methods
    
    =over
    
    =item cpanid
    
    If the path given looked like a CPAN authors directory path, then this will be the
    the CPAN id of the author.
    
    =item dist
    
    The name of the distribution
    
    =item distvname
    
    The file name with any suffix and leading directory names removed
    
    =item filename
    
    If the path given looked like a CPAN authors directory path, then this will be the
    path to the file relative to the detected CPAN author directory. Otherwise it is the path
    that was passed in.
    
    =item maturity
    
    The maturity of the distribution. This will be either C<released> or C<developer>
    
    =item extension
    
    The extension of the distribution, often used to denote the archive type (e.g. 'tar.gz')
    
    =item pathname
    
    The pathname that was passed to the constructor when creating the object.
    
    =item properties
    
    This will return a list of key-value pairs, suitable for assigning to a hash,
    for the known properties.
    
    =item version
    
    The extracted version
    
    =back
    
    =head1 AUTHOR
    
    Graham Barr <gbarr@pobox.com>
    
    =head1 COPYRIGHT 
    
    Copyright (c) 2003 Graham Barr. All rights reserved. This program is
    free software; you can redistribute it and/or modify it under the same
    terms as Perl itself.
    
    =cut
    
  CPAN_DISTNAMEINFO
  
  $fatpacked{"CPAN/Meta.pm"} = <<'CPAN_META';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta;
    our $VERSION = '2.132510'; # VERSION
    
    
    use Carp qw(carp croak);
    use CPAN::Meta::Feature;
    use CPAN::Meta::Prereqs;
    use CPAN::Meta::Converter;
    use CPAN::Meta::Validator;
    use Parse::CPAN::Meta 1.4403 ();
    
    BEGIN { *_dclone = \&CPAN::Meta::Converter::_dclone }
    
    
    BEGIN {
      my @STRING_READERS = qw(
        abstract
        description
        dynamic_config
        generated_by
        name
        release_status
        version
      );
    
      no strict 'refs';
      for my $attr (@STRING_READERS) {
        *$attr = sub { $_[0]{ $attr } };
      }
    }
    
    
    BEGIN {
      my @LIST_READERS = qw(
        author
        keywords
        license
      );
    
      no strict 'refs';
      for my $attr (@LIST_READERS) {
        *$attr = sub {
          my $value = $_[0]{ $attr };
          croak "$attr must be called in list context"
            unless wantarray;
          return @{ _dclone($value) } if ref $value;
          return $value;
        };
      }
    }
    
    sub authors  { $_[0]->author }
    sub licenses { $_[0]->license }
    
    
    BEGIN {
      my @MAP_READERS = qw(
        meta-spec
        resources
        provides
        no_index
    
        prereqs
        optional_features
      );
    
      no strict 'refs';
      for my $attr (@MAP_READERS) {
        (my $subname = $attr) =~ s/-/_/;
        *$subname = sub {
          my $value = $_[0]{ $attr };
          return _dclone($value) if $value;
          return {};
        };
      }
    }
    
    
    sub custom_keys {
      return grep { /^x_/i } keys %{$_[0]};
    }
    
    sub custom {
      my ($self, $attr) = @_;
      my $value = $self->{$attr};
      return _dclone($value) if ref $value;
      return $value;
    }
    
    
    sub _new {
      my ($class, $struct, $options) = @_;
      my $self;
    
      if ( $options->{lazy_validation} ) {
        # try to convert to a valid structure; if succeeds, then return it
        my $cmc = CPAN::Meta::Converter->new( $struct );
        $self = $cmc->convert( version => 2 ); # valid or dies
        return bless $self, $class;
      }
      else {
        # validate original struct
        my $cmv = CPAN::Meta::Validator->new( $struct );
        unless ( $cmv->is_valid) {
          die "Invalid metadata structure. Errors: "
            . join(", ", $cmv->errors) . "\n";
        }
      }
    
      # up-convert older spec versions
      my $version = $struct->{'meta-spec'}{version} || '1.0';
      if ( $version == 2 ) {
        $self = $struct;
      }
      else {
        my $cmc = CPAN::Meta::Converter->new( $struct );
        $self = $cmc->convert( version => 2 );
      }
    
      return bless $self, $class;
    }
    
    sub new {
      my ($class, $struct, $options) = @_;
      my $self = eval { $class->_new($struct, $options) };
      croak($@) if $@;
      return $self;
    }
    
    
    sub create {
      my ($class, $struct, $options) = @_;
      my $version = __PACKAGE__->VERSION || 2;
      $struct->{generated_by} ||= __PACKAGE__ . " version $version" ;
      $struct->{'meta-spec'}{version} ||= int($version);
      my $self = eval { $class->_new($struct, $options) };
      croak ($@) if $@;
      return $self;
    }
    
    
    sub load_file {
      my ($class, $file, $options) = @_;
      $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
    
      croak "load_file() requires a valid, readable filename"
        unless -r $file;
    
      my $self;
      eval {
        my $struct = Parse::CPAN::Meta->load_file( $file );
        $self = $class->_new($struct, $options);
      };
      croak($@) if $@;
      return $self;
    }
    
    
    sub load_yaml_string {
      my ($class, $yaml, $options) = @_;
      $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
    
      my $self;
      eval {
        my ($struct) = Parse::CPAN::Meta->load_yaml_string( $yaml );
        $self = $class->_new($struct, $options);
      };
      croak($@) if $@;
      return $self;
    }
    
    
    sub load_json_string {
      my ($class, $json, $options) = @_;
      $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
    
      my $self;
      eval {
        my $struct = Parse::CPAN::Meta->load_json_string( $json );
        $self = $class->_new($struct, $options);
      };
      croak($@) if $@;
      return $self;
    }
    
    
    sub save {
      my ($self, $file, $options) = @_;
    
      my $version = $options->{version} || '2';
      my $layer = $] ge '5.008001' ? ':utf8' : '';
    
      if ( $version ge '2' ) {
        carp "'$file' should end in '.json'"
          unless $file =~ m{\.json$};
      }
      else {
        carp "'$file' should end in '.yml'"
          unless $file =~ m{\.yml$};
      }
    
      my $data = $self->as_string( $options );
      open my $fh, ">$layer", $file
        or die "Error opening '$file' for writing: $!\n";
    
      print {$fh} $data;
      close $fh
        or die "Error closing '$file': $!\n";
    
      return 1;
    }
    
    
    sub meta_spec_version {
      my ($self) = @_;
      return $self->meta_spec->{version};
    }
    
    
    sub effective_prereqs {
      my ($self, $features) = @_;
      $features ||= [];
    
      my $prereq = CPAN::Meta::Prereqs->new($self->prereqs);
    
      return $prereq unless @$features;
    
      my @other = map {; $self->feature($_)->prereqs } @$features;
    
      return $prereq->with_merged_prereqs(\@other);
    }
    
    
    sub should_index_file {
      my ($self, $filename) = @_;
    
      for my $no_index_file (@{ $self->no_index->{file} || [] }) {
        return if $filename eq $no_index_file;
      }
    
      for my $no_index_dir (@{ $self->no_index->{directory} }) {
        $no_index_dir =~ s{$}{/} unless $no_index_dir =~ m{/\z};
        return if index($filename, $no_index_dir) == 0;
      }
    
      return 1;
    }
    
    
    sub should_index_package {
      my ($self, $package) = @_;
    
      for my $no_index_pkg (@{ $self->no_index->{package} || [] }) {
        return if $package eq $no_index_pkg;
      }
    
      for my $no_index_ns (@{ $self->no_index->{namespace} }) {
        return if index($package, "${no_index_ns}::") == 0;
      }
    
      return 1;
    }
    
    
    sub features {
      my ($self) = @_;
    
      my $opt_f = $self->optional_features;
      my @features = map {; CPAN::Meta::Feature->new($_ => $opt_f->{ $_ }) }
                     keys %$opt_f;
    
      return @features;
    }
    
    
    sub feature {
      my ($self, $ident) = @_;
    
      croak "no feature named $ident"
        unless my $f = $self->optional_features->{ $ident };
    
      return CPAN::Meta::Feature->new($ident, $f);
    }
    
    
    sub as_struct {
      my ($self, $options) = @_;
      my $struct = _dclone($self);
      if ( $options->{version} ) {
        my $cmc = CPAN::Meta::Converter->new( $struct );
        $struct = $cmc->convert( version => $options->{version} );
      }
      return $struct;
    }
    
    
    sub as_string {
      my ($self, $options) = @_;
    
      my $version = $options->{version} || '2';
    
      my $struct;
      if ( $self->meta_spec_version ne $version ) {
        my $cmc = CPAN::Meta::Converter->new( $self->as_struct );
        $struct = $cmc->convert( version => $version );
      }
      else {
        $struct = $self->as_struct;
      }
    
      my ($data, $backend);
      if ( $version ge '2' ) {
        $backend = Parse::CPAN::Meta->json_backend();
        $data = $backend->new->pretty->canonical->encode($struct);
      }
      else {
        $backend = Parse::CPAN::Meta->yaml_backend();
        $data = eval { no strict 'refs'; &{"$backend\::Dump"}($struct) };
        if ( $@ ) {
          croak $backend->can('errstr') ? $backend->errstr : $@
        }
      }
    
      return $data;
    }
    
    # Used by JSON::PP, etc. for "convert_blessed"
    sub TO_JSON {
      return { %{ $_[0] } };
    }
    
    1;
    
    # ABSTRACT: the distribution metadata for a CPAN dist
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    CPAN::Meta - the distribution metadata for a CPAN dist
    
    =head1 VERSION
    
    version 2.132510
    
    =head1 SYNOPSIS
    
        use v5.10;
        use strict;
        use warnings;
        use CPAN::Meta;
        use Module::Load;
    
        my $meta = CPAN::Meta->load_file('META.json');
    
        printf "testing requirements for %s version %s\n",
        $meta->name,
        $meta->version;
    
        my $prereqs = $meta->effective_prereqs;
    
        for my $phase ( qw/configure runtime build test/ ) {
            say "Requirements for $phase:";
            my $reqs = $prereqs->requirements_for($phase, "requires");
            for my $module ( sort $reqs->required_modules ) {
                my $status;
                if ( eval { load $module unless $module eq 'perl'; 1 } ) {
                    my $version = $module eq 'perl' ? $] : $module->VERSION;
                    $status = $reqs->accepts_module($module, $version)
                            ? "$version ok" : "$version not ok";
                } else {
                    $status = "missing"
                };
                say "  $module ($status)";
            }
        }
    
    =head1 DESCRIPTION
    
    Software distributions released to the CPAN include a F<META.json> or, for
    older distributions, F<META.yml>, which describes the distribution, its
    contents, and the requirements for building and installing the distribution.
    The data structure stored in the F<META.json> file is described in
    L<CPAN::Meta::Spec>.
    
    CPAN::Meta provides a simple class to represent this distribution metadata (or
    I<distmeta>), along with some helpful methods for interrogating that data.
    
    The documentation below is only for the methods of the CPAN::Meta object.  For
    information on the meaning of individual fields, consult the spec.
    
    =head1 METHODS
    
    =head2 new
    
      my $meta = CPAN::Meta->new($distmeta_struct, \%options);
    
    Returns a valid CPAN::Meta object or dies if the supplied metadata hash
    reference fails to validate.  Older-format metadata will be up-converted to
    version 2 if they validate against the original stated specification.
    
    It takes an optional hashref of options. Valid options include:
    
    =over
    
    =item *
    
    lazy_validation -- if true, new will attempt to convert the given metadata
    to version 2 before attempting to validate it.  This means than any
    fixable errors will be handled by CPAN::Meta::Converter before validation.
    (Note that this might result in invalid optional data being silently
    dropped.)  The default is false.
    
    =back
    
    =head2 create
    
      my $meta = CPAN::Meta->create($distmeta_struct, \%options);
    
    This is same as C<new()>, except that C<generated_by> and C<meta-spec> fields
    will be generated if not provided.  This means the metadata structure is
    assumed to otherwise follow the latest L<CPAN::Meta::Spec>.
    
    =head2 load_file
    
      my $meta = CPAN::Meta->load_file($distmeta_file, \%options);
    
    Given a pathname to a file containing metadata, this deserializes the file
    according to its file suffix and constructs a new C<CPAN::Meta> object, just
    like C<new()>.  It will die if the deserialized version fails to validate
    against its stated specification version.
    
    It takes the same options as C<new()> but C<lazy_validation> defaults to
    true.
    
    =head2 load_yaml_string
    
      my $meta = CPAN::Meta->load_yaml_string($yaml, \%options);
    
    This method returns a new CPAN::Meta object using the first document in the
    given YAML string.  In other respects it is identical to C<load_file()>.
    
    =head2 load_json_string
    
      my $meta = CPAN::Meta->load_json_string($json, \%options);
    
    This method returns a new CPAN::Meta object using the structure represented by
    the given JSON string.  In other respects it is identical to C<load_file()>.
    
    =head2 save
    
      $meta->save($distmeta_file, \%options);
    
    Serializes the object as JSON and writes it to the given file.  The only valid
    option is C<version>, which defaults to '2'. On Perl 5.8.1 or later, the file
    is saved with UTF-8 encoding.
    
    For C<version> 2 (or higher), the filename should end in '.json'.  L<JSON::PP>
    is the default JSON backend. Using another JSON backend requires L<JSON> 2.5 or
    later and you must set the C<$ENV{PERL_JSON_BACKEND}> to a supported alternate
    backend like L<JSON::XS>.
    
    For C<version> less than 2, the filename should end in '.yml'.
    L<CPAN::Meta::Converter> is used to generate an older metadata structure, which
    is serialized to YAML.  CPAN::Meta::YAML is the default YAML backend.  You may
    set the C<$ENV{PERL_YAML_BACKEND}> to a supported alternative backend, though
    this is not recommended due to subtle incompatibilities between YAML parsers on
    CPAN.
    
    =head2 meta_spec_version
    
    This method returns the version part of the C<meta_spec> entry in the distmeta
    structure.  It is equivalent to:
    
      $meta->meta_spec->{version};
    
    =head2 effective_prereqs
    
      my $prereqs = $meta->effective_prereqs;
    
      my $prereqs = $meta->effective_prereqs( \@feature_identifiers );
    
    This method returns a L<CPAN::Meta::Prereqs> object describing all the
    prereqs for the distribution.  If an arrayref of feature identifiers is given,
    the prereqs for the identified features are merged together with the
    distribution's core prereqs before the CPAN::Meta::Prereqs object is returned.
    
    =head2 should_index_file
    
      ... if $meta->should_index_file( $filename );
    
    This method returns true if the given file should be indexed.  It decides this
    by checking the C<file> and C<directory> keys in the C<no_index> property of
    the distmeta structure.
    
    C<$filename> should be given in unix format.
    
    =head2 should_index_package
    
      ... if $meta->should_index_package( $package );
    
    This method returns true if the given package should be indexed.  It decides
    this by checking the C<package> and C<namespace> keys in the C<no_index>
    property of the distmeta structure.
    
    =head2 features
    
      my @feature_objects = $meta->features;
    
    This method returns a list of L<CPAN::Meta::Feature> objects, one for each
    optional feature described by the distribution's metadata.
    
    =head2 feature
    
      my $feature_object = $meta->feature( $identifier );
    
    This method returns a L<CPAN::Meta::Feature> object for the optional feature
    with the given identifier.  If no feature with that identifier exists, an
    exception will be raised.
    
    =head2 as_struct
    
      my $copy = $meta->as_struct( \%options );
    
    This method returns a deep copy of the object's metadata as an unblessed hash
    reference.  It takes an optional hashref of options.  If the hashref contains
    a C<version> argument, the copied metadata will be converted to the version
    of the specification and returned.  For example:
    
      my $old_spec = $meta->as_struct( {version => "1.4"} );
    
    =head2 as_string
    
      my $string = $meta->as_string( \%options );
    
    This method returns a serialized copy of the object's metadata as a character
    string.  (The strings are B<not> UTF-8 encoded.)  It takes an optional hashref
    of options.  If the hashref contains a C<version> argument, the copied metadata
    will be converted to the version of the specification and returned.  For
    example:
    
      my $string = $meta->as_struct( {version => "1.4"} );
    
    For C<version> greater than or equal to 2, the string will be serialized as
    JSON.  For C<version> less than 2, the string will be serialized as YAML.  In
    both cases, the same rules are followed as in the C<save()> method for choosing
    a serialization backend.
    
    =head1 STRING DATA
    
    The following methods return a single value, which is the value for the
    corresponding entry in the distmeta structure.  Values should be either undef
    or strings.
    
    =over 4
    
    =item *
    
    abstract
    
    =item *
    
    description
    
    =item *
    
    dynamic_config
    
    =item *
    
    generated_by
    
    =item *
    
    name
    
    =item *
    
    release_status
    
    =item *
    
    version
    
    =back
    
    =head1 LIST DATA
    
    These methods return lists of string values, which might be represented in the
    distmeta structure as arrayrefs or scalars:
    
    =over 4
    
    =item *
    
    authors
    
    =item *
    
    keywords
    
    =item *
    
    licenses
    
    =back
    
    The C<authors> and C<licenses> methods may also be called as C<author> and
    C<license>, respectively, to match the field name in the distmeta structure.
    
    =head1 MAP DATA
    
    These readers return hashrefs of arbitrary unblessed data structures, each
    described more fully in the specification:
    
    =over 4
    
    =item *
    
    meta_spec
    
    =item *
    
    resources
    
    =item *
    
    provides
    
    =item *
    
    no_index
    
    =item *
    
    prereqs
    
    =item *
    
    optional_features
    
    =back
    
    =head1 CUSTOM DATA
    
    A list of custom keys are available from the C<custom_keys> method and
    particular keys may be retrieved with the C<custom> method.
    
      say $meta->custom($_) for $meta->custom_keys;
    
    If a custom key refers to a data structure, a deep clone is returned.
    
    =for Pod::Coverage TO_JSON abstract author authors custom custom_keys description dynamic_config
    generated_by keywords license licenses meta_spec name no_index
    optional_features prereqs provides release_status resources version
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 SEE ALSO
    
    =over 4
    
    =item *
    
    L<CPAN::Meta::Converter>
    
    =item *
    
    L<CPAN::Meta::Validator>
    
    =back
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/Perl-Toolchain-Gang/CPAN-Meta>
    
      git clone https://github.com/Perl-Toolchain-Gang/CPAN-Meta.git
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 CONTRIBUTORS
    
    =over 4
    
    =item *
    
    Ansgar Burchardt <ansgar@cpan.org>
    
    =item *
    
    Avar Arnfjord Bjarmason <avar@cpan.org>
    
    =item *
    
    Christopher J. Madsen <cjm@cpan.org>
    
    =item *
    
    Cory G Watson <gphat@cpan.org>
    
    =item *
    
    Damyan Ivanov <dam@cpan.org>
    
    =item *
    
    Eric Wilhelm <ewilhelm@cpan.org>
    
    =item *
    
    Gregor Hermann <gregoa@debian.org>
    
    =item *
    
    Karen Etheridge <ether@cpan.org>
    
    =item *
    
    Ken Williams <kwilliams@cpan.org>
    
    =item *
    
    Kenichi Ishigaki <ishigaki@cpan.org>
    
    =item *
    
    Lars Dieckow <daxim@cpan.org>
    
    =item *
    
    Leon Timmermans <leont@cpan.org>
    
    =item *
    
    Mark Fowler <markf@cpan.org>
    
    =item *
    
    Michael G. Schwern <mschwern@cpan.org>
    
    =item *
    
    Olaf Alders <olaf@wundersolutions.com>
    
    =item *
    
    Olivier Mengu <dolmen@cpan.org>
    
    =item *
    
    Randy Sims <randys@thepierianspring.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META
  
  $fatpacked{"CPAN/Meta/Check.pm"} = <<'CPAN_META_CHECK';
    package CPAN::Meta::Check;
    {
      $CPAN::Meta::Check::VERSION = '0.007';
    }
    use strict;
    use warnings;
    
    use Exporter 5.57 'import';
    our @EXPORT = qw//;
    our @EXPORT_OK = qw/check_requirements requirements_for verify_dependencies/;
    our %EXPORT_TAGS = (all => [ @EXPORT, @EXPORT_OK ] );
    
    use CPAN::Meta::Requirements 2.120920;
    use Module::Metadata;
    
    sub _check_dep {
    	my ($reqs, $module, $dirs) = @_;
    
    	my $version = $module eq 'perl' ? $] : do { 
    		my $metadata = Module::Metadata->new_from_module($module, inc => $dirs);
    		return "Module '$module' is not installed" if not defined $metadata;
    		eval { $metadata->version };
    	};
    	return "Missing version info for module '$module'" if $reqs->requirements_for_module($module) and not $version;
    	return sprintf 'Installed version (%s) of %s is not in range \'%s\'', $version, $module, $reqs->requirements_for_module($module) if not $reqs->accepts_module($module, $version || 0);
    	return;
    }
    
    sub _check_conflict {
    	my ($reqs, $module, $dirs) = @_;
    	my $metadata = Module::Metadata->new_from_module($module, inc => $dirs);
    	return if not defined $metadata;
    	my $version = eval { $metadata->version };
    	return "Missing version info for module '$module'" if not $version;
    	return sprintf 'Installed version (%s) of %s is in range \'%s\'', $version, $module, $reqs->requirements_for_module($module) if $reqs->accepts_module($module, $version);
    	return;
    }
    
    sub requirements_for {
    	my ($meta, $phases, $type) = @_;
    	my $prereqs = ref($meta) eq 'CPAN::Meta' ? $meta->effective_prereqs : $meta;
    	if (!ref $phases) {
    		return $prereqs->requirements_for($phases, $type);
    	}
    	else {
    		my $ret = CPAN::Meta::Requirements->new;
    		for my $phase (@{ $phases }) {
    			$ret->add_requirements($prereqs->requirements_for($phase, $type));
    		}
    		return $ret;
    	}
    }
    
    sub check_requirements {
    	my ($reqs, $type, $dirs) = @_;
    
    	my %ret;
    	if ($type ne 'conflicts') {
    		for my $module ($reqs->required_modules) {
    			$ret{$module} = _check_dep($reqs, $module, $dirs);
    		}
    	}
    	else {
    		for my $module ($reqs->required_modules) {
    			$ret{$module} = _check_conflict($reqs, $module, $dirs);
    		}
    	}
    	return \%ret;
    }
    
    sub verify_dependencies {
    	my ($meta, $phases, $type, $dirs) = @_;
    	my $reqs = requirements_for($meta, $phases, $type);
    	my $issues = check_requirements($reqs, $type, $dirs);
    	return grep { defined } values %{ $issues };
    }
    
    # vi:noet:sts=2:sw=2:ts=2
    1;
    
    #ABSTRACT: Verify requirements in a CPAN::Meta object
    
    __END__
    
    =pod
    
    =head1 NAME
    
    CPAN::Meta::Check - Verify requirements in a CPAN::Meta object
    
    =head1 VERSION
    
    version 0.007
    
    =head1 SYNOPSIS
    
     warn "$_\n" for verify_requirements($meta, [qw/runtime build test/], 'requires');
    
    =head1 DESCRIPTION
    
    This module verifies if requirements described in a CPAN::Meta object are present.
    
    =head1 FUNCTIONS
    
    =head2 check_requirements($reqs, $type)
    
    This function checks if all dependencies in C<$reqs> (a L<CPAN::Meta::Requirements|CPAN::Meta::Requirements> object) are met, taking into account that 'conflicts' dependencies have to be checked in reverse. It returns a hash with the modules as keys and any problems as values; the value for a successfully found module will be undef.
    
    =head2 verify_dependencies($meta, $phases, $types, $incdirs)
    
    Check all requirements in C<$meta> for phases C<$phases> and types C<$types>. Modules are searched for in C<@$incdirs>, defaulting to C<@INC>.
    
    =head2 requirements_for($meta, $phases, $types, incdirs)
    
    This function returns a unified L<CPAN::Meta::Requirements|CPAN::Meta::Requirements> object for all C<$type> requirements for C<$phases>. $phases may be either one (scalar) value or an arrayref of valid values as defined by the L<CPAN::Meta spec|CPAN::Meta::Spec>. C<$type> must be a relationship as defined by the same spec. Modules are searched for in C<@$incdirs>, defaulting to C<@INC>.
    
    =head1 SEE ALSO
    
    =over 4
    
    =item * L<Test::CheckDeps|Test::CheckDeps>
    
    =item * L<CPAN::Meta|CPAN::Meta>
    
    =back
    
    =head1 AUTHOR
    
    Leon Timmermans <leont@cpan.org>
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2012 by Leon Timmermans.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_CHECK
  
  $fatpacked{"CPAN/Meta/Converter.pm"} = <<'CPAN_META_CONVERTER';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Converter;
    our $VERSION = '2.132510'; # VERSION
    
    
    use CPAN::Meta::Validator;
    use CPAN::Meta::Requirements;
    use version 0.88 ();
    use Parse::CPAN::Meta 1.4400 ();
    
    sub _dclone {
      my $ref = shift;
    
      # if an object is in the data structure and doesn't specify how to
      # turn itself into JSON, we just stringify the object.  That does the
      # right thing for typical things that might be there, like version objects,
      # Path::Class objects, etc.
      no warnings 'once';
      local *UNIVERSAL::TO_JSON = sub { return "$_[0]" };
    
      my $backend = Parse::CPAN::Meta->json_backend();
      return $backend->new->utf8->decode(
        $backend->new->utf8->allow_blessed->convert_blessed->encode($ref)
      );
    }
    
    my %known_specs = (
        '2'   => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
        '1.4' => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
        '1.3' => 'http://module-build.sourceforge.net/META-spec-v1.3.html',
        '1.2' => 'http://module-build.sourceforge.net/META-spec-v1.2.html',
        '1.1' => 'http://module-build.sourceforge.net/META-spec-v1.1.html',
        '1.0' => 'http://module-build.sourceforge.net/META-spec-v1.0.html'
    );
    
    my @spec_list = sort { $a <=> $b } keys %known_specs;
    my ($LOWEST, $HIGHEST) = @spec_list[0,-1];
    
    #--------------------------------------------------------------------------#
    # converters
    #
    # called as $converter->($element, $field_name, $full_meta, $to_version)
    #
    # defined return value used for field
    # undef return value means field is skipped
    #--------------------------------------------------------------------------#
    
    sub _keep { $_[0] }
    
    sub _keep_or_one { defined($_[0]) ? $_[0] : 1 }
    
    sub _keep_or_zero { defined($_[0]) ? $_[0] : 0 }
    
    sub _keep_or_unknown { defined($_[0]) && length($_[0]) ? $_[0] : "unknown" }
    
    sub _generated_by {
      my $gen = shift;
      my $sig = __PACKAGE__ . " version " . (__PACKAGE__->VERSION || "<dev>");
    
      return $sig unless defined $gen and length $gen;
      return $gen if $gen =~ /(, )\Q$sig/;
      return "$gen, $sig";
    }
    
    sub _listify { ! defined $_[0] ? undef : ref $_[0] eq 'ARRAY' ? $_[0] : [$_[0]] }
    
    sub _prefix_custom {
      my $key = shift;
      $key =~ s/^(?!x_)   # Unless it already starts with x_
                 (?:x-?)? # Remove leading x- or x (if present)
               /x_/ix;    # and prepend x_
      return $key;
    }
    
    sub _ucfirst_custom {
      my $key = shift;
      $key = ucfirst $key unless $key =~ /[A-Z]/;
      return $key;
    }
    
    sub _no_prefix_ucfirst_custom {
      my $key = shift;
      $key =~ s/^x_//;
      return _ucfirst_custom($key);
    }
    
    sub _change_meta_spec {
      my ($element, undef, undef, $version) = @_;
      $element->{version} = $version;
      $element->{url} = $known_specs{$version};
      return $element;
    }
    
    my @valid_licenses_1 = (
      'perl',
      'gpl',
      'apache',
      'artistic',
      'artistic_2',
      'lgpl',
      'bsd',
      'gpl',
      'mit',
      'mozilla',
      'open_source',
      'unrestricted',
      'restrictive',
      'unknown',
    );
    
    my %license_map_1 = (
      ( map { $_ => $_ } @valid_licenses_1 ),
      artistic2 => 'artistic_2',
    );
    
    sub _license_1 {
      my ($element) = @_;
      return 'unknown' unless defined $element;
      if ( $license_map_1{lc $element} ) {
        return $license_map_1{lc $element};
      }
      return 'unknown';
    }
    
    my @valid_licenses_2 = qw(
      agpl_3
      apache_1_1
      apache_2_0
      artistic_1
      artistic_2
      bsd
      freebsd
      gfdl_1_2
      gfdl_1_3
      gpl_1
      gpl_2
      gpl_3
      lgpl_2_1
      lgpl_3_0
      mit
      mozilla_1_0
      mozilla_1_1
      openssl
      perl_5
      qpl_1_0
      ssleay
      sun
      zlib
      open_source
      restricted
      unrestricted
      unknown
    );
    
    # The "old" values were defined by Module::Build, and were often vague.  I have
    # made the decisions below based on reading Module::Build::API and how clearly
    # it specifies the version of the license.
    my %license_map_2 = (
      (map { $_ => $_ } @valid_licenses_2),
      apache      => 'apache_2_0',  # clearly stated as 2.0
      artistic    => 'artistic_1',  # clearly stated as 1
      artistic2   => 'artistic_2',  # clearly stated as 2
      gpl         => 'open_source', # we don't know which GPL; punt
      lgpl        => 'open_source', # we don't know which LGPL; punt
      mozilla     => 'open_source', # we don't know which MPL; punt
      perl        => 'perl_5',      # clearly Perl 5
      restrictive => 'restricted',
    );
    
    sub _license_2 {
      my ($element) = @_;
      return [ 'unknown' ] unless defined $element;
      $element = [ $element ] unless ref $element eq 'ARRAY';
      my @new_list;
      for my $lic ( @$element ) {
        next unless defined $lic;
        if ( my $new = $license_map_2{lc $lic} ) {
          push @new_list, $new;
        }
      }
      return @new_list ? \@new_list : [ 'unknown' ];
    }
    
    my %license_downgrade_map = qw(
      agpl_3            open_source
      apache_1_1        apache
      apache_2_0        apache
      artistic_1        artistic
      artistic_2        artistic_2
      bsd               bsd
      freebsd           open_source
      gfdl_1_2          open_source
      gfdl_1_3          open_source
      gpl_1             gpl
      gpl_2             gpl
      gpl_3             gpl
      lgpl_2_1          lgpl
      lgpl_3_0          lgpl
      mit               mit
      mozilla_1_0       mozilla
      mozilla_1_1       mozilla
      openssl           open_source
      perl_5            perl
      qpl_1_0           open_source
      ssleay            open_source
      sun               open_source
      zlib              open_source
      open_source       open_source
      restricted        restrictive
      unrestricted      unrestricted
      unknown           unknown
    );
    
    sub _downgrade_license {
      my ($element) = @_;
      if ( ! defined $element ) {
        return "unknown";
      }
      elsif( ref $element eq 'ARRAY' ) {
        if ( @$element == 1 ) {
          return $license_downgrade_map{$element->[0]} || "unknown";
        }
      }
      elsif ( ! ref $element ) {
        return $license_downgrade_map{$element} || "unknown";
      }
      return "unknown";
    }
    
    my $no_index_spec_1_2 = {
      'file' => \&_listify,
      'dir' => \&_listify,
      'package' => \&_listify,
      'namespace' => \&_listify,
    };
    
    my $no_index_spec_1_3 = {
      'file' => \&_listify,
      'directory' => \&_listify,
      'package' => \&_listify,
      'namespace' => \&_listify,
    };
    
    my $no_index_spec_2 = {
      'file' => \&_listify,
      'directory' => \&_listify,
      'package' => \&_listify,
      'namespace' => \&_listify,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _no_index_1_2 {
      my (undef, undef, $meta) = @_;
      my $no_index = $meta->{no_index} || $meta->{private};
      return unless $no_index;
    
      # cleanup wrong format
      if ( ! ref $no_index ) {
        my $item = $no_index;
        $no_index = { dir => [ $item ], file => [ $item ] };
      }
      elsif ( ref $no_index eq 'ARRAY' ) {
        my $list = $no_index;
        $no_index = { dir => [ @$list ], file => [ @$list ] };
      }
    
      # common mistake: files -> file
      if ( exists $no_index->{files} ) {
        $no_index->{file} = delete $no_index->{file};
      }
      # common mistake: modules -> module
      if ( exists $no_index->{modules} ) {
        $no_index->{module} = delete $no_index->{module};
      }
      return _convert($no_index, $no_index_spec_1_2);
    }
    
    sub _no_index_directory {
      my ($element, $key, $meta, $version) = @_;
      return unless $element;
    
      # cleanup wrong format
      if ( ! ref $element ) {
        my $item = $element;
        $element = { directory => [ $item ], file => [ $item ] };
      }
      elsif ( ref $element eq 'ARRAY' ) {
        my $list = $element;
        $element = { directory => [ @$list ], file => [ @$list ] };
      }
    
      if ( exists $element->{dir} ) {
        $element->{directory} = delete $element->{dir};
      }
      # common mistake: files -> file
      if ( exists $element->{files} ) {
        $element->{file} = delete $element->{file};
      }
      # common mistake: modules -> module
      if ( exists $element->{modules} ) {
        $element->{module} = delete $element->{module};
      }
      my $spec = $version == 2 ? $no_index_spec_2 : $no_index_spec_1_3;
      return _convert($element, $spec);
    }
    
    sub _is_module_name {
      my $mod = shift;
      return unless defined $mod && length $mod;
      return $mod =~ m{^[A-Za-z][A-Za-z0-9_]*(?:::[A-Za-z0-9_]+)*$};
    }
    
    sub _clean_version {
      my ($element) = @_;
      return 0 if ! defined $element;
    
      $element =~ s{^\s*}{};
      $element =~ s{\s*$}{};
      $element =~ s{^\.}{0.};
    
      return 0 if ! length $element;
      return 0 if ( $element eq 'undef' || $element eq '<undef>' );
    
      my $v = eval { version->new($element) };
      # XXX check defined $v and not just $v because version objects leak memory
      # in boolean context -- dagolden, 2012-02-03
      if ( defined $v ) {
        return $v->is_qv ? $v->normal : $element;
      }
      else {
        return 0;
      }
    }
    
    sub _bad_version_hook {
      my ($v) = @_;
      $v =~ s{[a-z]+$}{}; # strip trailing alphabetics
      my $vobj = eval { version->parse($v) };
      return defined($vobj) ? $vobj : version->parse(0); # or give up
    }
    
    sub _version_map {
      my ($element) = @_;
      return unless defined $element;
      if ( ref $element eq 'HASH' ) {
        # XXX turn this into CPAN::Meta::Requirements with bad version hook
        # and then turn it back into a hash
        my $new_map = CPAN::Meta::Requirements->new(
          { bad_version_hook => sub { version->new(0) } } # punt
        );
        while ( my ($k,$v) = each %$element ) {
          next unless _is_module_name($k);
          if ( !defined($v) || !length($v) || $v eq 'undef' || $v eq '<undef>'  ) {
            $v = 0;
          }
          # some weird, old META have bad yml with module => module
          # so check if value is like a module name and not like a version
          if ( _is_module_name($v) && ! version::is_lax($v) ) {
            $new_map->add_minimum($k => 0);
            $new_map->add_minimum($v => 0);
          }
          $new_map->add_string_requirement($k => $v);
        }
        return $new_map->as_string_hash;
      }
      elsif ( ref $element eq 'ARRAY' ) {
        my $hashref = { map { $_ => 0 } @$element };
        return _version_map($hashref); # cleanup any weird stuff
      }
      elsif ( ref $element eq '' && length $element ) {
        return { $element => 0 }
      }
      return;
    }
    
    sub _prereqs_from_1 {
      my (undef, undef, $meta) = @_;
      my $prereqs = {};
      for my $phase ( qw/build configure/ ) {
        my $key = "${phase}_requires";
        $prereqs->{$phase}{requires} = _version_map($meta->{$key})
          if $meta->{$key};
      }
      for my $rel ( qw/requires recommends conflicts/ ) {
        $prereqs->{runtime}{$rel} = _version_map($meta->{$rel})
          if $meta->{$rel};
      }
      return $prereqs;
    }
    
    my $prereqs_spec = {
      configure => \&_prereqs_rel,
      build     => \&_prereqs_rel,
      test      => \&_prereqs_rel,
      runtime   => \&_prereqs_rel,
      develop   => \&_prereqs_rel,
      ':custom'  => \&_prefix_custom,
    };
    
    my $relation_spec = {
      requires   => \&_version_map,
      recommends => \&_version_map,
      suggests   => \&_version_map,
      conflicts  => \&_version_map,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _cleanup_prereqs {
      my ($prereqs, $key, $meta, $to_version) = @_;
      return unless $prereqs && ref $prereqs eq 'HASH';
      return _convert( $prereqs, $prereqs_spec, $to_version );
    }
    
    sub _prereqs_rel {
      my ($relation, $key, $meta, $to_version) = @_;
      return unless $relation && ref $relation eq 'HASH';
      return _convert( $relation, $relation_spec, $to_version );
    }
    
    
    BEGIN {
      my @old_prereqs = qw(
        requires
        configure_requires
        recommends
        conflicts
      );
    
      for ( @old_prereqs ) {
        my $sub = "_get_$_";
        my ($phase,$type) = split qr/_/, $_;
        if ( ! defined $type ) {
          $type = $phase;
          $phase = 'runtime';
        }
        no strict 'refs';
        *{$sub} = sub { _extract_prereqs($_[2]->{prereqs},$phase,$type) };
      }
    }
    
    sub _get_build_requires {
      my ($data, $key, $meta) = @_;
    
      my $test_h  = _extract_prereqs($_[2]->{prereqs}, qw(test  requires)) || {};
      my $build_h = _extract_prereqs($_[2]->{prereqs}, qw(build requires)) || {};
    
      my $test_req  = CPAN::Meta::Requirements->from_string_hash($test_h);
      my $build_req = CPAN::Meta::Requirements->from_string_hash($build_h);
    
      $test_req->add_requirements($build_req)->as_string_hash;
    }
    
    sub _extract_prereqs {
      my ($prereqs, $phase, $type) = @_;
      return unless ref $prereqs eq 'HASH';
      return scalar _version_map($prereqs->{$phase}{$type});
    }
    
    sub _downgrade_optional_features {
      my (undef, undef, $meta) = @_;
      return unless exists $meta->{optional_features};
      my $origin = $meta->{optional_features};
      my $features = {};
      for my $name ( keys %$origin ) {
        $features->{$name} = {
          description => $origin->{$name}{description},
          requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','requires'),
          configure_requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','configure_requires'),
          build_requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','build_requires'),
          recommends => _extract_prereqs($origin->{$name}{prereqs},'runtime','recommends'),
          conflicts => _extract_prereqs($origin->{$name}{prereqs},'runtime','conflicts'),
        };
        for my $k (keys %{$features->{$name}} ) {
          delete $features->{$name}{$k} unless defined $features->{$name}{$k};
        }
      }
      return $features;
    }
    
    sub _upgrade_optional_features {
      my (undef, undef, $meta) = @_;
      return unless exists $meta->{optional_features};
      my $origin = $meta->{optional_features};
      my $features = {};
      for my $name ( keys %$origin ) {
        $features->{$name} = {
          description => $origin->{$name}{description},
          prereqs => _prereqs_from_1(undef, undef, $origin->{$name}),
        };
        delete $features->{$name}{prereqs}{configure};
      }
      return $features;
    }
    
    my $optional_features_2_spec = {
      description => \&_keep,
      prereqs => \&_cleanup_prereqs,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _feature_2 {
      my ($element, $key, $meta, $to_version) = @_;
      return unless $element && ref $element eq 'HASH';
      _convert( $element, $optional_features_2_spec, $to_version );
    }
    
    sub _cleanup_optional_features_2 {
      my ($element, $key, $meta, $to_version) = @_;
      return unless $element && ref $element eq 'HASH';
      my $new_data = {};
      for my $k ( keys %$element ) {
        $new_data->{$k} = _feature_2( $element->{$k}, $k, $meta, $to_version );
      }
      return unless keys %$new_data;
      return $new_data;
    }
    
    sub _optional_features_1_4 {
      my ($element) = @_;
      return unless $element;
      $element = _optional_features_as_map($element);
      for my $name ( keys %$element ) {
        for my $drop ( qw/requires_packages requires_os excluded_os/ ) {
          delete $element->{$name}{$drop};
        }
      }
      return $element;
    }
    
    sub _optional_features_as_map {
      my ($element) = @_;
      return unless $element;
      if ( ref $element eq 'ARRAY' ) {
        my %map;
        for my $feature ( @$element ) {
          my (@parts) = %$feature;
          $map{$parts[0]} = $parts[1];
        }
        $element = \%map;
      }
      return $element;
    }
    
    sub _is_urlish { defined $_[0] && $_[0] =~ m{\A[-+.a-z0-9]+:.+}i }
    
    sub _url_or_drop {
      my ($element) = @_;
      return $element if _is_urlish($element);
      return;
    }
    
    sub _url_list {
      my ($element) = @_;
      return unless $element;
      $element = _listify( $element );
      $element = [ grep { _is_urlish($_) } @$element ];
      return unless @$element;
      return $element;
    }
    
    sub _author_list {
      my ($element) = @_;
      return [ 'unknown' ] unless $element;
      $element = _listify( $element );
      $element = [ map { defined $_ && length $_ ? $_ : 'unknown' } @$element ];
      return [ 'unknown' ] unless @$element;
      return $element;
    }
    
    my $resource2_upgrade = {
      license    => sub { return _is_urlish($_[0]) ? _listify( $_[0] ) : undef },
      homepage   => \&_url_or_drop,
      bugtracker => sub {
        my ($item) = @_;
        return unless $item;
        if ( $item =~ m{^mailto:(.*)$} ) { return { mailto => $1 } }
        elsif( _is_urlish($item) ) { return { web => $item } }
        else { return }
      },
      repository => sub { return _is_urlish($_[0]) ? { url => $_[0] } : undef },
      ':custom'  => \&_prefix_custom,
    };
    
    sub _upgrade_resources_2 {
      my (undef, undef, $meta, $version) = @_;
      return unless exists $meta->{resources};
      return _convert($meta->{resources}, $resource2_upgrade);
    }
    
    my $bugtracker2_spec = {
      web => \&_url_or_drop,
      mailto => \&_keep,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _repo_type {
      my ($element, $key, $meta, $to_version) = @_;
      return $element if defined $element;
      return unless exists $meta->{url};
      my $repo_url = $meta->{url};
      for my $type ( qw/git svn/ ) {
        return $type if $repo_url =~ m{\A$type};
      }
      return;
    }
    
    my $repository2_spec = {
      web => \&_url_or_drop,
      url => \&_url_or_drop,
      type => \&_repo_type,
      ':custom'  => \&_prefix_custom,
    };
    
    my $resources2_cleanup = {
      license    => \&_url_list,
      homepage   => \&_url_or_drop,
      bugtracker => sub { ref $_[0] ? _convert( $_[0], $bugtracker2_spec ) : undef },
      repository => sub { my $data = shift; ref $data ? _convert( $data, $repository2_spec ) : undef },
      ':custom'  => \&_prefix_custom,
    };
    
    sub _cleanup_resources_2 {
      my ($resources, $key, $meta, $to_version) = @_;
      return unless $resources && ref $resources eq 'HASH';
      return _convert($resources, $resources2_cleanup, $to_version);
    }
    
    my $resource1_spec = {
      license    => \&_url_or_drop,
      homepage   => \&_url_or_drop,
      bugtracker => \&_url_or_drop,
      repository => \&_url_or_drop,
      ':custom'  => \&_keep,
    };
    
    sub _resources_1_3 {
      my (undef, undef, $meta, $version) = @_;
      return unless exists $meta->{resources};
      return _convert($meta->{resources}, $resource1_spec);
    }
    
    *_resources_1_4 = *_resources_1_3;
    
    sub _resources_1_2 {
      my (undef, undef, $meta) = @_;
      my $resources = $meta->{resources} || {};
      if ( $meta->{license_url} && ! $resources->{license} ) {
        $resources->{license} = $meta->license_url
          if _is_urlish($meta->{license_url});
      }
      return unless keys %$resources;
      return _convert($resources, $resource1_spec);
    }
    
    my $resource_downgrade_spec = {
      license    => sub { return ref $_[0] ? $_[0]->[0] : $_[0] },
      homepage   => \&_url_or_drop,
      bugtracker => sub { return $_[0]->{web} },
      repository => sub { return $_[0]->{url} || $_[0]->{web} },
      ':custom'  => \&_no_prefix_ucfirst_custom,
    };
    
    sub _downgrade_resources {
      my (undef, undef, $meta, $version) = @_;
      return unless exists $meta->{resources};
      return _convert($meta->{resources}, $resource_downgrade_spec);
    }
    
    sub _release_status {
      my ($element, undef, $meta) = @_;
      return $element if $element && $element =~ m{\A(?:stable|testing|unstable)\z};
      return _release_status_from_version(undef, undef, $meta);
    }
    
    sub _release_status_from_version {
      my (undef, undef, $meta) = @_;
      my $version = $meta->{version} || '';
      return ( $version =~ /_/ ) ? 'testing' : 'stable';
    }
    
    my $provides_spec = {
      file => \&_keep,
      version => \&_keep,
    };
    
    my $provides_spec_2 = {
      file => \&_keep,
      version => \&_keep,
      ':custom'  => \&_prefix_custom,
    };
    
    sub _provides {
      my ($element, $key, $meta, $to_version) = @_;
      return unless defined $element && ref $element eq 'HASH';
      my $spec = $to_version == 2 ? $provides_spec_2 : $provides_spec;
      my $new_data = {};
      for my $k ( keys %$element ) {
        $new_data->{$k} = _convert($element->{$k}, $spec, $to_version);
        $new_data->{$k}{version} = _clean_version($element->{$k}{version})
          if exists $element->{$k}{version};
      }
      return $new_data;
    }
    
    sub _convert {
      my ($data, $spec, $to_version) = @_;
    
      my $new_data = {};
      for my $key ( keys %$spec ) {
        next if $key eq ':custom' || $key eq ':drop';
        next unless my $fcn = $spec->{$key};
        die "spec for '$key' is not a coderef"
          unless ref $fcn && ref $fcn eq 'CODE';
        my $new_value = $fcn->($data->{$key}, $key, $data, $to_version);
        $new_data->{$key} = $new_value if defined $new_value;
      }
    
      my $drop_list   = $spec->{':drop'};
      my $customizer  = $spec->{':custom'} || \&_keep;
    
      for my $key ( keys %$data ) {
        next if $drop_list && grep { $key eq $_ } @$drop_list;
        next if exists $spec->{$key}; # we handled it
        $new_data->{ $customizer->($key) } = $data->{$key};
      }
    
      return $new_data;
    }
    
    #--------------------------------------------------------------------------#
    # define converters for each conversion
    #--------------------------------------------------------------------------#
    
    # each converts from prior version
    # special ":custom" field is used for keys not recognized in spec
    my %up_convert = (
      '2-from-1.4' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_2,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # CHANGED TO MANDATORY
        'dynamic_config'      => \&_keep_or_one,
        # ADDED MANDATORY
        'release_status'      => \&_release_status_from_version,
        # PRIOR OPTIONAL
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_upgrade_optional_features,
        'provides'            => \&_provides,
        'resources'           => \&_upgrade_resources_2,
        # ADDED OPTIONAL
        'description'         => \&_keep,
        'prereqs'             => \&_prereqs_from_1,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
            build_requires
            configure_requires
            conflicts
            distribution_type
            license_url
            private
            recommends
            requires
        ) ],
    
        # other random keys need x_ prefixing
        ':custom'              => \&_prefix_custom,
      },
      '1.4-from-1.3' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_1_4,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_4,
        # ADDED OPTIONAL
        'configure_requires'  => \&_keep,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
          license_url
          private
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep
      },
      '1.3-from-1.2' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_3,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
          license_url
          private
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep
      },
      '1.2-from-1.1' => {
        # PRIOR MANDATORY
        'version'             => \&_keep,
        # CHANGED TO MANDATORY
        'license'             => \&_license_1,
        'name'                => \&_keep,
        'generated_by'        => \&_generated_by,
        # ADDED MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'meta-spec'           => \&_change_meta_spec,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        # ADDED OPTIONAL
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_1_2,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'resources'           => \&_resources_1_2,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
          license_url
          private
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep
      },
      '1.1-from-1.0' => {
        # CHANGED TO MANDATORY
        'version'             => \&_keep,
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        # ADDED OPTIONAL
        'license_url'         => \&_url_or_drop,
        'private'             => \&_keep,
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep
      },
    );
    
    my %down_convert = (
      '1.4-from-2' => {
        # MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_downgrade_license,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # OPTIONAL
        'build_requires'      => \&_get_build_requires,
        'configure_requires'  => \&_get_configure_requires,
        'conflicts'           => \&_get_conflicts,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_downgrade_optional_features,
        'provides'            => \&_provides,
        'recommends'          => \&_get_recommends,
        'requires'            => \&_get_requires,
        'resources'           => \&_downgrade_resources,
    
        # drop these unsupported fields (after conversion)
        ':drop' => [ qw(
          description
          prereqs
          release_status
        )],
    
        # custom keys will be left unchanged
        ':custom'              => \&_keep
      },
      '1.3-from-1.4' => {
        # MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_3,
    
        # drop these unsupported fields, but only after we convert
        ':drop' => [ qw(
          configure_requires
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep,
      },
      '1.2-from-1.3' => {
        # MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_1_2,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_3,
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep,
      },
      '1.1-from-1.2' => {
        # MANDATORY
        'version'             => \&_keep,
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        'meta-spec'           => \&_change_meta_spec,
        # OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'private'             => \&_keep,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
    
        # drop unsupported fields
        ':drop' => [ qw(
          abstract
          author
          provides
          no_index
          keywords
          resources
        )],
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep,
      },
      '1.0-from-1.1' => {
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        'meta-spec'           => \&_change_meta_spec,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
    
        # other random keys are OK if already valid
        ':custom'              => \&_keep,
      },
    );
    
    my %cleanup = (
      '2' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_2,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # CHANGED TO MANDATORY
        'dynamic_config'      => \&_keep_or_one,
        # ADDED MANDATORY
        'release_status'      => \&_release_status,
        # PRIOR OPTIONAL
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_cleanup_optional_features_2,
        'provides'            => \&_provides,
        'resources'           => \&_cleanup_resources_2,
        # ADDED OPTIONAL
        'description'         => \&_keep,
        'prereqs'             => \&_cleanup_prereqs,
    
        # drop these deprecated fields, but only after we convert
        ':drop' => [ qw(
            build_requires
            configure_requires
            conflicts
            distribution_type
            license_url
            private
            recommends
            requires
        ) ],
    
        # other random keys need x_ prefixing
        ':custom'              => \&_prefix_custom,
      },
      '1.4' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_1_4,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_4,
        # ADDED OPTIONAL
        'configure_requires'  => \&_keep,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep
      },
      '1.3' => {
        # PRIOR MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'meta-spec'           => \&_change_meta_spec,
        'name'                => \&_keep,
        'version'             => \&_keep,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_directory,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        'resources'           => \&_resources_1_3,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep
      },
      '1.2' => {
        # PRIOR MANDATORY
        'version'             => \&_keep,
        # CHANGED TO MANDATORY
        'license'             => \&_license_1,
        'name'                => \&_keep,
        'generated_by'        => \&_generated_by,
        # ADDED MANDATORY
        'abstract'            => \&_keep_or_unknown,
        'author'              => \&_author_list,
        'meta-spec'           => \&_change_meta_spec,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        # ADDED OPTIONAL
        'keywords'            => \&_keep,
        'no_index'            => \&_no_index_1_2,
        'optional_features'   => \&_optional_features_as_map,
        'provides'            => \&_provides,
        'resources'           => \&_resources_1_2,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep
      },
      '1.1' => {
        # CHANGED TO MANDATORY
        'version'             => \&_keep,
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        'meta-spec'           => \&_change_meta_spec,
        # PRIOR OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
        # ADDED OPTIONAL
        'license_url'         => \&_url_or_drop,
        'private'             => \&_keep,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep
      },
      '1.0' => {
        # IMPLIED MANDATORY
        'name'                => \&_keep,
        'meta-spec'           => \&_change_meta_spec,
        'version'             => \&_keep,
        # IMPLIED OPTIONAL
        'build_requires'      => \&_version_map,
        'conflicts'           => \&_version_map,
        'distribution_type'   => \&_keep,
        'dynamic_config'      => \&_keep_or_one,
        'generated_by'        => \&_generated_by,
        'license'             => \&_license_1,
        'recommends'          => \&_version_map,
        'requires'            => \&_version_map,
    
        # other random keys are OK if already valid
        ':custom'             => \&_keep,
      },
    );
    
    #--------------------------------------------------------------------------#
    # Code
    #--------------------------------------------------------------------------#
    
    
    sub new {
      my ($class,$data) = @_;
    
      # create an attributes hash
      my $self = {
        'data'    => $data,
        'spec'    => $data->{'meta-spec'}{'version'} || "1.0",
      };
    
      # create the object
      return bless $self, $class;
    }
    
    
    sub convert {
      my ($self, %args) = @_;
      my $args = { %args };
    
      my $new_version = $args->{version} || $HIGHEST;
    
      my ($old_version) = $self->{spec};
      my $converted = _dclone($self->{data});
    
      if ( $old_version == $new_version ) {
        $converted = _convert( $converted, $cleanup{$old_version}, $old_version );
        my $cmv = CPAN::Meta::Validator->new( $converted );
        unless ( $cmv->is_valid ) {
          my $errs = join("\n", $cmv->errors);
          die "Failed to clean-up $old_version metadata. Errors:\n$errs\n";
        }
        return $converted;
      }
      elsif ( $old_version > $new_version )  {
        my @vers = sort { $b <=> $a } keys %known_specs;
        for my $i ( 0 .. $#vers-1 ) {
          next if $vers[$i] > $old_version;
          last if $vers[$i+1] < $new_version;
          my $spec_string = "$vers[$i+1]-from-$vers[$i]";
          $converted = _convert( $converted, $down_convert{$spec_string}, $vers[$i+1] );
          my $cmv = CPAN::Meta::Validator->new( $converted );
          unless ( $cmv->is_valid ) {
            my $errs = join("\n", $cmv->errors);
            die "Failed to downconvert metadata to $vers[$i+1]. Errors:\n$errs\n";
          }
        }
        return $converted;
      }
      else {
        my @vers = sort { $a <=> $b } keys %known_specs;
        for my $i ( 0 .. $#vers-1 ) {
          next if $vers[$i] < $old_version;
          last if $vers[$i+1] > $new_version;
          my $spec_string = "$vers[$i+1]-from-$vers[$i]";
          $converted = _convert( $converted, $up_convert{$spec_string}, $vers[$i+1] );
          my $cmv = CPAN::Meta::Validator->new( $converted );
          unless ( $cmv->is_valid ) {
            my $errs = join("\n", $cmv->errors);
            die "Failed to upconvert metadata to $vers[$i+1]. Errors:\n$errs\n";
          }
        }
        return $converted;
      }
    }
    
    1;
    
    # ABSTRACT: Convert CPAN distribution metadata structures
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    CPAN::Meta::Converter - Convert CPAN distribution metadata structures
    
    =head1 VERSION
    
    version 2.132510
    
    =head1 SYNOPSIS
    
      my $struct = decode_json_file('META.json');
    
      my $cmc = CPAN::Meta::Converter->new( $struct );
    
      my $new_struct = $cmc->convert( version => "2" );
    
    =head1 DESCRIPTION
    
    This module converts CPAN Meta structures from one form to another.  The
    primary use is to convert older structures to the most modern version of
    the specification, but other transformations may be implemented in the
    future as needed.  (E.g. stripping all custom fields or stripping all
    optional fields.)
    
    =head1 METHODS
    
    =head2 new
    
      my $cmc = CPAN::Meta::Converter->new( $struct );
    
    The constructor should be passed a valid metadata structure but invalid
    structures are accepted.  If no meta-spec version is provided, version 1.0 will
    be assumed.
    
    =head2 convert
    
      my $new_struct = $cmc->convert( version => "2" );
    
    Returns a new hash reference with the metadata converted to a different form.
    C<convert> will die if any conversion/standardization still results in an
    invalid structure.
    
    Valid parameters include:
    
    =over
    
    =item *
    
    C<version> -- Indicates the desired specification version (e.g. "1.0", "1.1" ... "1.4", "2").
    Defaults to the latest version of the CPAN Meta Spec.
    
    =back
    
    Conversion proceeds through each version in turn.  For example, a version 1.2
    structure might be converted to 1.3 then 1.4 then finally to version 2. The
    conversion process attempts to clean-up simple errors and standardize data.
    For example, if C<author> is given as a scalar, it will converted to an array
    reference containing the item. (Converting a structure to its own version will
    also clean-up and standardize.)
    
    When data are cleaned and standardized, missing or invalid fields will be
    replaced with sensible defaults when possible.  This may be lossy or imprecise.
    For example, some badly structured META.yml files on CPAN have prerequisite
    modules listed as both keys and values:
    
      requires => { 'Foo::Bar' => 'Bam::Baz' }
    
    These would be split and each converted to a prerequisite with a minimum
    version of zero.
    
    When some mandatory fields are missing or invalid, the conversion will attempt
    to provide a sensible default or will fill them with a value of 'unknown'.  For
    example a missing or unrecognized C<license> field will result in a C<license>
    field of 'unknown'.  Fields that may get an 'unknown' include:
    
    =over 4
    
    =item *
    
    abstract
    
    =item *
    
    author
    
    =item *
    
    license
    
    =back
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_CONVERTER
  
  $fatpacked{"CPAN/Meta/Feature.pm"} = <<'CPAN_META_FEATURE';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Feature;
    our $VERSION = '2.132510'; # VERSION
    
    use CPAN::Meta::Prereqs;
    
    
    sub new {
      my ($class, $identifier, $spec) = @_;
    
      my %guts = (
        identifier  => $identifier,
        description => $spec->{description},
        prereqs     => CPAN::Meta::Prereqs->new($spec->{prereqs}),
      );
    
      bless \%guts => $class;
    }
    
    
    sub identifier  { $_[0]{identifier}  }
    
    
    sub description { $_[0]{description} }
    
    
    sub prereqs     { $_[0]{prereqs} }
    
    1;
    
    # ABSTRACT: an optional feature provided by a CPAN distribution
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    CPAN::Meta::Feature - an optional feature provided by a CPAN distribution
    
    =head1 VERSION
    
    version 2.132510
    
    =head1 DESCRIPTION
    
    A CPAN::Meta::Feature object describes an optional feature offered by a CPAN
    distribution and specified in the distribution's F<META.json> (or F<META.yml>)
    file.
    
    For the most part, this class will only be used when operating on the result of
    the C<feature> or C<features> methods on a L<CPAN::Meta> object.
    
    =head1 METHODS
    
    =head2 new
    
      my $feature = CPAN::Meta::Feature->new( $identifier => \%spec );
    
    This returns a new Feature object.  The C<%spec> argument to the constructor
    should be the same as the value of the C<optional_feature> entry in the
    distmeta.  It must contain entries for C<description> and C<prereqs>.
    
    =head2 identifier
    
    This method returns the feature's identifier.
    
    =head2 description
    
    This method returns the feature's long description.
    
    =head2 prereqs
    
    This method returns the feature's prerequisites as a L<CPAN::Meta::Prereqs>
    object.
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_FEATURE
  
  $fatpacked{"CPAN/Meta/History.pm"} = <<'CPAN_META_HISTORY';
    # vi:tw=72
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::History;
    our $VERSION = '2.132510'; # VERSION
    
    1;
    
    # ABSTRACT: history of CPAN Meta Spec changes
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    CPAN::Meta::History - history of CPAN Meta Spec changes
    
    =head1 VERSION
    
    version 2.132510
    
    =head1 DESCRIPTION
    
    The CPAN Meta Spec has gone through several iterations.  It was
    originally written in HTML and later revised into POD (though published
    in HTML generated from the POD).  Fields were added, removed or changed,
    sometimes by design and sometimes to reflect real-world usage after the
    fact.
    
    This document reconstructs the history of the CPAN Meta Spec based on
    change logs, repository commit messages and the published HTML files.
    In some cases, particularly prior to version 1.2, the exact version
    when certain fields were introduced or changed is inconsistent between
    sources.  When in doubt, the published HTML files for versions 1.0 to
    1.4 as they existed when version 2 was developed are used as the
    definitive source.
    
    Starting with version 2, the specification document is part of the
    CPAN-Meta distribution and will be published on CPAN as
    L<CPAN::Meta::Spec>.
    
    Going forward, specification version numbers will be integers and
    decimal portions will correspond to a release date for the CPAN::Meta
    library.
    
    =head1 HISTORY
    
    =head2 Version 2
    
    April 2010
    
    =over
    
    =item *
    
    Revised spec examples as perl data structures rather than YAML
    
    =item *
    
    Switched to JSON serialization from YAML
    
    =item *
    
    Specified allowed version number formats
    
    =item *
    
    Replaced 'requires', 'build_requires', 'configure_requires',
    'recommends' and 'conflicts' with new 'prereqs' data structure divided
    by I<phase> (configure, build, test, runtime, etc.) and I<relationship>
    (requires, recommends, suggests, conflicts)
    
    =item *
    
    Added support for 'develop' phase for requirements for maintaining
    a list of authoring tools
    
    =item *
    
    Changed 'license' to a list and revised the set of valid licenses
    
    =item *
    
    Made 'dynamic_config' mandatory to reduce confusion
    
    =item *
    
    Changed 'resources' subkey 'repository' to a hash that clarifies
    repository type, url for browsing and url for checkout
    
    =item *
    
    Changed 'resources' subkey 'bugtracker' to a hash for either web
    or mailto resource
    
    =item *
    
    Changed specification of 'optional_features':
    
    =over
    
    =item *
    
    Added formal specification and usage guide instead of just example
    
    =item *
    
    Changed to use new prereqs data structure instead of individual keys
    
    =back
    
    =item *
    
    Clarified intended use of 'author' as generalized contact list
    
    =item *
    
    Added 'release_status' field to indicate stable, testing or unstable
    status to provide hints to indexers
    
    =item *
    
    Added 'description' field for a longer description of the distribution
    
    =item *
    
    Formalized use of "x_" or "X_" for all custom keys not listed in the
    official spec
    
    =back
    
    =head2 Version 1.4
    
    June 2008
    
    =over
    
    =item *
    
    Noted explicit support for 'perl' in prerequisites
    
    =item *
    
    Added 'configure_requires' prerequisite type
    
    =item *
    
    Changed 'optional_features'
    
    =over
    
    =item *
    
    Example corrected to show map of maps instead of list of maps
    (though descriptive text said 'map' even in v1.3)
    
    =item *
    
    Removed 'requires_packages', 'requires_os' and 'excluded_os'
    as valid subkeys
    
    =back
    
    =back
    
    =head2 Version 1.3
    
    November 2006
    
    =over
    
    =item *
    
    Added 'no_index' subkey 'directory' and removed 'dir' to match actual
    usage in the wild
    
    =item *
    
    Added a 'repository' subkey to 'resources'
    
    =back
    
    =head2 Version 1.2
    
    August 2005
    
    =over
    
    =item *
    
    Re-wrote and restructured spec in POD syntax
    
    =item *
    
    Changed 'name' to be mandatory
    
    =item *
    
    Changed 'generated_by' to be mandatory
    
    =item *
    
    Changed 'license' to be mandatory
    
    =item *
    
    Added version range specifications for prerequisites
    
    =item *
    
    Added required 'abstract' field
    
    =item *
    
    Added required 'author' field
    
    =item *
    
    Added required 'meta-spec' field to define 'version' (and 'url') of the
    CPAN Meta Spec used for metadata
    
    =item *
    
    Added 'provides' field
    
    =item *
    
    Added 'no_index' field and deprecated 'private' field.  'no_index'
    subkeys include 'file', 'dir', 'package' and 'namespace'
    
    =item *
    
    Added 'keywords' field
    
    =item *
    
    Added 'resources' field with subkeys 'homepage', 'license', and
    'bugtracker'
    
    =item *
    
    Added 'optional_features' field as an alternate under 'recommends'.
    Includes 'description', 'requires', 'build_requires', 'conflicts',
    'requires_packages', 'requires_os' and 'excluded_os' as valid subkeys
    
    =item *
    
    Removed 'license_uri' field
    
    =back
    
    =head2 Version 1.1
    
    May 2003
    
    =over
    
    =item *
    
    Changed 'version' to be mandatory
    
    =item *
    
    Added 'private' field
    
    =item *
    
    Added 'license_uri' field
    
    =back
    
    =head2 Version 1.0
    
    March 2003
    
    =over
    
    =item *
    
    Original release (in HTML format only)
    
    =item *
    
    Included 'name', 'version', 'license', 'distribution_type', 'requires',
    'recommends', 'build_requires', 'conflicts', 'dynamic_config',
    'generated_by'
    
    =back
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_HISTORY
  
  $fatpacked{"CPAN/Meta/Prereqs.pm"} = <<'CPAN_META_PREREQS';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Prereqs;
    our $VERSION = '2.132510'; # VERSION
    
    
    use Carp qw(confess);
    use Scalar::Util qw(blessed);
    use CPAN::Meta::Requirements 2.121;
    
    
    sub __legal_phases { qw(configure build test runtime develop)   }
    sub __legal_types  { qw(requires recommends suggests conflicts) }
    
    # expect a prereq spec from META.json -- rjbs, 2010-04-11
    sub new {
      my ($class, $prereq_spec) = @_;
      $prereq_spec ||= {};
    
      my %is_legal_phase = map {; $_ => 1 } $class->__legal_phases;
      my %is_legal_type  = map {; $_ => 1 } $class->__legal_types;
    
      my %guts;
      PHASE: for my $phase (keys %$prereq_spec) {
        next PHASE unless $phase =~ /\Ax_/i or $is_legal_phase{$phase};
    
        my $phase_spec = $prereq_spec->{ $phase };
        next PHASE unless keys %$phase_spec;
    
        TYPE: for my $type (keys %$phase_spec) {
          next TYPE unless $type =~ /\Ax_/i or $is_legal_type{$type};
    
          my $spec = $phase_spec->{ $type };
    
          next TYPE unless keys %$spec;
    
          $guts{prereqs}{$phase}{$type} = CPAN::Meta::Requirements->from_string_hash(
            $spec
          );
        }
      }
    
      return bless \%guts => $class;
    }
    
    
    sub requirements_for {
      my ($self, $phase, $type) = @_;
    
      confess "requirements_for called without phase" unless defined $phase;
      confess "requirements_for called without type"  unless defined $type;
    
      unless ($phase =~ /\Ax_/i or grep { $phase eq $_ } $self->__legal_phases) {
        confess "requested requirements for unknown phase: $phase";
      }
    
      unless ($type =~ /\Ax_/i or grep { $type eq $_ } $self->__legal_types) {
        confess "requested requirements for unknown type: $type";
      }
    
      my $req = ($self->{prereqs}{$phase}{$type} ||= CPAN::Meta::Requirements->new);
    
      $req->finalize if $self->is_finalized;
    
      return $req;
    }
    
    
    sub with_merged_prereqs {
      my ($self, $other) = @_;
    
      my @other = blessed($other) ? $other : @$other;
    
      my @prereq_objs = ($self, @other);
    
      my %new_arg;
    
      for my $phase ($self->__legal_phases) {
        for my $type ($self->__legal_types) {
          my $req = CPAN::Meta::Requirements->new;
    
          for my $prereq (@prereq_objs) {
            my $this_req = $prereq->requirements_for($phase, $type);
            next unless $this_req->required_modules;
    
            $req->add_requirements($this_req);
          }
    
          next unless $req->required_modules;
    
          $new_arg{ $phase }{ $type } = $req->as_string_hash;
        }
      }
    
      return (ref $self)->new(\%new_arg);
    }
    
    
    sub as_string_hash {
      my ($self) = @_;
    
      my %hash;
    
      for my $phase ($self->__legal_phases) {
        for my $type ($self->__legal_types) {
          my $req = $self->requirements_for($phase, $type);
          next unless $req->required_modules;
    
          $hash{ $phase }{ $type } = $req->as_string_hash;
        }
      }
    
      return \%hash;
    }
    
    
    sub is_finalized { $_[0]{finalized} }
    
    
    sub finalize {
      my ($self) = @_;
    
      $self->{finalized} = 1;
    
      for my $phase (keys %{ $self->{prereqs} }) {
        $_->finalize for values %{ $self->{prereqs}{$phase} };
      }
    }
    
    
    sub clone {
      my ($self) = @_;
    
      my $clone = (ref $self)->new( $self->as_string_hash );
    }
    
    1;
    
    # ABSTRACT: a set of distribution prerequisites by phase and type
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    CPAN::Meta::Prereqs - a set of distribution prerequisites by phase and type
    
    =head1 VERSION
    
    version 2.132510
    
    =head1 DESCRIPTION
    
    A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN
    distribution or one of its optional features.  Each set of prereqs is
    organized by phase and type, as described in L<CPAN::Meta::Prereqs>.
    
    =head1 METHODS
    
    =head2 new
    
      my $prereq = CPAN::Meta::Prereqs->new( \%prereq_spec );
    
    This method returns a new set of Prereqs.  The input should look like the
    contents of the C<prereqs> field described in L<CPAN::Meta::Spec>, meaning
    something more or less like this:
    
      my $prereq = CPAN::Meta::Prereqs->new({
        runtime => {
          requires => {
            'Some::Module' => '1.234',
            ...,
          },
          ...,
        },
        ...,
      });
    
    You can also construct an empty set of prereqs with:
    
      my $prereqs = CPAN::Meta::Prereqs->new;
    
    This empty set of prereqs is useful for accumulating new prereqs before finally
    dumping the whole set into a structure or string.
    
    =head2 requirements_for
    
      my $requirements = $prereqs->requirements_for( $phase, $type );
    
    This method returns a L<CPAN::Meta::Requirements> object for the given
    phase/type combination.  If no prerequisites are registered for that
    combination, a new CPAN::Meta::Requirements object will be returned, and it may
    be added to as needed.
    
    If C<$phase> or C<$type> are undefined or otherwise invalid, an exception will
    be raised.
    
    =head2 with_merged_prereqs
    
      my $new_prereqs = $prereqs->with_merged_prereqs( $other_prereqs );
    
      my $new_prereqs = $prereqs->with_merged_prereqs( \@other_prereqs );
    
    This method returns a new CPAN::Meta::Prereqs objects in which all the
    other prerequisites given are merged into the current set.  This is primarily
    provided for combining a distribution's core prereqs with the prereqs of one of
    its optional features.
    
    The new prereqs object has no ties to the originals, and altering it further
    will not alter them.
    
    =head2 as_string_hash
    
    This method returns a hashref containing structures suitable for dumping into a
    distmeta data structure.  It is made up of hashes and strings, only; there will
    be no Prereqs, CPAN::Meta::Requirements, or C<version> objects inside it.
    
    =head2 is_finalized
    
    This method returns true if the set of prereqs has been marked "finalized," and
    cannot be altered.
    
    =head2 finalize
    
    Calling C<finalize> on a Prereqs object will close it for further modification.
    Attempting to make any changes that would actually alter the prereqs will
    result in an exception being thrown.
    
    =head2 clone
    
      my $cloned_prereqs = $prereqs->clone;
    
    This method returns a Prereqs object that is identical to the original object,
    but can be altered without affecting the original object.  Finalization does
    not survive cloning, meaning that you may clone a finalized set of prereqs and
    then modify the clone.
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_PREREQS
  
  $fatpacked{"CPAN/Meta/Requirements.pm"} = <<'CPAN_META_REQUIREMENTS';
    use strict;
    use warnings;
    package CPAN::Meta::Requirements;
    our $VERSION = '2.123'; # VERSION
    # ABSTRACT: a set of version requirements for a CPAN dist
    
    
    use Carp ();
    use Scalar::Util ();
    use version 0.77 (); # the ->parse method
    
    
    my @valid_options = qw( bad_version_hook );
    
    sub new {
      my ($class, $options) = @_;
      $options ||= {};
      Carp::croak "Argument to $class\->new() must be a hash reference"
        unless ref $options eq 'HASH';
      my %self = map {; $_ => $options->{$_}} @valid_options;
    
      return bless \%self => $class;
    }
    
    sub _version_object {
      my ($self, $version) = @_;
    
      my $vobj;
    
      eval {
        $vobj  = (! defined $version)                ? version->parse(0)
               : (! Scalar::Util::blessed($version)) ? version->parse($version)
               :                                       $version;
      };
    
      if ( my $err = $@ ) {
        my $hook = $self->{bad_version_hook};
        $vobj = eval { $hook->($version) }
          if ref $hook eq 'CODE';
        unless (Scalar::Util::blessed($vobj) && $vobj->isa("version")) {
          $err =~ s{ at .* line \d+.*$}{};
          die "Can't convert '$version': $err";
        }
      }
    
      # ensure no leading '.'
      if ( $vobj =~ m{\A\.} ) {
        $vobj = version->parse("0$vobj");
      }
    
      # ensure normal v-string form
      if ( $vobj->is_qv ) {
        $vobj = version->parse($vobj->normal);
      }
    
      return $vobj;
    }
    
    
    BEGIN {
      for my $type (qw(minimum maximum exclusion exact_version)) {
        my $method = "with_$type";
        my $to_add = $type eq 'exact_version' ? $type : "add_$type";
    
        my $code = sub {
          my ($self, $name, $version) = @_;
    
          $version = $self->_version_object( $version );
    
          $self->__modify_entry_for($name, $method, $version);
    
          return $self;
        };
        
        no strict 'refs';
        *$to_add = $code;
      }
    }
    
    
    sub add_requirements {
      my ($self, $req) = @_;
    
      for my $module ($req->required_modules) {
        my $modifiers = $req->__entry_for($module)->as_modifiers;
        for my $modifier (@$modifiers) {
          my ($method, @args) = @$modifier;
          $self->$method($module => @args);
        };
      }
    
      return $self;
    }
    
    
    sub accepts_module {
      my ($self, $module, $version) = @_;
    
      $version = $self->_version_object( $version );
    
      return 1 unless my $range = $self->__entry_for($module);
      return $range->_accepts($version);
    }
    
    
    sub clear_requirement {
      my ($self, $module) = @_;
    
      return $self unless $self->__entry_for($module);
    
      Carp::confess("can't clear requirements on finalized requirements")
        if $self->is_finalized;
    
      delete $self->{requirements}{ $module };
    
      return $self;
    }
    
    
    sub requirements_for_module {
      my ($self, $module) = @_;
      my $entry = $self->__entry_for($module);
      return unless $entry;
      return $entry->as_string;
    }
    
    
    sub required_modules { keys %{ $_[0]{requirements} } }
    
    
    sub clone {
      my ($self) = @_;
      my $new = (ref $self)->new;
    
      return $new->add_requirements($self);
    }
    
    sub __entry_for     { $_[0]{requirements}{ $_[1] } }
    
    sub __modify_entry_for {
      my ($self, $name, $method, $version) = @_;
    
      my $fin = $self->is_finalized;
      my $old = $self->__entry_for($name);
    
      Carp::confess("can't add new requirements to finalized requirements")
        if $fin and not $old;
    
      my $new = ($old || 'CPAN::Meta::Requirements::_Range::Range')
              ->$method($version);
    
      Carp::confess("can't modify finalized requirements")
        if $fin and $old->as_string ne $new->as_string;
    
      $self->{requirements}{ $name } = $new;
    }
    
    
    sub is_simple {
      my ($self) = @_;
      for my $module ($self->required_modules) {
        # XXX: This is a complete hack, but also entirely correct.
        return if $self->__entry_for($module)->as_string =~ /\s/;
      }
    
      return 1;
    }
    
    
    sub is_finalized { $_[0]{finalized} }
    
    
    sub finalize { $_[0]{finalized} = 1 }
    
    
    sub as_string_hash {
      my ($self) = @_;
    
      my %hash = map {; $_ => $self->{requirements}{$_}->as_string }
                 $self->required_modules;
    
      return \%hash;
    }
    
    
    my %methods_for_op = (
      '==' => [ qw(exact_version) ],
      '!=' => [ qw(add_exclusion) ],
      '>=' => [ qw(add_minimum)   ],
      '<=' => [ qw(add_maximum)   ],
      '>'  => [ qw(add_minimum add_exclusion) ],
      '<'  => [ qw(add_maximum add_exclusion) ],
    );
    
    sub add_string_requirement {
      my ($self, $module, $req) = @_;
    
      Carp::confess("No requirement string provided for $module")
        unless defined $req && length $req;
    
      my @parts = split qr{\s*,\s*}, $req;
    
    
      for my $part (@parts) {
        my ($op, $ver) = $part =~ m{\A\s*(==|>=|>|<=|<|!=)\s*(.*)\z};
    
        if (! defined $op) {
          $self->add_minimum($module => $part);
        } else {
          Carp::confess("illegal requirement string: $req")
            unless my $methods = $methods_for_op{ $op };
    
          $self->$_($module => $ver) for @$methods;
        }
      }
    }
    
    
    sub from_string_hash {
      my ($class, $hash) = @_;
    
      my $self = $class->new;
    
      for my $module (keys %$hash) {
        my $req = $hash->{$module};
        unless ( defined $req && length $req ) {
          $req = 0;
          Carp::carp("Undefined requirement for $module treated as '0'");
        }
        $self->add_string_requirement($module, $req);
      }
    
      return $self;
    }
    
    ##############################################################
    
    {
      package
        CPAN::Meta::Requirements::_Range::Exact;
      sub _new     { bless { version => $_[1] } => $_[0] }
    
      sub _accepts { return $_[0]{version} == $_[1] }
    
      sub as_string { return "== $_[0]{version}" }
    
      sub as_modifiers { return [ [ exact_version => $_[0]{version} ] ] }
    
      sub _clone {
        (ref $_[0])->_new( version->new( $_[0]{version} ) )
      }
    
      sub with_exact_version {
        my ($self, $version) = @_;
    
        return $self->_clone if $self->_accepts($version);
    
        Carp::confess("illegal requirements: unequal exact version specified");
      }
    
      sub with_minimum {
        my ($self, $minimum) = @_;
        return $self->_clone if $self->{version} >= $minimum;
        Carp::confess("illegal requirements: minimum above exact specification");
      }
    
      sub with_maximum {
        my ($self, $maximum) = @_;
        return $self->_clone if $self->{version} <= $maximum;
        Carp::confess("illegal requirements: maximum below exact specification");
      }
    
      sub with_exclusion {
        my ($self, $exclusion) = @_;
        return $self->_clone unless $exclusion == $self->{version};
        Carp::confess("illegal requirements: excluded exact specification");
      }
    }
    
    ##############################################################
    
    {
      package
        CPAN::Meta::Requirements::_Range::Range;
    
      sub _self { ref($_[0]) ? $_[0] : (bless { } => $_[0]) }
    
      sub _clone {
        return (bless { } => $_[0]) unless ref $_[0];
    
        my ($s) = @_;
        my %guts = (
          (exists $s->{minimum} ? (minimum => version->new($s->{minimum})) : ()),
          (exists $s->{maximum} ? (maximum => version->new($s->{maximum})) : ()),
    
          (exists $s->{exclusions}
            ? (exclusions => [ map { version->new($_) } @{ $s->{exclusions} } ])
            : ()),
        );
    
        bless \%guts => ref($s);
      }
    
      sub as_modifiers {
        my ($self) = @_;
        my @mods;
        push @mods, [ add_minimum => $self->{minimum} ] if exists $self->{minimum};
        push @mods, [ add_maximum => $self->{maximum} ] if exists $self->{maximum};
        push @mods, map {; [ add_exclusion => $_ ] } @{$self->{exclusions} || []};
        return \@mods;
      }
    
      sub as_string {
        my ($self) = @_;
    
        return 0 if ! keys %$self;
    
        return "$self->{minimum}" if (keys %$self) == 1 and exists $self->{minimum};
    
        my @exclusions = @{ $self->{exclusions} || [] };
    
        my @parts;
    
        for my $pair (
          [ qw( >= > minimum ) ],
          [ qw( <= < maximum ) ],
        ) {
          my ($op, $e_op, $k) = @$pair;
          if (exists $self->{$k}) {
            my @new_exclusions = grep { $_ != $self->{ $k } } @exclusions;
            if (@new_exclusions == @exclusions) {
              push @parts, "$op $self->{ $k }";
            } else {
              push @parts, "$e_op $self->{ $k }";
              @exclusions = @new_exclusions;
            }
          }
        }
    
        push @parts, map {; "!= $_" } @exclusions;
    
        return join q{, }, @parts;
      }
    
      sub with_exact_version {
        my ($self, $version) = @_;
        $self = $self->_clone;
    
        Carp::confess("illegal requirements: exact specification outside of range")
          unless $self->_accepts($version);
    
        return CPAN::Meta::Requirements::_Range::Exact->_new($version);
      }
    
      sub _simplify {
        my ($self) = @_;
    
        if (defined $self->{minimum} and defined $self->{maximum}) {
          if ($self->{minimum} == $self->{maximum}) {
            Carp::confess("illegal requirements: excluded all values")
              if grep { $_ == $self->{minimum} } @{ $self->{exclusions} || [] };
    
            return CPAN::Meta::Requirements::_Range::Exact->_new($self->{minimum})
          }
    
          Carp::confess("illegal requirements: minimum exceeds maximum")
            if $self->{minimum} > $self->{maximum};
        }
    
        # eliminate irrelevant exclusions
        if ($self->{exclusions}) {
          my %seen;
          @{ $self->{exclusions} } = grep {
            (! defined $self->{minimum} or $_ >= $self->{minimum})
            and
            (! defined $self->{maximum} or $_ <= $self->{maximum})
            and
            ! $seen{$_}++
          } @{ $self->{exclusions} };
        }
    
        return $self;
      }
    
      sub with_minimum {
        my ($self, $minimum) = @_;
        $self = $self->_clone;
    
        if (defined (my $old_min = $self->{minimum})) {
          $self->{minimum} = (sort { $b cmp $a } ($minimum, $old_min))[0];
        } else {
          $self->{minimum} = $minimum;
        }
    
        return $self->_simplify;
      }
    
      sub with_maximum {
        my ($self, $maximum) = @_;
        $self = $self->_clone;
    
        if (defined (my $old_max = $self->{maximum})) {
          $self->{maximum} = (sort { $a cmp $b } ($maximum, $old_max))[0];
        } else {
          $self->{maximum} = $maximum;
        }
    
        return $self->_simplify;
      }
    
      sub with_exclusion {
        my ($self, $exclusion) = @_;
        $self = $self->_clone;
    
        push @{ $self->{exclusions} ||= [] }, $exclusion;
    
        return $self->_simplify;
      }
    
      sub _accepts {
        my ($self, $version) = @_;
    
        return if defined $self->{minimum} and $version < $self->{minimum};
        return if defined $self->{maximum} and $version > $self->{maximum};
        return if defined $self->{exclusions}
              and grep { $version == $_ } @{ $self->{exclusions} };
    
        return 1;
      }
    }
    
    1;
    # vim: ts=2 sts=2 sw=2 et:
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    CPAN::Meta::Requirements - a set of version requirements for a CPAN dist
    
    =head1 VERSION
    
    version 2.123
    
    =head1 SYNOPSIS
    
      use CPAN::Meta::Requirements;
    
      my $build_requires = CPAN::Meta::Requirements->new;
    
      $build_requires->add_minimum('Library::Foo' => 1.208);
    
      $build_requires->add_minimum('Library::Foo' => 2.602);
    
      $build_requires->add_minimum('Module::Bar'  => 'v1.2.3');
    
      $METAyml->{build_requires} = $build_requires->as_string_hash;
    
    =head1 DESCRIPTION
    
    A CPAN::Meta::Requirements object models a set of version constraints like
    those specified in the F<META.yml> or F<META.json> files in CPAN distributions.
    It can be built up by adding more and more constraints, and it will reduce them
    to the simplest representation.
    
    Logically impossible constraints will be identified immediately by thrown
    exceptions.
    
    =head1 METHODS
    
    =head2 new
    
      my $req = CPAN::Meta::Requirements->new;
    
    This returns a new CPAN::Meta::Requirements object.  It takes an optional
    hash reference argument.  The following keys are supported:
    
    =over 4
    
    =item *
    
    <bad_version_hook> -- if provided, when a version cannot be parsed into
    
    a version object, this code reference will be called with the invalid version
    string as an argument.  It must return a valid version object.
    
    =back
    
    All other keys are ignored.
    
    =head2 add_minimum
    
      $req->add_minimum( $module => $version );
    
    This adds a new minimum version requirement.  If the new requirement is
    redundant to the existing specification, this has no effect.
    
    Minimum requirements are inclusive.  C<$version> is required, along with any
    greater version number.
    
    This method returns the requirements object.
    
    =head2 add_maximum
    
      $req->add_maximum( $module => $version );
    
    This adds a new maximum version requirement.  If the new requirement is
    redundant to the existing specification, this has no effect.
    
    Maximum requirements are inclusive.  No version strictly greater than the given
    version is allowed.
    
    This method returns the requirements object.
    
    =head2 add_exclusion
    
      $req->add_exclusion( $module => $version );
    
    This adds a new excluded version.  For example, you might use these three
    method calls:
    
      $req->add_minimum( $module => '1.00' );
      $req->add_maximum( $module => '1.82' );
    
      $req->add_exclusion( $module => '1.75' );
    
    Any version between 1.00 and 1.82 inclusive would be acceptable, except for
    1.75.
    
    This method returns the requirements object.
    
    =head2 exact_version
    
      $req->exact_version( $module => $version );
    
    This sets the version required for the given module to I<exactly> the given
    version.  No other version would be considered acceptable.
    
    This method returns the requirements object.
    
    =head2 add_requirements
    
      $req->add_requirements( $another_req_object );
    
    This method adds all the requirements in the given CPAN::Meta::Requirements object
    to the requirements object on which it was called.  If there are any conflicts,
    an exception is thrown.
    
    This method returns the requirements object.
    
    =head2 accepts_module
    
      my $bool = $req->accepts_modules($module => $version);
    
    Given an module and version, this method returns true if the version
    specification for the module accepts the provided version.  In other words,
    given:
    
      Module => '>= 1.00, < 2.00'
    
    We will accept 1.00 and 1.75 but not 0.50 or 2.00.
    
    For modules that do not appear in the requirements, this method will return
    true.
    
    =head2 clear_requirement
    
      $req->clear_requirement( $module );
    
    This removes the requirement for a given module from the object.
    
    This method returns the requirements object.
    
    =head2 requirements_for_module
    
      $req->requirements_for_module( $module );
    
    This returns a string containing the version requirements for a given module in
    the format described in L<CPAN::Meta::Spec> or undef if the given module has no
    requirements. This should only be used for informational purposes such as error
    messages and should not be interpreted or used for comparison (see
    L</accepts_module> instead.)
    
    =head2 required_modules
    
    This method returns a list of all the modules for which requirements have been
    specified.
    
    =head2 clone
    
      $req->clone;
    
    This method returns a clone of the invocant.  The clone and the original object
    can then be changed independent of one another.
    
    =head2 is_simple
    
    This method returns true if and only if all requirements are inclusive minimums
    -- that is, if their string expression is just the version number.
    
    =head2 is_finalized
    
    This method returns true if the requirements have been finalized by having the
    C<finalize> method called on them.
    
    =head2 finalize
    
    This method marks the requirements finalized.  Subsequent attempts to change
    the requirements will be fatal, I<if> they would result in a change.  If they
    would not alter the requirements, they have no effect.
    
    If a finalized set of requirements is cloned, the cloned requirements are not
    also finalized.
    
    =head2 as_string_hash
    
    This returns a reference to a hash describing the requirements using the
    strings in the F<META.yml> specification.
    
    For example after the following program:
    
      my $req = CPAN::Meta::Requirements->new;
    
      $req->add_minimum('CPAN::Meta::Requirements' => 0.102);
    
      $req->add_minimum('Library::Foo' => 1.208);
    
      $req->add_maximum('Library::Foo' => 2.602);
    
      $req->add_minimum('Module::Bar'  => 'v1.2.3');
    
      $req->add_exclusion('Module::Bar'  => 'v1.2.8');
    
      $req->exact_version('Xyzzy'  => '6.01');
    
      my $hashref = $req->as_string_hash;
    
    C<$hashref> would contain:
    
      {
        'CPAN::Meta::Requirements' => '0.102',
        'Library::Foo' => '>= 1.208, <= 2.206',
        'Module::Bar'  => '>= v1.2.3, != v1.2.8',
        'Xyzzy'        => '== 6.01',
      }
    
    =head2 add_string_requirement
    
      $req->add_string_requirement('Library::Foo' => '>= 1.208, <= 2.206');
    
    This method parses the passed in string and adds the appropriate requirement
    for the given module.  It understands version ranges as described in the
    L<CPAN::Meta::Spec/Version Ranges>. For example:
    
    =over 4
    
    =item 1.3
    
    =item >= 1.3
    
    =item <= 1.3
    
    =item == 1.3
    
    =item != 1.3
    
    =item > 1.3
    
    =item < 1.3
    
    =item >= 1.3, != 1.5, <= 2.0
    
    A version number without an operator is equivalent to specifying a minimum
    (C<E<gt>=>).  Extra whitespace is allowed.
    
    =back
    
    =head2 from_string_hash
    
      my $req = CPAN::Meta::Requirements->from_string_hash( \%hash );
    
    This is an alternate constructor for a CPAN::Meta::Requirements object.  It takes
    a hash of module names and version requirement strings and returns a new
    CPAN::Meta::Requirements object.
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<https://rt.cpan.org/Public/Dist/Display.html?Name=CPAN-Meta-Requirements>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/dagolden/cpan-meta-requirements>
    
      git clone git://github.com/dagolden/cpan-meta-requirements.git
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_REQUIREMENTS
  
  $fatpacked{"CPAN/Meta/Spec.pm"} = <<'CPAN_META_SPEC';
    # XXX RULES FOR PATCHING THIS FILE XXX
    # Patches that fix typos or formatting are acceptable.  Patches
    # that change semantics are not acceptable without prior approval
    # by David Golden or Ricardo Signes.
    
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Spec;
    our $VERSION = '2.132510'; # VERSION
    
    1;
    
    # ABSTRACT: specification for CPAN distribution metadata
    
    
    # vi:tw=72
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    CPAN::Meta::Spec - specification for CPAN distribution metadata
    
    =head1 VERSION
    
    version 2.132510
    
    =head1 SYNOPSIS
    
      my $distmeta = {
        name => 'Module-Build',
        abstract => 'Build and install Perl modules',
        description =>  "Module::Build is a system for "
          . "building, testing, and installing Perl modules. "
          . "It is meant to ... blah blah blah ...",
        version  => '0.36',
        release_status => 'stable',
        author   => [
          'Ken Williams <kwilliams@cpan.org>',
          'Module-Build List <module-build@perl.org>', # additional contact
        ],
        license  => [ 'perl_5' ],
        prereqs => {
          runtime => {
            requires => {
              'perl'   => '5.006',
              'ExtUtils::Install' => '0',
              'File::Basename' => '0',
              'File::Compare'  => '0',
              'IO::File'   => '0',
            },
            recommends => {
              'Archive::Tar' => '1.00',
              'ExtUtils::Install' => '0.3',
              'ExtUtils::ParseXS' => '2.02',
            },
          },
          build => {
            requires => {
              'Test::More' => '0',
            },
          }
        },
        resources => {
          license => ['http://dev.perl.org/licenses/'],
        },
        optional_features => {
          domination => {
            description => 'Take over the world',
            prereqs     => {
              develop => { requires => { 'Genius::Evil'     => '1.234' } },
              runtime => { requires => { 'Machine::Weather' => '2.0'   } },
            },
          },
        },
        dynamic_config => 1,
        keywords => [ qw/ toolchain cpan dual-life / ],
        'meta-spec' => {
          version => '2',
          url     => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
        },
        generated_by => 'Module::Build version 0.36',
      };
    
    =head1 DESCRIPTION
    
    This document describes version 2 of the CPAN distribution metadata
    specification, also known as the "CPAN Meta Spec".
    
    Revisions of this specification for typo corrections and prose
    clarifications may be issued as CPAN::Meta::Spec 2.I<x>.  These
    revisions will never change semantics or add or remove specified
    behavior.
    
    Distribution metadata describe important properties of Perl
    distributions. Distribution building tools like Module::Build,
    Module::Install, ExtUtils::MakeMaker or Dist::Zilla should create a
    metadata file in accordance with this specification and include it with
    the distribution for use by automated tools that index, examine, package
    or install Perl distributions.
    
    =head1 TERMINOLOGY
    
    =over 4
    
    =item distribution
    
    This is the primary object described by the metadata. In the context of
    this document it usually refers to a collection of modules, scripts,
    and/or documents that are distributed together for other developers to
    use.  Examples of distributions are C<Class-Container>, C<libwww-perl>,
    or C<DBI>.
    
    =item module
    
    This refers to a reusable library of code contained in a single file.
    Modules usually contain one or more packages and are often referred
    to by the name of a primary package that can be mapped to the file
    name. For example, one might refer to C<File::Spec> instead of
    F<File/Spec.pm>
    
    =item package
    
    This refers to a namespace declared with the Perl C<package> statement.
    In Perl, packages often have a version number property given by the
    C<$VERSION> variable in the namespace.
    
    =item consumer
    
    This refers to code that reads a metadata file, deserializes it into a
    data structure in memory, or interprets a data structure of metadata
    elements.
    
    =item producer
    
    This refers to code that constructs a metadata data structure,
    serializes into a bytestream and/or writes it to disk.
    
    =item must, should, may, etc.
    
    These terms are interpreted as described in IETF RFC 2119.
    
    =back
    
    =head1 DATA TYPES
    
    Fields in the L</STRUCTURE> section describe data elements, each of
    which has an associated data type as described herein.  There are four
    primitive types: Boolean, String, List and Map.  Other types are
    subtypes of primitives and define compound data structures or define
    constraints on the values of a data element.
    
    =head2 Boolean
    
    A I<Boolean> is used to provide a true or false value.  It B<must> be
    represented as a defined value.
    
    =head2 String
    
    A I<String> is data element containing a non-zero length sequence of
    Unicode characters, such as an ordinary Perl scalar that is not a
    reference.
    
    =head2 List
    
    A I<List> is an ordered collection of zero or more data elements.
    Elements of a List may be of mixed types.
    
    Producers B<must> represent List elements using a data structure which
    unambiguously indicates that multiple values are possible, such as a
    reference to a Perl array (an "arrayref").
    
    Consumers expecting a List B<must> consider a String as equivalent to a
    List of length 1.
    
    =head2 Map
    
    A I<Map> is an unordered collection of zero or more data elements
    ("values"), indexed by associated String elements ("keys").  The Map's
    value elements may be of mixed types.
    
    =head2 License String
    
    A I<License String> is a subtype of String with a restricted set of
    values.  Valid values are described in detail in the description of
    the L</license> field.
    
    =head2 URL
    
    I<URL> is a subtype of String containing a Uniform Resource Locator or
    Identifier.  [ This type is called URL and not URI for historical reasons. ]
    
    =head2 Version
    
    A I<Version> is a subtype of String containing a value that describes
    the version number of packages or distributions.  Restrictions on format
    are described in detail in the L</Version Formats> section.
    
    =head2 Version Range
    
    The I<Version Range> type is a subtype of String.  It describes a range
    of Versions that may be present or installed to fulfill prerequisites.
    It is specified in detail in the L</Version Ranges> section.
    
    =head1 STRUCTURE
    
    The metadata structure is a data element of type Map.  This section
    describes valid keys within the Map.
    
    Any keys not described in this specification document (whether top-level
    or within compound data structures described herein) are considered
    I<custom keys> and B<must> begin with an "x" or "X" and be followed by an
    underscore; i.e. they must match the pattern: C<< qr{\Ax_}i >>.  If a
    custom key refers to a compound data structure, subkeys within it do not
    need an "x_" or "X_" prefix.
    
    Consumers of metadata may ignore any or all custom keys.  All other keys
    not described herein are invalid and should be ignored by consumers.
    Producers must not generate or output invalid keys.
    
    For each key, an example is provided followed by a description.  The
    description begins with the version of spec in which the key was added
    or in which the definition was modified, whether the key is I<required>
    or I<optional> and the data type of the corresponding data element.
    These items are in parentheses, brackets and braces, respectively.
    
    If a data type is a Map or Map subtype, valid subkeys will be described
    as well.
    
    Some fields are marked I<Deprecated>.  These are shown for historical
    context and must not be produced in or consumed from any metadata structure
    of version 2 or higher.
    
    =head2 REQUIRED FIELDS
    
    =head3 abstract
    
    Example:
    
      abstract => 'Build and install Perl modules'
    
    (Spec 1.2) [required] {String}
    
    This is a short description of the purpose of the distribution.
    
    =head3 author
    
    Example:
    
      author => [ 'Ken Williams <kwilliams@cpan.org>' ]
    
    (Spec 1.2) [required] {List of one or more Strings}
    
    This List indicates the person(s) to contact concerning the
    distribution. The preferred form of the contact string is:
    
      contact-name <email-address>
    
    This field provides a general contact list independent of other
    structured fields provided within the L</resources> field, such as
    C<bugtracker>.  The addressee(s) can be contacted for any purpose
    including but not limited to (security) problems with the distribution,
    questions about the distribution or bugs in the distribution.
    
    A distribution's original author is usually the contact listed within
    this field.  Co-maintainers, successor maintainers or mailing lists
    devoted to the distribution may also be listed in addition to or instead
    of the original author.
    
    =head3 dynamic_config
    
    Example:
    
      dynamic_config => 1
    
    (Spec 2) [required] {Boolean}
    
    A boolean flag indicating whether a F<Build.PL> or F<Makefile.PL> (or
    similar) must be executed to determine prerequisites.
    
    This field should be set to a true value if the distribution performs
    some dynamic configuration (asking questions, sensing the environment,
    etc.) as part of its configuration.  This field should be set to a false
    value to indicate that prerequisites included in metadata may be
    considered final and valid for static analysis.
    
    This field explicitly B<does not> indicate whether installation may be
    safely performed without using a Makefile or Build file, as there may be
    special files to install or custom installation targets (e.g. for
    dual-life modules that exist on CPAN as well as in the Perl core).  This
    field only defines whether prerequisites are complete as given in the
    metadata.
    
    =head3 generated_by
    
    Example:
    
      generated_by => 'Module::Build version 0.36'
    
    (Spec 1.0) [required] {String}
    
    This field indicates the tool that was used to create this metadata.
    There are no defined semantics for this field, but it is traditional to
    use a string in the form "Generating::Package version 1.23" or the
    author's name, if the file was generated by hand.
    
    =head3 license
    
    Example:
    
      license => [ 'perl_5' ]
    
      license => [ 'apache_2', 'mozilla_1_0' ]
    
    (Spec 2) [required] {List of one or more License Strings}
    
    One or more licenses that apply to some or all of the files in the
    distribution.  If multiple licenses are listed, the distribution
    documentation should be consulted to clarify the interpretation of
    multiple licenses.
    
    The following list of license strings are valid:
    
     string          description
     -------------   -----------------------------------------------
     agpl_3          GNU Affero General Public License, Version 3
     apache_1_1      Apache Software License, Version 1.1
     apache_2_0      Apache License, Version 2.0
     artistic_1      Artistic License, (Version 1)
     artistic_2      Artistic License, Version 2.0
     bsd             BSD License (three-clause)
     freebsd         FreeBSD License (two-clause)
     gfdl_1_2        GNU Free Documentation License, Version 1.2
     gfdl_1_3        GNU Free Documentation License, Version 1.3
     gpl_1           GNU General Public License, Version 1
     gpl_2           GNU General Public License, Version 2
     gpl_3           GNU General Public License, Version 3
     lgpl_2_1        GNU Lesser General Public License, Version 2.1
     lgpl_3_0        GNU Lesser General Public License, Version 3.0
     mit             MIT (aka X11) License
     mozilla_1_0     Mozilla Public License, Version 1.0
     mozilla_1_1     Mozilla Public License, Version 1.1
     openssl         OpenSSL License
     perl_5          The Perl 5 License (Artistic 1 & GPL 1 or later)
     qpl_1_0         Q Public License, Version 1.0
     ssleay          Original SSLeay License
     sun             Sun Internet Standards Source License (SISSL)
     zlib            zlib License
    
    The following license strings are also valid and indicate other
    licensing not described above:
    
     string          description
     -------------   -----------------------------------------------
     open_source     Other Open Source Initiative (OSI) approved license
     restricted      Requires special permission from copyright holder
     unrestricted    Not an OSI approved license, but not restricted
     unknown         License not provided in metadata
    
    All other strings are invalid in the license field.
    
    =head3 meta-spec
    
    Example:
    
      'meta-spec' => {
        version => '2',
        url     => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
      }
    
    (Spec 1.2) [required] {Map}
    
    This field indicates the version of the CPAN Meta Spec that should be
    used to interpret the metadata.  Consumers must check this key as soon
    as possible and abort further metadata processing if the meta-spec
    version is not supported by the consumer.
    
    The following keys are valid, but only C<version> is required.
    
    =over
    
    =item version
    
    This subkey gives the integer I<Version> of the CPAN Meta Spec against
    which the document was generated.
    
    =item url
    
    This is a I<URL> of the metadata specification document corresponding to
    the given version.  This is strictly for human-consumption and should
    not impact the interpretation of the document.
    
    =back
    
    =head3 name
    
    Example:
    
      name => 'Module-Build'
    
    (Spec 1.0) [required] {String}
    
    This field is the name of the distribution.  This is often created by
    taking the "main package" in the distribution and changing C<::> to
    C<->, but the name may be completely unrelated to the packages within
    the distribution.  C.f. L<http://search.cpan.org/dist/libwww-perl/>.
    
    =head3 release_status
    
    Example:
    
      release_status => 'stable'
    
    (Spec 2) [required] {String}
    
    This field provides the  release status of this distribution.  If the
    C<version> field contains an underscore character, then
    C<release_status> B<must not> be "stable."
    
    The C<release_status> field B<must> have one of the following values:
    
    =over
    
    =item stable
    
    This indicates an ordinary, "final" release that should be indexed by PAUSE
    or other indexers.
    
    =item testing
    
    This indicates a "beta" release that is substantially complete, but has an
    elevated risk of bugs and requires additional testing.  The distribution
    should not be installed over a stable release without an explicit request
    or other confirmation from a user.  This release status may also be used
    for "release candidate" versions of a distribution.
    
    =item unstable
    
    This indicates an "alpha" release that is under active development, but has
    been released for early feedback or testing and may be missing features or
    may have serious bugs.  The distribution should not be installed over a
    stable release without an explicit request or other confirmation from a
    user.
    
    =back
    
    Consumers B<may> use this field to determine how to index the
    distribution for CPAN or other repositories in addition to or in
    replacement of heuristics based on version number or file name.
    
    =head3 version
    
    Example:
    
      version => '0.36'
    
    (Spec 1.0) [required] {Version}
    
    This field gives the version of the distribution to which the metadata
    structure refers.
    
    =head2 OPTIONAL FIELDS
    
    =head3 description
    
    Example:
    
        description =>  "Module::Build is a system for "
          . "building, testing, and installing Perl modules. "
          . "It is meant to ... blah blah blah ...",
    
    (Spec 2) [optional] {String}
    
    A longer, more complete description of the purpose or intended use of
    the distribution than the one provided by the C<abstract> key.
    
    =head3 keywords
    
    Example:
    
      keywords => [ qw/ toolchain cpan dual-life / ]
    
    (Spec 1.1) [optional] {List of zero or more Strings}
    
    A List of keywords that describe this distribution.  Keywords
    B<must not> include whitespace.
    
    =head3 no_index
    
    Example:
    
      no_index => {
        file      => [ 'My/Module.pm' ],
        directory => [ 'My/Private' ],
        package   => [ 'My::Module::Secret' ],
        namespace => [ 'My::Module::Sample' ],
      }
    
    (Spec 1.2) [optional] {Map}
    
    This Map describes any files, directories, packages, and namespaces that
    are private to the packaging or implementation of the distribution and
    should be ignored by indexing or search tools.
    
    Valid subkeys are as follows:
    
    =over
    
    =item file
    
    A I<List> of relative paths to files.  Paths B<must be> specified with
    unix conventions.
    
    =item directory
    
    A I<List> of relative paths to directories.  Paths B<must be> specified
    with unix conventions.
    
    [ Note: previous editions of the spec had C<dir> instead of C<directory> ]
    
    =item package
    
    A I<List> of package names.
    
    =item namespace
    
    A I<List> of package namespaces, where anything below the namespace
    must be ignored, but I<not> the namespace itself.
    
    In the example above for C<no_index>, C<My::Module::Sample::Foo> would
    be ignored, but C<My::Module::Sample> would not.
    
    =back
    
    =head3 optional_features
    
    Example:
    
      optional_features => {
        sqlite => {
          description => 'Provides SQLite support',
          prereqs => {
            runtime => {
              requires => {
                'DBD::SQLite' => '1.25'
              }
            }
          }
        }
      }
    
    (Spec 2) [optional] {Map}
    
    This Map describes optional features with incremental prerequisites.
    Each key of the C<optional_features> Map is a String used to identify
    the feature and each value is a Map with additional information about
    the feature.  Valid subkeys include:
    
    =over
    
    =item description
    
    This is a String describing the feature.  Every optional feature
    should provide a description
    
    =item prereqs
    
    This entry is required and has the same structure as that of the
    C<L</prereqs>> key.  It provides a list of package requirements
    that must be satisfied for the feature to be supported or enabled.
    
    There is one crucial restriction:  the prereqs of an optional feature
    B<must not> include C<configure> phase prereqs.
    
    =back
    
    Consumers B<must not> include optional features as prerequisites without
    explicit instruction from users (whether via interactive prompting,
    a function parameter or a configuration value, etc. ).
    
    If an optional feature is used by a consumer to add additional
    prerequisites, the consumer should merge the optional feature
    prerequisites into those given by the C<prereqs> key using the same
    semantics.  See L</Merging and Resolving Prerequisites> for details on
    merging prerequisites.
    
    I<Suggestion for disuse:> Because there is currently no way for a
    distribution to specify a dependency on an optional feature of another
    dependency, the use of C<optional_feature> is discouraged.  Instead,
    create a separate, installable distribution that ensures the desired
    feature is available.  For example, if C<Foo::Bar> has a C<Baz> feature,
    release a separate C<Foo-Bar-Baz> distribution that satisfies
    requirements for the feature.
    
    =head3 prereqs
    
    Example:
    
      prereqs => {
        runtime => {
          requires => {
            'perl'          => '5.006',
            'File::Spec'    => '0.86',
            'JSON'          => '2.16',
          },
          recommends => {
            'JSON::XS'      => '2.26',
          },
          suggests => {
            'Archive::Tar'  => '0',
          },
        },
        build => {
          requires => {
            'Alien::SDL'    => '1.00',
          },
        },
        test => {
          recommends => {
            'Test::Deep'    => '0.10',
          },
        }
      }
    
    (Spec 2) [optional] {Map}
    
    This is a Map that describes all the prerequisites of the distribution.
    The keys are phases of activity, such as C<configure>, C<build>, C<test>
    or C<runtime>.  Values are Maps in which the keys name the type of
    prerequisite relationship such as C<requires>, C<recommends>, or
    C<suggests> and the value provides a set of prerequisite relations.  The
    set of relations B<must> be specified as a Map of package names to
    version ranges.
    
    The full definition for this field is given in the L</Prereq Spec>
    section.
    
    =head3 provides
    
    Example:
    
      provides => {
        'Foo::Bar' => {
          file    => 'lib/Foo/Bar.pm',
          version => '0.27_02',
        },
        'Foo::Bar::Blah' => {
          file    => 'lib/Foo/Bar/Blah.pm',
        },
        'Foo::Bar::Baz' => {
          file    => 'lib/Foo/Bar/Baz.pm',
          version => '0.3',
        },
      }
    
    (Spec 1.2) [optional] {Map}
    
    This describes all packages provided by this distribution.  This
    information is used by distribution and automation mechanisms like
    PAUSE, CPAN, and search.cpan.org to build indexes saying in which
    distribution various packages can be found.
    
    The keys of C<provides> are package names that can be found within
    the distribution.  If a package name key is provided, it must
    have a Map with the following valid subkeys:
    
    =over
    
    =item file
    
    This field is required.  It must contain a Unix-style relative file path
    from the root of the distribution directory to a file that contains or
    generates the package.
    
    =item version
    
    If it exists, this field must contains a I<Version> String for the
    package.  If the package does not have a C<$VERSION>, this field must
    be omitted.
    
    =back
    
    =head3 resources
    
    Example:
    
      resources => {
        license     => [ 'http://dev.perl.org/licenses/' ],
        homepage    => 'http://sourceforge.net/projects/module-build',
        bugtracker  => {
          web    => 'http://rt.cpan.org/Public/Dist/Display.html?Name=CPAN-Meta',
          mailto => 'meta-bugs@example.com',
        },
        repository  => {
          url  => 'git://github.com/dagolden/cpan-meta.git',
          web  => 'http://github.com/dagolden/cpan-meta',
          type => 'git',
        },
        x_twitter   => 'http://twitter.com/cpan_linked/',
      }
    
    (Spec 2) [optional] {Map}
    
    This field describes resources related to this distribution.
    
    Valid subkeys include:
    
    =over
    
    =item homepage
    
    The official home of this project on the web.
    
    =item license
    
    A List of I<URL>'s that relate to this distribution's license.  As with the
    top-level C<license> field, distribution documentation should be consulted
    to clarify the interpretation of multiple licenses provided here.
    
    =item bugtracker
    
    This entry describes the bug tracking system for this distribution.  It
    is a Map with the following valid keys:
    
      web    - a URL pointing to a web front-end for the bug tracker
      mailto - an email address to which bugs can be sent
    
    =item repository
    
    This entry describes the source control repository for this distribution.  It
    is a Map with the following valid keys:
    
      url  - a URL pointing to the repository itself
      web  - a URL pointing to a web front-end for the repository
      type - a lowercase string indicating the VCS used
    
    Because a url like C<http://myrepo.example.com/> is ambiguous as to
    type, producers should provide a C<type> whenever a C<url> key is given.
    The C<type> field should be the name of the most common program used
    to work with the repository, e.g. C<git>, C<svn>, C<cvs>, C<darcs>,
    C<bzr> or C<hg>.
    
    =back
    
    =head2 DEPRECATED FIELDS
    
    =head3 build_requires
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head3 configure_requires
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head3 conflicts
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head3 distribution_type
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    This field indicated 'module' or 'script' but was considered
    meaningless, since many distributions are hybrids of several kinds of
    things.
    
    =head3 license_uri
    
    I<(Deprecated in Spec 1.2)> [optional] {URL}
    
    Replaced by C<license> in C<resources>
    
    =head3 private
    
    I<(Deprecated in Spec 1.2)> [optional] {Map}
    
    This field has been renamed to L</"no_index">.
    
    =head3 recommends
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head3 requires
    
    I<(Deprecated in Spec 2)> [optional] {String}
    
    Replaced by C<prereqs>
    
    =head1 VERSION NUMBERS
    
    =head2 Version Formats
    
    This section defines the Version type, used by several fields in the
    CPAN Meta Spec.
    
    Version numbers must be treated as strings, not numbers.  For
    example, C<1.200> B<must not> be serialized as C<1.2>.  Version
    comparison should be delegated to the Perl L<version> module, version
    0.80 or newer.
    
    Unless otherwise specified, version numbers B<must> appear in one of two
    formats:
    
    =over
    
    =item Decimal versions
    
    Decimal versions are regular "decimal numbers", with some limitations.
    They B<must> be non-negative and B<must> begin and end with a digit.  A
    single underscore B<may> be included, but B<must> be between two digits.
    They B<must not> use exponential notation ("1.23e-2").
    
       version => '1.234'       # OK
       version => '1.23_04'     # OK
    
       version => '1.23_04_05'  # Illegal
       version => '1.'          # Illegal
       version => '.1'          # Illegal
    
    =item Dotted-integer versions
    
    Dotted-integer (also known as dotted-decimal) versions consist of
    positive integers separated by full stop characters (i.e. "dots",
    "periods" or "decimal points").  This are equivalent in format to Perl
    "v-strings", with some additional restrictions on form.  They must be
    given in "normal" form, which has a leading "v" character and at least
    three integer components.  To retain a one-to-one mapping with decimal
    versions, all components after the first B<should> be restricted to the
    range 0 to 999.  The final component B<may> be separated by an
    underscore character instead of a period.
    
       version => 'v1.2.3'      # OK
       version => 'v1.2_3'      # OK
       version => 'v1.2.3.4'    # OK
       version => 'v1.2.3_4'    # OK
       version => 'v2009.10.31' # OK
    
       version => 'v1.2'          # Illegal
       version => '1.2.3'         # Illegal
       version => 'v1.2_3_4'      # Illegal
       version => 'v1.2009.10.31' # Not recommended
    
    =back
    
    =head2 Version Ranges
    
    Some fields (prereq, optional_features) indicate the particular
    version(s) of some other module that may be required as a prerequisite.
    This section details the Version Range type used to provide this
    information.
    
    The simplest format for a Version Range is just the version
    number itself, e.g. C<2.4>.  This means that B<at least> version 2.4
    must be present.  To indicate that B<any> version of a prerequisite is
    okay, even if the prerequisite doesn't define a version at all, use
    the version C<0>.
    
    Alternatively, a version range B<may> use the operators E<lt> (less than),
    E<lt>= (less than or equal), E<gt> (greater than), E<gt>= (greater than
    or equal), == (equal), and != (not equal).  For example, the
    specification C<E<lt> 2.0> means that any version of the prerequisite
    less than 2.0 is suitable.
    
    For more complicated situations, version specifications B<may> be AND-ed
    together using commas.  The specification C<E<gt>= 1.2, != 1.5, E<lt>
    2.0> indicates a version that must be B<at least> 1.2, B<less than> 2.0,
    and B<not equal to> 1.5.
    
    =head1 PREREQUISITES
    
    =head2 Prereq Spec
    
    The C<prereqs> key in the top-level metadata and within
    C<optional_features> define the relationship between a distribution and
    other packages.  The prereq spec structure is a hierarchical data
    structure which divides prerequisites into I<Phases> of activity in the
    installation process and I<Relationships> that indicate how
    prerequisites should be resolved.
    
    For example, to specify that C<Data::Dumper> is C<required> during the
    C<test> phase, this entry would appear in the distribution metadata:
    
      prereqs => {
        test => {
          requires => {
            'Data::Dumper' => '2.00'
          }
        }
      }
    
    =head3 Phases
    
    Requirements for regular use must be listed in the C<runtime> phase.
    Other requirements should be listed in the earliest stage in which they
    are required and consumers must accumulate and satisfy requirements
    across phases before executing the activity. For example, C<build>
    requirements must also be available during the C<test> phase.
    
      before action       requirements that must be met
      ----------------    --------------------------------
      perl Build.PL       configure
      perl Makefile.PL
    
      make                configure, runtime, build
      Build
    
      make test           configure, runtime, build, test
      Build test
    
    Consumers that install the distribution must ensure that
    I<runtime> requirements are also installed and may install
    dependencies from other phases.
    
      after action        requirements that must be met
      ----------------    --------------------------------
      make install        runtime
      Build install
    
    =over
    
    =item configure
    
    The configure phase occurs before any dynamic configuration has been
    attempted.  Libraries required by the configure phase B<must> be
    available for use before the distribution building tool has been
    executed.
    
    =item build
    
    The build phase is when the distribution's source code is compiled (if
    necessary) and otherwise made ready for installation.
    
    =item test
    
    The test phase is when the distribution's automated test suite is run.
    Any library that is needed only for testing and not for subsequent use
    should be listed here.
    
    =item runtime
    
    The runtime phase refers not only to when the distribution's contents
    are installed, but also to its continued use.  Any library that is a
    prerequisite for regular use of this distribution should be indicated
    here.
    
    =item develop
    
    The develop phase's prereqs are libraries needed to work on the
    distribution's source code as its author does.  These tools might be
    needed to build a release tarball, to run author-only tests, or to
    perform other tasks related to developing new versions of the
    distribution.
    
    =back
    
    =head3 Relationships
    
    =over
    
    =item requires
    
    These dependencies B<must> be installed for proper completion of the
    phase.
    
    =item recommends
    
    Recommended dependencies are I<strongly> encouraged and should be
    satisfied except in resource constrained environments.
    
    =item suggests
    
    These dependencies are optional, but are suggested for enhanced operation
    of the described distribution.
    
    =item conflicts
    
    These libraries cannot be installed when the phase is in operation.
    This is a very rare situation, and the C<conflicts> relationship should
    be used with great caution, or not at all.
    
    =back
    
    =head2 Merging and Resolving Prerequisites
    
    Whenever metadata consumers merge prerequisites, either from different
    phases or from C<optional_features>, they should merged in a way which
    preserves the intended semantics of the prerequisite structure.  Generally,
    this means concatenating the version specifications using commas, as
    described in the L<Version Ranges> section.
    
    Another subtle error that can occur in resolving prerequisites comes from
    the way that modules in prerequisites are indexed to distribution files on
    CPAN.  When a module is deleted from a distribution, prerequisites calling
    for that module could indicate an older distribution should be installed,
    potentially overwriting files from a newer distribution.
    
    For example, as of Oct 31, 2009, the CPAN index file contained these
    module-distribution mappings:
    
      Class::MOP                   0.94  D/DR/DROLSKY/Class-MOP-0.94.tar.gz
      Class::MOP::Class            0.94  D/DR/DROLSKY/Class-MOP-0.94.tar.gz
      Class::MOP::Class::Immutable 0.04  S/ST/STEVAN/Class-MOP-0.36.tar.gz
    
    Consider the case where "Class::MOP" 0.94 is installed.  If a
    distribution specified "Class::MOP::Class::Immutable" as a prerequisite,
    it could result in Class-MOP-0.36.tar.gz being installed, overwriting
    any files from Class-MOP-0.94.tar.gz.
    
    Consumers of metadata B<should> test whether prerequisites would result
    in installed module files being "downgraded" to an older version and
    B<may> warn users or ignore the prerequisite that would cause such a
    result.
    
    =head1 SERIALIZATION
    
    Distribution metadata should be serialized (as a hashref) as
    JSON-encoded data and packaged with distributions as the file
    F<META.json>.
    
    In the past, the distribution metadata structure had been packed with
    distributions as F<META.yml>, a file in the YAML Tiny format (for which,
    see L<YAML::Tiny>).  Tools that consume distribution metadata from disk
    should be capable of loading F<META.yml>, but should prefer F<META.json>
    if both are found.
    
    =head1 NOTES FOR IMPLEMENTORS
    
    =head2 Extracting Version Numbers from Perl Modules
    
    To get the version number from a Perl module, consumers should use the
    C<< MM->parse_version($file) >> method provided by
    L<ExtUtils::MakeMaker> or L<Module::Metadata>.  For example, for the
    module given by C<$mod>, the version may be retrieved in one of the
    following ways:
    
      # via ExtUtils::MakeMaker
      my $file = MM->_installed_file_for_module($mod);
      my $version = MM->parse_version($file)
    
    The private C<_installed_file_for_module> method may be replaced with
    other methods for locating a module in C<@INC>.
    
      # via Module::Metadata
      my $info = Module::Metadata->new_from_module($mod);
      my $version = $info->version;
    
    If only a filename is available, the following approach may be used:
    
      # via Module::Build
      my $info = Module::Metadata->new_from_file($file);
      my $version = $info->version;
    
    =head2 Comparing Version Numbers
    
    The L<version> module provides the most reliable way to compare version
    numbers in all the various ways they might be provided or might exist
    within modules.  Given two strings containing version numbers, C<$v1> and
    C<$v2>, they should be converted to C<version> objects before using
    ordinary comparison operators.  For example:
    
      use version;
      if ( version->new($v1) <=> version->new($v2) ) {
        print "Versions are not equal\n";
      }
    
    If the only comparison needed is whether an installed module is of a
    sufficiently high version, a direct test may be done using the string
    form of C<eval> and the C<use> function.  For example, for module C<$mod>
    and version prerequisite C<$prereq>:
    
      if ( eval "use $mod $prereq (); 1" ) {
        print "Module $mod version is OK.\n";
      }
    
    If the values of C<$mod> and C<$prereq> have not been scrubbed, however,
    this presents security implications.
    
    =head1 SEE ALSO
    
    CPAN, L<http://www.cpan.org/>
    
    CPAN.pm, L<http://search.cpan.org/dist/CPAN/>
    
    CPANPLUS, L<http://search.cpan.org/dist/CPANPLUS/>
    
    ExtUtils::MakeMaker, L<http://search.cpan.org/dist/ExtUtils-MakeMaker/>
    
    Module::Build, L<http://search.cpan.org/dist/Module-Build/>
    
    Module::Install, L<http://search.cpan.org/dist/Module-Install/>
    
    JSON, L<http://json.org/>
    
    YAML, L<http://www.yaml.org/>
    
    =head1 HISTORY
    
    Ken Williams wrote the original CPAN Meta Spec (also known as the
    "META.yml spec") in 2003 and maintained it through several revisions
    with input from various members of the community.  In 2005, Randy
    Sims redrafted it from HTML to POD for the version 1.2 release.  Ken
    continued to maintain the spec through version 1.4.
    
    In late 2009, David Golden organized the version 2 proposal review
    process.  David and Ricardo Signes drafted the final version 2 spec
    in April 2010 based on the version 1.4 spec and patches contributed
    during the proposal process.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_SPEC
  
  $fatpacked{"CPAN/Meta/Validator.pm"} = <<'CPAN_META_VALIDATOR';
    use 5.006;
    use strict;
    use warnings;
    package CPAN::Meta::Validator;
    our $VERSION = '2.132510'; # VERSION
    
    
    #--------------------------------------------------------------------------#
    # This code copied and adapted from Test::CPAN::Meta
    # by Barbie, <barbie@cpan.org> for Miss Barbell Productions,
    # L<http://www.missbarbell.co.uk>
    #--------------------------------------------------------------------------#
    
    #--------------------------------------------------------------------------#
    # Specification Definitions
    #--------------------------------------------------------------------------#
    
    my %known_specs = (
        '1.4' => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
        '1.3' => 'http://module-build.sourceforge.net/META-spec-v1.3.html',
        '1.2' => 'http://module-build.sourceforge.net/META-spec-v1.2.html',
        '1.1' => 'http://module-build.sourceforge.net/META-spec-v1.1.html',
        '1.0' => 'http://module-build.sourceforge.net/META-spec-v1.0.html'
    );
    my %known_urls = map {$known_specs{$_} => $_} keys %known_specs;
    
    my $module_map1 = { 'map' => { ':key' => { name => \&module, value => \&exversion } } };
    
    my $module_map2 = { 'map' => { ':key' => { name => \&module, value => \&version   } } };
    
    my $no_index_2 = {
        'map'       => { file       => { list => { value => \&string } },
                         directory  => { list => { value => \&string } },
                         'package'  => { list => { value => \&string } },
                         namespace  => { list => { value => \&string } },
                        ':key'      => { name => \&custom_2, value => \&anything },
        }
    };
    
    my $no_index_1_3 = {
        'map'       => { file       => { list => { value => \&string } },
                         directory  => { list => { value => \&string } },
                         'package'  => { list => { value => \&string } },
                         namespace  => { list => { value => \&string } },
                         ':key'     => { name => \&string, value => \&anything },
        }
    };
    
    my $no_index_1_2 = {
        'map'       => { file       => { list => { value => \&string } },
                         dir        => { list => { value => \&string } },
                         'package'  => { list => { value => \&string } },
                         namespace  => { list => { value => \&string } },
                         ':key'     => { name => \&string, value => \&anything },
        }
    };
    
    my $no_index_1_1 = {
        'map'       => { ':key'     => { name => \&string, list => { value => \&string } },
        }
    };
    
    my $prereq_map = {
      map => {
        ':key' => {
          name => \&phase,
          'map' => {
            ':key'  => {
              name => \&relation,
              %$module_map1,
            },
          },
        }
      },
    };
    
    my %definitions = (
      '2' => {
        # REQUIRED
        'abstract'            => { mandatory => 1, value => \&string  },
        'author'              => { mandatory => 1, lazylist => { value => \&string } },
        'dynamic_config'      => { mandatory => 1, value => \&boolean },
        'generated_by'        => { mandatory => 1, value => \&string  },
        'license'             => { mandatory => 1, lazylist => { value => \&license } },
        'meta-spec' => {
          mandatory => 1,
          'map' => {
            version => { mandatory => 1, value => \&version},
            url     => { value => \&url },
            ':key' => { name => \&custom_2, value => \&anything },
          }
        },
        'name'                => { mandatory => 1, value => \&string  },
        'release_status'      => { mandatory => 1, value => \&release_status },
        'version'             => { mandatory => 1, value => \&version },
    
        # OPTIONAL
        'description' => { value => \&string },
        'keywords'    => { lazylist => { value => \&string } },
        'no_index'    => $no_index_2,
        'optional_features'   => {
          'map'       => {
            ':key'  => {
              name => \&string,
              'map'   => {
                description        => { value => \&string },
                prereqs => $prereq_map,
                ':key' => { name => \&custom_2, value => \&anything },
              }
            }
          }
        },
        'prereqs' => $prereq_map,
        'provides'    => {
          'map'       => {
            ':key' => {
              name  => \&module,
              'map' => {
                file    => { mandatory => 1, value => \&file },
                version => { value => \&version },
                ':key' => { name => \&custom_2, value => \&anything },
              }
            }
          }
        },
        'resources'   => {
          'map'       => {
            license    => { lazylist => { value => \&url } },
            homepage   => { value => \&url },
            bugtracker => {
              'map' => {
                web => { value => \&url },
                mailto => { value => \&string},
                ':key' => { name => \&custom_2, value => \&anything },
              }
            },
            repository => {
              'map' => {
                web => { value => \&url },
                url => { value => \&url },
                type => { value => \&string },
                ':key' => { name => \&custom_2, value => \&anything },
              }
            },
            ':key'     => { value => \&string, name => \&custom_2 },
          }
        },
    
        # CUSTOM -- additional user defined key/value pairs
        # note we can only validate the key name, as the structure is user defined
        ':key'        => { name => \&custom_2, value => \&anything },
      },
    
    '1.4' => {
      'meta-spec'           => {
        mandatory => 1,
        'map' => {
          version => { mandatory => 1, value => \&version},
          url     => { mandatory => 1, value => \&urlspec },
          ':key'  => { name => \&string, value => \&anything },
        },
      },
    
      'name'                => { mandatory => 1, value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'abstract'            => { mandatory => 1, value => \&string  },
      'author'              => { mandatory => 1, list  => { value => \&string } },
      'license'             => { mandatory => 1, value => \&license },
      'generated_by'        => { mandatory => 1, value => \&string  },
    
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'configure_requires'  => $module_map1,
      'conflicts'           => $module_map2,
    
      'optional_features'   => {
        'map'       => {
            ':key'  => { name => \&string,
                'map'   => { description        => { value => \&string },
                             requires           => $module_map1,
                             recommends         => $module_map1,
                             build_requires     => $module_map1,
                             conflicts          => $module_map2,
                             ':key'  => { name => \&string, value => \&anything },
                }
            }
         }
      },
    
      'provides'    => {
        'map'       => {
          ':key' => { name  => \&module,
            'map' => {
              file    => { mandatory => 1, value => \&file },
              version => { value => \&version },
              ':key'  => { name => \&string, value => \&anything },
            }
          }
        }
      },
    
      'no_index'    => $no_index_1_3,
      'private'     => $no_index_1_3,
    
      'keywords'    => { list => { value => \&string } },
    
      'resources'   => {
        'map'       => { license    => { value => \&url },
                         homepage   => { value => \&url },
                         bugtracker => { value => \&url },
                         repository => { value => \&url },
                         ':key'     => { value => \&string, name => \&custom_1 },
        }
      },
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    
    '1.3' => {
      'meta-spec'           => {
        mandatory => 1,
        'map' => {
          version => { mandatory => 1, value => \&version},
          url     => { mandatory => 1, value => \&urlspec },
          ':key'  => { name => \&string, value => \&anything },
        },
      },
    
      'name'                => { mandatory => 1, value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'abstract'            => { mandatory => 1, value => \&string  },
      'author'              => { mandatory => 1, list  => { value => \&string } },
      'license'             => { mandatory => 1, value => \&license },
      'generated_by'        => { mandatory => 1, value => \&string  },
    
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'conflicts'           => $module_map2,
    
      'optional_features'   => {
        'map'       => {
            ':key'  => { name => \&string,
                'map'   => { description        => { value => \&string },
                             requires           => $module_map1,
                             recommends         => $module_map1,
                             build_requires     => $module_map1,
                             conflicts          => $module_map2,
                             ':key'  => { name => \&string, value => \&anything },
                }
            }
         }
      },
    
      'provides'    => {
        'map'       => {
          ':key' => { name  => \&module,
            'map' => {
              file    => { mandatory => 1, value => \&file },
              version => { value => \&version },
              ':key'  => { name => \&string, value => \&anything },
            }
          }
        }
      },
    
    
      'no_index'    => $no_index_1_3,
      'private'     => $no_index_1_3,
    
      'keywords'    => { list => { value => \&string } },
    
      'resources'   => {
        'map'       => { license    => { value => \&url },
                         homepage   => { value => \&url },
                         bugtracker => { value => \&url },
                         repository => { value => \&url },
                         ':key'     => { value => \&string, name => \&custom_1 },
        }
      },
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    
    # v1.2 is misleading, it seems to assume that a number of fields where created
    # within v1.1, when they were created within v1.2. This may have been an
    # original mistake, and that a v1.1 was retro fitted into the timeline, when
    # v1.2 was originally slated as v1.1. But I could be wrong ;)
    '1.2' => {
      'meta-spec'           => {
        mandatory => 1,
        'map' => {
          version => { mandatory => 1, value => \&version},
          url     => { mandatory => 1, value => \&urlspec },
          ':key'  => { name => \&string, value => \&anything },
        },
      },
    
    
      'name'                => { mandatory => 1, value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'license'             => { mandatory => 1, value => \&license },
      'generated_by'        => { mandatory => 1, value => \&string  },
      'author'              => { mandatory => 1, list => { value => \&string } },
      'abstract'            => { mandatory => 1, value => \&string  },
    
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'keywords'            => { list => { value => \&string } },
    
      'private'             => $no_index_1_2,
      '$no_index'           => $no_index_1_2,
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'conflicts'           => $module_map2,
    
      'optional_features'   => {
        'map'       => {
            ':key'  => { name => \&string,
                'map'   => { description        => { value => \&string },
                             requires           => $module_map1,
                             recommends         => $module_map1,
                             build_requires     => $module_map1,
                             conflicts          => $module_map2,
                             ':key'  => { name => \&string, value => \&anything },
                }
            }
         }
      },
    
      'provides'    => {
        'map'       => {
          ':key' => { name  => \&module,
            'map' => {
              file    => { mandatory => 1, value => \&file },
              version => { value => \&version },
              ':key'  => { name => \&string, value => \&anything },
            }
          }
        }
      },
    
      'resources'   => {
        'map'       => { license    => { value => \&url },
                         homepage   => { value => \&url },
                         bugtracker => { value => \&url },
                         repository => { value => \&url },
                         ':key'     => { value => \&string, name => \&custom_1 },
        }
      },
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    
    # note that the 1.1 spec only specifies 'version' as mandatory
    '1.1' => {
      'name'                => { value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'license'             => { value => \&license },
      'generated_by'        => { value => \&string  },
    
      'license_uri'         => { value => \&url },
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'private'             => $no_index_1_1,
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'conflicts'           => $module_map2,
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    
    # note that the 1.0 spec doesn't specify optional or mandatory fields
    # but we will treat version as mandatory since otherwise META 1.0 is
    # completely arbitrary and pointless
    '1.0' => {
      'name'                => { value => \&string  },
      'version'             => { mandatory => 1, value => \&version },
      'license'             => { value => \&license },
      'generated_by'        => { value => \&string  },
    
      'license_uri'         => { value => \&url },
      'distribution_type'   => { value => \&string  },
      'dynamic_config'      => { value => \&boolean },
    
      'requires'            => $module_map1,
      'recommends'          => $module_map1,
      'build_requires'      => $module_map1,
      'conflicts'           => $module_map2,
    
      # additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&string, value => \&anything },
    },
    );
    
    #--------------------------------------------------------------------------#
    # Code
    #--------------------------------------------------------------------------#
    
    
    sub new {
      my ($class,$data) = @_;
    
      # create an attributes hash
      my $self = {
        'data'    => $data,
        'spec'    => $data->{'meta-spec'}{'version'} || "1.0",
        'errors'  => undef,
      };
    
      # create the object
      return bless $self, $class;
    }
    
    
    sub is_valid {
        my $self = shift;
        my $data = $self->{data};
        my $spec_version = $self->{spec};
        $self->check_map($definitions{$spec_version},$data);
        return ! $self->errors;
    }
    
    
    sub errors {
        my $self = shift;
        return ()   unless(defined $self->{errors});
        return @{$self->{errors}};
    }
    
    
    my $spec_error = "Missing validation action in specification. "
      . "Must be one of 'map', 'list', 'lazylist', or 'value'";
    
    sub check_map {
        my ($self,$spec,$data) = @_;
    
        if(ref($spec) ne 'HASH') {
            $self->_error( "Unknown META specification, cannot validate." );
            return;
        }
    
        if(ref($data) ne 'HASH') {
            $self->_error( "Expected a map structure from string or file." );
            return;
        }
    
        for my $key (keys %$spec) {
            next    unless($spec->{$key}->{mandatory});
            next    if(defined $data->{$key});
            push @{$self->{stack}}, $key;
            $self->_error( "Missing mandatory field, '$key'" );
            pop @{$self->{stack}};
        }
    
        for my $key (keys %$data) {
            push @{$self->{stack}}, $key;
            if($spec->{$key}) {
                if($spec->{$key}{value}) {
                    $spec->{$key}{value}->($self,$key,$data->{$key});
                } elsif($spec->{$key}{'map'}) {
                    $self->check_map($spec->{$key}{'map'},$data->{$key});
                } elsif($spec->{$key}{'list'}) {
                    $self->check_list($spec->{$key}{'list'},$data->{$key});
                } elsif($spec->{$key}{'lazylist'}) {
                    $self->check_lazylist($spec->{$key}{'lazylist'},$data->{$key});
                } else {
                    $self->_error( "$spec_error for '$key'" );
                }
    
            } elsif ($spec->{':key'}) {
                $spec->{':key'}{name}->($self,$key,$key);
                if($spec->{':key'}{value}) {
                    $spec->{':key'}{value}->($self,$key,$data->{$key});
                } elsif($spec->{':key'}{'map'}) {
                    $self->check_map($spec->{':key'}{'map'},$data->{$key});
                } elsif($spec->{':key'}{'list'}) {
                    $self->check_list($spec->{':key'}{'list'},$data->{$key});
                } elsif($spec->{':key'}{'lazylist'}) {
                    $self->check_lazylist($spec->{':key'}{'lazylist'},$data->{$key});
                } else {
                    $self->_error( "$spec_error for ':key'" );
                }
    
    
            } else {
                $self->_error( "Unknown key, '$key', found in map structure" );
            }
            pop @{$self->{stack}};
        }
    }
    
    # if it's a string, make it into a list and check the list
    sub check_lazylist {
        my ($self,$spec,$data) = @_;
    
        if ( defined $data && ! ref($data) ) {
          $data = [ $data ];
        }
    
        $self->check_list($spec,$data);
    }
    
    sub check_list {
        my ($self,$spec,$data) = @_;
    
        if(ref($data) ne 'ARRAY') {
            $self->_error( "Expected a list structure" );
            return;
        }
    
        if(defined $spec->{mandatory}) {
            if(!defined $data->[0]) {
                $self->_error( "Missing entries from mandatory list" );
            }
        }
    
        for my $value (@$data) {
            push @{$self->{stack}}, $value || "<undef>";
            if(defined $spec->{value}) {
                $spec->{value}->($self,'list',$value);
            } elsif(defined $spec->{'map'}) {
                $self->check_map($spec->{'map'},$value);
            } elsif(defined $spec->{'list'}) {
                $self->check_list($spec->{'list'},$value);
            } elsif(defined $spec->{'lazylist'}) {
                $self->check_lazylist($spec->{'lazylist'},$value);
            } elsif ($spec->{':key'}) {
                $self->check_map($spec,$value);
            } else {
              $self->_error( "$spec_error associated with '$self->{stack}[-2]'" );
            }
            pop @{$self->{stack}};
        }
    }
    
    
    sub header {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 1    if($value && $value =~ /^--- #YAML:1.0/);
        }
        $self->_error( "file does not have a valid YAML header." );
        return 0;
    }
    
    sub release_status {
      my ($self,$key,$value) = @_;
      if(defined $value) {
        my $version = $self->{data}{version} || '';
        if ( $version =~ /_/ ) {
          return 1 if ( $value =~ /\A(?:testing|unstable)\z/ );
          $self->_error( "'$value' for '$key' is invalid for version '$version'" );
        }
        else {
          return 1 if ( $value =~ /\A(?:stable|testing|unstable)\z/ );
          $self->_error( "'$value' for '$key' is invalid" );
        }
      }
      else {
        $self->_error( "'$key' is not defined" );
      }
      return 0;
    }
    
    # _uri_split taken from URI::Split by Gisle Aas, Copyright 2003
    sub _uri_split {
         return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
    }
    
    sub url {
        my ($self,$key,$value) = @_;
        if(defined $value) {
          my ($scheme, $auth, $path, $query, $frag) = _uri_split($value);
          unless ( defined $scheme && length $scheme ) {
            $self->_error( "'$value' for '$key' does not have a URL scheme" );
            return 0;
          }
          unless ( defined $auth && length $auth ) {
            $self->_error( "'$value' for '$key' does not have a URL authority" );
            return 0;
          }
          return 1;
        }
        $value ||= '';
        $self->_error( "'$value' for '$key' is not a valid URL." );
        return 0;
    }
    
    sub urlspec {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 1    if($value && $known_specs{$self->{spec}} eq $value);
            if($value && $known_urls{$value}) {
                $self->_error( 'META specification URL does not match version' );
                return 0;
            }
        }
        $self->_error( 'Unknown META specification' );
        return 0;
    }
    
    sub anything { return 1 }
    
    sub string {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 1    if($value || $value =~ /^0$/);
        }
        $self->_error( "value is an undefined string" );
        return 0;
    }
    
    sub string_or_undef {
        my ($self,$key,$value) = @_;
        return 1    unless(defined $value);
        return 1    if($value || $value =~ /^0$/);
        $self->_error( "No string defined for '$key'" );
        return 0;
    }
    
    sub file {
        my ($self,$key,$value) = @_;
        return 1    if(defined $value);
        $self->_error( "No file defined for '$key'" );
        return 0;
    }
    
    sub exversion {
        my ($self,$key,$value) = @_;
        if(defined $value && ($value || $value =~ /0/)) {
            my $pass = 1;
            for(split(",",$value)) { $self->version($key,$_) or ($pass = 0); }
            return $pass;
        }
        $value = '<undef>'  unless(defined $value);
        $self->_error( "'$value' for '$key' is not a valid version." );
        return 0;
    }
    
    sub version {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 0    unless($value || $value =~ /0/);
            return 1    if($value =~ /^\s*((<|<=|>=|>|!=|==)\s*)?v?\d+((\.\d+((_|\.)\d+)?)?)/);
        } else {
            $value = '<undef>';
        }
        $self->_error( "'$value' for '$key' is not a valid version." );
        return 0;
    }
    
    sub boolean {
        my ($self,$key,$value) = @_;
        if(defined $value) {
            return 1    if($value =~ /^(0|1|true|false)$/);
        } else {
            $value = '<undef>';
        }
        $self->_error( "'$value' for '$key' is not a boolean value." );
        return 0;
    }
    
    my %v1_licenses = (
        'perl'         => 'http://dev.perl.org/licenses/',
        'gpl'          => 'http://www.opensource.org/licenses/gpl-license.php',
        'apache'       => 'http://apache.org/licenses/LICENSE-2.0',
        'artistic'     => 'http://opensource.org/licenses/artistic-license.php',
        'artistic_2'   => 'http://opensource.org/licenses/artistic-license-2.0.php',
        'lgpl'         => 'http://www.opensource.org/licenses/lgpl-license.php',
        'bsd'          => 'http://www.opensource.org/licenses/bsd-license.php',
        'gpl'          => 'http://www.opensource.org/licenses/gpl-license.php',
        'mit'          => 'http://opensource.org/licenses/mit-license.php',
        'mozilla'      => 'http://opensource.org/licenses/mozilla1.1.php',
        'open_source'  => undef,
        'unrestricted' => undef,
        'restrictive'  => undef,
        'unknown'      => undef,
    );
    
    my %v2_licenses = map { $_ => 1 } qw(
      agpl_3
      apache_1_1
      apache_2_0
      artistic_1
      artistic_2
      bsd
      freebsd
      gfdl_1_2
      gfdl_1_3
      gpl_1
      gpl_2
      gpl_3
      lgpl_2_1
      lgpl_3_0
      mit
      mozilla_1_0
      mozilla_1_1
      openssl
      perl_5
      qpl_1_0
      ssleay
      sun
      zlib
      open_source
      restricted
      unrestricted
      unknown
    );
    
    sub license {
        my ($self,$key,$value) = @_;
        my $licenses = $self->{spec} < 2 ? \%v1_licenses : \%v2_licenses;
        if(defined $value) {
            return 1    if($value && exists $licenses->{$value});
        } else {
            $value = '<undef>';
        }
        $self->_error( "License '$value' is invalid" );
        return 0;
    }
    
    sub custom_1 {
        my ($self,$key) = @_;
        if(defined $key) {
            # a valid user defined key should be alphabetic
            # and contain at least one capital case letter.
            return 1    if($key && $key =~ /^[_a-z]+$/i && $key =~ /[A-Z]/);
        } else {
            $key = '<undef>';
        }
        $self->_error( "Custom resource '$key' must be in CamelCase." );
        return 0;
    }
    
    sub custom_2 {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1    if($key && $key =~ /^x_/i);  # user defined
        } else {
            $key = '<undef>';
        }
        $self->_error( "Custom key '$key' must begin with 'x_' or 'X_'." );
        return 0;
    }
    
    sub identifier {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1    if($key && $key =~ /^([a-z][_a-z]+)$/i);    # spec 2.0 defined
        } else {
            $key = '<undef>';
        }
        $self->_error( "Key '$key' is not a legal identifier." );
        return 0;
    }
    
    sub module {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1    if($key && $key =~ /^[A-Za-z0-9_]+(::[A-Za-z0-9_]+)*$/);
        } else {
            $key = '<undef>';
        }
        $self->_error( "Key '$key' is not a legal module name." );
        return 0;
    }
    
    my @valid_phases = qw/ configure build test runtime develop /;
    sub phase {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1 if( length $key && grep { $key eq $_ } @valid_phases );
            return 1 if $key =~ /x_/i;
        } else {
            $key = '<undef>';
        }
        $self->_error( "Key '$key' is not a legal phase." );
        return 0;
    }
    
    my @valid_relations = qw/ requires recommends suggests conflicts /;
    sub relation {
        my ($self,$key) = @_;
        if(defined $key) {
            return 1 if( length $key && grep { $key eq $_ } @valid_relations );
            return 1 if $key =~ /x_/i;
        } else {
            $key = '<undef>';
        }
        $self->_error( "Key '$key' is not a legal prereq relationship." );
        return 0;
    }
    
    sub _error {
        my $self = shift;
        my $mess = shift;
    
        $mess .= ' ('.join(' -> ',@{$self->{stack}}).')'  if($self->{stack});
        $mess .= " [Validation: $self->{spec}]";
    
        push @{$self->{errors}}, $mess;
    }
    
    1;
    
    # ABSTRACT: validate CPAN distribution metadata structures
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    CPAN::Meta::Validator - validate CPAN distribution metadata structures
    
    =head1 VERSION
    
    version 2.132510
    
    =head1 SYNOPSIS
    
      my $struct = decode_json_file('META.json');
    
      my $cmv = CPAN::Meta::Validator->new( $struct );
    
      unless ( $cmv->is_valid ) {
        my $msg = "Invalid META structure.  Errors found:\n";
        $msg .= join( "\n", $cmv->errors );
        die $msg;
      }
    
    =head1 DESCRIPTION
    
    This module validates a CPAN Meta structure against the version of the
    the specification claimed in the C<meta-spec> field of the structure.
    
    =head1 METHODS
    
    =head2 new
    
      my $cmv = CPAN::Meta::Validator->new( $struct )
    
    The constructor must be passed a metadata structure.
    
    =head2 is_valid
    
      if ( $cmv->is_valid ) {
        ...
      }
    
    Returns a boolean value indicating whether the metadata provided
    is valid.
    
    =head2 errors
    
      warn( join "\n", $cmv->errors );
    
    Returns a list of errors seen during validation.
    
    =begin :internals
    
    =head2 Check Methods
    
    =over
    
    =item *
    
    check_map($spec,$data)
    
    Checks whether a map (or hash) part of the data structure conforms to the
    appropriate specification definition.
    
    =item *
    
    check_list($spec,$data)
    
    Checks whether a list (or array) part of the data structure conforms to
    the appropriate specification definition.
    
    =item *
    
    check_lazylist($spec,$data)
    
    Checks whether a list conforms, but converts strings to a single-element list
    
    =back
    
    =head2 Validator Methods
    
    =over
    
    =item *
    
    header($self,$key,$value)
    
    Validates that the header is valid.
    
    Note: No longer used as we now read the data structure, not the file.
    
    =item *
    
    url($self,$key,$value)
    
    Validates that a given value is in an acceptable URL format
    
    =item *
    
    urlspec($self,$key,$value)
    
    Validates that the URL to a META specification is a known one.
    
    =item *
    
    string_or_undef($self,$key,$value)
    
    Validates that the value is either a string or an undef value. Bit of a
    catchall function for parts of the data structure that are completely user
    defined.
    
    =item *
    
    string($self,$key,$value)
    
    Validates that a string exists for the given key.
    
    =item *
    
    file($self,$key,$value)
    
    Validate that a file is passed for the given key. This may be made more
    thorough in the future. For now it acts like \&string.
    
    =item *
    
    exversion($self,$key,$value)
    
    Validates a list of versions, e.g. '<= 5, >=2, ==3, !=4, >1, <6, 0'.
    
    =item *
    
    version($self,$key,$value)
    
    Validates a single version string. Versions of the type '5.8.8' and '0.00_00'
    are both valid. A leading 'v' like 'v1.2.3' is also valid.
    
    =item *
    
    boolean($self,$key,$value)
    
    Validates for a boolean value. Currently these values are '1', '0', 'true',
    'false', however the latter 2 may be removed.
    
    =item *
    
    license($self,$key,$value)
    
    Validates that a value is given for the license. Returns 1 if an known license
    type, or 2 if a value is given but the license type is not a recommended one.
    
    =item *
    
    custom_1($self,$key,$value)
    
    Validates that the given key is in CamelCase, to indicate a user defined
    keyword and only has characters in the class [-_a-zA-Z].  In version 1.X
    of the spec, this was only explicitly stated for 'resources'.
    
    =item *
    
    custom_2($self,$key,$value)
    
    Validates that the given key begins with 'x_' or 'X_', to indicate a user
    defined keyword and only has characters in the class [-_a-zA-Z]
    
    =item *
    
    identifier($self,$key,$value)
    
    Validates that key is in an acceptable format for the META specification,
    for an identifier, i.e. any that matches the regular expression
    qr/[a-z][a-z_]/i.
    
    =item *
    
    module($self,$key,$value)
    
    Validates that a given key is in an acceptable module name format, e.g.
    'Test::CPAN::Meta::Version'.
    
    =back
    
    =end :internals
    
    =for Pod::Coverage anything boolean check_lazylist check_list custom_1 custom_2 exversion file
    identifier license module phase relation release_status string string_or_undef
    url urlspec version header check_map
    
    =head1 BUGS
    
    Please report any bugs or feature using the CPAN Request Tracker.
    Bugs can be submitted through the web interface at
    L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
    
    When submitting a bug or request, please include a test-file or a patch to an
    existing test-file that illustrates the bug or desired feature.
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =item *
    
    Ricardo Signes <rjbs@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by David Golden and Ricardo Signes.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  CPAN_META_VALIDATOR
  
  $fatpacked{"CPAN/Meta/YAML.pm"} = <<'CPAN_META_YAML';
    package CPAN::Meta::YAML;
    {
      $CPAN::Meta::YAML::VERSION = '0.008';
    }
    
    use strict;
    
    # UTF Support?
    sub HAVE_UTF8 () { $] >= 5.007003 }
    BEGIN {
    	if ( HAVE_UTF8 ) {
    		# The string eval helps hide this from Test::MinimumVersion
    		eval "require utf8;";
    		die "Failed to load UTF-8 support" if $@;
    	}
    
    	# Class structure
    	require 5.004;
    	require Exporter;
    	require Carp;
    	@CPAN::Meta::YAML::ISA       = qw{ Exporter  };
    	@CPAN::Meta::YAML::EXPORT    = qw{ Load Dump };
    	@CPAN::Meta::YAML::EXPORT_OK = qw{ LoadFile DumpFile freeze thaw };
    
    	# Error storage
    	$CPAN::Meta::YAML::errstr    = '';
    }
    
    # The character class of all characters we need to escape
    # NOTE: Inlined, since it's only used once
    # my $RE_ESCAPE = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f\"\n]';
    
    # Printed form of the unprintable characters in the lowest range
    # of ASCII characters, listed by ASCII ordinal position.
    my @UNPRINTABLE = qw(
    	z    x01  x02  x03  x04  x05  x06  a
    	x08  t    n    v    f    r    x0e  x0f
    	x10  x11  x12  x13  x14  x15  x16  x17
    	x18  x19  x1a  e    x1c  x1d  x1e  x1f
    );
    
    # Printable characters for escapes
    my %UNESCAPES = (
    	z => "\x00", a => "\x07", t    => "\x09",
    	n => "\x0a", v => "\x0b", f    => "\x0c",
    	r => "\x0d", e => "\x1b", '\\' => '\\',
    );
    
    # Special magic boolean words
    my %QUOTE = map { $_ => 1 } qw{
    	null Null NULL
    	y Y yes Yes YES n N no No NO
    	true True TRUE false False FALSE
    	on On ON off Off OFF
    };
    
    
    
    
    
    #####################################################################
    # Implementation
    
    # Create an empty CPAN::Meta::YAML object
    sub new {
    	my $class = shift;
    	bless [ @_ ], $class;
    }
    
    # Create an object from a file
    sub read {
    	my $class = ref $_[0] ? ref shift : shift;
    
    	# Check the file
    	my $file = shift or return $class->_error( 'You did not specify a file name' );
    	return $class->_error( "File '$file' does not exist" )              unless -e $file;
    	return $class->_error( "'$file' is a directory, not a file" )       unless -f _;
    	return $class->_error( "Insufficient permissions to read '$file'" ) unless -r _;
    
    	# Slurp in the file
    	local $/ = undef;
    	local *CFG;
    	unless ( open(CFG, $file) ) {
    		return $class->_error("Failed to open file '$file': $!");
    	}
    	my $contents = <CFG>;
    	unless ( close(CFG) ) {
    		return $class->_error("Failed to close file '$file': $!");
    	}
    
    	$class->read_string( $contents );
    }
    
    # Create an object from a string
    sub read_string {
    	my $class  = ref $_[0] ? ref shift : shift;
    	my $self   = bless [], $class;
    	my $string = $_[0];
    	eval {
    		unless ( defined $string ) {
    			die \"Did not provide a string to load";
    		}
    
    		# Byte order marks
    		# NOTE: Keeping this here to educate maintainers
    		# my %BOM = (
    		#     "\357\273\277" => 'UTF-8',
    		#     "\376\377"     => 'UTF-16BE',
    		#     "\377\376"     => 'UTF-16LE',
    		#     "\377\376\0\0" => 'UTF-32LE'
    		#     "\0\0\376\377" => 'UTF-32BE',
    		# );
    		if ( $string =~ /^(?:\376\377|\377\376|\377\376\0\0|\0\0\376\377)/ ) {
    			die \"Stream has a non UTF-8 BOM";
    		} else {
    			# Strip UTF-8 bom if found, we'll just ignore it
    			$string =~ s/^\357\273\277//;
    		}
    
    		# Try to decode as utf8
    		utf8::decode($string) if HAVE_UTF8;
    
    		# Check for some special cases
    		return $self unless length $string;
    		unless ( $string =~ /[\012\015]+\z/ ) {
    			die \"Stream does not end with newline character";
    		}
    
    		# Split the file into lines
    		my @lines = grep { ! /^\s*(?:\#.*)?\z/ }
    			    split /(?:\015{1,2}\012|\015|\012)/, $string;
    
    		# Strip the initial YAML header
    		@lines and $lines[0] =~ /^\%YAML[: ][\d\.]+.*\z/ and shift @lines;
    
    		# A nibbling parser
    		while ( @lines ) {
    			# Do we have a document header?
    			if ( $lines[0] =~ /^---\s*(?:(.+)\s*)?\z/ ) {
    				# Handle scalar documents
    				shift @lines;
    				if ( defined $1 and $1 !~ /^(?:\#.+|\%YAML[: ][\d\.]+)\z/ ) {
    					push @$self, $self->_read_scalar( "$1", [ undef ], \@lines );
    					next;
    				}
    			}
    
    			if ( ! @lines or $lines[0] =~ /^(?:---|\.\.\.)/ ) {
    				# A naked document
    				push @$self, undef;
    				while ( @lines and $lines[0] !~ /^---/ ) {
    					shift @lines;
    				}
    
    			} elsif ( $lines[0] =~ /^\s*\-/ ) {
    				# An array at the root
    				my $document = [ ];
    				push @$self, $document;
    				$self->_read_array( $document, [ 0 ], \@lines );
    
    			} elsif ( $lines[0] =~ /^(\s*)\S/ ) {
    				# A hash at the root
    				my $document = { };
    				push @$self, $document;
    				$self->_read_hash( $document, [ length($1) ], \@lines );
    
    			} else {
    				die \"CPAN::Meta::YAML failed to classify the line '$lines[0]'";
    			}
    		}
    	};
    	if ( ref $@ eq 'SCALAR' ) {
    		return $self->_error(${$@});
    	} elsif ( $@ ) {
    		require Carp;
    		Carp::croak($@);
    	}
    
    	return $self;
    }
    
    # Deparse a scalar string to the actual scalar
    sub _read_scalar {
    	my ($self, $string, $indent, $lines) = @_;
    
    	# Trim trailing whitespace
    	$string =~ s/\s*\z//;
    
    	# Explitic null/undef
    	return undef if $string eq '~';
    
    	# Single quote
    	if ( $string =~ /^\'(.*?)\'(?:\s+\#.*)?\z/ ) {
    		return '' unless defined $1;
    		$string = $1;
    		$string =~ s/\'\'/\'/g;
    		return $string;
    	}
    
    	# Double quote.
    	# The commented out form is simpler, but overloaded the Perl regex
    	# engine due to recursion and backtracking problems on strings
    	# larger than 32,000ish characters. Keep it for reference purposes.
    	# if ( $string =~ /^\"((?:\\.|[^\"])*)\"\z/ ) {
    	if ( $string =~ /^\"([^\\"]*(?:\\.[^\\"]*)*)\"(?:\s+\#.*)?\z/ ) {
    		# Reusing the variable is a little ugly,
    		# but avoids a new variable and a string copy.
    		$string = $1;
    		$string =~ s/\\"/"/g;
    		$string =~ s/\\([never\\fartz]|x([0-9a-fA-F]{2}))/(length($1)>1)?pack("H2",$2):$UNESCAPES{$1}/gex;
    		return $string;
    	}
    
    	# Special cases
    	if ( $string =~ /^[\'\"!&]/ ) {
    		die \"CPAN::Meta::YAML does not support a feature in line '$string'";
    	}
    	return {} if $string =~ /^{}(?:\s+\#.*)?\z/;
    	return [] if $string =~ /^\[\](?:\s+\#.*)?\z/;
    
    	# Regular unquoted string
    	if ( $string !~ /^[>|]/ ) {
    		if (
    			$string =~ /^(?:-(?:\s|$)|[\@\%\`])/
    			or
    			$string =~ /:(?:\s|$)/
    		) {
    			die \"CPAN::Meta::YAML found illegal characters in plain scalar: '$string'";
    		}
    		$string =~ s/\s+#.*\z//;
    		return $string;
    	}
    
    	# Error
    	die \"CPAN::Meta::YAML failed to find multi-line scalar content" unless @$lines;
    
    	# Check the indent depth
    	$lines->[0]   =~ /^(\s*)/;
    	$indent->[-1] = length("$1");
    	if ( defined $indent->[-2] and $indent->[-1] <= $indent->[-2] ) {
    		die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'";
    	}
    
    	# Pull the lines
    	my @multiline = ();
    	while ( @$lines ) {
    		$lines->[0] =~ /^(\s*)/;
    		last unless length($1) >= $indent->[-1];
    		push @multiline, substr(shift(@$lines), length($1));
    	}
    
    	my $j = (substr($string, 0, 1) eq '>') ? ' ' : "\n";
    	my $t = (substr($string, 1, 1) eq '-') ? ''  : "\n";
    	return join( $j, @multiline ) . $t;
    }
    
    # Parse an array
    sub _read_array {
    	my ($self, $array, $indent, $lines) = @_;
    
    	while ( @$lines ) {
    		# Check for a new document
    		if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
    			while ( @$lines and $lines->[0] !~ /^---/ ) {
    				shift @$lines;
    			}
    			return 1;
    		}
    
    		# Check the indent level
    		$lines->[0] =~ /^(\s*)/;
    		if ( length($1) < $indent->[-1] ) {
    			return 1;
    		} elsif ( length($1) > $indent->[-1] ) {
    			die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'";
    		}
    
    		if ( $lines->[0] =~ /^(\s*\-\s+)[^\'\"]\S*\s*:(?:\s+|$)/ ) {
    			# Inline nested hash
    			my $indent2 = length("$1");
    			$lines->[0] =~ s/-/ /;
    			push @$array, { };
    			$self->_read_hash( $array->[-1], [ @$indent, $indent2 ], $lines );
    
    		} elsif ( $lines->[0] =~ /^\s*\-(\s*)(.+?)\s*\z/ ) {
    			# Array entry with a value
    			shift @$lines;
    			push @$array, $self->_read_scalar( "$2", [ @$indent, undef ], $lines );
    
    		} elsif ( $lines->[0] =~ /^\s*\-\s*\z/ ) {
    			shift @$lines;
    			unless ( @$lines ) {
    				push @$array, undef;
    				return 1;
    			}
    			if ( $lines->[0] =~ /^(\s*)\-/ ) {
    				my $indent2 = length("$1");
    				if ( $indent->[-1] == $indent2 ) {
    					# Null array entry
    					push @$array, undef;
    				} else {
    					# Naked indenter
    					push @$array, [ ];
    					$self->_read_array( $array->[-1], [ @$indent, $indent2 ], $lines );
    				}
    
    			} elsif ( $lines->[0] =~ /^(\s*)\S/ ) {
    				push @$array, { };
    				$self->_read_hash( $array->[-1], [ @$indent, length("$1") ], $lines );
    
    			} else {
    				die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'";
    			}
    
    		} elsif ( defined $indent->[-2] and $indent->[-1] == $indent->[-2] ) {
    			# This is probably a structure like the following...
    			# ---
    			# foo:
    			# - list
    			# bar: value
    			#
    			# ... so lets return and let the hash parser handle it
    			return 1;
    
    		} else {
    			die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'";
    		}
    	}
    
    	return 1;
    }
    
    # Parse an array
    sub _read_hash {
    	my ($self, $hash, $indent, $lines) = @_;
    
    	while ( @$lines ) {
    		# Check for a new document
    		if ( $lines->[0] =~ /^(?:---|\.\.\.)/ ) {
    			while ( @$lines and $lines->[0] !~ /^---/ ) {
    				shift @$lines;
    			}
    			return 1;
    		}
    
    		# Check the indent level
    		$lines->[0] =~ /^(\s*)/;
    		if ( length($1) < $indent->[-1] ) {
    			return 1;
    		} elsif ( length($1) > $indent->[-1] ) {
    			die \"CPAN::Meta::YAML found bad indenting in line '$lines->[0]'";
    		}
    
    		# Get the key
    		unless ( $lines->[0] =~ s/^\s*([^\'\" ][^\n]*?)\s*:(\s+(?:\#.*)?|$)// ) {
    			if ( $lines->[0] =~ /^\s*[?\'\"]/ ) {
    				die \"CPAN::Meta::YAML does not support a feature in line '$lines->[0]'";
    			}
    			die \"CPAN::Meta::YAML failed to classify line '$lines->[0]'";
    		}
    		my $key = $1;
    
    		# Do we have a value?
    		if ( length $lines->[0] ) {
    			# Yes
    			$hash->{$key} = $self->_read_scalar( shift(@$lines), [ @$indent, undef ], $lines );
    		} else {
    			# An indent
    			shift @$lines;
    			unless ( @$lines ) {
    				$hash->{$key} = undef;
    				return 1;
    			}
    			if ( $lines->[0] =~ /^(\s*)-/ ) {
    				$hash->{$key} = [];
    				$self->_read_array( $hash->{$key}, [ @$indent, length($1) ], $lines );
    			} elsif ( $lines->[0] =~ /^(\s*)./ ) {
    				my $indent2 = length("$1");
    				if ( $indent->[-1] >= $indent2 ) {
    					# Null hash entry
    					$hash->{$key} = undef;
    				} else {
    					$hash->{$key} = {};
    					$self->_read_hash( $hash->{$key}, [ @$indent, length($1) ], $lines );
    				}
    			}
    		}
    	}
    
    	return 1;
    }
    
    # Save an object to a file
    sub write {
    	my $self = shift;
    	my $file = shift or return $self->_error('No file name provided');
    
    	# Write it to the file
    	open( CFG, '>' . $file ) or return $self->_error(
    		"Failed to open file '$file' for writing: $!"
    		);
    	print CFG $self->write_string;
    	close CFG;
    
    	return 1;
    }
    
    # Save an object to a string
    sub write_string {
    	my $self = shift;
    	return '' unless @$self;
    
    	# Iterate over the documents
    	my $indent = 0;
    	my @lines  = ();
    	foreach my $cursor ( @$self ) {
    		push @lines, '---';
    
    		# An empty document
    		if ( ! defined $cursor ) {
    			# Do nothing
    
    		# A scalar document
    		} elsif ( ! ref $cursor ) {
    			$lines[-1] .= ' ' . $self->_write_scalar( $cursor, $indent );
    
    		# A list at the root
    		} elsif ( ref $cursor eq 'ARRAY' ) {
    			unless ( @$cursor ) {
    				$lines[-1] .= ' []';
    				next;
    			}
    			push @lines, $self->_write_array( $cursor, $indent, {} );
    
    		# A hash at the root
    		} elsif ( ref $cursor eq 'HASH' ) {
    			unless ( %$cursor ) {
    				$lines[-1] .= ' {}';
    				next;
    			}
    			push @lines, $self->_write_hash( $cursor, $indent, {} );
    
    		} else {
    			Carp::croak("Cannot serialize " . ref($cursor));
    		}
    	}
    
    	join '', map { "$_\n" } @lines;
    }
    
    sub _write_scalar {
    	my $string = $_[1];
    	return '~'  unless defined $string;
    	return "''" unless length  $string;
    	if ( $string =~ /[\x00-\x08\x0b-\x0d\x0e-\x1f\"\'\n]/ ) {
    		$string =~ s/\\/\\\\/g;
    		$string =~ s/"/\\"/g;
    		$string =~ s/\n/\\n/g;
    		$string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;
    		return qq|"$string"|;
    	}
    	if ( $string =~ /(?:^\W|\s|:\z)/ or $QUOTE{$string} ) {
    		return "'$string'";
    	}
    	return $string;
    }
    
    sub _write_array {
    	my ($self, $array, $indent, $seen) = @_;
    	if ( $seen->{refaddr($array)}++ ) {
    		die "CPAN::Meta::YAML does not support circular references";
    	}
    	my @lines  = ();
    	foreach my $el ( @$array ) {
    		my $line = ('  ' x $indent) . '-';
    		my $type = ref $el;
    		if ( ! $type ) {
    			$line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
    			push @lines, $line;
    
    		} elsif ( $type eq 'ARRAY' ) {
    			if ( @$el ) {
    				push @lines, $line;
    				push @lines, $self->_write_array( $el, $indent + 1, $seen );
    			} else {
    				$line .= ' []';
    				push @lines, $line;
    			}
    
    		} elsif ( $type eq 'HASH' ) {
    			if ( keys %$el ) {
    				push @lines, $line;
    				push @lines, $self->_write_hash( $el, $indent + 1, $seen );
    			} else {
    				$line .= ' {}';
    				push @lines, $line;
    			}
    
    		} else {
    			die "CPAN::Meta::YAML does not support $type references";
    		}
    	}
    
    	@lines;
    }
    
    sub _write_hash {
    	my ($self, $hash, $indent, $seen) = @_;
    	if ( $seen->{refaddr($hash)}++ ) {
    		die "CPAN::Meta::YAML does not support circular references";
    	}
    	my @lines  = ();
    	foreach my $name ( sort keys %$hash ) {
    		my $el   = $hash->{$name};
    		my $line = ('  ' x $indent) . "$name:";
    		my $type = ref $el;
    		if ( ! $type ) {
    			$line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
    			push @lines, $line;
    
    		} elsif ( $type eq 'ARRAY' ) {
    			if ( @$el ) {
    				push @lines, $line;
    				push @lines, $self->_write_array( $el, $indent + 1, $seen );
    			} else {
    				$line .= ' []';
    				push @lines, $line;
    			}
    
    		} elsif ( $type eq 'HASH' ) {
    			if ( keys %$el ) {
    				push @lines, $line;
    				push @lines, $self->_write_hash( $el, $indent + 1, $seen );
    			} else {
    				$line .= ' {}';
    				push @lines, $line;
    			}
    
    		} else {
    			die "CPAN::Meta::YAML does not support $type references";
    		}
    	}
    
    	@lines;
    }
    
    # Set error
    sub _error {
    	$CPAN::Meta::YAML::errstr = $_[1];
    	undef;
    }
    
    # Retrieve error
    sub errstr {
    	$CPAN::Meta::YAML::errstr;
    }
    
    
    
    
    
    #####################################################################
    # YAML Compatibility
    
    sub Dump {
    	CPAN::Meta::YAML->new(@_)->write_string;
    }
    
    sub Load {
    	my $self = CPAN::Meta::YAML->read_string(@_);
    	unless ( $self ) {
    		Carp::croak("Failed to load YAML document from string");
    	}
    	if ( wantarray ) {
    		return @$self;
    	} else {
    		# To match YAML.pm, return the last document
    		return $self->[-1];
    	}
    }
    
    BEGIN {
    	*freeze = *Dump;
    	*thaw   = *Load;
    }
    
    sub DumpFile {
    	my $file = shift;
    	CPAN::Meta::YAML->new(@_)->write($file);
    }
    
    sub LoadFile {
    	my $self = CPAN::Meta::YAML->read($_[0]);
    	unless ( $self ) {
    		Carp::croak("Failed to load YAML document from '" . ($_[0] || '') . "'");
    	}
    	if ( wantarray ) {
    		return @$self;
    	} else {
    		# Return only the last document to match YAML.pm, 
    		return $self->[-1];
    	}
    }
    
    
    
    
    
    #####################################################################
    # Use Scalar::Util if possible, otherwise emulate it
    
    BEGIN {
    	local $@;
    	eval {
    		require Scalar::Util;
    	};
    	my $v = eval("$Scalar::Util::VERSION") || 0;
    	if ( $@ or $v < 1.18 ) {
    		eval <<'END_PERL';
    # Scalar::Util failed to load or too old
    sub refaddr {
    	my $pkg = ref($_[0]) or return undef;
    	if ( !! UNIVERSAL::can($_[0], 'can') ) {
    		bless $_[0], 'Scalar::Util::Fake';
    	} else {
    		$pkg = undef;
    	}
    	"$_[0]" =~ /0x(\w+)/;
    	my $i = do { local $^W; hex $1 };
    	bless $_[0], $pkg if defined $pkg;
    	$i;
    }
    END_PERL
    	} else {
    		*refaddr = *Scalar::Util::refaddr;
    	}
    }
    
    1;
    
    
    
    =pod
    
    =head1 NAME
    
    CPAN::Meta::YAML - Read and write a subset of YAML for CPAN Meta files
    
    =head1 VERSION
    
    version 0.008
    
    =head1 SYNOPSIS
    
        use CPAN::Meta::YAML;
    
        # reading a META file
        open $fh, "<:utf8", "META.yml";
        $yaml_text = do { local $/; <$fh> };
        $yaml = CPAN::Meta::YAML->read_string($yaml_text)
          or die CPAN::Meta::YAML->errstr;
    
        # finding the metadata
        $meta = $yaml->[0];
    
        # writing a META file
        $yaml_text = $yaml->write_string
          or die CPAN::Meta::YAML->errstr;
        open $fh, ">:utf8", "META.yml";
        print $fh $yaml_text;
    
    =head1 DESCRIPTION
    
    This module implements a subset of the YAML specification for use in reading
    and writing CPAN metadata files like F<META.yml> and F<MYMETA.yml>.  It should
    not be used for any other general YAML parsing or generation task.
    
    NOTE: F<META.yml> (and F<MYMETA.yml>) files should be UTF-8 encoded.  Users are
    responsible for proper encoding and decoding.  In particular, the C<read> and
    C<write> methods do B<not> support UTF-8 and should not be used.
    
    =head1 SUPPORT
    
    This module is currently derived from L<YAML::Tiny> by Adam Kennedy.  If
    there are bugs in how it parses a particular META.yml file, please file
    a bug report in the YAML::Tiny bugtracker:
    L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=YAML-Tiny>
    
    =head1 SEE ALSO
    
    L<YAML::Tiny>, L<YAML>, L<YAML::XS>
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<http://rt.cpan.org/Public/Dist/Display.html?Name=CPAN-Meta-YAML>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/dagolden/cpan-meta-yaml>
    
      git clone https://github.com/dagolden/cpan-meta-yaml.git
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    Adam Kennedy <adamk@cpan.org>
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2010 by Adam Kennedy.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
    
    
    __END__
    
    
    # ABSTRACT: Read and write a subset of YAML for CPAN Meta files
    
    
  CPAN_META_YAML
  
  $fatpacked{"Exporter.pm"} = <<'EXPORTER';
    package Exporter;
    
    require 5.006;
    
    # Be lean.
    #use strict;
    #no strict 'refs';
    
    our $Debug = 0;
    our $ExportLevel = 0;
    our $Verbose ||= 0;
    our $VERSION = '5.68';
    our (%Cache);
    
    sub as_heavy {
      require Exporter::Heavy;
      # Unfortunately, this does not work if the caller is aliased as *name = \&foo
      # Thus the need to create a lot of identical subroutines
      my $c = (caller(1))[3];
      $c =~ s/.*:://;
      \&{"Exporter::Heavy::heavy_$c"};
    }
    
    sub export {
      goto &{as_heavy()};
    }
    
    sub import {
      my $pkg = shift;
      my $callpkg = caller($ExportLevel);
    
      if ($pkg eq "Exporter" and @_ and $_[0] eq "import") {
        *{$callpkg."::import"} = \&import;
        return;
      }
    
      # We *need* to treat @{"$pkg\::EXPORT_FAIL"} since Carp uses it :-(
      my $exports = \@{"$pkg\::EXPORT"};
      # But, avoid creating things if they don't exist, which saves a couple of
      # hundred bytes per package processed.
      my $fail = ${$pkg . '::'}{EXPORT_FAIL} && \@{"$pkg\::EXPORT_FAIL"};
      return export $pkg, $callpkg, @_
        if $Verbose or $Debug or $fail && @$fail > 1;
      my $export_cache = ($Cache{$pkg} ||= {});
      my $args = @_ or @_ = @$exports;
    
      if ($args and not %$export_cache) {
        s/^&//, $export_cache->{$_} = 1
          foreach (@$exports, @{"$pkg\::EXPORT_OK"});
      }
      my $heavy;
      # Try very hard not to use {} and hence have to  enter scope on the foreach
      # We bomb out of the loop with last as soon as heavy is set.
      if ($args or $fail) {
        ($heavy = (/\W/ or $args and not exists $export_cache->{$_}
                   or $fail and @$fail and $_ eq $fail->[0])) and last
                     foreach (@_);
      } else {
        ($heavy = /\W/) and last
          foreach (@_);
      }
      return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;
      local $SIG{__WARN__} = 
    	sub {require Carp; &Carp::carp} if not $SIG{__WARN__};
      # shortcut for the common case of no type character
      *{"$callpkg\::$_"} = \&{"$pkg\::$_"} foreach @_;
    }
    
    # Default methods
    
    sub export_fail {
        my $self = shift;
        @_;
    }
    
    # Unfortunately, caller(1)[3] "does not work" if the caller is aliased as
    # *name = \&foo.  Thus the need to create a lot of identical subroutines
    # Otherwise we could have aliased them to export().
    
    sub export_to_level {
      goto &{as_heavy()};
    }
    
    sub export_tags {
      goto &{as_heavy()};
    }
    
    sub export_ok_tags {
      goto &{as_heavy()};
    }
    
    sub require_version {
      goto &{as_heavy()};
    }
    
    1;
    __END__
    
    =head1 NAME
    
    Exporter - Implements default import method for modules
    
    =head1 SYNOPSIS
    
    In module F<YourModule.pm>:
    
      package YourModule;
      require Exporter;
      @ISA = qw(Exporter);
      @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    
    or
    
      package YourModule;
      use Exporter 'import'; # gives you Exporter's import() method directly
      @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
    
    In other files which wish to use C<YourModule>:
    
      use YourModule qw(frobnicate);      # import listed symbols
      frobnicate ($left, $right)          # calls YourModule::frobnicate
    
    Take a look at L</Good Practices> for some variants
    you will like to use in modern Perl code.
    
    =head1 DESCRIPTION
    
    The Exporter module implements an C<import> method which allows a module
    to export functions and variables to its users' namespaces.  Many modules
    use Exporter rather than implementing their own C<import> method because
    Exporter provides a highly flexible interface, with an implementation optimised
    for the common case.
    
    Perl automatically calls the C<import> method when processing a
    C<use> statement for a module.  Modules and C<use> are documented
    in L<perlfunc> and L<perlmod>.  Understanding the concept of
    modules and how the C<use> statement operates is important to
    understanding the Exporter.
    
    =head2 How to Export
    
    The arrays C<@EXPORT> and C<@EXPORT_OK> in a module hold lists of
    symbols that are going to be exported into the users name space by
    default, or which they can request to be exported, respectively.  The
    symbols can represent functions, scalars, arrays, hashes, or typeglobs.
    The symbols must be given by full name with the exception that the
    ampersand in front of a function is optional, e.g.
    
        @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
        @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
    
    If you are only exporting function names it is recommended to omit the
    ampersand, as the implementation is faster this way.
    
    =head2 Selecting What to Export
    
    Do B<not> export method names!
    
    Do B<not> export anything else by default without a good reason!
    
    Exports pollute the namespace of the module user.  If you must export
    try to use C<@EXPORT_OK> in preference to C<@EXPORT> and avoid short or
    common symbol names to reduce the risk of name clashes.
    
    Generally anything not exported is still accessible from outside the
    module using the C<YourModule::item_name> (or C<< $blessed_ref->method >>)
    syntax.  By convention you can use a leading underscore on names to
    informally indicate that they are 'internal' and not for public use.
    
    (It is actually possible to get private functions by saying:
    
      my $subref = sub { ... };
      $subref->(@args);            # Call it as a function
      $obj->$subref(@args);        # Use it as a method
    
    However if you use them for methods it is up to you to figure out
    how to make inheritance work.)
    
    As a general rule, if the module is trying to be object oriented
    then export nothing.  If it's just a collection of functions then
    C<@EXPORT_OK> anything but use C<@EXPORT> with caution.  For function and
    method names use barewords in preference to names prefixed with
    ampersands for the export lists.
    
    Other module design guidelines can be found in L<perlmod>.
    
    =head2 How to Import
    
    In other files which wish to use your module there are three basic ways for
    them to load your module and import its symbols:
    
    =over 4
    
    =item C<use YourModule;>
    
    This imports all the symbols from YourModule's C<@EXPORT> into the namespace
    of the C<use> statement.
    
    =item C<use YourModule ();>
    
    This causes perl to load your module but does not import any symbols.
    
    =item C<use YourModule qw(...);>
    
    This imports only the symbols listed by the caller into their namespace.
    All listed symbols must be in your C<@EXPORT> or C<@EXPORT_OK>, else an error
    occurs.  The advanced export features of Exporter are accessed like this,
    but with list entries that are syntactically distinct from symbol names.
    
    =back
    
    Unless you want to use its advanced features, this is probably all you
    need to know to use Exporter.
    
    =head1 Advanced Features
    
    =head2 Specialised Import Lists
    
    If any of the entries in an import list begins with !, : or / then
    the list is treated as a series of specifications which either add to
    or delete from the list of names to import.  They are processed left to
    right. Specifications are in the form:
    
        [!]name         This name only
        [!]:DEFAULT     All names in @EXPORT
        [!]:tag         All names in $EXPORT_TAGS{tag} anonymous list
        [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
    
    A leading ! indicates that matching names should be deleted from the
    list of names to import.  If the first specification is a deletion it
    is treated as though preceded by :DEFAULT.  If you just want to import
    extra names in addition to the default set you will still need to
    include :DEFAULT explicitly.
    
    e.g., F<Module.pm> defines:
    
        @EXPORT      = qw(A1 A2 A3 A4 A5);
        @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
        %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
    
    Note that you cannot use tags in @EXPORT or @EXPORT_OK.
    
    Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
    
    An application using Module can say something like:
    
        use Module qw(:DEFAULT :T2 !B3 A3);
    
    Other examples include:
    
        use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
        use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
    
    Remember that most patterns (using //) will need to be anchored
    with a leading ^, e.g., C</^EXIT/> rather than C</EXIT/>.
    
    You can say C<BEGIN { $Exporter::Verbose=1 }> to see how the
    specifications are being processed and what is actually being imported
    into modules.
    
    =head2 Exporting Without Using Exporter's import Method
    
    Exporter has a special method, 'export_to_level' which is used in situations
    where you can't directly call Exporter's
    import method.  The export_to_level
    method looks like:
    
        MyPackage->export_to_level(
    	$where_to_export, $package, @what_to_export
        );
    
    where C<$where_to_export> is an integer telling how far up the calling stack
    to export your symbols, and C<@what_to_export> is an array telling what
    symbols *to* export (usually this is C<@_>).  The C<$package> argument is
    currently unused.
    
    For example, suppose that you have a module, A, which already has an
    import function:
    
        package A;
    
        @ISA = qw(Exporter);
        @EXPORT_OK = qw ($b);
    
        sub import
        {
    	$A::b = 1;     # not a very useful import method
        }
    
    and you want to Export symbol C<$A::b> back to the module that called 
    package A.  Since Exporter relies on the import method to work, via 
    inheritance, as it stands Exporter::import() will never get called. 
    Instead, say the following:
    
        package A;
        @ISA = qw(Exporter);
        @EXPORT_OK = qw ($b);
    
        sub import
        {
    	$A::b = 1;
    	A->export_to_level(1, @_);
        }
    
    This will export the symbols one level 'above' the current package - ie: to 
    the program or module that used package A. 
    
    Note: Be careful not to modify C<@_> at all before you call export_to_level
    - or people using your package will get very unexplained results!
    
    =head2 Exporting Without Inheriting from Exporter
    
    By including Exporter in your C<@ISA> you inherit an Exporter's import() method
    but you also inherit several other helper methods which you probably don't
    want.  To avoid this you can do
    
      package YourModule;
      use Exporter qw( import );
    
    which will export Exporter's own import() method into YourModule.
    Everything will work as before but you won't need to include Exporter in
    C<@YourModule::ISA>.
    
    Note: This feature was introduced in version 5.57
    of Exporter, released with perl 5.8.3.
    
    =head2 Module Version Checking
    
    The Exporter module will convert an attempt to import a number from a
    module into a call to C<< $module_name->VERSION($value) >>.  This can
    be used to validate that the version of the module being used is
    greater than or equal to the required version.
    
    For historical reasons, Exporter supplies a C<require_version> method that
    simply delegates to C<VERSION>.  Originally, before C<UNIVERSAL::VERSION>
    existed, Exporter would call C<require_version>.
    
    Since the C<UNIVERSAL::VERSION> method treats the C<$VERSION> number as
    a simple numeric value it will regard version 1.10 as lower than
    1.9.  For this reason it is strongly recommended that you use numbers
    with at least two decimal places, e.g., 1.09.
    
    =head2 Managing Unknown Symbols
    
    In some situations you may want to prevent certain symbols from being
    exported.  Typically this applies to extensions which have functions
    or constants that may not exist on some systems.
    
    The names of any symbols that cannot be exported should be listed
    in the C<@EXPORT_FAIL> array.
    
    If a module attempts to import any of these symbols the Exporter
    will give the module an opportunity to handle the situation before
    generating an error.  The Exporter will call an export_fail method
    with a list of the failed symbols:
    
      @failed_symbols = $module_name->export_fail(@failed_symbols);
    
    If the C<export_fail> method returns an empty list then no error is
    recorded and all the requested symbols are exported.  If the returned
    list is not empty then an error is generated for each symbol and the
    export fails.  The Exporter provides a default C<export_fail> method which
    simply returns the list unchanged.
    
    Uses for the C<export_fail> method include giving better error messages
    for some symbols and performing lazy architectural checks (put more
    symbols into C<@EXPORT_FAIL> by default and then take them out if someone
    actually tries to use them and an expensive check shows that they are
    usable on that platform).
    
    =head2 Tag Handling Utility Functions
    
    Since the symbols listed within C<%EXPORT_TAGS> must also appear in either
    C<@EXPORT> or C<@EXPORT_OK>, two utility functions are provided which allow
    you to easily add tagged sets of symbols to C<@EXPORT> or C<@EXPORT_OK>:
    
      %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
    
      Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
      Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
    
    Any names which are not tags are added to C<@EXPORT> or C<@EXPORT_OK>
    unchanged but will trigger a warning (with C<-w>) to avoid misspelt tags
    names being silently added to C<@EXPORT> or C<@EXPORT_OK>.  Future versions
    may make this a fatal error.
    
    =head2 Generating Combined Tags
    
    If several symbol categories exist in C<%EXPORT_TAGS>, it's usually
    useful to create the utility ":all" to simplify "use" statements.
    
    The simplest way to do this is:
    
      %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
    
      # add all the other ":class" tags to the ":all" class,
      # deleting duplicates
      {
        my %seen;
    
        push @{$EXPORT_TAGS{all}},
          grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
      }
    
    F<CGI.pm> creates an ":all" tag which contains some (but not really
    all) of its categories.  That could be done with one small
    change:
    
      # add some of the other ":class" tags to the ":all" class,
      # deleting duplicates
      {
        my %seen;
    
        push @{$EXPORT_TAGS{all}},
          grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
            foreach qw/html2 html3 netscape form cgi internal/;
      }
    
    Note that the tag names in C<%EXPORT_TAGS> don't have the leading ':'.
    
    =head2 C<AUTOLOAD>ed Constants
    
    Many modules make use of C<AUTOLOAD>ing for constant subroutines to
    avoid having to compile and waste memory on rarely used values (see
    L<perlsub> for details on constant subroutines).  Calls to such
    constant subroutines are not optimized away at compile time because
    they can't be checked at compile time for constancy.
    
    Even if a prototype is available at compile time, the body of the
    subroutine is not (it hasn't been C<AUTOLOAD>ed yet).  perl needs to
    examine both the C<()> prototype and the body of a subroutine at
    compile time to detect that it can safely replace calls to that
    subroutine with the constant value.
    
    A workaround for this is to call the constants once in a C<BEGIN> block:
    
       package My ;
    
       use Socket ;
    
       foo( SO_LINGER );  ## SO_LINGER NOT optimized away; called at runtime
       BEGIN { SO_LINGER }
       foo( SO_LINGER );  ## SO_LINGER optimized away at compile time.
    
    This forces the C<AUTOLOAD> for C<SO_LINGER> to take place before
    SO_LINGER is encountered later in C<My> package.
    
    If you are writing a package that C<AUTOLOAD>s, consider forcing
    an C<AUTOLOAD> for any constants explicitly imported by other packages
    or which are usually used when your package is C<use>d.
    
    =head1 Good Practices
    
    =head2 Declaring C<@EXPORT_OK> and Friends
    
    When using C<Exporter> with the standard C<strict> and C<warnings>
    pragmas, the C<our> keyword is needed to declare the package
    variables C<@EXPORT_OK>, C<@EXPORT>, C<@ISA>, etc.
    
      our @ISA = qw(Exporter);
      our @EXPORT_OK = qw(munge frobnicate);
    
    If backward compatibility for Perls under 5.6 is important,
    one must write instead a C<use vars> statement.
    
      use vars qw(@ISA @EXPORT_OK);
      @ISA = qw(Exporter);
      @EXPORT_OK = qw(munge frobnicate);
    
    =head2 Playing Safe
    
    There are some caveats with the use of runtime statements
    like C<require Exporter> and the assignment to package
    variables, which can very subtle for the unaware programmer.
    This may happen for instance with mutually recursive
    modules, which are affected by the time the relevant
    constructions are executed.
    
    The ideal (but a bit ugly) way to never have to think
    about that is to use C<BEGIN> blocks.  So the first part
    of the L</SYNOPSIS> code could be rewritten as:
    
      package YourModule;
    
      use strict;
      use warnings;
    
      our (@ISA, @EXPORT_OK);
      BEGIN {
         require Exporter;
         @ISA = qw(Exporter);
         @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
      }
    
    The C<BEGIN> will assure that the loading of F<Exporter.pm>
    and the assignments to C<@ISA> and C<@EXPORT_OK> happen
    immediately, leaving no room for something to get awry
    or just plain wrong.
    
    With respect to loading C<Exporter> and inheriting, there
    are alternatives with the use of modules like C<base> and C<parent>.
    
      use base qw( Exporter );
      # or
      use parent qw( Exporter );
    
    Any of these statements are nice replacements for
    C<BEGIN { require Exporter; @ISA = qw(Exporter); }>
    with the same compile-time effect.  The basic difference
    is that C<base> code interacts with declared C<fields>
    while C<parent> is a streamlined version of the older
    C<base> code to just establish the IS-A relationship.
    
    For more details, see the documentation and code of
    L<base> and L<parent>.
    
    Another thorough remedy to that runtime
    vs. compile-time trap is to use L<Exporter::Easy>,
    which is a wrapper of Exporter that allows all
    boilerplate code at a single gulp in the
    use statement.
    
       use Exporter::Easy (
           OK => [ qw(munge frobnicate) ],
       );
       # @ISA setup is automatic
       # all assignments happen at compile time
    
    =head2 What Not to Export
    
    You have been warned already in L</Selecting What to Export>
    to not export:
    
    =over 4
    
    =item *
    
    method names (because you don't need to
    and that's likely to not do what you want),
    
    =item *
    
    anything by default (because you don't want to surprise your users...
    badly)
    
    =item *
    
    anything you don't need to (because less is more)
    
    =back
    
    There's one more item to add to this list.  Do B<not>
    export variable names.  Just because C<Exporter> lets you
    do that, it does not mean you should.
    
      @EXPORT_OK = qw( $svar @avar %hvar ); # DON'T!
    
    Exporting variables is not a good idea.  They can
    change under the hood, provoking horrible
    effects at-a-distance, that are too hard to track
    and to fix.  Trust me: they are not worth it.
    
    To provide the capability to set/get class-wide
    settings, it is best instead to provide accessors
    as subroutines or class methods instead.
    
    =head1 SEE ALSO
    
    C<Exporter> is definitely not the only module with
    symbol exporter capabilities.  At CPAN, you may find
    a bunch of them.  Some are lighter.  Some
    provide improved APIs and features.  Peek the one
    that fits your needs.  The following is
    a sample list of such modules.
    
        Exporter::Easy
        Exporter::Lite
        Exporter::Renaming
        Exporter::Tidy
        Sub::Exporter / Sub::Installer
        Perl6::Export / Perl6::Export::Attrs
    
    =head1 LICENSE
    
    This library is free software.  You can redistribute it
    and/or modify it under the same terms as Perl itself.
    
    =cut
    
    
    
  EXPORTER
  
  $fatpacked{"Exporter/Heavy.pm"} = <<'EXPORTER_HEAVY';
    package Exporter::Heavy;
    
    use strict;
    no strict 'refs';
    
    # On one line so MakeMaker will see it.
    require Exporter;  our $VERSION = $Exporter::VERSION;
    
    =head1 NAME
    
    Exporter::Heavy - Exporter guts
    
    =head1 SYNOPSIS
    
    (internal use only)
    
    =head1 DESCRIPTION
    
    No user-serviceable parts inside.
    
    =cut
    
    #
    # We go to a lot of trouble not to 'require Carp' at file scope,
    #  because Carp requires Exporter, and something has to give.
    #
    
    sub _rebuild_cache {
        my ($pkg, $exports, $cache) = @_;
        s/^&// foreach @$exports;
        @{$cache}{@$exports} = (1) x @$exports;
        my $ok = \@{"${pkg}::EXPORT_OK"};
        if (@$ok) {
    	s/^&// foreach @$ok;
    	@{$cache}{@$ok} = (1) x @$ok;
        }
    }
    
    sub heavy_export {
    
        # First make import warnings look like they're coming from the "use".
        local $SIG{__WARN__} = sub {
    	my $text = shift;
    	if ($text =~ s/ at \S*Exporter\S*.pm line \d+.*\n//) {
    	    require Carp;
    	    local $Carp::CarpLevel = 1;	# ignore package calling us too.
    	    Carp::carp($text);
    	}
    	else {
    	    warn $text;
    	}
        };
        local $SIG{__DIE__} = sub {
    	require Carp;
    	local $Carp::CarpLevel = 1;	# ignore package calling us too.
    	Carp::croak("$_[0]Illegal null symbol in \@${1}::EXPORT")
    	    if $_[0] =~ /^Unable to create sub named "(.*?)::"/;
        };
    
        my($pkg, $callpkg, @imports) = @_;
        my($type, $sym, $cache_is_current, $oops);
        my($exports, $export_cache) = (\@{"${pkg}::EXPORT"},
                                       $Exporter::Cache{$pkg} ||= {});
    
        if (@imports) {
    	if (!%$export_cache) {
    	    _rebuild_cache ($pkg, $exports, $export_cache);
    	    $cache_is_current = 1;
    	}
    
    	if (grep m{^[/!:]}, @imports) {
    	    my $tagsref = \%{"${pkg}::EXPORT_TAGS"};
    	    my $tagdata;
    	    my %imports;
    	    my($remove, $spec, @names, @allexports);
    	    # negated first item implies starting with default set:
    	    unshift @imports, ':DEFAULT' if $imports[0] =~ m/^!/;
    	    foreach $spec (@imports){
    		$remove = $spec =~ s/^!//;
    
    		if ($spec =~ s/^://){
    		    if ($spec eq 'DEFAULT'){
    			@names = @$exports;
    		    }
    		    elsif ($tagdata = $tagsref->{$spec}) {
    			@names = @$tagdata;
    		    }
    		    else {
    			warn qq["$spec" is not defined in %${pkg}::EXPORT_TAGS];
    			++$oops;
    			next;
    		    }
    		}
    		elsif ($spec =~ m:^/(.*)/$:){
    		    my $patn = $1;
    		    @allexports = keys %$export_cache unless @allexports; # only do keys once
    		    @names = grep(/$patn/, @allexports); # not anchored by default
    		}
    		else {
    		    @names = ($spec); # is a normal symbol name
    		}
    
    		warn "Import ".($remove ? "del":"add").": @names "
    		    if $Exporter::Verbose;
    
    		if ($remove) {
    		   foreach $sym (@names) { delete $imports{$sym} } 
    		}
    		else {
    		    @imports{@names} = (1) x @names;
    		}
    	    }
    	    @imports = keys %imports;
    	}
    
            my @carp;
    	foreach $sym (@imports) {
    	    if (!$export_cache->{$sym}) {
    		if ($sym =~ m/^\d/) {
    		    $pkg->VERSION($sym); # inherit from UNIVERSAL
    		    # If the version number was the only thing specified
    		    # then we should act as if nothing was specified:
    		    if (@imports == 1) {
    			@imports = @$exports;
    			last;
    		    }
    		    # We need a way to emulate 'use Foo ()' but still
    		    # allow an easy version check: "use Foo 1.23, ''";
    		    if (@imports == 2 and !$imports[1]) {
    			@imports = ();
    			last;
    		    }
    		} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {
    		    # Last chance - see if they've updated EXPORT_OK since we
    		    # cached it.
    
    		    unless ($cache_is_current) {
    			%$export_cache = ();
    			_rebuild_cache ($pkg, $exports, $export_cache);
    			$cache_is_current = 1;
    		    }
    
    		    if (!$export_cache->{$sym}) {
    			# accumulate the non-exports
    			push @carp,
    			  qq["$sym" is not exported by the $pkg module\n];
    			$oops++;
    		    }
    		}
    	    }
    	}
    	if ($oops) {
    	    require Carp;
    	    Carp::croak("@{carp}Can't continue after import errors");
    	}
        }
        else {
    	@imports = @$exports;
        }
    
        my($fail, $fail_cache) = (\@{"${pkg}::EXPORT_FAIL"},
                                  $Exporter::FailCache{$pkg} ||= {});
    
        if (@$fail) {
    	if (!%$fail_cache) {
    	    # Build cache of symbols. Optimise the lookup by adding
    	    # barewords twice... both with and without a leading &.
    	    # (Technique could be applied to $export_cache at cost of memory)
    	    my @expanded = map { /^\w/ ? ($_, '&'.$_) : $_ } @$fail;
    	    warn "${pkg}::EXPORT_FAIL cached: @expanded" if $Exporter::Verbose;
    	    @{$fail_cache}{@expanded} = (1) x @expanded;
    	}
    	my @failed;
    	foreach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }
    	if (@failed) {
    	    @failed = $pkg->export_fail(@failed);
    	    foreach $sym (@failed) {
                    require Carp;
    		Carp::carp(qq["$sym" is not implemented by the $pkg module ],
    			"on this architecture");
    	    }
    	    if (@failed) {
    		require Carp;
    		Carp::croak("Can't continue after import errors");
    	    }
    	}
        }
    
        warn "Importing into $callpkg from $pkg: ",
    		join(", ",sort @imports) if $Exporter::Verbose;
    
        foreach $sym (@imports) {
    	# shortcut for the common case of no type character
    	(*{"${callpkg}::$sym"} = \&{"${pkg}::$sym"}, next)
    	    unless $sym =~ s/^(\W)//;
    	$type = $1;
    	no warnings 'once';
    	*{"${callpkg}::$sym"} =
    	    $type eq '&' ? \&{"${pkg}::$sym"} :
    	    $type eq '$' ? \${"${pkg}::$sym"} :
    	    $type eq '@' ? \@{"${pkg}::$sym"} :
    	    $type eq '%' ? \%{"${pkg}::$sym"} :
    	    $type eq '*' ?  *{"${pkg}::$sym"} :
    	    do { require Carp; Carp::croak("Can't export symbol: $type$sym") };
        }
    }
    
    sub heavy_export_to_level
    {
          my $pkg = shift;
          my $level = shift;
          (undef) = shift;			# XXX redundant arg
          my $callpkg = caller($level);
          $pkg->export($callpkg, @_);
    }
    
    # Utility functions
    
    sub _push_tags {
        my($pkg, $var, $syms) = @_;
        my @nontag = ();
        my $export_tags = \%{"${pkg}::EXPORT_TAGS"};
        push(@{"${pkg}::$var"},
    	map { $export_tags->{$_} ? @{$export_tags->{$_}} 
                                     : scalar(push(@nontag,$_),$_) }
    		(@$syms) ? @$syms : keys %$export_tags);
        if (@nontag and $^W) {
    	# This may change to a die one day
    	require Carp;
    	Carp::carp(join(", ", @nontag)." are not tags of $pkg");
        }
    }
    
    sub heavy_require_version {
        my($self, $wanted) = @_;
        my $pkg = ref $self || $self;
        return ${pkg}->VERSION($wanted);
    }
    
    sub heavy_export_tags {
      _push_tags((caller)[0], "EXPORT",    \@_);
    }
    
    sub heavy_export_ok_tags {
      _push_tags((caller)[0], "EXPORT_OK", \@_);
    }
    
    1;
  EXPORTER_HEAVY
  
  $fatpacked{"File/pushd.pm"} = <<'FILE_PUSHD';
    use strict;
    use warnings;
    package File::pushd;
    # ABSTRACT: change directory temporarily for a limited scope
    our $VERSION = '1.005'; # VERSION
    
    our @EXPORT  = qw( pushd tempd );
    our @ISA     = qw( Exporter );
    
    use Exporter;
    use Carp;
    use Cwd         qw( getcwd abs_path );
    use File::Path  qw( rmtree );
    use File::Temp  qw();
    use File::Spec;
    
    use overload
        q{""} => sub { File::Spec->canonpath( $_[0]->{_pushd} ) },
        fallback => 1;
    
    #--------------------------------------------------------------------------#
    # pushd()
    #--------------------------------------------------------------------------#
    
    sub pushd {
        my ($target_dir, $options) = @_;
        $options->{untaint_pattern} ||= qr{^([-+@\w./]+)$};
    
        $target_dir = "." unless defined $target_dir;
        croak "Can't locate directory $target_dir" unless -d $target_dir;
    
        my $tainted_orig = getcwd;
        my $orig;
        if ( $tainted_orig =~ $options->{untaint_pattern} ) {
          $orig = $1;
        }
        else {
          $orig = $tainted_orig;
        }
    
        my $tainted_dest;
        eval { $tainted_dest   = $target_dir ? abs_path( $target_dir ) : $orig };
        croak "Can't locate absolute path for $target_dir: $@" if $@;
    
        my $dest;
        if ( $tainted_dest =~ $options->{untaint_pattern} ) {
          $dest = $1;
        }
        else {
          $dest = $tainted_dest;
        }
    
        if ($dest ne $orig) {
            chdir $dest or croak "Can't chdir to $dest\: $!";
        }
    
        my $self = bless {
            _pushd => $dest,
            _original => $orig
        }, __PACKAGE__;
    
        return $self;
    }
    
    #--------------------------------------------------------------------------#
    # tempd()
    #--------------------------------------------------------------------------#
    
    sub tempd {
        my ($options) = @_;
        my $dir;
        eval { $dir = pushd( File::Temp::tempdir( CLEANUP => 0 ), $options ) };
        croak $@ if $@;
        $dir->{_tempd} = 1;
        return $dir;
    }
    
    #--------------------------------------------------------------------------#
    # preserve()
    #--------------------------------------------------------------------------#
    
    sub preserve {
        my $self = shift;
        return 1 if ! $self->{"_tempd"};
        if ( @_ == 0 ) {
            return $self->{_preserve} = 1;
        }
        else {
            return $self->{_preserve} = $_[0] ? 1 : 0;
        }
    }
    
    #--------------------------------------------------------------------------#
    # DESTROY()
    # Revert to original directory as object is destroyed and cleanup
    # if necessary
    #--------------------------------------------------------------------------#
    
    sub DESTROY {
        my ($self) = @_;
        my $orig = $self->{_original};
        chdir $orig if $orig; # should always be so, but just in case...
        if ( $self->{_tempd} &&
            !$self->{_preserve} ) {
            # don't destroy existing $@ if there is no error.
            my $err = do {
                local $@;
                eval { rmtree( $self->{_pushd} ) };
                $@;
            };
            carp $err if $err;
        }
    }
    
    1;
    
    __END__
    
    =pod
    
    =head1 NAME
    
    File::pushd - change directory temporarily for a limited scope
    
    =head1 VERSION
    
    version 1.005
    
    =head1 SYNOPSIS
    
      use File::pushd;
     
      chdir $ENV{HOME};
     
      # change directory again for a limited scope
      {
          my $dir = pushd( '/tmp' );
          # working directory changed to /tmp
      }
      # working directory has reverted to $ENV{HOME}
     
      # tempd() is equivalent to pushd( File::Temp::tempdir )
      {
          my $dir = tempd();
      }
     
      # object stringifies naturally as an absolute path
      {
         my $dir = pushd( '/tmp' );
         my $filename = File::Spec->catfile( $dir, "somefile.txt" );
         # gives /tmp/somefile.txt
      }
    
    =head1 DESCRIPTION
    
    File::pushd does a temporary C<<< chdir >>> that is easily and automatically
    reverted, similar to C<<< pushd >>> in some Unix command shells.  It works by
    creating an object that caches the original working directory.  When the object
    is destroyed, the destructor calls C<<< chdir >>> to revert to the original working
    directory.  By storing the object in a lexical variable with a limited scope,
    this happens automatically at the end of the scope.
    
    This is very handy when working with temporary directories for tasks like
    testing; a function is provided to streamline getting a temporary
    directory from L<File::Temp>.
    
    For convenience, the object stringifies as the canonical form of the absolute
    pathname of the directory entered.
    
    =head1 USAGE
    
      use File::pushd;
    
    Using File::pushd automatically imports the C<<< pushd >>> and C<<< tempd >>> functions.
    
    =head2 pushd
    
      {
          my $dir = pushd( $target_directory );
      }
    
    Caches the current working directory, calls C<<< chdir >>> to change to the target
    directory, and returns a File::pushd object.  When the object is
    destroyed, the working directory reverts to the original directory.
    
    The provided target directory can be a relative or absolute path. If
    called with no arguments, it uses the current directory as its target and
    returns to the current directory when the object is destroyed.
    
    If the target directory does not exist or if the directory change fails
    for some reason, C<<< pushd >>> will die with an error message.
    
    Can be given a hashref as an optional second argument.  The only supported
    option is C<<< untaint_pattern >>>, which is used to untaint file paths involved.
    It defaults to C<<< qr{^([-+@\w./]+)$} >>>, which is reasonably restrictive (e.g.
    it does not even allow spaces in the path).  Change this to suit your
    circumstances and security needs if running under taint mode. B<Note>: you
    must include the parentheses in the pattern to capture the untainted
    portion of the path.
    
    =head2 tempd
    
      {
          my $dir = tempd();
      }
    
    This function is like C<<< pushd >>> but automatically creates and calls C<<< chdir >>> to
    a temporary directory created by L<File::Temp>. Unlike normal L<File::Temp>
    cleanup which happens at the end of the program, this temporary directory is
    removed when the object is destroyed. (But also see C<<< preserve >>>.)  A warning
    will be issued if the directory cannot be removed.
    
    As with C<<< pushd >>>, C<<< tempd >>> will die if C<<< chdir >>> fails.
    
    It may be given a single options hash that will be passed internally
    to CE<lt>pushdE<gt>.
    
    =head2 preserve
    
      {
          my $dir = tempd();
          $dir->preserve;      # mark to preserve at end of scope
          $dir->preserve(0);   # mark to delete at end of scope
      }
    
    Controls whether a temporary directory will be cleaned up when the object is
    destroyed.  With no arguments, C<<< preserve >>> sets the directory to be preserved.
    With an argument, the directory will be preserved if the argument is true, or
    marked for cleanup if the argument is false.  Only C<<< tempd >>> objects may be
    marked for cleanup.  (Target directories to C<<< pushd >>> are always preserved.)
    C<<< preserve >>> returns true if the directory will be preserved, and false
    otherwise.
    
    =head1 SEE ALSO
    
    =over
    
    =item *
    
    L<File::chdir>
    
    =back
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<https://github.com/dagolden/file-pushd/issues>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/dagolden/file-pushd>
    
      git clone git://github.com/dagolden/file-pushd.git
    
    =head1 AUTHOR
    
    David Golden <dagolden@cpan.org>
    
    =head1 CONTRIBUTOR
    
    Diab Jerius <djerius@cfa.harvard.edu>
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is Copyright (c) 2013 by David A Golden.
    
    This is free software, licensed under:
    
      The Apache License, Version 2.0, January 2004
    
    =cut
  FILE_PUSHD
  
  $fatpacked{"HTTP/Tiny.pm"} = <<'HTTP_TINY';
    # vim: ts=4 sts=4 sw=4 et:
    package HTTP::Tiny;
    use strict;
    use warnings;
    # ABSTRACT: A small, simple, correct HTTP/1.1 client
    our $VERSION = '0.034'; # VERSION
    
    use Carp ();
    
    
    my @attributes;
    BEGIN {
        @attributes = qw(cookie_jar default_headers local_address max_redirect max_size proxy no_proxy timeout SSL_options verify_SSL);
        no strict 'refs';
        for my $accessor ( @attributes ) {
            *{$accessor} = sub {
                @_ > 1 ? $_[0]->{$accessor} = $_[1] : $_[0]->{$accessor};
            };
        }
    }
    
    sub agent {
        my($self, $agent) = @_;
        if( @_ > 1 ){
            $self->{agent} =
                (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
        }
        return $self->{agent};
    }
    
    sub new {
        my($class, %args) = @_;
    
        my $self = {
            max_redirect => 5,
            timeout      => 60,
            verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
            no_proxy     => $ENV{no_proxy},
        };
    
        bless $self, $class;
    
        $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
    
        for my $key ( @attributes ) {
            $self->{$key} = $args{$key} if exists $args{$key}
        }
    
        $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
    
        # Never override proxy argument as this breaks backwards compat.
        if (!exists $self->{proxy} && (my $http_proxy = $ENV{http_proxy})) {
            if ($http_proxy =~ m{\Ahttp://[^/?#:@]+:\d+/?\z}) {
                $self->{proxy} = $http_proxy;
            }
            else {
                Carp::croak(qq{Environment 'http_proxy' must be in format http://<host>:<port>/\n});
            }
        }
    
        # Split no_proxy to array reference if not provided as such
        unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
            $self->{no_proxy} =
                (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
        }
    
        return $self;
    }
    
    
    for my $sub_name ( qw/get head put post delete/ ) {
        my $req_method = uc $sub_name;
        no strict 'refs';
        eval <<"HERE"; ## no critic
        sub $sub_name {
            my (\$self, \$url, \$args) = \@_;
            \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
            or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
            return \$self->request('$req_method', \$url, \$args || {});
        }
    HERE
    }
    
    
    sub post_form {
        my ($self, $url, $data, $args) = @_;
        (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
            or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
    
        my $headers = {};
        while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
            $headers->{lc $key} = $value;
        }
        delete $args->{headers};
    
        return $self->request('POST', $url, {
                %$args,
                content => $self->www_form_urlencode($data),
                headers => {
                    %$headers,
                    'content-type' => 'application/x-www-form-urlencoded'
                },
            }
        );
    }
    
    
    sub mirror {
        my ($self, $url, $file, $args) = @_;
        @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
        if ( -e $file and my $mtime = (stat($file))[9] ) {
            $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
        }
        my $tempfile = $file . int(rand(2**31));
        open my $fh, ">", $tempfile
            or Carp::croak(qq/Error: Could not open temporary file $tempfile for downloading: $!\n/);
        binmode $fh;
        $args->{data_callback} = sub { print {$fh} $_[0] };
        my $response = $self->request('GET', $url, $args);
        close $fh
            or Carp::croak(qq/Error: Could not close temporary file $tempfile: $!\n/);
        if ( $response->{success} ) {
            rename $tempfile, $file
                or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);
            my $lm = $response->{headers}{'last-modified'};
            if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
                utime $mtime, $mtime, $file;
            }
        }
        $response->{success} ||= $response->{status} eq '304';
        unlink $tempfile;
        return $response;
    }
    
    
    my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
    
    sub request {
        my ($self, $method, $url, $args) = @_;
        @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
        $args ||= {}; # we keep some state in this during _request
    
        # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
        my $response;
        for ( 0 .. 1 ) {
            $response = eval { $self->_request($method, $url, $args) };
            last unless $@ && $idempotent{$method}
                && $@ =~ m{^(?:Socket closed|Unexpected end)};
        }
    
        if (my $e = "$@") {
            $response = {
                url     => $url,
                success => q{},
                status  => 599,
                reason  => 'Internal Exception',
                content => $e,
                headers => {
                    'content-type'   => 'text/plain',
                    'content-length' => length $e,
                }
            };
        }
        return $response;
    }
    
    
    sub www_form_urlencode {
        my ($self, $data) = @_;
        (@_ == 2 && ref $data)
            or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
        (ref $data eq 'HASH' || ref $data eq 'ARRAY')
            or Carp::croak("form data must be a hash or array reference\n");
    
        my @params = ref $data eq 'HASH' ? %$data : @$data;
        @params % 2 == 0
            or Carp::croak("form data reference must have an even number of terms\n");
    
        my @terms;
        while( @params ) {
            my ($key, $value) = splice(@params, 0, 2);
            if ( ref $value eq 'ARRAY' ) {
                unshift @params, map { $key => $_ } @$value;
            }
            else {
                push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
            }
        }
    
        return join("&", sort @terms);
    }
    
    #--------------------------------------------------------------------------#
    # private methods
    #--------------------------------------------------------------------------#
    
    my %DefaultPort = (
        http => 80,
        https => 443,
    );
    
    sub _agent {
        my $class = ref($_[0]) || $_[0];
        (my $default_agent = $class) =~ s{::}{-}g;
        return $default_agent . "/" . ($class->VERSION || 0);
    }
    
    sub _request {
        my ($self, $method, $url, $args) = @_;
    
        my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
    
        my $request = {
            method    => $method,
            scheme    => $scheme,
            host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
            uri       => $path_query,
            headers   => {},
        };
    
        my $handle  = HTTP::Tiny::Handle->new(
            timeout         => $self->{timeout},
            SSL_options     => $self->{SSL_options},
            verify_SSL      => $self->{verify_SSL},
            local_address   => $self->{local_address},
        );
    
        if ($self->{proxy} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
            $request->{uri} = "$scheme://$request->{host_port}$path_query";
            die(qq/HTTPS via proxy is not supported\n/)
                if $request->{scheme} eq 'https';
            $handle->connect(($self->_split_url($self->{proxy}))[0..2]);
        }
        else {
            $handle->connect($scheme, $host, $port);
        }
    
        $self->_prepare_headers_and_cb($request, $args, $url, $auth);
        $handle->write_request($request);
    
        my $response;
        do { $response = $handle->read_response_header }
            until (substr($response->{status},0,1) ne '1');
    
        $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
    
        if ( my @redir_args = $self->_maybe_redirect($request, $response, $args) ) {
            $handle->close;
            return $self->_request(@redir_args, $args);
        }
    
        if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
            # response has no message body
        }
        else {
            my $data_cb = $self->_prepare_data_cb($response, $args);
            $handle->read_body($data_cb, $response);
        }
    
        $handle->close;
        $response->{success} = substr($response->{status},0,1) eq '2';
        $response->{url} = $url;
        return $response;
    }
    
    sub _prepare_headers_and_cb {
        my ($self, $request, $args, $url, $auth) = @_;
    
        for ($self->{default_headers}, $args->{headers}) {
            next unless defined;
            while (my ($k, $v) = each %$_) {
                $request->{headers}{lc $k} = $v;
            }
        }
        $request->{headers}{'host'}         = $request->{host_port};
        $request->{headers}{'connection'}   = "close";
        $request->{headers}{'user-agent'} ||= $self->{agent};
    
        if ( defined $args->{content} ) {
            if (ref $args->{content} eq 'CODE') {
                $request->{headers}{'content-type'} ||= "application/octet-stream";
                $request->{headers}{'transfer-encoding'} = 'chunked'
                  unless $request->{headers}{'content-length'}
                      || $request->{headers}{'transfer-encoding'};
                $request->{cb} = $args->{content};
            }
            elsif ( length $args->{content} ) {
                my $content = $args->{content};
                if ( $] ge '5.008' ) {
                    utf8::downgrade($content, 1)
                        or die(qq/Wide character in request message body\n/);
                }
                $request->{headers}{'content-type'} ||= "application/octet-stream";
                $request->{headers}{'content-length'} = length $content
                  unless $request->{headers}{'content-length'}
                      || $request->{headers}{'transfer-encoding'};
                $request->{cb} = sub { substr $content, 0, length $content, '' };
            }
            $request->{trailer_cb} = $args->{trailer_callback}
                if ref $args->{trailer_callback} eq 'CODE';
        }
    
        ### If we have a cookie jar, then maybe add relevant cookies
        if ( $self->{cookie_jar} ) {
            my $cookies = $self->cookie_jar->cookie_header( $url );
            $request->{headers}{cookie} = $cookies if length $cookies;
        }
    
        # if we have Basic auth parameters, add them
        if ( length $auth && ! defined $request->{headers}{authentication} ) {
            require MIME::Base64;
            $request->{headers}{authorization} =
                "Basic " . MIME::Base64::encode_base64($auth, "");
        }
    
        return;
    }
    
    sub _prepare_data_cb {
        my ($self, $response, $args) = @_;
        my $data_cb = $args->{data_callback};
        $response->{content} = '';
    
        if (!$data_cb || $response->{status} !~ /^2/) {
            if (defined $self->{max_size}) {
                $data_cb = sub {
                    $_[1]->{content} .= $_[0];
                    die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                      if length $_[1]->{content} > $self->{max_size};
                };
            }
            else {
                $data_cb = sub { $_[1]->{content} .= $_[0] };
            }
        }
        return $data_cb;
    }
    
    sub _update_cookie_jar {
        my ($self, $url, $response) = @_;
    
        my $cookies = $response->{headers}->{'set-cookie'};
        return unless defined $cookies;
    
        my @cookies = ref $cookies ? @$cookies : $cookies;
    
        $self->cookie_jar->add( $url, $_ ) for @cookies;
    
        return;
    }
    
    sub _validate_cookie_jar {
        my ($class, $jar) = @_;
    
        # duck typing
        for my $method ( qw/add cookie_header/ ) {
            Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
                unless ref($jar) && ref($jar)->can($method);
        }
    
        return;
    }
    
    sub _maybe_redirect {
        my ($self, $request, $response, $args) = @_;
        my $headers = $response->{headers};
        my ($status, $method) = ($response->{status}, $request->{method});
        if (($status eq '303' or ($status =~ /^30[127]/ && $method =~ /^GET|HEAD$/))
            and $headers->{location}
            and ++$args->{redirects} <= $self->{max_redirect}
        ) {
            my $location = ($headers->{location} =~ /^\//)
                ? "$request->{scheme}://$request->{host_port}$headers->{location}"
                : $headers->{location} ;
            return (($status eq '303' ? 'GET' : $method), $location);
        }
        return;
    }
    
    sub _split_url {
        my $url = pop;
    
        # URI regex adapted from the URI module
        my ($scheme, $authority, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
          or die(qq/Cannot parse URL: '$url'\n/);
    
        $scheme     = lc $scheme;
        $path_query = "/$path_query" unless $path_query =~ m<\A/>;
    
        my ($auth,$host);
        $authority = (length($authority)) ? $authority : 'localhost';
        if ( $authority =~ /@/ ) {
            ($auth,$host) = $authority =~ m/\A([^@]*)@(.*)\z/;   # user:pass@host
        }
        else {
            $host = $authority;
            $auth = '';
        }
        $host = lc $host;
        my $port = do {
           $host =~ s/:([0-9]*)\z// && length $1
             ? $1
             : ($scheme eq 'http' ? 80 : $scheme eq 'https' ? 443 : undef);
        };
    
        return ($scheme, $host, $port, $path_query, $auth);
    }
    
    # Date conversions adapted from HTTP::Date
    my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
    my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
    sub _http_date {
        my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
        return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
            substr($DoW,$wday*4,3),
            $mday, substr($MoY,$mon*4,3), $year+1900,
            $hour, $min, $sec
        );
    }
    
    sub _parse_http_date {
        my ($self, $str) = @_;
        require Time::Local;
        my @tl_parts;
        if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
            @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
        }
        elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
            @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
        }
        elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
            @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
        }
        return eval {
            my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
            $t < 0 ? undef : $t;
        };
    }
    
    # URI escaping adapted from URI::Escape
    # c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
    # perl 5.6 ready UTF-8 encoding adapted from JSON::PP
    my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
    $escapes{' '}="+";
    my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
    
    sub _uri_escape {
        my ($self, $str) = @_;
        if ( $] ge '5.008' ) {
            utf8::encode($str);
        }
        else {
            $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
                if ( length $str == do { use bytes; length $str } );
            $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
        }
        $str =~ s/($unsafe_char)/$escapes{$1}/ge;
        return $str;
    }
    
    package
        HTTP::Tiny::Handle; # hide from PAUSE/indexers
    use strict;
    use warnings;
    
    use Errno      qw[EINTR EPIPE];
    use IO::Socket qw[SOCK_STREAM];
    
    sub BUFSIZE () { 32768 } ## no critic
    
    my $Printable = sub {
        local $_ = shift;
        s/\r/\\r/g;
        s/\n/\\n/g;
        s/\t/\\t/g;
        s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
        $_;
    };
    
    my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
    
    sub new {
        my ($class, %args) = @_;
        return bless {
            rbuf             => '',
            timeout          => 60,
            max_line_size    => 16384,
            max_header_lines => 64,
            verify_SSL       => 0,
            SSL_options      => {},
            %args
        }, $class;
    }
    
    sub connect {
        @_ == 4 || die(q/Usage: $handle->connect(scheme, host, port)/ . "\n");
        my ($self, $scheme, $host, $port) = @_;
    
        if ( $scheme eq 'https' ) {
            # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
            die(qq/IO::Socket::SSL 1.42 must be installed for https support\n/)
                unless eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)};
            # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
            die(qq/Net::SSLeay 1.49 must be installed for https support\n/)
                unless eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)};
        }
        elsif ( $scheme ne 'http' ) {
          die(qq/Unsupported URL scheme '$scheme'\n/);
        }
        $self->{fh} = 'IO::Socket::INET'->new(
            PeerHost  => $host,
            PeerPort  => $port,
            $self->{local_address} ?
                ( LocalAddr => $self->{local_address} ) : (),
            Proto     => 'tcp',
            Type      => SOCK_STREAM,
            Timeout   => $self->{timeout}
        ) or die(qq/Could not connect to '$host:$port': $@\n/);
    
        binmode($self->{fh})
          or die(qq/Could not binmode() socket: '$!'\n/);
    
        if ( $scheme eq 'https') {
            my $ssl_args = $self->_ssl_args($host);
            IO::Socket::SSL->start_SSL(
                $self->{fh},
                %$ssl_args,
                SSL_create_ctx_callback => sub {
                    my $ctx = shift;
                    Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
                },
            );
    
            unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
                my $ssl_err = IO::Socket::SSL->errstr;
                die(qq/SSL connection failed for $host: $ssl_err\n/);
            }
        }
    
        $self->{host} = $host;
        $self->{port} = $port;
    
        return $self;
    }
    
    sub close {
        @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
        my ($self) = @_;
        CORE::close($self->{fh})
          or die(qq/Could not close socket: '$!'\n/);
    }
    
    sub write {
        @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
        my ($self, $buf) = @_;
    
        if ( $] ge '5.008' ) {
            utf8::downgrade($buf, 1)
                or die(qq/Wide character in write()\n/);
        }
    
        my $len = length $buf;
        my $off = 0;
    
        local $SIG{PIPE} = 'IGNORE';
    
        while () {
            $self->can_write
              or die(qq/Timed out while waiting for socket to become ready for writing\n/);
            my $r = syswrite($self->{fh}, $buf, $len, $off);
            if (defined $r) {
                $len -= $r;
                $off += $r;
                last unless $len > 0;
            }
            elsif ($! == EPIPE) {
                die(qq/Socket closed by remote server: $!\n/);
            }
            elsif ($! != EINTR) {
                if ($self->{fh}->can('errstr')){
                    my $err = $self->{fh}->errstr();
                    die (qq/Could not write to SSL socket: '$err'\n /);
                }
                else {
                    die(qq/Could not write to socket: '$!'\n/);
                }
    
            }
        }
        return $off;
    }
    
    sub read {
        @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
        my ($self, $len, $allow_partial) = @_;
    
        my $buf  = '';
        my $got = length $self->{rbuf};
    
        if ($got) {
            my $take = ($got < $len) ? $got : $len;
            $buf  = substr($self->{rbuf}, 0, $take, '');
            $len -= $take;
        }
    
        while ($len > 0) {
            $self->can_read
              or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
            my $r = sysread($self->{fh}, $buf, $len, length $buf);
            if (defined $r) {
                last unless $r;
                $len -= $r;
            }
            elsif ($! != EINTR) {
                if ($self->{fh}->can('errstr')){
                    my $err = $self->{fh}->errstr();
                    die (qq/Could not read from SSL socket: '$err'\n /);
                }
                else {
                    die(qq/Could not read from socket: '$!'\n/);
                }
            }
        }
        if ($len && !$allow_partial) {
            die(qq/Unexpected end of stream\n/);
        }
        return $buf;
    }
    
    sub readline {
        @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
        my ($self) = @_;
    
        while () {
            if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
                return $1;
            }
            if (length $self->{rbuf} >= $self->{max_line_size}) {
                die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
            }
            $self->can_read
              or die(qq/Timed out while waiting for socket to become ready for reading\n/);
            my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
            if (defined $r) {
                last unless $r;
            }
            elsif ($! != EINTR) {
                if ($self->{fh}->can('errstr')){
                    my $err = $self->{fh}->errstr();
                    die (qq/Could not read from SSL socket: '$err'\n /);
                }
                else {
                    die(qq/Could not read from socket: '$!'\n/);
                }
            }
        }
        die(qq/Unexpected end of stream while looking for line\n/);
    }
    
    sub read_header_lines {
        @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
        my ($self, $headers) = @_;
        $headers ||= {};
        my $lines   = 0;
        my $val;
    
        while () {
             my $line = $self->readline;
    
             if (++$lines >= $self->{max_header_lines}) {
                 die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
             }
             elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
                 my ($field_name) = lc $1;
                 if (exists $headers->{$field_name}) {
                     for ($headers->{$field_name}) {
                         $_ = [$_] unless ref $_ eq "ARRAY";
                         push @$_, $2;
                         $val = \$_->[-1];
                     }
                 }
                 else {
                     $val = \($headers->{$field_name} = $2);
                 }
             }
             elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
                 $val
                   or die(qq/Unexpected header continuation line\n/);
                 next unless length $1;
                 $$val .= ' ' if length $$val;
                 $$val .= $1;
             }
             elsif ($line =~ /\A \x0D?\x0A \z/x) {
                last;
             }
             else {
                die(q/Malformed header line: / . $Printable->($line) . "\n");
             }
        }
        return $headers;
    }
    
    sub write_request {
        @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
        my($self, $request) = @_;
        $self->write_request_header(@{$request}{qw/method uri headers/});
        $self->write_body($request) if $request->{cb};
        return;
    }
    
    my %HeaderCase = (
        'content-md5'      => 'Content-MD5',
        'etag'             => 'ETag',
        'te'               => 'TE',
        'www-authenticate' => 'WWW-Authenticate',
        'x-xss-protection' => 'X-XSS-Protection',
    );
    
    sub write_header_lines {
        (@_ == 2 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers)/ . "\n");
        my($self, $headers) = @_;
    
        my $buf = '';
        while (my ($k, $v) = each %$headers) {
            my $field_name = lc $k;
            if (exists $HeaderCase{$field_name}) {
                $field_name = $HeaderCase{$field_name};
            }
            else {
                $field_name =~ /\A $Token+ \z/xo
                  or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
                $field_name =~ s/\b(\w)/\u$1/g;
                $HeaderCase{lc $field_name} = $field_name;
            }
            for (ref $v eq 'ARRAY' ? @$v : $v) {
                /[^\x0D\x0A]/
                  or die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n");
                $buf .= "$field_name: $_\x0D\x0A";
            }
        }
        $buf .= "\x0D\x0A";
        return $self->write($buf);
    }
    
    sub read_body {
        @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
        my ($self, $cb, $response) = @_;
        my $te = $response->{headers}{'transfer-encoding'} || '';
        if ( grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ) {
            $self->read_chunked_body($cb, $response);
        }
        else {
            $self->read_content_body($cb, $response);
        }
        return;
    }
    
    sub write_body {
        @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
        my ($self, $request) = @_;
        if ($request->{headers}{'content-length'}) {
            return $self->write_content_body($request);
        }
        else {
            return $self->write_chunked_body($request);
        }
    }
    
    sub read_content_body {
        @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
        my ($self, $cb, $response, $content_length) = @_;
        $content_length ||= $response->{headers}{'content-length'};
    
        if ( defined $content_length ) {
            my $len = $content_length;
            while ($len > 0) {
                my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
                $cb->($self->read($read, 0), $response);
                $len -= $read;
            }
        }
        else {
            my $chunk;
            $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
        }
    
        return;
    }
    
    sub write_content_body {
        @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
        my ($self, $request) = @_;
    
        my ($len, $content_length) = (0, $request->{headers}{'content-length'});
        while () {
            my $data = $request->{cb}->();
    
            defined $data && length $data
              or last;
    
            if ( $] ge '5.008' ) {
                utf8::downgrade($data, 1)
                    or die(qq/Wide character in write_content()\n/);
            }
    
            $len += $self->write($data);
        }
    
        $len == $content_length
          or die(qq/Content-Length missmatch (got: $len expected: $content_length)\n/);
    
        return $len;
    }
    
    sub read_chunked_body {
        @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
        my ($self, $cb, $response) = @_;
    
        while () {
            my $head = $self->readline;
    
            $head =~ /\A ([A-Fa-f0-9]+)/x
              or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
    
            my $len = hex($1)
              or last;
    
            $self->read_content_body($cb, $response, $len);
    
            $self->read(2) eq "\x0D\x0A"
              or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
        }
        $self->read_header_lines($response->{headers});
        return;
    }
    
    sub write_chunked_body {
        @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
        my ($self, $request) = @_;
    
        my $len = 0;
        while () {
            my $data = $request->{cb}->();
    
            defined $data && length $data
              or last;
    
            if ( $] ge '5.008' ) {
                utf8::downgrade($data, 1)
                    or die(qq/Wide character in write_chunked_body()\n/);
            }
    
            $len += length $data;
    
            my $chunk  = sprintf '%X', length $data;
               $chunk .= "\x0D\x0A";
               $chunk .= $data;
               $chunk .= "\x0D\x0A";
    
            $self->write($chunk);
        }
        $self->write("0\x0D\x0A");
        $self->write_header_lines($request->{trailer_cb}->())
            if ref $request->{trailer_cb} eq 'CODE';
        return $len;
    }
    
    sub read_response_header {
        @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
        my ($self) = @_;
    
        my $line = $self->readline;
    
        $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
          or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
    
        my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
    
        die (qq/Unsupported HTTP protocol: $protocol\n/)
            unless $version =~ /0*1\.0*[01]/;
    
        return {
            status   => $status,
            reason   => $reason,
            headers  => $self->read_header_lines,
            protocol => $protocol,
        };
    }
    
    sub write_request_header {
        @_ == 4 || die(q/Usage: $handle->write_request_header(method, request_uri, headers)/ . "\n");
        my ($self, $method, $request_uri, $headers) = @_;
    
        return $self->write("$method $request_uri HTTP/1.1\x0D\x0A")
             + $self->write_header_lines($headers);
    }
    
    sub _do_timeout {
        my ($self, $type, $timeout) = @_;
        $timeout = $self->{timeout}
            unless defined $timeout && $timeout >= 0;
    
        my $fd = fileno $self->{fh};
        defined $fd && $fd >= 0
          or die(qq/select(2): 'Bad file descriptor'\n/);
    
        my $initial = time;
        my $pending = $timeout;
        my $nfound;
    
        vec(my $fdset = '', $fd, 1) = 1;
    
        while () {
            $nfound = ($type eq 'read')
                ? select($fdset, undef, undef, $pending)
                : select(undef, $fdset, undef, $pending) ;
            if ($nfound == -1) {
                $! == EINTR
                  or die(qq/select(2): '$!'\n/);
                redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
                $nfound = 0;
            }
            last;
        }
        $! = 0;
        return $nfound;
    }
    
    sub can_read {
        @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
        my $self = shift;
        return $self->_do_timeout('read', @_)
    }
    
    sub can_write {
        @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
        my $self = shift;
        return $self->_do_timeout('write', @_)
    }
    
    # Try to find a CA bundle to validate the SSL cert,
    # prefer Mozilla::CA or fallback to a system file
    sub _find_CA_file {
        my $self = shift();
    
        return $self->{SSL_options}->{SSL_ca_file}
            if $self->{SSL_options}->{SSL_ca_file} and -e $self->{SSL_options}->{SSL_ca_file};
    
        return Mozilla::CA::SSL_ca_file()
            if eval { require Mozilla::CA };
    
        foreach my $ca_bundle (qw{
            /etc/ssl/certs/ca-certificates.crt
            /etc/pki/tls/certs/ca-bundle.crt
            /etc/ssl/ca-bundle.pem
            }
        ) {
            return $ca_bundle if -e $ca_bundle;
        }
    
        die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
          . qq/Try installing Mozilla::CA from CPAN\n/;
    }
    
    sub _ssl_args {
        my ($self, $host) = @_;
    
        my %ssl_args;
        
        # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
        # added until IO::Socket::SSL 1.84
        if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
            $ssl_args{SSL_hostname} = $host,          # Sane SNI support
        }
    
        if ($self->{verify_SSL}) {
            $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
            $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
            $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
            $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
        }
        else {
            $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
            $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
        }
    
        # user options override settings from verify_SSL
        for my $k ( keys %{$self->{SSL_options}} ) {
            $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
        }
    
        return \%ssl_args;
    }
    
    1;
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    HTTP::Tiny - A small, simple, correct HTTP/1.1 client
    
    =head1 VERSION
    
    version 0.034
    
    =head1 SYNOPSIS
    
        use HTTP::Tiny;
    
        my $response = HTTP::Tiny->new->get('http://example.com/');
    
        die "Failed!\n" unless $response->{success};
    
        print "$response->{status} $response->{reason}\n";
    
        while (my ($k, $v) = each %{$response->{headers}}) {
            for (ref $v eq 'ARRAY' ? @$v : $v) {
                print "$k: $_\n";
            }
        }
    
        print $response->{content} if length $response->{content};
    
    =head1 DESCRIPTION
    
    This is a very simple HTTP/1.1 client, designed for doing simple GET
    requests without the overhead of a large framework like L<LWP::UserAgent>.
    
    It is more correct and more complete than L<HTTP::Lite>.  It supports
    proxies (currently only non-authenticating ones) and redirection.  It
    also correctly resumes after EINTR.
    
    =head1 METHODS
    
    =head2 new
    
        $http = HTTP::Tiny->new( %attributes );
    
    This constructor returns a new HTTP::Tiny object.  Valid attributes include:
    
    =over 4
    
    =item *
    
    C<agent>
    
    A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> ends in a space character, the default user-agent string is appended.
    
    =item *
    
    C<cookie_jar>
    
    An instance of L<HTTP::CookieJar> or equivalent class that supports the C<add> and C<cookie_header> methods
    
    =item *
    
    C<default_headers>
    
    A hashref of default headers to apply to requests
    
    =item *
    
    C<local_address>
    
    The local IP address to bind to
    
    =item *
    
    C<max_redirect>
    
    Maximum number of redirects allowed (defaults to 5)
    
    =item *
    
    C<max_size>
    
    Maximum response size (only when not using a data callback).  If defined,
    responses larger than this will return an exception.
    
    =item *
    
    C<proxy>
    
    URL of a proxy server to use (default is C<$ENV{http_proxy}> if set)
    
    =item *
    
    C<no_proxy>
    
    List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}>)
    
    =item *
    
    C<timeout>
    
    Request timeout in seconds (default is 60)
    
    =item *
    
    C<verify_SSL>
    
    A boolean that indicates whether to validate the SSL certificate of an C<https>
    connection (default is false)
    
    =item *
    
    C<SSL_options>
    
    A hashref of C<SSL_*> options to pass through to L<IO::Socket::SSL>
    
    =back
    
    Exceptions from C<max_size>, C<timeout> or other errors will result in a
    pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
    content field in the response will contain the text of the exception.
    
    See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
    
    =head2 get|head|put|post|delete
    
        $response = $http->get($url);
        $response = $http->get($url, \%options);
        $response = $http->head($url);
    
    These methods are shorthand for calling C<request()> for the given method.  The
    URL must have unsafe characters escaped and international domain names encoded.
    See C<request()> for valid options and a description of the response.
    
    The C<success> field of the response will be true if the status code is 2XX.
    
    =head2 post_form
    
        $response = $http->post_form($url, $form_data);
        $response = $http->post_form($url, $form_data, \%options);
    
    This method executes a C<POST> request and sends the key/value pairs from a
    form data hash or array reference to the given URL with a C<content-type> of
    C<application/x-www-form-urlencoded>.  See documentation for the
    C<www_form_urlencode> method for details on the encoding.
    
    The URL must have unsafe characters escaped and international domain names
    encoded.  See C<request()> for valid options and a description of the response.
    Any C<content-type> header or content in the options hashref will be ignored.
    
    The C<success> field of the response will be true if the status code is 2XX.
    
    =head2 mirror
    
        $response = $http->mirror($url, $file, \%options)
        if ( $response->{success} ) {
            print "$file is up to date\n";
        }
    
    Executes a C<GET> request for the URL and saves the response body to the file
    name provided.  The URL must have unsafe characters escaped and international
    domain names encoded.  If the file already exists, the request will include an
    C<If-Modified-Since> header with the modification timestamp of the file.  You
    may specify a different C<If-Modified-Since> header yourself in the C<<
    $options->{headers} >> hash.
    
    The C<success> field of the response will be true if the status code is 2XX
    or if the status code is 304 (unmodified).
    
    If the file was modified and the server response includes a properly
    formatted C<Last-Modified> header, the file modification time will
    be updated accordingly.
    
    =head2 request
    
        $response = $http->request($method, $url);
        $response = $http->request($method, $url, \%options);
    
    Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
    'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
    international domain names encoded.
    
    If the URL includes a "user:password" stanza, they will be used for Basic-style
    authorization headers.  (Authorization headers will not be included in a
    redirected request.) For example:
    
        $http->request('GET', 'http://Aladdin:open sesame@example.com/');
    
    A hashref of options may be appended to modify the request.
    
    Valid options are:
    
    =over 4
    
    =item *
    
    C<headers>
    
    A hashref containing headers to include with the request.  If the value for
    a header is an array reference, the header will be output multiple times with
    each value in the array.  These headers over-write any default headers.
    
    =item *
    
    C<content>
    
    A scalar to include as the body of the request OR a code reference
    that will be called iteratively to produce the body of the request
    
    =item *
    
    C<trailer_callback>
    
    A code reference that will be called if it exists to provide a hashref
    of trailing headers (only used with chunked transfer-encoding)
    
    =item *
    
    C<data_callback>
    
    A code reference that will be called for each chunks of the response
    body received.
    
    =back
    
    If the C<content> option is a code reference, it will be called iteratively
    to provide the content body of the request.  It should return the empty
    string or undef when the iterator is exhausted.
    
    If the C<content> option is the empty string, no C<content-type> or
    C<content-length> headers will be generated.
    
    If the C<data_callback> option is provided, it will be called iteratively until
    the entire response body is received.  The first argument will be a string
    containing a chunk of the response body, the second argument will be the
    in-progress response hash reference, as described below.  (This allows
    customizing the action of the callback based on the C<status> or C<headers>
    received prior to the content body.)
    
    The C<request> method returns a hashref containing the response.  The hashref
    will have the following keys:
    
    =over 4
    
    =item *
    
    C<success>
    
    Boolean indicating whether the operation returned a 2XX status code
    
    =item *
    
    C<url>
    
    URL that provided the response. This is the URL of the request unless
    there were redirections, in which case it is the last URL queried
    in a redirection chain
    
    =item *
    
    C<status>
    
    The HTTP status code of the response
    
    =item *
    
    C<reason>
    
    The response phrase returned by the server
    
    =item *
    
    C<content>
    
    The body of the response.  If the response does not have any content
    or if a data callback is provided to consume the response body,
    this will be the empty string
    
    =item *
    
    C<headers>
    
    A hashref of header fields.  All header field names will be normalized
    to be lower case. If a header is repeated, the value will be an arrayref;
    it will otherwise be a scalar string containing the value
    
    =back
    
    On an exception during the execution of the request, the C<status> field will
    contain 599, and the C<content> field will contain the text of the exception.
    
    =head2 www_form_urlencode
    
        $params = $http->www_form_urlencode( $data );
        $response = $http->get("http://example.com/query?$params");
    
    This method converts the key/value pairs from a data hash or array reference
    into a C<x-www-form-urlencoded> string.  The keys and values from the data
    reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
    array reference, the key will be repeated with each of the values of the array
    reference.  The key/value pairs in the resulting string will be sorted by key
    and value.
    
    =for Pod::Coverage agent
    cookie_jar
    default_headers
    local_address
    max_redirect
    max_size
    proxy
    no_proxy
    timeout
    verify_SSL
    SSL_options
    
    =head1 SSL SUPPORT
    
    Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
    greater and L<Net::SSLeay> 1.49 or greater are installed. An exception will be
    thrown if a new enough versions of these modules not installed or if the SSL
    encryption fails. There is no support for C<https> connections via proxy (i.e.
    RFC 2817).
    
    SSL provides two distinct capabilities:
    
    =over 4
    
    =item *
    
    Encrypted communication channel
    
    =item *
    
    Verification of server identity
    
    =back
    
    B<By default, HTTP::Tiny does not verify server identity>.
    
    Server identity verification is controversial and potentially tricky because it
    depends on a (usually paid) third-party Certificate Authority (CA) trust model
    to validate a certificate as legitimate.  This discriminates against servers
    with self-signed certificates or certificates signed by free, community-driven
    CA's such as L<CAcert.org|http://cacert.org>.
    
    By default, HTTP::Tiny does not make any assumptions about your trust model,
    threat level or risk tolerance.  It just aims to give you an encrypted channel
    when you need one.
    
    Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
    that an SSL connection has a valid SSL certificate corresponding to the host
    name of the connection and that the SSL certificate has been verified by a CA.
    Assuming you trust the CA, this will protect against a L<man-in-the-middle
    attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
    concerned about security, you should enable this option.
    
    Certificate verification requires a file containing trusted CA certificates.
    If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
    included with it as a source of trusted CA's.  (This means you trust Mozilla,
    the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the
    toolchain used to install it, and your operating system security, right?)
    
    If that module is not available, then HTTP::Tiny will search several
    system-specific default locations for a CA certificate file:
    
    =over 4
    
    =item *
    
    /etc/ssl/certs/ca-certificates.crt
    
    =item *
    
    /etc/pki/tls/certs/ca-bundle.crt
    
    =item *
    
    /etc/ssl/ca-bundle.pem
    
    =back
    
    An exception will be raised if C<verify_SSL> is true and no CA certificate file
    is available.
    
    If you desire complete control over SSL connections, the C<SSL_options> attribute
    lets you provide a hash reference that will be passed through to
    C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
    example, to provide your own trusted CA file:
    
        SSL_options => {
            SSL_ca_file => $file_path,
        }
    
    The C<SSL_options> attribute could also be used for such things as providing a
    client certificate for authentication to a server or controlling the choice of
    cipher used for the SSL connection. See L<IO::Socket::SSL> documentation for
    details.
    
    =head1 LIMITATIONS
    
    HTTP::Tiny is I<conditionally compliant> with the
    L<HTTP/1.1 specification|http://www.w3.org/Protocols/rfc2616/rfc2616.html>.
    It attempts to meet all "MUST" requirements of the specification, but does not
    implement all "SHOULD" requirements.
    
    Some particular limitations of note include:
    
    =over
    
    =item *
    
    HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
    that user-defined headers and content are compliant with the HTTP/1.1
    specification.
    
    =item *
    
    Users must ensure that URLs are properly escaped for unsafe characters and that
    international domain names are properly encoded to ASCII. See L<URI::Escape>,
    L<URI::_punycode> and L<Net::IDN::Encode>.
    
    =item *
    
    Redirection is very strict against the specification.  Redirection is only
    automatic for response codes 301, 302 and 307 if the request method is 'GET' or
    'HEAD'.  Response code 303 is always converted into a 'GET' redirection, as
    mandated by the specification.  There is no automatic support for status 305
    ("Use proxy") redirections.
    
    =item *
    
    Persistent connections are not supported.  The C<Connection> header will
    always be set to C<close>.
    
    =item *
    
    Cookie support requires L<HTTP::CookieJar> or an equivalent class.
    
    =item *
    
    Only the C<http_proxy> environment variable is supported in the format
    C<http://HOST:PORT/>.  If a C<proxy> argument is passed to C<new> (including
    undef), then the C<http_proxy> environment variable is ignored.
    
    =item *
    
    C<no_proxy> environment variable is supported in the format comma-separated
    list of domain extensions proxy should not be used for.  If a C<no_proxy>
    argument is passed to C<new>, then the C<no_proxy> environment variable is
    ignored.
    
    =item *
    
    There is no provision for delaying a request body using an C<Expect> header.
    Unexpected C<1XX> responses are silently ignored as per the specification.
    
    =item *
    
    Only 'chunked' C<Transfer-Encoding> is supported.
    
    =item *
    
    There is no support for a Request-URI of '*' for the 'OPTIONS' request.
    
    =item *
    
    There is no support for IPv6 of any kind.
    
    =back
    
    =head1 SEE ALSO
    
    =over 4
    
    =item *
    
    L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility
    
    =item *
    
    L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface
    
    =item *
    
    L<IO::Socket::SSL> - Required for SSL support
    
    =item *
    
    L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things
    
    =item *
    
    L<Mozilla::CA> - Required if you want to validate SSL certificates
    
    =item *
    
    L<Net::SSLeay> - Required for SSL support
    
    =back
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<https://github.com/chansen/p5-http-tiny/issues>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/chansen/p5-http-tiny>
    
      git clone git://github.com/chansen/p5-http-tiny.git
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    Christian Hansen <chansen@cpan.org>
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =back
    
    =head1 CONTRIBUTORS
    
    =over 4
    
    =item *
    
    Alan Gardner <gardner@pythian.com>
    
    =item *
    
    Alessandro Ghedini <al3xbio@gmail.com>
    
    =item *
    
    Brad Gilbert <bgills@cpan.org>
    
    =item *
    
    Chris Nehren <apeiron@cpan.org>
    
    =item *
    
    Chris Weyl <cweyl@alumni.drew.edu>
    
    =item *
    
    Claes Jakobsson <claes@surfar.nu>
    
    =item *
    
    Craig Berry <cberry@cpan.org>
    
    =item *
    
    David Mitchell <davem@iabyn.com>
    
    =item *
    
    Edward Zborowski <ed@rubensteintech.com>
    
    =item *
    
    Jess Robinson <castaway@desert-island.me.uk>
    
    =item *
    
    Lukas Eklund <leklund@gmail.com>
    
    =item *
    
    Martin-Louis Bright <mlbright@gmail.com>
    
    =item *
    
    Mike Doherty <doherty@cpan.org>
    
    =item *
    
    Serguei Trouchelle <stro@cpan.org>
    
    =item *
    
    Syohei YOSHIDA <syohex@gmail.com>
    
    =item *
    
    Tony Cook <tony@develop-help.com>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2013 by Christian Hansen.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  HTTP_TINY
  
  $fatpacked{"JSON/PP.pm"} = <<'JSON_PP';
    package JSON::PP;
    
    # JSON-2.0
    
    use 5.005;
    use strict;
    use base qw(Exporter);
    use overload ();
    
    use Carp ();
    use B ();
    #use Devel::Peek;
    
    $JSON::PP::VERSION = '2.27202';
    
    @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
    
    # instead of hash-access, i tried index-access for speed.
    # but this method is not faster than what i expected. so it will be changed.
    
    use constant P_ASCII                => 0;
    use constant P_LATIN1               => 1;
    use constant P_UTF8                 => 2;
    use constant P_INDENT               => 3;
    use constant P_CANONICAL            => 4;
    use constant P_SPACE_BEFORE         => 5;
    use constant P_SPACE_AFTER          => 6;
    use constant P_ALLOW_NONREF         => 7;
    use constant P_SHRINK               => 8;
    use constant P_ALLOW_BLESSED        => 9;
    use constant P_CONVERT_BLESSED      => 10;
    use constant P_RELAXED              => 11;
    
    use constant P_LOOSE                => 12;
    use constant P_ALLOW_BIGNUM         => 13;
    use constant P_ALLOW_BAREKEY        => 14;
    use constant P_ALLOW_SINGLEQUOTE    => 15;
    use constant P_ESCAPE_SLASH         => 16;
    use constant P_AS_NONBLESSED        => 17;
    
    use constant P_ALLOW_UNKNOWN        => 18;
    
    use constant OLD_PERL => $] < 5.008 ? 1 : 0;
    
    BEGIN {
        my @xs_compati_bit_properties = qw(
                latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
                allow_blessed convert_blessed relaxed allow_unknown
        );
        my @pp_bit_properties = qw(
                allow_singlequote allow_bignum loose
                allow_barekey escape_slash as_nonblessed
        );
    
        # Perl version check, Unicode handling is enable?
        # Helper module sets @JSON::PP::_properties.
        if ($] < 5.008 ) {
            my $helper = $] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';
            eval qq| require $helper |;
            if ($@) { Carp::croak $@; }
        }
    
        for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
            my $flag_name = 'P_' . uc($name);
    
            eval qq/
                sub $name {
                    my \$enable = defined \$_[1] ? \$_[1] : 1;
    
                    if (\$enable) {
                        \$_[0]->{PROPS}->[$flag_name] = 1;
                    }
                    else {
                        \$_[0]->{PROPS}->[$flag_name] = 0;
                    }
    
                    \$_[0];
                }
    
                sub get_$name {
                    \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
                }
            /;
        }
    
    }
    
    
    
    # Functions
    
    my %encode_allow_method
         = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                              allow_blessed convert_blessed indent indent_length allow_bignum
                              as_nonblessed
                            /;
    my %decode_allow_method
         = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                              allow_barekey max_size relaxed/;
    
    
    my $JSON; # cache
    
    sub encode_json ($) { # encode
        ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
    }
    
    
    sub decode_json { # decode
        ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
    }
    
    # Obsoleted
    
    sub to_json($) {
       Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
    }
    
    
    sub from_json($) {
       Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
    }
    
    
    # Methods
    
    sub new {
        my $class = shift;
        my $self  = {
            max_depth   => 512,
            max_size    => 0,
            indent      => 0,
            FLAGS       => 0,
            fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
            indent_length => 3,
        };
    
        bless $self, $class;
    }
    
    
    sub encode {
        return $_[0]->PP_encode_json($_[1]);
    }
    
    
    sub decode {
        return $_[0]->PP_decode_json($_[1], 0x00000000);
    }
    
    
    sub decode_prefix {
        return $_[0]->PP_decode_json($_[1], 0x00000001);
    }
    
    
    # accessor
    
    
    # pretty printing
    
    sub pretty {
        my ($self, $v) = @_;
        my $enable = defined $v ? $v : 1;
    
        if ($enable) { # indent_length(3) for JSON::XS compatibility
            $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
        }
        else {
            $self->indent(0)->space_before(0)->space_after(0);
        }
    
        $self;
    }
    
    # etc
    
    sub max_depth {
        my $max  = defined $_[1] ? $_[1] : 0x80000000;
        $_[0]->{max_depth} = $max;
        $_[0];
    }
    
    
    sub get_max_depth { $_[0]->{max_depth}; }
    
    
    sub max_size {
        my $max  = defined $_[1] ? $_[1] : 0;
        $_[0]->{max_size} = $max;
        $_[0];
    }
    
    
    sub get_max_size { $_[0]->{max_size}; }
    
    
    sub filter_json_object {
        $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
        $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
        $_[0];
    }
    
    sub filter_json_single_key_object {
        if (@_ > 1) {
            $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
        }
        $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
        $_[0];
    }
    
    sub indent_length {
        if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
            Carp::carp "The acceptable range of indent_length() is 0 to 15.";
        }
        else {
            $_[0]->{indent_length} = $_[1];
        }
        $_[0];
    }
    
    sub get_indent_length {
        $_[0]->{indent_length};
    }
    
    sub sort_by {
        $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
        $_[0];
    }
    
    sub allow_bigint {
        Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
    }
    
    ###############################
    
    ###
    ### Perl => JSON
    ###
    
    
    { # Convert
    
        my $max_depth;
        my $indent;
        my $ascii;
        my $latin1;
        my $utf8;
        my $space_before;
        my $space_after;
        my $canonical;
        my $allow_blessed;
        my $convert_blessed;
    
        my $indent_length;
        my $escape_slash;
        my $bignum;
        my $as_nonblessed;
    
        my $depth;
        my $indent_count;
        my $keysort;
    
    
        sub PP_encode_json {
            my $self = shift;
            my $obj  = shift;
    
            $indent_count = 0;
            $depth        = 0;
    
            my $idx = $self->{PROPS};
    
            ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
                $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
             = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                        P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
    
            ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
    
            $keysort = $canonical ? sub { $a cmp $b } : undef;
    
            if ($self->{sort_by}) {
                $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                         : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                         : sub { $a cmp $b };
            }
    
            encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
                 if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
    
            my $str  = $self->object_to_json($obj);
    
            $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
    
            unless ($ascii or $latin1 or $utf8) {
                utf8::upgrade($str);
            }
    
            if ($idx->[ P_SHRINK ]) {
                utf8::downgrade($str, 1);
            }
    
            return $str;
        }
    
    
        sub object_to_json {
            my ($self, $obj) = @_;
            my $type = ref($obj);
    
            if($type eq 'HASH'){
                return $self->hash_to_json($obj);
            }
            elsif($type eq 'ARRAY'){
                return $self->array_to_json($obj);
            }
            elsif ($type) { # blessed object?
                if (blessed($obj)) {
    
                    return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
    
                    if ( $convert_blessed and $obj->can('TO_JSON') ) {
                        my $result = $obj->TO_JSON();
                        if ( defined $result and ref( $result ) ) {
                            if ( refaddr( $obj ) eq refaddr( $result ) ) {
                                encode_error( sprintf(
                                    "%s::TO_JSON method returned same object as was passed instead of a new one",
                                    ref $obj
                                ) );
                            }
                        }
    
                        return $self->object_to_json( $result );
                    }
    
                    return "$obj" if ( $bignum and _is_bignum($obj) );
                    return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
    
                    encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                        . "nor convert_blessed settings are enabled", $obj)
                    ) unless ($allow_blessed);
    
                    return 'null';
                }
                else {
                    return $self->value_to_json($obj);
                }
            }
            else{
                return $self->value_to_json($obj);
            }
        }
    
    
        sub hash_to_json {
            my ($self, $obj) = @_;
            my @res;
    
            encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                             if (++$depth > $max_depth);
    
            my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
            my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
    
            for my $k ( _sort( $obj ) ) {
                if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
                push @res, string_to_json( $self, $k )
                              .  $del
                              . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
            }
    
            --$depth;
            $self->_down_indent() if ($indent);
    
            return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
        }
    
    
        sub array_to_json {
            my ($self, $obj) = @_;
            my @res;
    
            encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                             if (++$depth > $max_depth);
    
            my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
    
            for my $v (@$obj){
                push @res, $self->object_to_json($v) || $self->value_to_json($v);
            }
    
            --$depth;
            $self->_down_indent() if ($indent);
    
            return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
        }
    
    
        sub value_to_json {
            my ($self, $value) = @_;
    
            return 'null' if(!defined $value);
    
            my $b_obj = B::svref_2object(\$value);  # for round trip problem
            my $flags = $b_obj->FLAGS;
    
            return $value # as is 
                if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
    
            my $type = ref($value);
    
            if(!$type){
                return string_to_json($self, $value);
            }
            elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
                return $$value == 1 ? 'true' : 'false';
            }
            elsif ($type) {
                if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                    return $self->value_to_json("$value");
                }
    
                if ($type eq 'SCALAR' and defined $$value) {
                    return   $$value eq '1' ? 'true'
                           : $$value eq '0' ? 'false'
                           : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                           : encode_error("cannot encode reference to scalar");
                }
    
                 if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                     return 'null';
                 }
                 else {
                     if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                        encode_error("cannot encode reference to scalar");
                     }
                     else {
                        encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                     }
                 }
    
            }
            else {
                return $self->{fallback}->($value)
                     if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
                return 'null';
            }
    
        }
    
    
        my %esc = (
            "\n" => '\n',
            "\r" => '\r',
            "\t" => '\t',
            "\f" => '\f',
            "\b" => '\b',
            "\"" => '\"',
            "\\" => '\\\\',
            "\'" => '\\\'',
        );
    
    
        sub string_to_json {
            my ($self, $arg) = @_;
    
            $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
            $arg =~ s/\//\\\//g if ($escape_slash);
            $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
    
            if ($ascii) {
                $arg = JSON_PP_encode_ascii($arg);
            }
    
            if ($latin1) {
                $arg = JSON_PP_encode_latin1($arg);
            }
    
            if ($utf8) {
                utf8::encode($arg);
            }
    
            return '"' . $arg . '"';
        }
    
    
        sub blessed_to_json {
            my $reftype = reftype($_[1]) || '';
            if ($reftype eq 'HASH') {
                return $_[0]->hash_to_json($_[1]);
            }
            elsif ($reftype eq 'ARRAY') {
                return $_[0]->array_to_json($_[1]);
            }
            else {
                return 'null';
            }
        }
    
    
        sub encode_error {
            my $error  = shift;
            Carp::croak "$error";
        }
    
    
        sub _sort {
            defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
        }
    
    
        sub _up_indent {
            my $self  = shift;
            my $space = ' ' x $indent_length;
    
            my ($pre,$post) = ('','');
    
            $post = "\n" . $space x $indent_count;
    
            $indent_count++;
    
            $pre = "\n" . $space x $indent_count;
    
            return ($pre,$post);
        }
    
    
        sub _down_indent { $indent_count--; }
    
    
        sub PP_encode_box {
            {
                depth        => $depth,
                indent_count => $indent_count,
            };
        }
    
    } # Convert
    
    
    sub _encode_ascii {
        join('',
            map {
                $_ <= 127 ?
                    chr($_) :
                $_ <= 65535 ?
                    sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
            } unpack('U*', $_[0])
        );
    }
    
    
    sub _encode_latin1 {
        join('',
            map {
                $_ <= 255 ?
                    chr($_) :
                $_ <= 65535 ?
                    sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
            } unpack('U*', $_[0])
        );
    }
    
    
    sub _encode_surrogates { # from perlunicode
        my $uni = $_[0] - 0x10000;
        return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
    }
    
    
    sub _is_bignum {
        $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
    }
    
    
    
    #
    # JSON => Perl
    #
    
    my $max_intsize;
    
    BEGIN {
        my $checkint = 1111;
        for my $d (5..64) {
            $checkint .= 1;
            my $int   = eval qq| $checkint |;
            if ($int =~ /[eE]/) {
                $max_intsize = $d - 1;
                last;
            }
        }
    }
    
    { # PARSE 
    
        my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
            b    => "\x8",
            t    => "\x9",
            n    => "\xA",
            f    => "\xC",
            r    => "\xD",
            '\\' => '\\',
            '"'  => '"',
            '/'  => '/',
        );
    
        my $text; # json data
        my $at;   # offset
        my $ch;   # 1chracter
        my $len;  # text length (changed according to UTF8 or NON UTF8)
        # INTERNAL
        my $depth;          # nest counter
        my $encoding;       # json text encoding
        my $is_valid_utf8;  # temp variable
        my $utf8_len;       # utf8 byte length
        # FLAGS
        my $utf8;           # must be utf8
        my $max_depth;      # max nest nubmer of objects and arrays
        my $max_size;
        my $relaxed;
        my $cb_object;
        my $cb_sk_object;
    
        my $F_HOOK;
    
        my $allow_bigint;   # using Math::BigInt
        my $singlequote;    # loosely quoting
        my $loose;          # 
        my $allow_barekey;  # bareKey
    
        # $opt flag
        # 0x00000001 .... decode_prefix
        # 0x10000000 .... incr_parse
    
        sub PP_decode_json {
            my ($self, $opt); # $opt is an effective flag during this decode_json.
    
            ($self, $text, $opt) = @_;
    
            ($at, $ch, $depth) = (0, '', 0);
    
            if ( !defined $text or ref $text ) {
                decode_error("malformed JSON string, neither array, object, number, string or atom");
            }
    
            my $idx = $self->{PROPS};
    
            ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
                = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
    
            if ( $utf8 ) {
                utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
            }
            else {
                utf8::upgrade( $text );
            }
    
            $len = length $text;
    
            ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
                 = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
    
            if ($max_size > 1) {
                use bytes;
                my $bytes = length $text;
                decode_error(
                    sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                        , $bytes, $max_size), 1
                ) if ($bytes > $max_size);
            }
    
            # Currently no effect
            # should use regexp
            my @octets = unpack('C4', $text);
            $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                        : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                        : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                        : ( $octets[2]                ) ? 'UTF-16LE'
                        : (!$octets[2]                ) ? 'UTF-32LE'
                        : 'unknown';
    
            white(); # remove head white space
    
            my $valid_start = defined $ch; # Is there a first character for JSON structure?
    
            my $result = value();
    
            return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
    
            decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
    
            if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                    decode_error(
                    'JSON text must be an object or array (but found number, string, true, false or null,'
                           . ' use allow_nonref to allow this)', 1);
            }
    
            Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
    
            my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
    
            white(); # remove tail white space
    
            if ( $ch ) {
                return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
                decode_error("garbage after JSON object");
            }
    
            ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
        }
    
    
        sub next_chr {
            return $ch = undef if($at >= $len);
            $ch = substr($text, $at++, 1);
        }
    
    
        sub value {
            white();
            return          if(!defined $ch);
            return object() if($ch eq '{');
            return array()  if($ch eq '[');
            return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
            return number() if($ch =~ /[0-9]/ or $ch eq '-');
            return word();
        }
    
        sub string {
            my ($i, $s, $t, $u);
            my $utf16;
            my $is_utf8;
    
            ($is_valid_utf8, $utf8_len) = ('', 0);
    
            $s = ''; # basically UTF8 flag on
    
            if($ch eq '"' or ($singlequote and $ch eq "'")){
                my $boundChar = $ch;
    
                OUTER: while( defined(next_chr()) ){
    
                    if($ch eq $boundChar){
                        next_chr();
    
                        if ($utf16) {
                            decode_error("missing low surrogate character in surrogate pair");
                        }
    
                        utf8::decode($s) if($is_utf8);
    
                        return $s;
                    }
                    elsif($ch eq '\\'){
                        next_chr();
                        if(exists $escapes{$ch}){
                            $s .= $escapes{$ch};
                        }
                        elsif($ch eq 'u'){ # UNICODE handling
                            my $u = '';
    
                            for(1..4){
                                $ch = next_chr();
                                last OUTER if($ch !~ /[0-9a-fA-F]/);
                                $u .= $ch;
                            }
    
                            # U+D800 - U+DBFF
                            if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                                $utf16 = $u;
                            }
                            # U+DC00 - U+DFFF
                            elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                                unless (defined $utf16) {
                                    decode_error("missing high surrogate character in surrogate pair");
                                }
                                $is_utf8 = 1;
                                $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                                $utf16 = undef;
                            }
                            else {
                                if (defined $utf16) {
                                    decode_error("surrogate pair expected");
                                }
    
                                if ( ( my $hex = hex( $u ) ) > 127 ) {
                                    $is_utf8 = 1;
                                    $s .= JSON_PP_decode_unicode($u) || next;
                                }
                                else {
                                    $s .= chr $hex;
                                }
                            }
    
                        }
                        else{
                            unless ($loose) {
                                $at -= 2;
                                decode_error('illegal backslash escape sequence in string');
                            }
                            $s .= $ch;
                        }
                    }
                    else{
    
                        if ( ord $ch  > 127 ) {
                            if ( $utf8 ) {
                                unless( $ch = is_valid_utf8($ch) ) {
                                    $at -= 1;
                                    decode_error("malformed UTF-8 character in JSON string");
                                }
                                else {
                                    $at += $utf8_len - 1;
                                }
                            }
                            else {
                                utf8::encode( $ch );
                            }
    
                            $is_utf8 = 1;
                        }
    
                        if (!$loose) {
                            if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                                $at--;
                                decode_error('invalid character encountered while parsing JSON string');
                            }
                        }
    
                        $s .= $ch;
                    }
                }
            }
    
            decode_error("unexpected end of string while parsing JSON string");
        }
    
    
        sub white {
            while( defined $ch  ){
                if($ch le ' '){
                    next_chr();
                }
                elsif($ch eq '/'){
                    next_chr();
                    if(defined $ch and $ch eq '/'){
                        1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                    }
                    elsif(defined $ch and $ch eq '*'){
                        next_chr();
                        while(1){
                            if(defined $ch){
                                if($ch eq '*'){
                                    if(defined(next_chr()) and $ch eq '/'){
                                        next_chr();
                                        last;
                                    }
                                }
                                else{
                                    next_chr();
                                }
                            }
                            else{
                                decode_error("Unterminated comment");
                            }
                        }
                        next;
                    }
                    else{
                        $at--;
                        decode_error("malformed JSON string, neither array, object, number, string or atom");
                    }
                }
                else{
                    if ($relaxed and $ch eq '#') { # correctly?
                        pos($text) = $at;
                        $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                        $at = pos($text);
                        next_chr;
                        next;
                    }
    
                    last;
                }
            }
        }
    
    
        sub array {
            my $a  = $_[0] || []; # you can use this code to use another array ref object.
    
            decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                        if (++$depth > $max_depth);
    
            next_chr();
            white();
    
            if(defined $ch and $ch eq ']'){
                --$depth;
                next_chr();
                return $a;
            }
            else {
                while(defined($ch)){
                    push @$a, value();
    
                    white();
    
                    if (!defined $ch) {
                        last;
                    }
    
                    if($ch eq ']'){
                        --$depth;
                        next_chr();
                        return $a;
                    }
    
                    if($ch ne ','){
                        last;
                    }
    
                    next_chr();
                    white();
    
                    if ($relaxed and $ch eq ']') {
                        --$depth;
                        next_chr();
                        return $a;
                    }
    
                }
            }
    
            decode_error(", or ] expected while parsing array");
        }
    
    
        sub object {
            my $o = $_[0] || {}; # you can use this code to use another hash ref object.
            my $k;
    
            decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                    if (++$depth > $max_depth);
            next_chr();
            white();
    
            if(defined $ch and $ch eq '}'){
                --$depth;
                next_chr();
                if ($F_HOOK) {
                    return _json_object_hook($o);
                }
                return $o;
            }
            else {
                while (defined $ch) {
                    $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                    white();
    
                    if(!defined $ch or $ch ne ':'){
                        $at--;
                        decode_error("':' expected");
                    }
    
                    next_chr();
                    $o->{$k} = value();
                    white();
    
                    last if (!defined $ch);
    
                    if($ch eq '}'){
                        --$depth;
                        next_chr();
                        if ($F_HOOK) {
                            return _json_object_hook($o);
                        }
                        return $o;
                    }
    
                    if($ch ne ','){
                        last;
                    }
    
                    next_chr();
                    white();
    
                    if ($relaxed and $ch eq '}') {
                        --$depth;
                        next_chr();
                        if ($F_HOOK) {
                            return _json_object_hook($o);
                        }
                        return $o;
                    }
    
                }
    
            }
    
            $at--;
            decode_error(", or } expected while parsing object/hash");
        }
    
    
        sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
            my $key;
            while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
                $key .= $ch;
                next_chr();
            }
            return $key;
        }
    
    
        sub word {
            my $word =  substr($text,$at-1,4);
    
            if($word eq 'true'){
                $at += 3;
                next_chr;
                return $JSON::PP::true;
            }
            elsif($word eq 'null'){
                $at += 3;
                next_chr;
                return undef;
            }
            elsif($word eq 'fals'){
                $at += 3;
                if(substr($text,$at,1) eq 'e'){
                    $at++;
                    next_chr;
                    return $JSON::PP::false;
                }
            }
    
            $at--; # for decode_error report
    
            decode_error("'null' expected")  if ($word =~ /^n/);
            decode_error("'true' expected")  if ($word =~ /^t/);
            decode_error("'false' expected") if ($word =~ /^f/);
            decode_error("malformed JSON string, neither array, object, number, string or atom");
        }
    
    
        sub number {
            my $n    = '';
            my $v;
    
            # According to RFC4627, hex or oct digts are invalid.
            if($ch eq '0'){
                my $peek = substr($text,$at,1);
                my $hex  = $peek =~ /[xX]/; # 0 or 1
    
                if($hex){
                    decode_error("malformed number (leading zero must not be followed by another digit)");
                    ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
                }
                else{ # oct
                    ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                    if (defined $n and length $n > 1) {
                        decode_error("malformed number (leading zero must not be followed by another digit)");
                    }
                }
    
                if(defined $n and length($n)){
                    if (!$hex and length($n) == 1) {
                       decode_error("malformed number (leading zero must not be followed by another digit)");
                    }
                    $at += length($n) + $hex;
                    next_chr;
                    return $hex ? hex($n) : oct($n);
                }
            }
    
            if($ch eq '-'){
                $n = '-';
                next_chr;
                if (!defined $ch or $ch !~ /\d/) {
                    decode_error("malformed number (no digits after initial minus)");
                }
            }
    
            while(defined $ch and $ch =~ /\d/){
                $n .= $ch;
                next_chr;
            }
    
            if(defined $ch and $ch eq '.'){
                $n .= '.';
    
                next_chr;
                if (!defined $ch or $ch !~ /\d/) {
                    decode_error("malformed number (no digits after decimal point)");
                }
                else {
                    $n .= $ch;
                }
    
                while(defined(next_chr) and $ch =~ /\d/){
                    $n .= $ch;
                }
            }
    
            if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
                $n .= $ch;
                next_chr;
    
                if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                    $n .= $ch;
                    next_chr;
                    if (!defined $ch or $ch =~ /\D/) {
                        decode_error("malformed number (no digits after exp sign)");
                    }
                    $n .= $ch;
                }
                elsif(defined($ch) and $ch =~ /\d/){
                    $n .= $ch;
                }
                else {
                    decode_error("malformed number (no digits after exp sign)");
                }
    
                while(defined(next_chr) and $ch =~ /\d/){
                    $n .= $ch;
                }
    
            }
    
            $v .= $n;
    
            if ($v !~ /[.eE]/ and length $v > $max_intsize) {
                if ($allow_bigint) { # from Adam Sussman
                    require Math::BigInt;
                    return Math::BigInt->new($v);
                }
                else {
                    return "$v";
                }
            }
            elsif ($allow_bigint) {
                require Math::BigFloat;
                return Math::BigFloat->new($v);
            }
    
            return 0+$v;
        }
    
    
        sub is_valid_utf8 {
    
            $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                      : $_[0] =~ /[\xC2-\xDF]/  ? 2
                      : $_[0] =~ /[\xE0-\xEF]/  ? 3
                      : $_[0] =~ /[\xF0-\xF4]/  ? 4
                      : 0
                      ;
    
            return unless $utf8_len;
    
            my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
    
            return ( $is_valid_utf8 =~ /^(?:
                 [\x00-\x7F]
                |[\xC2-\xDF][\x80-\xBF]
                |[\xE0][\xA0-\xBF][\x80-\xBF]
                |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
                |[\xED][\x80-\x9F][\x80-\xBF]
                |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
                |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
                |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
                |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )$/x )  ? $is_valid_utf8 : '';
        }
    
    
        sub decode_error {
            my $error  = shift;
            my $no_rep = shift;
            my $str    = defined $text ? substr($text, $at) : '';
            my $mess   = '';
            my $type   = $] >= 5.008           ? 'U*'
                       : $] <  5.006           ? 'C*'
                       : utf8::is_utf8( $str ) ? 'U*' # 5.6
                       : 'C*'
                       ;
    
            for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
                $mess .=  $c == 0x07 ? '\a'
                        : $c == 0x09 ? '\t'
                        : $c == 0x0a ? '\n'
                        : $c == 0x0d ? '\r'
                        : $c == 0x0c ? '\f'
                        : $c <  0x20 ? sprintf('\x{%x}', $c)
                        : $c == 0x5c ? '\\\\'
                        : $c <  0x80 ? chr($c)
                        : sprintf('\x{%x}', $c)
                        ;
                if ( length $mess >= 20 ) {
                    $mess .= '...';
                    last;
                }
            }
    
            unless ( length $mess ) {
                $mess = '(end of string)';
            }
    
            Carp::croak (
                $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
            );
    
        }
    
    
        sub _json_object_hook {
            my $o    = $_[0];
            my @ks = keys %{$o};
    
            if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
                my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
                if (@val == 1) {
                    return $val[0];
                }
            }
    
            my @val = $cb_object->($o) if ($cb_object);
            if (@val == 0 or @val > 1) {
                return $o;
            }
            else {
                return $val[0];
            }
        }
    
    
        sub PP_decode_box {
            {
                text    => $text,
                at      => $at,
                ch      => $ch,
                len     => $len,
                depth   => $depth,
                encoding      => $encoding,
                is_valid_utf8 => $is_valid_utf8,
            };
        }
    
    } # PARSE
    
    
    sub _decode_surrogates { # from perlunicode
        my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
        my $un  = pack('U*', $uni);
        utf8::encode( $un );
        return $un;
    }
    
    
    sub _decode_unicode {
        my $un = pack('U', hex shift);
        utf8::encode( $un );
        return $un;
    }
    
    #
    # Setup for various Perl versions (the code from JSON::PP58)
    #
    
    BEGIN {
    
        unless ( defined &utf8::is_utf8 ) {
           require Encode;
           *utf8::is_utf8 = *Encode::is_utf8;
        }
    
        if ( $] >= 5.008 ) {
            *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
            *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
            *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
            *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
        }
    
        if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
            package JSON::PP;
            require subs;
            subs->import('join');
            eval q|
                sub join {
                    return '' if (@_ < 2);
                    my $j   = shift;
                    my $str = shift;
                    for (@_) { $str .= $j . $_; }
                    return $str;
                }
            |;
        }
    
    
        sub JSON::PP::incr_parse {
            local $Carp::CarpLevel = 1;
            ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
        }
    
    
        sub JSON::PP::incr_skip {
            ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
        }
    
    
        sub JSON::PP::incr_reset {
            ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
        }
    
        eval q{
            sub JSON::PP::incr_text : lvalue {
                $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
    
                if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                    Carp::croak("incr_text can not be called when the incremental parser already started parsing");
                }
                $_[0]->{_incr_parser}->{incr_text};
            }
        } if ( $] >= 5.006 );
    
    } # Setup for various Perl versions (the code from JSON::PP58)
    
    
    ###############################
    # Utilities
    #
    
    BEGIN {
        eval 'require Scalar::Util';
        unless($@){
            *JSON::PP::blessed = \&Scalar::Util::blessed;
            *JSON::PP::reftype = \&Scalar::Util::reftype;
            *JSON::PP::refaddr = \&Scalar::Util::refaddr;
        }
        else{ # This code is from Sclar::Util.
            # warn $@;
            eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
            *JSON::PP::blessed = sub {
                local($@, $SIG{__DIE__}, $SIG{__WARN__});
                ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
            };
            my %tmap = qw(
                B::NULL   SCALAR
                B::HV     HASH
                B::AV     ARRAY
                B::CV     CODE
                B::IO     IO
                B::GV     GLOB
                B::REGEXP REGEXP
            );
            *JSON::PP::reftype = sub {
                my $r = shift;
    
                return undef unless length(ref($r));
    
                my $t = ref(B::svref_2object($r));
    
                return
                    exists $tmap{$t} ? $tmap{$t}
                  : length(ref($$r)) ? 'REF'
                  :                    'SCALAR';
            };
            *JSON::PP::refaddr = sub {
              return undef unless length(ref($_[0]));
    
              my $addr;
              if(defined(my $pkg = blessed($_[0]))) {
                $addr .= bless $_[0], 'Scalar::Util::Fake';
                bless $_[0], $pkg;
              }
              else {
                $addr .= $_[0]
              }
    
              $addr =~ /0x(\w+)/;
              local $^W;
              #no warnings 'portable';
              hex($1);
            }
        }
    }
    
    
    # shamely copied and modified from JSON::XS code.
    
    $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
    $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
    
    sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
    
    sub true  { $JSON::PP::true  }
    sub false { $JSON::PP::false }
    sub null  { undef; }
    
    ###############################
    
    package JSON::PP::Boolean;
    
    use overload (
       "0+"     => sub { ${$_[0]} },
       "++"     => sub { $_[0] = ${$_[0]} + 1 },
       "--"     => sub { $_[0] = ${$_[0]} - 1 },
       fallback => 1,
    );
    
    
    ###############################
    
    package JSON::PP::IncrParser;
    
    use strict;
    
    use constant INCR_M_WS   => 0; # initial whitespace skipping
    use constant INCR_M_STR  => 1; # inside string
    use constant INCR_M_BS   => 2; # inside backslash
    use constant INCR_M_JSON => 3; # outside anything, count nesting
    use constant INCR_M_C0   => 4;
    use constant INCR_M_C1   => 5;
    
    $JSON::PP::IncrParser::VERSION = '1.01';
    
    my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
    
    sub new {
        my ( $class ) = @_;
    
        bless {
            incr_nest    => 0,
            incr_text    => undef,
            incr_parsing => 0,
            incr_p       => 0,
        }, $class;
    }
    
    
    sub incr_parse {
        my ( $self, $coder, $text ) = @_;
    
        $self->{incr_text} = '' unless ( defined $self->{incr_text} );
    
        if ( defined $text ) {
            if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
                utf8::upgrade( $self->{incr_text} ) ;
                utf8::decode( $self->{incr_text} ) ;
            }
            $self->{incr_text} .= $text;
        }
    
    
        my $max_size = $coder->get_max_size;
    
        if ( defined wantarray ) {
    
            $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
    
            if ( wantarray ) {
                my @ret;
    
                $self->{incr_parsing} = 1;
    
                do {
                    push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
    
                    unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                        $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                    }
    
                } until ( length $self->{incr_text} >= $self->{incr_p} );
    
                $self->{incr_parsing} = 0;
    
                return @ret;
            }
            else { # in scalar context
                $self->{incr_parsing} = 1;
                my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
                $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
                return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
            }
    
        }
    
    }
    
    
    sub _incr_parse {
        my ( $self, $coder, $text, $skip ) = @_;
        my $p = $self->{incr_p};
        my $restore = $p;
    
        my @obj;
        my $len = length $text;
    
        if ( $self->{incr_mode} == INCR_M_WS ) {
            while ( $len > $p ) {
                my $s = substr( $text, $p, 1 );
                $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
                $self->{incr_mode} = INCR_M_JSON;
                last;
           }
        }
    
        while ( $len > $p ) {
            my $s = substr( $text, $p++, 1 );
    
            if ( $s eq '"' ) {
                if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                    next;
                }
    
                if ( $self->{incr_mode} != INCR_M_STR  ) {
                    $self->{incr_mode} = INCR_M_STR;
                }
                else {
                    $self->{incr_mode} = INCR_M_JSON;
                    unless ( $self->{incr_nest} ) {
                        last;
                    }
                }
            }
    
            if ( $self->{incr_mode} == INCR_M_JSON ) {
    
                if ( $s eq '[' or $s eq '{' ) {
                    if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                        Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                    }
                }
                elsif ( $s eq ']' or $s eq '}' ) {
                    last if ( --$self->{incr_nest} <= 0 );
                }
                elsif ( $s eq '#' ) {
                    while ( $len > $p ) {
                        last if substr( $text, $p++, 1 ) eq "\n";
                    }
                }
    
            }
    
        }
    
        $self->{incr_p} = $p;
    
        return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
        return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
    
        return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
    
        local $Carp::CarpLevel = 2;
    
        $self->{incr_p} = $restore;
        $self->{incr_c} = $p;
    
        my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
    
        $self->{incr_text} = substr( $self->{incr_text}, $p );
        $self->{incr_p} = 0;
    
        return $obj or '';
    }
    
    
    sub incr_text {
        if ( $_[0]->{incr_parsing} ) {
            Carp::croak("incr_text can not be called when the incremental parser already started parsing");
        }
        $_[0]->{incr_text};
    }
    
    
    sub incr_skip {
        my $self  = shift;
        $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
        $self->{incr_p} = 0;
    }
    
    
    sub incr_reset {
        my $self = shift;
        $self->{incr_text}    = undef;
        $self->{incr_p}       = 0;
        $self->{incr_mode}    = 0;
        $self->{incr_nest}    = 0;
        $self->{incr_parsing} = 0;
    }
    
    ###############################
    
    
    1;
    __END__
    =pod
    
    =head1 NAME
    
    JSON::PP - JSON::XS compatible pure-Perl module.
    
    =head1 SYNOPSIS
    
     use JSON::PP;
    
     # exported functions, they croak on error
     # and expect/generate UTF-8
    
     $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
     $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
    
     # OO-interface
    
     $coder = JSON::PP->new->ascii->pretty->allow_nonref;
     
     $json_text   = $json->encode( $perl_scalar );
     $perl_scalar = $json->decode( $json_text );
     
     $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
     
     # Note that JSON version 2.0 and above will automatically use
     # JSON::XS or JSON::PP, so you should be able to just:
     
     use JSON;
    
    
    =head1 VERSION
    
        2.27202
    
    L<JSON::XS> 2.27 (~2.30) compatible.
    
    =head1 NOTE
    
    JSON::PP had been inculded in JSON distribution (CPAN module).
    It was a perl core module in Perl 5.14.
    
    =head1 DESCRIPTION
    
    This module is L<JSON::XS> compatible pure Perl module.
    (Perl 5.8 or later is recommended)
    
    JSON::XS is the fastest and most proper JSON module on CPAN.
    It is written by Marc Lehmann in C, so must be compiled and
    installed in the used environment.
    
    JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
    
    
    =head2 FEATURES
    
    =over
    
    =item * correct unicode handling
    
    This module knows how to handle Unicode (depending on Perl version).
    
    See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and L<UNICODE HANDLING ON PERLS>.
    
    
    =item * round-trip integrity
    
    When you serialise a perl data structure using only data types supported
    by JSON and Perl, the deserialised data structure is identical on the Perl
    level. (e.g. the string "2.0" doesn't suddenly become "2" just because
    it looks like a number). There I<are> minor exceptions to this, read the
    MAPPING section below to learn about those.
    
    
    =item * strict checking of JSON correctness
    
    There is no guessing, no generating of illegal JSON texts by default,
    and only JSON is accepted as input by default (the latter is a security feature).
    But when some options are set, loose chcking features are available.
    
    =back
    
    =head1 FUNCTIONAL INTERFACE
    
    Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
    
    =head2 encode_json
    
        $json_text = encode_json $perl_scalar
    
    Converts the given Perl data structure to a UTF-8 encoded, binary string.
    
    This function call is functionally identical to:
    
        $json_text = JSON::PP->new->utf8->encode($perl_scalar)
    
    =head2 decode_json
    
        $perl_scalar = decode_json $json_text
    
    The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
    to parse that as an UTF-8 encoded JSON text, returning the resulting
    reference.
    
    This function call is functionally identical to:
    
        $perl_scalar = JSON::PP->new->utf8->decode($json_text)
    
    =head2 JSON::PP::is_bool
    
        $is_boolean = JSON::PP::is_bool($scalar)
    
    Returns true if the passed scalar represents either JSON::PP::true or
    JSON::PP::false, two constants that act like C<1> and C<0> respectively
    and are also used to represent JSON C<true> and C<false> in Perl strings.
    
    =head2 JSON::PP::true
    
    Returns JSON true value which is blessed object.
    It C<isa> JSON::PP::Boolean object.
    
    =head2 JSON::PP::false
    
    Returns JSON false value which is blessed object.
    It C<isa> JSON::PP::Boolean object.
    
    =head2 JSON::PP::null
    
    Returns C<undef>.
    
    See L<MAPPING>, below, for more information on how JSON values are mapped to
    Perl.
    
    
    =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
    
    This section supposes that your perl vresion is 5.8 or later.
    
    If you know a JSON text from an outer world - a network, a file content, and so on,
    is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
    with C<utf8> enable. And the decoded result will contain UNICODE characters.
    
      # from network
      my $json        = JSON::PP->new->utf8;
      my $json_text   = CGI->new->param( 'json_data' );
      my $perl_scalar = $json->decode( $json_text );
      
      # from file content
      local $/;
      open( my $fh, '<', 'json.data' );
      $json_text   = <$fh>;
      $perl_scalar = decode_json( $json_text );
    
    If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
    
      use Encode;
      local $/;
      open( my $fh, '<', 'json.data' );
      my $encoding = 'cp932';
      my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
      
      # or you can write the below code.
      #
      # open( my $fh, "<:encoding($encoding)", 'json.data' );
      # $unicode_json_text = <$fh>;
    
    In this case, C<$unicode_json_text> is of course UNICODE string.
    So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
    Instead of them, you use C<JSON> module object with C<utf8> disable.
    
      $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
    
    Or C<encode 'utf8'> and C<decode_json>:
    
      $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
      # this way is not efficient.
    
    And now, you want to convert your C<$perl_scalar> into JSON data and
    send it to an outer world - a network or a file content, and so on.
    
    Your data usually contains UNICODE strings and you want the converted data to be encoded
    in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
    
      print encode_json( $perl_scalar ); # to a network? file? or display?
      # or
      print $json->utf8->encode( $perl_scalar );
    
    If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
    for some reason, then its characters are regarded as B<latin1> for perl
    (because it does not concern with your $encoding).
    You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
    Instead of them, you use C<JSON> module object with C<utf8> disable.
    Note that the resulted text is a UNICODE string but no problem to print it.
    
      # $perl_scalar contains $encoding encoded string values
      $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
      # $unicode_json_text consists of characters less than 0x100
      print $unicode_json_text;
    
    Or C<decode $encoding> all string values and C<encode_json>:
    
      $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
      # ... do it to each string values, then encode_json
      $json_text = encode_json( $perl_scalar );
    
    This method is a proper way but probably not efficient.
    
    See to L<Encode>, L<perluniintro>.
    
    
    =head1 METHODS
    
    Basically, check to L<JSON> or L<JSON::XS>.
    
    =head2 new
    
        $json = JSON::PP->new
    
    Rturns a new JSON::PP object that can be used to de/encode JSON
    strings.
    
    All boolean flags described below are by default I<disabled>.
    
    The mutators for flags all return the JSON object again and thus calls can
    be chained:
    
       my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
       => {"a": [1, 2]}
    
    =head2 ascii
    
        $json = $json->ascii([$enable])
        
        $enabled = $json->get_ascii
    
    If $enable is true (or missing), then the encode method will not generate characters outside
    the code range 0..127. Any Unicode characters outside that range will be escaped using either
    a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
    (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
    
    In Perl 5.005, there is no character having high value (more than 255).
    See to L<UNICODE HANDLING ON PERLS>.
    
    If $enable is false, then the encode method will not escape Unicode characters unless
    required by the JSON syntax or other flags. This results in a faster and more compact format.
    
      JSON::PP->new->ascii(1)->encode([chr 0x10401])
      => ["\ud801\udc01"]
    
    =head2 latin1
    
        $json = $json->latin1([$enable])
        
        $enabled = $json->get_latin1
    
    If $enable is true (or missing), then the encode method will encode the resulting JSON
    text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
    
    If $enable is false, then the encode method will not escape Unicode characters
    unless required by the JSON syntax or other flags.
    
      JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
      => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
    
    See to L<UNICODE HANDLING ON PERLS>.
    
    =head2 utf8
    
        $json = $json->utf8([$enable])
        
        $enabled = $json->get_utf8
    
    If $enable is true (or missing), then the encode method will encode the JSON result
    into UTF-8, as required by many protocols, while the decode method expects to be handled
    an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
    characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
    
    (In Perl 5.005, any character outside the range 0..255 does not exist.
    See to L<UNICODE HANDLING ON PERLS>.)
    
    In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
    encoding families, as described in RFC4627.
    
    If $enable is false, then the encode method will return the JSON string as a (non-encoded)
    Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
    (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
    
    Example, output UTF-16BE-encoded JSON:
    
      use Encode;
      $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
    
    Example, decode UTF-32LE-encoded JSON:
    
      use Encode;
      $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
    
    
    =head2 pretty
    
        $json = $json->pretty([$enable])
    
    This enables (or disables) all of the C<indent>, C<space_before> and
    C<space_after> flags in one call to generate the most readable
    (or most compact) form possible.
    
    Equivalent to:
    
       $json->indent->space_before->space_after
    
    =head2 indent
    
        $json = $json->indent([$enable])
        
        $enabled = $json->get_indent
    
    The default indent space length is three.
    You can use C<indent_length> to change the length.
    
    =head2 space_before
    
        $json = $json->space_before([$enable])
        
        $enabled = $json->get_space_before
    
    If C<$enable> is true (or missing), then the C<encode> method will add an extra
    optional space before the C<:> separating keys from values in JSON objects.
    
    If C<$enable> is false, then the C<encode> method will not add any extra
    space at those places.
    
    This setting has no effect when decoding JSON texts.
    
    Example, space_before enabled, space_after and indent disabled:
    
       {"key" :"value"}
    
    =head2 space_after
    
        $json = $json->space_after([$enable])
        
        $enabled = $json->get_space_after
    
    If C<$enable> is true (or missing), then the C<encode> method will add an extra
    optional space after the C<:> separating keys from values in JSON objects
    and extra whitespace after the C<,> separating key-value pairs and array
    members.
    
    If C<$enable> is false, then the C<encode> method will not add any extra
    space at those places.
    
    This setting has no effect when decoding JSON texts.
    
    Example, space_before and indent disabled, space_after enabled:
    
       {"key": "value"}
    
    =head2 relaxed
    
        $json = $json->relaxed([$enable])
        
        $enabled = $json->get_relaxed
    
    If C<$enable> is true (or missing), then C<decode> will accept some
    extensions to normal JSON syntax (see below). C<encode> will not be
    affected in anyway. I<Be aware that this option makes you accept invalid
    JSON texts as if they were valid!>. I suggest only to use this option to
    parse application-specific files written by humans (configuration files,
    resource files etc.)
    
    If C<$enable> is false (the default), then C<decode> will only accept
    valid JSON texts.
    
    Currently accepted extensions are:
    
    =over 4
    
    =item * list items can have an end-comma
    
    JSON I<separates> array elements and key-value pairs with commas. This
    can be annoying if you write JSON texts manually and want to be able to
    quickly append elements, so this extension accepts comma at the end of
    such items not just between them:
    
       [
          1,
          2, <- this comma not normally allowed
       ]
       {
          "k1": "v1",
          "k2": "v2", <- this comma not normally allowed
       }
    
    =item * shell-style '#'-comments
    
    Whenever JSON allows whitespace, shell-style comments are additionally
    allowed. They are terminated by the first carriage-return or line-feed
    character, after which more white-space and comments are allowed.
    
      [
         1, # this comment not allowed in JSON
            # neither this one...
      ]
    
    =back
    
    =head2 canonical
    
        $json = $json->canonical([$enable])
        
        $enabled = $json->get_canonical
    
    If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
    by sorting their keys. This is adding a comparatively high overhead.
    
    If C<$enable> is false, then the C<encode> method will output key-value
    pairs in the order Perl stores them (which will likely change between runs
    of the same script).
    
    This option is useful if you want the same data structure to be encoded as
    the same JSON text (given the same overall settings). If it is disabled,
    the same hash might be encoded differently even if contains the same data,
    as key-value pairs have no inherent ordering in Perl.
    
    This setting has no effect when decoding JSON texts.
    
    If you want your own sorting routine, you can give a code referece
    or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
    
    =head2 allow_nonref
    
        $json = $json->allow_nonref([$enable])
        
        $enabled = $json->get_allow_nonref
    
    If C<$enable> is true (or missing), then the C<encode> method can convert a
    non-reference into its corresponding string, number or null JSON value,
    which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
    values instead of croaking.
    
    If C<$enable> is false, then the C<encode> method will croak if it isn't
    passed an arrayref or hashref, as JSON texts must either be an object
    or array. Likewise, C<decode> will croak if given something that is not a
    JSON object or array.
    
       JSON::PP->new->allow_nonref->encode ("Hello, World!")
       => "Hello, World!"
    
    =head2 allow_unknown
    
        $json = $json->allow_unknown ([$enable])
        
        $enabled = $json->get_allow_unknown
    
    If $enable is true (or missing), then "encode" will *not* throw an
    exception when it encounters values it cannot represent in JSON (for
    example, filehandles) but instead will encode a JSON "null" value.
    Note that blessed objects are not included here and are handled
    separately by c<allow_nonref>.
    
    If $enable is false (the default), then "encode" will throw an
    exception when it encounters anything it cannot encode as JSON.
    
    This option does not affect "decode" in any way, and it is
    recommended to leave it off unless you know your communications
    partner.
    
    =head2 allow_blessed
    
        $json = $json->allow_blessed([$enable])
        
        $enabled = $json->get_allow_blessed
    
    If C<$enable> is true (or missing), then the C<encode> method will not
    barf when it encounters a blessed reference. Instead, the value of the
    B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
    disabled or no C<TO_JSON> method found) or a representation of the
    object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
    encoded. Has no effect on C<decode>.
    
    If C<$enable> is false (the default), then C<encode> will throw an
    exception when it encounters a blessed object.
    
    =head2 convert_blessed
    
        $json = $json->convert_blessed([$enable])
        
        $enabled = $json->get_convert_blessed
    
    If C<$enable> is true (or missing), then C<encode>, upon encountering a
    blessed object, will check for the availability of the C<TO_JSON> method
    on the object's class. If found, it will be called in scalar context
    and the resulting scalar will be encoded instead of the object. If no
    C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
    to do.
    
    The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
    returns other blessed objects, those will be handled in the same
    way. C<TO_JSON> must take care of not causing an endless recursion cycle
    (== crash) in this case. The name of C<TO_JSON> was chosen because other
    methods called by the Perl core (== not by the user of the object) are
    usually in upper case letters and to avoid collisions with the C<to_json>
    function or method.
    
    This setting does not yet influence C<decode> in any way.
    
    If C<$enable> is false, then the C<allow_blessed> setting will decide what
    to do when a blessed object is found.
    
    =head2 filter_json_object
    
        $json = $json->filter_json_object([$coderef])
    
    When C<$coderef> is specified, it will be called from C<decode> each
    time it decodes a JSON object. The only argument passed to the coderef
    is a reference to the newly-created hash. If the code references returns
    a single scalar (which need not be a reference), this value
    (i.e. a copy of that scalar to avoid aliasing) is inserted into the
    deserialised data structure. If it returns an empty list
    (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
    hash will be inserted. This setting can slow down decoding considerably.
    
    When C<$coderef> is omitted or undefined, any existing callback will
    be removed and C<decode> will not change the deserialised hash in any
    way.
    
    Example, convert all JSON objects into the integer 5:
    
       my $js = JSON::PP->new->filter_json_object (sub { 5 });
       # returns [5]
       $js->decode ('[{}]'); # the given subroutine takes a hash reference.
       # throw an exception because allow_nonref is not enabled
       # so a lone 5 is not allowed.
       $js->decode ('{"a":1, "b":2}');
    
    =head2 filter_json_single_key_object
    
        $json = $json->filter_json_single_key_object($key [=> $coderef])
    
    Works remotely similar to C<filter_json_object>, but is only called for
    JSON objects having a single key named C<$key>.
    
    This C<$coderef> is called before the one specified via
    C<filter_json_object>, if any. It gets passed the single value in the JSON
    object. If it returns a single value, it will be inserted into the data
    structure. If it returns nothing (not even C<undef> but the empty list),
    the callback from C<filter_json_object> will be called next, as if no
    single-key callback were specified.
    
    If C<$coderef> is omitted or undefined, the corresponding callback will be
    disabled. There can only ever be one callback for a given key.
    
    As this callback gets called less often then the C<filter_json_object>
    one, decoding speed will not usually suffer as much. Therefore, single-key
    objects make excellent targets to serialise Perl objects into, especially
    as single-key JSON objects are as close to the type-tagged value concept
    as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
    support this in any way, so you need to make sure your data never looks
    like a serialised Perl hash.
    
    Typical names for the single object key are C<__class_whatever__>, or
    C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
    things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
    with real hashes.
    
    Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
    into the corresponding C<< $WIDGET{<id>} >> object:
    
       # return whatever is in $WIDGET{5}:
       JSON::PP
          ->new
          ->filter_json_single_key_object (__widget__ => sub {
                $WIDGET{ $_[0] }
             })
          ->decode ('{"__widget__": 5')
    
       # this can be used with a TO_JSON method in some "widget" class
       # for serialisation to json:
       sub WidgetBase::TO_JSON {
          my ($self) = @_;
    
          unless ($self->{id}) {
             $self->{id} = ..get..some..id..;
             $WIDGET{$self->{id}} = $self;
          }
    
          { __widget__ => $self->{id} }
       }
    
    =head2 shrink
    
        $json = $json->shrink([$enable])
        
        $enabled = $json->get_shrink
    
    In JSON::XS, this flag resizes strings generated by either
    C<encode> or C<decode> to their minimum size possible.
    It will also try to downgrade any strings to octet-form if possible.
    
    In JSON::PP, it is noop about resizing strings but tries
    C<utf8::downgrade> to the returned string by C<encode>.
    See to L<utf8>.
    
    See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
    
    =head2 max_depth
    
        $json = $json->max_depth([$maximum_nesting_depth])
        
        $max_depth = $json->get_max_depth
    
    Sets the maximum nesting level (default C<512>) accepted while encoding
    or decoding. If a higher nesting level is detected in JSON text or a Perl
    data structure, then the encoder and decoder will stop and croak at that
    point.
    
    Nesting level is defined by number of hash- or arrayrefs that the encoder
    needs to traverse to reach a given point or the number of C<{> or C<[>
    characters without their matching closing parenthesis crossed to reach a
    given character in a string.
    
    If no argument is given, the highest possible setting will be used, which
    is rarely useful.
    
    See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
    
    When a large value (100 or more) was set and it de/encodes a deep nested object/text,
    it may raise a warning 'Deep recursion on subroutin' at the perl runtime phase.
    
    =head2 max_size
    
        $json = $json->max_size([$maximum_string_size])
        
        $max_size = $json->get_max_size
    
    Set the maximum length a JSON text may have (in bytes) where decoding is
    being attempted. The default is C<0>, meaning no limit. When C<decode>
    is called on a string that is longer then this many bytes, it will not
    attempt to decode the string but throw an exception. This setting has no
    effect on C<encode> (yet).
    
    If no argument is given, the limit check will be deactivated (same as when
    C<0> is specified).
    
    See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
    
    =head2 encode
    
        $json_text = $json->encode($perl_scalar)
    
    Converts the given Perl data structure (a simple scalar or a reference
    to a hash or array) to its JSON representation. Simple scalars will be
    converted into JSON string or number sequences, while references to arrays
    become JSON arrays and references to hashes become JSON objects. Undefined
    Perl values (e.g. C<undef>) become JSON C<null> values.
    References to the integers C<0> and C<1> are converted into C<true> and C<false>.
    
    =head2 decode
    
        $perl_scalar = $json->decode($json_text)
    
    The opposite of C<encode>: expects a JSON text and tries to parse it,
    returning the resulting simple scalar or reference. Croaks on error.
    
    JSON numbers and strings become simple Perl scalars. JSON arrays become
    Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
    C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
    C<null> becomes C<undef>.
    
    =head2 decode_prefix
    
        ($perl_scalar, $characters) = $json->decode_prefix($json_text)
    
    This works like the C<decode> method, but instead of raising an exception
    when there is trailing garbage after the first JSON object, it will
    silently stop parsing there and return the number of characters consumed
    so far.
    
       JSON->new->decode_prefix ("[1] the tail")
       => ([], 3)
    
    =head1 INCREMENTAL PARSING
    
    Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
    
    In some cases, there is the need for incremental parsing of JSON texts.
    This module does allow you to parse a JSON stream incrementally.
    It does so by accumulating text until it has a full JSON object, which
    it then can decode. This process is similar to using C<decode_prefix>
    to see if a full JSON object is available, but is much more efficient
    (and can be implemented with a minimum of method calls).
    
    This module will only attempt to parse the JSON text once it is sure it
    has enough text to get a decisive result, using a very simple but
    truly incremental parser. This means that it sometimes won't stop as
    early as the full parser, for example, it doesn't detect parenthese
    mismatches. The only thing it guarantees is that it starts decoding as
    soon as a syntactically valid JSON text has been seen. This means you need
    to set resource limits (e.g. C<max_size>) to ensure the parser will stop
    parsing in the presence if syntax errors.
    
    The following methods implement this incremental parser.
    
    =head2 incr_parse
    
        $json->incr_parse( [$string] ) # void context
        
        $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
        
        @obj_or_empty = $json->incr_parse( [$string] ) # list context
    
    This is the central parsing function. It can both append new text and
    extract objects from the stream accumulated so far (both of these
    functions are optional).
    
    If C<$string> is given, then this string is appended to the already
    existing JSON fragment stored in the C<$json> object.
    
    After that, if the function is called in void context, it will simply
    return without doing anything further. This can be used to add more text
    in as many chunks as you want.
    
    If the method is called in scalar context, then it will try to extract
    exactly I<one> JSON object. If that is successful, it will return this
    object, otherwise it will return C<undef>. If there is a parse error,
    this method will croak just as C<decode> would do (one can then use
    C<incr_skip> to skip the errornous part). This is the most common way of
    using the method.
    
    And finally, in list context, it will try to extract as many objects
    from the stream as it can find and return them, or the empty list
    otherwise. For this to work, there must be no separators between the JSON
    objects or arrays, instead they must be concatenated back-to-back. If
    an error occurs, an exception will be raised as in the scalar context
    case. Note that in this case, any previously-parsed JSON texts will be
    lost.
    
    Example: Parse some JSON arrays/objects in a given string and return them.
    
        my @objs = JSON->new->incr_parse ("[5][7][1,2]");
    
    =head2 incr_text
    
        $lvalue_string = $json->incr_text
    
    This method returns the currently stored JSON fragment as an lvalue, that
    is, you can manipulate it. This I<only> works when a preceding call to
    C<incr_parse> in I<scalar context> successfully returned an object. Under
    all other circumstances you must not call this function (I mean it.
    although in simple tests it might actually work, it I<will> fail under
    real world conditions). As a special exception, you can also call this
    method before having parsed anything.
    
    This function is useful in two cases: a) finding the trailing text after a
    JSON object or b) parsing multiple JSON objects separated by non-JSON text
    (such as commas).
    
        $json->incr_text =~ s/\s*,\s*//;
    
    In Perl 5.005, C<lvalue> attribute is not available.
    You must write codes like the below:
    
        $string = $json->incr_text;
        $string =~ s/\s*,\s*//;
        $json->incr_text( $string );
    
    =head2 incr_skip
    
        $json->incr_skip
    
    This will reset the state of the incremental parser and will remove the
    parsed text from the input buffer. This is useful after C<incr_parse>
    died, in which case the input buffer and incremental parser state is left
    unchanged, to skip the text parsed so far and to reset the parse state.
    
    =head2 incr_reset
    
        $json->incr_reset
    
    This completely resets the incremental parser, that is, after this call,
    it will be as if the parser had never parsed anything.
    
    This is useful if you want ot repeatedly parse JSON objects and want to
    ignore any trailing data, which means you have to reset the parser after
    each successful decode.
    
    See to L<JSON::XS/INCREMENTAL PARSING> for examples.
    
    
    =head1 JSON::PP OWN METHODS
    
    =head2 allow_singlequote
    
        $json = $json->allow_singlequote([$enable])
    
    If C<$enable> is true (or missing), then C<decode> will accept
    JSON strings quoted by single quotations that are invalid JSON
    format.
    
        $json->allow_singlequote->decode({"foo":'bar'});
        $json->allow_singlequote->decode({'foo':"bar"});
        $json->allow_singlequote->decode({'foo':'bar'});
    
    As same as the C<relaxed> option, this option may be used to parse
    application-specific files written by humans.
    
    
    =head2 allow_barekey
    
        $json = $json->allow_barekey([$enable])
    
    If C<$enable> is true (or missing), then C<decode> will accept
    bare keys of JSON object that are invalid JSON format.
    
    As same as the C<relaxed> option, this option may be used to parse
    application-specific files written by humans.
    
        $json->allow_barekey->decode('{foo:"bar"}');
    
    =head2 allow_bignum
    
        $json = $json->allow_bignum([$enable])
    
    If C<$enable> is true (or missing), then C<decode> will convert
    the big integer Perl cannot handle as integer into a L<Math::BigInt>
    object and convert a floating number (any) into a L<Math::BigFloat>.
    
    On the contary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
    objects into JSON numbers with C<allow_blessed> enable.
    
       $json->allow_nonref->allow_blessed->allow_bignum;
       $bigfloat = $json->decode('2.000000000000000000000000001');
       print $json->encode($bigfloat);
       # => 2.000000000000000000000000001
    
    See to L<JSON::XS/MAPPING> aboout the normal conversion of JSON number.
    
    =head2 loose
    
        $json = $json->loose([$enable])
    
    The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
    and the module doesn't allow to C<decode> to these (except for \x2f).
    If C<$enable> is true (or missing), then C<decode>  will accept these
    unescaped strings.
    
        $json->loose->decode(qq|["abc
                                       def"]|);
    
    See L<JSON::XS/SSECURITY CONSIDERATIONS>.
    
    =head2 escape_slash
    
        $json = $json->escape_slash([$enable])
    
    According to JSON Grammar, I<slash> (U+002F) is escaped. But default
    JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
    
    If C<$enable> is true (or missing), then C<encode> will escape slashes.
    
    =head2 indent_length
    
        $json = $json->indent_length($length)
    
    JSON::XS indent space length is 3 and cannot be changed.
    JSON::PP set the indent space length with the given $length.
    The default is 3. The acceptable range is 0 to 15.
    
    =head2 sort_by
    
        $json = $json->sort_by($function_name)
        $json = $json->sort_by($subroutine_ref)
    
    If $function_name or $subroutine_ref are set, its sort routine are used
    in encoding JSON objects.
    
       $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
       # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
    
       $js = $pc->sort_by('own_sort')->encode($obj);
       # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
    
       sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
    
    As the sorting routine runs in the JSON::PP scope, the given
    subroutine name and the special variables C<$a>, C<$b> will begin
    'JSON::PP::'.
    
    If $integer is set, then the effect is same as C<canonical> on.
    
    =head1 INTERNAL
    
    For developers.
    
    =over
    
    =item PP_encode_box
    
    Returns
    
            {
                depth        => $depth,
                indent_count => $indent_count,
            }
    
    
    =item PP_decode_box
    
    Returns
    
            {
                text    => $text,
                at      => $at,
                ch      => $ch,
                len     => $len,
                depth   => $depth,
                encoding      => $encoding,
                is_valid_utf8 => $is_valid_utf8,
            };
    
    =back
    
    =head1 MAPPING
    
    This section is copied from JSON::XS and modified to C<JSON::PP>.
    JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
    
    See to L<JSON::XS/MAPPING>.
    
    =head2 JSON -> PERL
    
    =over 4
    
    =item object
    
    A JSON object becomes a reference to a hash in Perl. No ordering of object
    keys is preserved (JSON does not preserver object key ordering itself).
    
    =item array
    
    A JSON array becomes a reference to an array in Perl.
    
    =item string
    
    A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
    are represented by the same codepoints in the Perl string, so no manual
    decoding is necessary.
    
    =item number
    
    A JSON number becomes either an integer, numeric (floating point) or
    string scalar in perl, depending on its range and any fractional parts. On
    the Perl level, there is no difference between those as Perl handles all
    the conversion details, but an integer may take slightly less memory and
    might represent more values exactly than floating point numbers.
    
    If the number consists of digits only, C<JSON> will try to represent
    it as an integer value. If that fails, it will try to represent it as
    a numeric (floating point) value if that is possible without loss of
    precision. Otherwise it will preserve the number as a string value (in
    which case you lose roundtripping ability, as the JSON number will be
    re-encoded toa JSON string).
    
    Numbers containing a fractional or exponential part will always be
    represented as numeric (floating point) values, possibly at a loss of
    precision (in which case you might lose perfect roundtripping ability, but
    the JSON number will still be re-encoded as a JSON number).
    
    Note that precision is not accuracy - binary floating point values cannot
    represent most decimal fractions exactly, and when converting from and to
    floating point, C<JSON> only guarantees precision up to but not including
    the leats significant bit.
    
    When C<allow_bignum> is enable, the big integers 
    and the numeric can be optionally converted into L<Math::BigInt> and
    L<Math::BigFloat> objects.
    
    =item true, false
    
    These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
    respectively. They are overloaded to act almost exactly like the numbers
    C<1> and C<0>. You can check wether a scalar is a JSON boolean by using
    the C<JSON::is_bool> function.
    
       print JSON::PP::true . "\n";
        => true
       print JSON::PP::true + 1;
        => 1
    
       ok(JSON::true eq  '1');
       ok(JSON::true == 1);
    
    C<JSON> will install these missing overloading features to the backend modules.
    
    
    =item null
    
    A JSON null atom becomes C<undef> in Perl.
    
    C<JSON::PP::null> returns C<unddef>.
    
    =back
    
    
    =head2 PERL -> JSON
    
    The mapping from Perl to JSON is slightly more difficult, as Perl is a
    truly typeless language, so we can only guess which JSON type is meant by
    a Perl value.
    
    =over 4
    
    =item hash references
    
    Perl hash references become JSON objects. As there is no inherent ordering
    in hash keys (or JSON objects), they will usually be encoded in a
    pseudo-random order that can change between runs of the same program but
    stays generally the same within a single run of a program. C<JSON>
    optionally sort the hash keys (determined by the I<canonical> flag), so
    the same datastructure will serialise to the same JSON text (given same
    settings and version of JSON::XS), but this incurs a runtime overhead
    and is only rarely useful, e.g. when you want to compare some JSON text
    against another for equality.
    
    
    =item array references
    
    Perl array references become JSON arrays.
    
    =item other references
    
    Other unblessed references are generally not allowed and will cause an
    exception to be thrown, except for references to the integers C<0> and
    C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
    also use C<JSON::false> and C<JSON::true> to improve readability.
    
       to_json [\0,JSON::PP::true]      # yields [false,true]
    
    =item JSON::PP::true, JSON::PP::false, JSON::PP::null
    
    These special values become JSON true and JSON false values,
    respectively. You can also use C<\1> and C<\0> directly if you want.
    
    JSON::PP::null returns C<undef>.
    
    =item blessed objects
    
    Blessed objects are not directly representable in JSON. See the
    C<allow_blessed> and C<convert_blessed> methods on various options on
    how to deal with this: basically, you can choose between throwing an
    exception, encoding the reference as if it weren't blessed, or provide
    your own serialiser method.
    
    See to L<convert_blessed>.
    
    =item simple scalars
    
    Simple Perl scalars (any scalar that is not a reference) are the most
    difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
    JSON C<null> values, scalars that have last been used in a string context
    before encoding as JSON strings, and anything else as number value:
    
       # dump as number
       encode_json [2]                      # yields [2]
       encode_json [-3.0e17]                # yields [-3e+17]
       my $value = 5; encode_json [$value]  # yields [5]
    
       # used as string, so dump as string
       print $value;
       encode_json [$value]                 # yields ["5"]
    
       # undef becomes null
       encode_json [undef]                  # yields [null]
    
    You can force the type to be a string by stringifying it:
    
       my $x = 3.1; # some variable containing a number
       "$x";        # stringified
       $x .= "";    # another, more awkward way to stringify
       print $x;    # perl does it for you, too, quite often
    
    You can force the type to be a number by numifying it:
    
       my $x = "3"; # some variable containing a string
       $x += 0;     # numify it, ensuring it will be dumped as a number
       $x *= 1;     # same thing, the choise is yours.
    
    You can not currently force the type in other, less obscure, ways.
    
    Note that numerical precision has the same meaning as under Perl (so
    binary to decimal conversion follows the same rules as in Perl, which
    can differ to other languages). Also, your perl interpreter might expose
    extensions to the floating point numbers of your platform, such as
    infinities or NaN's - these cannot be represented in JSON, and it is an
    error to pass those in.
    
    =item Big Number
    
    When C<allow_bignum> is enable, 
    C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
    objects into JSON numbers.
    
    
    =back
    
    =head1 UNICODE HANDLING ON PERLS
    
    If you do not know about Unicode on Perl well,
    please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
    
    =head2 Perl 5.8 and later
    
    Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
    
        $json->allow_nonref->encode(chr hex 3042);
        $json->allow_nonref->encode(chr hex 12345);
    
    Reuturns C<"\u3042"> and C<"\ud808\udf45"> respectively.
    
        $json->allow_nonref->decode('"\u3042"');
        $json->allow_nonref->decode('"\ud808\udf45"');
    
    Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
    
    Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
    so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
    
    
    =head2 Perl 5.6
    
    Perl can handle Unicode and the JSON::PP de/encode methods also work.
    
    =head2 Perl 5.005
    
    Perl 5.005 is a byte sementics world -- all strings are sequences of bytes.
    That means the unicode handling is not available.
    
    In encoding,
    
        $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
        $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
    
    Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
    as C<$value % 256>, so the above codes are equivalent to :
    
        $json->allow_nonref->encode(chr 66);
        $json->allow_nonref->encode(chr 69);
    
    In decoding,
    
        $json->decode('"\u00e3\u0081\u0082"');
    
    The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
    japanese character (C<HIRAGANA LETTER A>).
    And if it is represented in Unicode code point, C<U+3042>.
    
    Next, 
    
        $json->decode('"\u3042"');
    
    We ordinary expect the returned value is a Unicode character C<U+3042>.
    But here is 5.005 world. This is C<0xE3 0x81 0x82>.
    
        $json->decode('"\ud808\udf45"');
    
    This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
    
    
    =head1 TODO
    
    =over
    
    =item speed
    
    =item memory saving
    
    =back
    
    
    =head1 SEE ALSO
    
    Most of the document are copied and modified from JSON::XS doc.
    
    L<JSON::XS>
    
    RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
    
    =head1 AUTHOR
    
    Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
    
    
    =head1 COPYRIGHT AND LICENSE
    
    Copyright 2007-2013 by Makamaka Hannyaharamitu
    
    This library is free software; you can redistribute it and/or modify
    it under the same terms as Perl itself. 
    
    =cut
  JSON_PP
  
  $fatpacked{"JSON/PP/Boolean.pm"} = <<'JSON_PP_BOOLEAN';
    =head1 NAME
    
    JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
    
    =head1 SYNOPSIS
    
     # do not "use" yourself
    
    =head1 DESCRIPTION
    
    This module exists only to provide overload resolution for Storable and similar modules. See
    L<JSON::PP> for more info about this class.
    
    =cut
    
    use JSON::PP ();
    use strict;
    
    1;
    
    =head1 AUTHOR
    
    This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
    
    =cut
    
  JSON_PP_BOOLEAN
  
  $fatpacked{"Module/CPANfile.pm"} = <<'MODULE_CPANFILE';
    package Module::CPANfile;
    use strict;
    use warnings;
    use Cwd;
    use Carp ();
    use Module::CPANfile::Environment;
    use Module::CPANfile::Result;
    
    our $VERSION = '1.0002';
    
    sub new {
        my($class, $file) = @_;
        bless {}, $class;
    }
    
    sub load {
        my($proto, $file) = @_;
    
        my $self = ref $proto ? $proto : $proto->new;
        $self->parse($file || Cwd::abs_path('cpanfile'));
        $self;
    }
    
    sub save {
        my($self, $path) = @_;
    
        open my $out, ">", $path or die "$path: $!";
        print {$out} $self->to_string;
    }
    
    sub parse {
        my($self, $file) = @_;
    
        my $code = do {
            open my $fh, "<", $file or die "$file: $!";
            join '', <$fh>;
        };
    
        my $env = Module::CPANfile::Environment->new($file);
        $self->{result} = $env->parse($code) or die $@;
    }
    
    sub from_prereqs {
        my($proto, $prereqs) = @_;
    
        my $self = $proto->new;
        $self->{result} = Module::CPANfile::Result->from_prereqs($prereqs);
    
        $self;
    }
    
    sub features {
        my $self = shift;
        map $self->feature($_), keys %{$self->{result}{features}};
    }
    
    sub feature {
        my($self, $identifier) = @_;
    
        my $data = $self->{result}{features}{$identifier}
          or Carp::croak("Unknown feature '$identifier'");
    
        require CPAN::Meta::Feature;
        CPAN::Meta::Feature->new($data->{identifier}, {
            description => $data->{description},
            prereqs => $data->{spec},
        });
    }
    
    sub prereq { shift->prereqs }
    
    sub prereqs {
        my $self = shift;
        require CPAN::Meta::Prereqs;
        CPAN::Meta::Prereqs->new($self->prereq_specs);
    }
    
    sub effective_prereqs {
        my($self, $features) = @_;
        $self->prereqs_with(@{$features || []});
    }
    
    sub prereqs_with {
        my($self, @feature_identifiers) = @_;
    
        my $prereqs = $self->prereqs;
        my @others = map { $self->feature($_)->prereqs } @feature_identifiers;
    
        $prereqs->with_merged_prereqs(\@others);
    }
    
    sub prereq_specs {
        my $self = shift;
        $self->{result}{spec};
    }
    
    sub merge_meta {
        my($self, $file, $version) = @_;
    
        require CPAN::Meta;
    
        $version ||= $file =~ /\.yml$/ ? '1.4' : '2';
    
        my $prereq = $self->prereqs;
    
        my $meta = CPAN::Meta->load_file($file);
        my $prereqs_hash = $prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;
        my $struct = { %{$meta->as_struct}, prereqs => $prereqs_hash };
    
        CPAN::Meta->new($struct)->save($file, { version => $version });
    }
    
    sub _dump {
        my $str = shift;
        require Data::Dumper;
        chomp(my $value = Data::Dumper->new([$str])->Terse(1)->Dump);
        $value;
    }
    
    sub to_string {
        my($self, $include_empty) = @_;
    
        my $prereqs = $self->{result}{spec};
    
        my $code = '';
        $code .= $self->_dump_prereqs($self->{result}{spec}, $include_empty);
    
        for my $feature (values %{$self->{result}{features}}) {
            $code .= sprintf "feature %s, %s => sub {\n", _dump($feature->{identifier}), _dump($feature->{description});
            $code .= $self->_dump_prereqs($feature->{spec}, $include_empty, 4);
            $code .= "}\n\n";
        }
    
        $code =~ s/\n+$/\n/s;
        $code;
    }
    
    sub _dump_prereqs {
        my($self, $prereqs, $include_empty, $base_indent) = @_;
    
        my $code = '';
        for my $phase (qw(runtime configure build test develop)) {
            my $indent = $phase eq 'runtime' ? '' : '    ';
            $indent = (' ' x ($base_indent || 0)) . $indent;
    
            my($phase_code, $requirements);
            $phase_code .= "on $phase => sub {\n" unless $phase eq 'runtime';
    
            for my $type (qw(requires recommends suggests conflicts)) {
                for my $mod (sort keys %{$prereqs->{$phase}{$type}}) {
                    my $ver = $prereqs->{$phase}{$type}{$mod};
                    $phase_code .= $ver eq '0'
                                 ? "${indent}$type '$mod';\n"
                                 : "${indent}$type '$mod', '$ver';\n";
                    $requirements++;
                }
            }
    
            $phase_code .= "\n" unless $requirements;
            $phase_code .= "};\n" unless $phase eq 'runtime';
    
            $code .= $phase_code . "\n" if $requirements or $include_empty;
        }
    
        $code =~ s/\n+$/\n/s;
        $code;
    }
    
    1;
    
    __END__
    
    =head1 NAME
    
    Module::CPANfile - Parse cpanfile
    
    =head1 SYNOPSIS
    
      use Module::CPANfile;
    
      my $file = Module::CPANfile->load("cpanfile");
      my $prereqs = $file->prereqs; # CPAN::Meta::Prereqs object
    
      my @features = $file->features; # CPAN::Meta::Feature objects
      my $merged_prereqs = $file->prereqs_with(@identifiers); # CPAN::Meta::Prereqs
    
      $file->merge_meta('MYMETA.json');
    
    =head1 DESCRIPTION
    
    Module::CPANfile is a tool to handle L<cpanfile> format to load application
    specific dependencies, not just for CPAN distributions.
    
    =head1 METHODS
    
    =over 4
    
    =item load
    
      $file = Module::CPANfile->load;
      $file = Module::CPANfile->load('cpanfile');
    
    Load and parse a cpanfile. By default it tries to load C<cpanfile> in
    the current directory, unless you pass the path to its argument.
    
    =item from_prereqs
    
      $file = Module::CPANfile->from_prereqs({
        runtime => { requires => { DBI => '1.000' } },
      });
    
    Creates a new Module::CPANfile object from prereqs hash you can get
    via L<CPAN::Meta>'s C<prereqs>, or L<CPAN::Meta::Prereqs>'
    C<as_string_hash>.
    
      # read MYMETA, then feed the prereqs to create Module::CPANfile
      my $meta = CPAN::Meta->load_file('MYMETA.json');
      my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    
      # load cpanfile, then recreate it with round-trip
      my $file = Module::CPANfile->load('cpanfile');
      $file = Module::CPANfile->from_prereqs($file->prereq_specs);
                                        # or $file->prereqs->as_string_hash
    
    =item prereqs
    
    Returns L<CPAN::Meta::Prereqs> object out of the parsed cpanfile.
    
    =item prereq_specs
    
    Returns a hash reference that should be passed to C<< CPAN::Meta::Prereqs->new >>.
    
    =item features
    
    Returns a list of features available in the cpanfile as L<CPAN::Meta::Feature>.
    
    =item prereqs_with(@identifiers), effective_prereqs(\@identifiers)
    
    Returns L<CPAN::Meta::Prereqs> object, with merged prereqs for
    features identified with the C<@identifiers>.
    
    =item to_string($include_empty)
    
      $file->to_string;
      $file->to_string(1);
    
    Returns a canonical string (code) representation for cpanfile. Useful
    if you want to convert L<CPAN::Meta::Prereqs> to a new cpanfile.
    
      # read MYMETA's prereqs and print cpanfile representation of it
      my $meta = CPAN::Meta->load_file('MYMETA.json');
      my $file = Module::CPANfile->from_prereqs($meta->prereqs);
      print $file->to_sring;
    
    By default, it omits the phase where there're no modules
    registered. If you pass the argument of a true value, it will print
    them as well.
    
    =item save
    
      $file->save('cpanfile');
    
    Saves the currently loaded prereqs as a new C<cpanfile> by calling
    C<to_string>. Beware B<this method will overwrite the existing
    cpanfile without any warning or backup>. Taking a backup or giving
    warnings to users is a caller's responsibility.
    
      # Read MYMETA.json and creates a new cpanfile
      my $meta = CPAN::Meta->load_file('MYMETA.json');
      my $file = Module::CPANfile->from_prereqs($meta->prereqs);
      $file->save('cpanfile');
    
    =item merge_meta
    
      $file->merge_meta('META.yml');
      $file->merge_meta('MYMETA.json', '2.0');
    
    Merge the effective prereqs with Meta specification loaded from the
    given META file, using CPAN::Meta. You can specify the META spec
    version in the second argument, which defaults to 1.4 in case the
    given file is YAML, and 2 if it is JSON.
    
    =back
    
    =head1 AUTHOR
    
    Tatsuhiko Miyagawa
    
    =head1 SEE ALSO
    
    L<cpanfile>, L<CPAN::Meta>, L<CPAN::Meta::Spec>
    
    =cut
  MODULE_CPANFILE
  
  $fatpacked{"Module/CPANfile/Environment.pm"} = <<'MODULE_CPANFILE_ENVIRONMENT';
    package Module::CPANfile::Environment;
    use strict;
    use warnings;
    use Module::CPANfile::Result;
    use Carp ();
    
    my @bindings = qw(
        on requires recommends suggests conflicts
        feature
        osname
        configure_requires build_requires test_requires author_requires
    );
    
    my $file_id = 1;
    
    sub new {
        my($class, $file) = @_;
        bless {
            file => $file,
        }, $class;
    }
    
    sub bind {
        my $class = shift;
        my $pkg = caller;
    
        my $result = Module::CPANfile::Result->new;
        for my $binding (@bindings) {
            no strict 'refs';
            *{"$pkg\::$binding"} = sub { $result->$binding(@_) };
        }
    
        return $result;
    }
    
    sub parse {
        my($self, $code) = @_;
    
        my($res, $err);
    
        {
            local $@;
            $file_id++;
            $res = eval <<EVAL;
    package Module::CPANfile::Sandbox$file_id;
    no warnings;
    my \$_result;
    BEGIN { \$_result = Module::CPANfile::Environment->bind }
    
    # line 1 "$self->{file}"
    $code;
    
    \$_result;
    EVAL
            $err = $@;
        }
    
        if ($err) { die "Parsing $self->{file} failed: $err" };
    
        return $res;
    }
    
    1;
    
  MODULE_CPANFILE_ENVIRONMENT
  
  $fatpacked{"Module/CPANfile/Result.pm"} = <<'MODULE_CPANFILE_RESULT';
    package Module::CPANfile::Result;
    use strict;
    
    sub from_prereqs {
        my($class, $spec) = @_;
        bless {
            phase => 'runtime',
            spec => $spec,
        }, $class;
    }
    
    sub new {
        bless {
            phase => 'runtime', # default phase
            features => {},
            feature => undef,
            spec  => {},
        }, shift;
    }
    
    sub on {
        my($self, $phase, $code) = @_;
        local $self->{phase} = $phase;
        $code->()
    }
    
    sub feature {
        my($self, $identifier, $description, $code) = @_;
    
        # shortcut: feature identifier => sub { ... }
        if (@_ == 3 && ref($description) eq 'CODE') {
            $code = $description;
            $description = $identifier;
        }
    
        unless (ref $description eq '' && ref $code eq 'CODE') {
            Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }");
        }
    
        local $self->{feature} = $self->{features}{$identifier}
          = { identifier => $identifier, description => $description, spec => {} };
        $code->();
    }
    
    sub osname { die "TODO" }
    
    sub requires {
        my($self, $module, $requirement) = @_;
        ($self->{feature} ? $self->{feature}{spec} : $self->{spec})
          ->{$self->{phase}}{requires}{$module} = $requirement || 0;
    }
    
    sub recommends {
        my($self, $module, $requirement) = @_;
        ($self->{feature} ? $self->{feature}{spec} : $self->{spec})
          ->{$self->{phase}}{recommends}{$module} = $requirement || 0;
    }
    
    sub suggests {
        my($self, $module, $requirement) = @_;
        ($self->{feature} ? $self->{feature}{spec} : $self->{spec})
          ->{$self->{phase}}{suggests}{$module} = $requirement || 0;
    }
    
    sub conflicts {
        my($self, $module, $requirement) = @_;
        ($self->{feature} ? $self->{feature}{spec} : $self->{spec})
          ->{$self->{phase}}{conflicts}{$module} = $requirement || 0;
    }
    
    # Module::Install compatible shortcuts
    
    sub configure_requires {
        my($self, @args) = @_;
        $self->on(configure => sub { $self->requires(@args) });
    }
    
    sub build_requires {
        my($self, @args) = @_;
        $self->on(build => sub { $self->requires(@args) });
    }
    
    sub test_requires {
        my($self, @args) = @_;
        $self->on(test => sub { $self->requires(@args) });
    }
    
    sub author_requires {
        my($self, @args) = @_;
        $self->on(develop => sub { $self->requires(@args) });
    }
    
    1;
  MODULE_CPANFILE_RESULT
  
  $fatpacked{"Module/Metadata.pm"} = <<'MODULE_METADATA';
    # -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
    # vim:ts=8:sw=2:et:sta:sts=2
    package Module::Metadata;
    
    # Adapted from Perl-licensed code originally distributed with
    # Module-Build by Ken Williams
    
    # This module provides routines to gather information about
    # perl modules (assuming this may be expanded in the distant
    # parrot future to look at other types of modules).
    
    use strict;
    use vars qw($VERSION);
    $VERSION = '1.000016';
    $VERSION = eval $VERSION;
    
    use Carp qw/croak/;
    use File::Spec;
    use IO::File;
    use version 0.87;
    BEGIN {
      if ($INC{'Log/Contextual.pm'}) {
        Log::Contextual->import('log_info');
      } else {
        *log_info = sub (&) { warn $_[0]->() };
      }
    }
    use File::Find qw(find);
    
    my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal
    
    my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
      [a-zA-Z_]                     # the first word CANNOT start with a digit
        (?:
          [\w']?                    # can contain letters, digits, _, or ticks
          \w                        # But, NO multi-ticks or trailing ticks
        )*
    }x;
    
    my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
      \w                           # the 2nd+ word CAN start with digits
        (?:
          [\w']?                   # and can contain letters or ticks
          \w                       # But, NO multi-ticks or trailing ticks
        )*
    }x;
    
    my $PKG_NAME_REGEXP = qr{ # match a package name
      (?: :: )?               # a pkg name can start with aristotle
      $PKG_FIRST_WORD_REGEXP  # a package word
      (?:
        (?: :: )+             ### aristotle (allow one or many times)
        $PKG_ADDL_WORD_REGEXP ### a package word
      )*                      # ^ zero, one or many times
      (?:
        ::                    # allow trailing aristotle
      )?
    }x;
    
    my $PKG_REGEXP  = qr{   # match a package declaration
      ^[\s\{;]*             # intro chars on a line
      package               # the word 'package'
      \s+                   # whitespace
      ($PKG_NAME_REGEXP)    # a package name
      \s*                   # optional whitespace
      ($V_NUM_REGEXP)?        # optional version number
      \s*                   # optional whitesapce
      [;\{]                 # semicolon line terminator or block start (since 5.16)
    }x;
    
    my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
      ([\$*])         # sigil - $ or *
      (
        (             # optional leading package name
          (?:::|\')?  # possibly starting like just :: (  la $::VERSION)
          (?:\w+(?:::|\'))*  # Foo::Bar:: ...
        )?
        VERSION
      )\b
    }x;
    
    my $VERS_REGEXP = qr{ # match a VERSION definition
      (?:
        \(\s*$VARNAME_REGEXP\s*\) # with parens
      |
        $VARNAME_REGEXP           # without parens
      )
      \s*
      =[^=~]  # = but not ==, nor =~
    }x;
    
    sub new_from_file {
      my $class    = shift;
      my $filename = File::Spec->rel2abs( shift );
    
      return undef unless defined( $filename ) && -f $filename;
      return $class->_init(undef, $filename, @_);
    }
    
    sub new_from_handle {
      my $class    = shift;
      my $handle   = shift;
      my $filename = shift;
      return undef unless defined($handle) && defined($filename);
      $filename = File::Spec->rel2abs( $filename );
    
      return $class->_init(undef, $filename, @_, handle => $handle);
    
    }
    
    
    sub new_from_module {
      my $class   = shift;
      my $module  = shift;
      my %props   = @_;
    
      $props{inc} ||= \@INC;
      my $filename = $class->find_module_by_name( $module, $props{inc} );
      return undef unless defined( $filename ) && -f $filename;
      return $class->_init($module, $filename, %props);
    }
    
    {
    
      my $compare_versions = sub {
        my ($v1, $op, $v2) = @_;
        $v1 = version->new($v1)
          unless UNIVERSAL::isa($v1,'version');
    
        my $eval_str = "\$v1 $op \$v2";
        my $result   = eval $eval_str;
        log_info { "error comparing versions: '$eval_str' $@" } if $@;
    
        return $result;
      };
    
      my $normalize_version = sub {
        my ($version) = @_;
        if ( $version =~ /[=<>!,]/ ) { # logic, not just version
          # take as is without modification
        }
        elsif ( ref $version eq 'version' ) { # version objects
          $version = $version->is_qv ? $version->normal : $version->stringify;
        }
        elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
          # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
          $version = "v$version";
        }
        else {
          # leave alone
        }
        return $version;
      };
    
      # separate out some of the conflict resolution logic
    
      my $resolve_module_versions = sub {
        my $packages = shift;
    
        my( $file, $version );
        my $err = '';
          foreach my $p ( @$packages ) {
            if ( defined( $p->{version} ) ) {
      	if ( defined( $version ) ) {
       	  if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
      	    $err .= "  $p->{file} ($p->{version})\n";
      	  } else {
      	    # same version declared multiple times, ignore
      	  }
      	} else {
      	  $file    = $p->{file};
      	  $version = $p->{version};
      	}
            }
            $file ||= $p->{file} if defined( $p->{file} );
          }
    
        if ( $err ) {
          $err = "  $file ($version)\n" . $err;
        }
    
        my %result = (
          file    => $file,
          version => $version,
          err     => $err
        );
    
        return \%result;
      };
    
      sub provides {
        my $class = shift;
    
        croak "provides() requires key/value pairs \n" if @_ % 2;
        my %args = @_;
    
        croak "provides() takes only one of 'dir' or 'files'\n"
          if $args{dir} && $args{files};
    
        croak "provides() requires a 'version' argument"
          unless defined $args{version};
    
        croak "provides() does not support version '$args{version}' metadata"
            unless grep { $args{version} eq $_ } qw/1.4 2/;
    
        $args{prefix} = 'lib' unless defined $args{prefix};
    
        my $p;
        if ( $args{dir} ) {
          $p = $class->package_versions_from_directory($args{dir});
        }
        else {
          croak "provides() requires 'files' to be an array reference\n"
            unless ref $args{files} eq 'ARRAY';
          $p = $class->package_versions_from_directory($args{files});
        }
    
        # Now, fix up files with prefix
        if ( length $args{prefix} ) { # check in case disabled with q{}
          $args{prefix} =~ s{/$}{};
          for my $v ( values %$p ) {
            $v->{file} = "$args{prefix}/$v->{file}";
          }
        }
    
        return $p
      }
    
      sub package_versions_from_directory {
        my ( $class, $dir, $files ) = @_;
    
        my @files;
    
        if ( $files ) {
          @files = @$files;
        } else {
          find( {
            wanted => sub {
              push @files, $_ if -f $_ && /\.pm$/;
            },
            no_chdir => 1,
          }, $dir );
        }
    
        # First, we enumerate all packages & versions,
        # separating into primary & alternative candidates
        my( %prime, %alt );
        foreach my $file (@files) {
          my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
          my @path = split( /\//, $mapped_filename );
          (my $prime_package = join( '::', @path )) =~ s/\.pm$//;
    
          my $pm_info = $class->new_from_file( $file );
    
          foreach my $package ( $pm_info->packages_inside ) {
            next if $package eq 'main';  # main can appear numerous times, ignore
            next if $package eq 'DB';    # special debugging package, ignore
            next if grep /^_/, split( /::/, $package ); # private package, ignore
    
            my $version = $pm_info->version( $package );
    
            $prime_package = $package if lc($prime_package) eq lc($package);
            if ( $package eq $prime_package ) {
              if ( exists( $prime{$package} ) ) {
                croak "Unexpected conflict in '$package'; multiple versions found.\n";
              } else {
                $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
                $prime{$package}{file} = $mapped_filename;
                $prime{$package}{version} = $version if defined( $version );
              }
            } else {
              push( @{$alt{$package}}, {
                                        file    => $mapped_filename,
                                        version => $version,
                                       } );
            }
          }
        }
    
        # Then we iterate over all the packages found above, identifying conflicts
        # and selecting the "best" candidate for recording the file & version
        # for each package.
        foreach my $package ( keys( %alt ) ) {
          my $result = $resolve_module_versions->( $alt{$package} );
    
          if ( exists( $prime{$package} ) ) { # primary package selected
    
            if ( $result->{err} ) {
      	# Use the selected primary package, but there are conflicting
      	# errors among multiple alternative packages that need to be
      	# reported
              log_info {
      	    "Found conflicting versions for package '$package'\n" .
      	    "  $prime{$package}{file} ($prime{$package}{version})\n" .
      	    $result->{err}
              };
    
            } elsif ( defined( $result->{version} ) ) {
      	# There is a primary package selected, and exactly one
      	# alternative package
    
      	if ( exists( $prime{$package}{version} ) &&
      	     defined( $prime{$package}{version} ) ) {
      	  # Unless the version of the primary package agrees with the
      	  # version of the alternative package, report a conflict
      	  if ( $compare_versions->(
                     $prime{$package}{version}, '!=', $result->{version}
                   )
                 ) {
    
                log_info {
                  "Found conflicting versions for package '$package'\n" .
      	      "  $prime{$package}{file} ($prime{$package}{version})\n" .
      	      "  $result->{file} ($result->{version})\n"
                };
      	  }
    
      	} else {
      	  # The prime package selected has no version so, we choose to
      	  # use any alternative package that does have a version
      	  $prime{$package}{file}    = $result->{file};
      	  $prime{$package}{version} = $result->{version};
      	}
    
            } else {
      	# no alt package found with a version, but we have a prime
      	# package so we use it whether it has a version or not
            }
    
          } else { # No primary package was selected, use the best alternative
    
            if ( $result->{err} ) {
              log_info {
                "Found conflicting versions for package '$package'\n" .
      	    $result->{err}
              };
            }
    
            # Despite possible conflicting versions, we choose to record
            # something rather than nothing
            $prime{$package}{file}    = $result->{file};
            $prime{$package}{version} = $result->{version}
      	  if defined( $result->{version} );
          }
        }
    
        # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
        # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
        for (grep defined $_->{version}, values %prime) {
          $_->{version} = $normalize_version->( $_->{version} );
        }
    
        return \%prime;
      }
    }
    
    
    sub _init {
      my $class    = shift;
      my $module   = shift;
      my $filename = shift;
      my %props = @_;
    
      my $handle = delete $props{handle};
      my( %valid_props, @valid_props );
      @valid_props = qw( collect_pod inc );
      @valid_props{@valid_props} = delete( @props{@valid_props} );
      warn "Unknown properties: @{[keys %props]}\n" if scalar( %props );
    
      my %data = (
        module       => $module,
        filename     => $filename,
        version      => undef,
        packages     => [],
        versions     => {},
        pod          => {},
        pod_headings => [],
        collect_pod  => 0,
    
        %valid_props,
      );
    
      my $self = bless(\%data, $class);
    
      if ( $handle ) {
        $self->_parse_fh($handle);
      }
      else {
        $self->_parse_file();
      }
    
      unless($self->{module} and length($self->{module})) {
        my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
        if($f =~ /\.pm$/) {
          $f =~ s/\..+$//;
          my @candidates = grep /$f$/, @{$self->{packages}};
          $self->{module} = shift(@candidates); # punt
        }
        else {
          if(grep /main/, @{$self->{packages}}) {
            $self->{module} = 'main';
          }
          else {
            $self->{module} = $self->{packages}[0] || '';
          }
        }
      }
    
      $self->{version} = $self->{versions}{$self->{module}}
          if defined( $self->{module} );
    
      return $self;
    }
    
    # class method
    sub _do_find_module {
      my $class   = shift;
      my $module  = shift || croak 'find_module_by_name() requires a package name';
      my $dirs    = shift || \@INC;
    
      my $file = File::Spec->catfile(split( /::/, $module));
      foreach my $dir ( @$dirs ) {
        my $testfile = File::Spec->catfile($dir, $file);
        return [ File::Spec->rel2abs( $testfile ), $dir ]
    	if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
        return [ File::Spec->rel2abs( "$testfile.pm" ), $dir ]
    	if -e "$testfile.pm";
      }
      return;
    }
    
    # class method
    sub find_module_by_name {
      my $found = shift()->_do_find_module(@_) or return;
      return $found->[0];
    }
    
    # class method
    sub find_module_dir_by_name {
      my $found = shift()->_do_find_module(@_) or return;
      return $found->[1];
    }
    
    
    # given a line of perl code, attempt to parse it if it looks like a
    # $VERSION assignment, returning sigil, full name, & package name
    sub _parse_version_expression {
      my $self = shift;
      my $line = shift;
    
      my( $sig, $var, $pkg );
      if ( $line =~ /$VERS_REGEXP/o ) {
        ( $sig, $var, $pkg ) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
        if ( $pkg ) {
          $pkg = ($pkg eq '::') ? 'main' : $pkg;
          $pkg =~ s/::$//;
        }
      }
    
      return ( $sig, $var, $pkg );
    }
    
    sub _parse_file {
      my $self = shift;
    
      my $filename = $self->{filename};
      my $fh = IO::File->new( $filename )
        or croak( "Can't open '$filename': $!" );
    
      $self->_handle_bom($fh, $filename);
    
      $self->_parse_fh($fh);
    }
    
    # Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
    # If there's one, then skip it and set the :encoding layer appropriately.
    sub _handle_bom {
      my ($self, $fh, $filename) = @_;
    
      my $pos = $fh->getpos;
      return unless defined $pos;
    
      my $buf = ' ' x 2;
      my $count = $fh->read( $buf, length $buf );
      return unless defined $count and $count >= 2;
    
      my $encoding;
      if ( $buf eq "\x{FE}\x{FF}" ) {
        $encoding = 'UTF-16BE';
      } elsif ( $buf eq "\x{FF}\x{FE}" ) {
        $encoding = 'UTF-16LE';
      } elsif ( $buf eq "\x{EF}\x{BB}" ) {
        $buf = ' ';
        $count = $fh->read( $buf, length $buf );
        if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
          $encoding = 'UTF-8';
        }
      }
    
      if ( defined $encoding ) {
        if ( "$]" >= 5.008 ) {
          # $fh->binmode requires perl 5.10
          binmode( $fh, ":encoding($encoding)" );
        }
      } else {
        $fh->setpos($pos)
          or croak( sprintf "Can't reset position to the top of '$filename'" );
      }
    
      return $encoding;
    }
    
    sub _parse_fh {
      my ($self, $fh) = @_;
    
      my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
      my( @pkgs, %vers, %pod, @pod );
      my $pkg = 'main';
      my $pod_sect = '';
      my $pod_data = '';
      my $in_end = 0;
    
      while (defined( my $line = <$fh> )) {
        my $line_num = $.;
    
        chomp( $line );
    
        # From toke.c : any line that begins by "=X", where X is an alphabetic
        # character, introduces a POD segment.
        my $is_cut;
        if ( $line =~ /^=([a-zA-Z].*)/ ) {
          my $cmd = $1;
          # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
          # character (which includes the newline, but here we chomped it away).
          $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
          $in_pod = !$is_cut;
        }
    
        if ( $in_pod ) {
    
          if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
    	push( @pod, $1 );
    	if ( $self->{collect_pod} && length( $pod_data ) ) {
              $pod{$pod_sect} = $pod_data;
              $pod_data = '';
            }
    	$pod_sect = $1;
    
          } elsif ( $self->{collect_pod} ) {
    	$pod_data .= "$line\n";
    
          }
    
        } elsif ( $is_cut ) {
    
          if ( $self->{collect_pod} && length( $pod_data ) ) {
            $pod{$pod_sect} = $pod_data;
            $pod_data = '';
          }
          $pod_sect = '';
    
        } else {
    
          # Skip after __END__
          next if $in_end;
    
          # Skip comments in code
          next if $line =~ /^\s*#/;
    
          # Would be nice if we could also check $in_string or something too
          if ($line eq '__END__') {
            $in_end++;
            next;
          }
          last if $line eq '__DATA__';
    
          # parse $line to see if it's a $VERSION declaration
          my( $vers_sig, $vers_fullname, $vers_pkg ) =
              ($line =~ /VERSION/)
                  ? $self->_parse_version_expression( $line )
                  : ();
    
          if ( $line =~ /$PKG_REGEXP/o ) {
            $pkg = $1;
            push( @pkgs, $pkg ) unless grep( $pkg eq $_, @pkgs );
            $vers{$pkg} = $2 unless exists( $vers{$pkg} );
            $need_vers = defined $2 ? 0 : 1;
    
          # VERSION defined with full package spec, i.e. $Module::VERSION
          } elsif ( $vers_fullname && $vers_pkg ) {
    	push( @pkgs, $vers_pkg ) unless grep( $vers_pkg eq $_, @pkgs );
    	$need_vers = 0 if $vers_pkg eq $pkg;
    
    	unless ( defined $vers{$vers_pkg} && length $vers{$vers_pkg} ) {
    	  $vers{$vers_pkg} =
    	    $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
    	}
    
          # first non-comment line in undeclared package main is VERSION
          } elsif ( !exists($vers{main}) && $pkg eq 'main' && $vers_fullname ) {
    	$need_vers = 0;
    	my $v =
    	  $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
    	$vers{$pkg} = $v;
    	push( @pkgs, 'main' );
    
          # first non-comment line in undeclared package defines package main
          } elsif ( !exists($vers{main}) && $pkg eq 'main' && $line =~ /\w+/ ) {
    	$need_vers = 1;
    	$vers{main} = '';
    	push( @pkgs, 'main' );
    
          # only keep if this is the first $VERSION seen
          } elsif ( $vers_fullname && $need_vers ) {
    	$need_vers = 0;
    	my $v =
    	  $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
    
    
    	unless ( defined $vers{$pkg} && length $vers{$pkg} ) {
    	  $vers{$pkg} = $v;
    	}
    
          }
    
        }
    
      }
    
      if ( $self->{collect_pod} && length($pod_data) ) {
        $pod{$pod_sect} = $pod_data;
      }
    
      $self->{versions} = \%vers;
      $self->{packages} = \@pkgs;
      $self->{pod} = \%pod;
      $self->{pod_headings} = \@pod;
    }
    
    {
    my $pn = 0;
    sub _evaluate_version_line {
      my $self = shift;
      my( $sigil, $var, $line ) = @_;
    
      # Some of this code came from the ExtUtils:: hierarchy.
    
      # We compile into $vsub because 'use version' would cause
      # compiletime/runtime issues with local()
      my $vsub;
      $pn++; # everybody gets their own package
      my $eval = qq{BEGIN { q#  Hide from _packages_inside()
        #; package Module::Metadata::_version::p$pn;
        use version;
        no strict;
    
          \$vsub = sub {
            local $sigil$var;
            \$$var=undef;
            $line;
            \$$var
          };
      }};
    
      local $^W;
      # Try to get the $VERSION
      eval $eval;
      # some modules say $VERSION = $Foo::Bar::VERSION, but Foo::Bar isn't
      # installed, so we need to hunt in ./lib for it
      if ( $@ =~ /Can't locate/ && -d 'lib' ) {
        local @INC = ('lib',@INC);
        eval $eval;
      }
      warn "Error evaling version line '$eval' in $self->{filename}: $@\n"
        if $@;
      (ref($vsub) eq 'CODE') or
        croak "failed to build version sub for $self->{filename}";
      my $result = eval { $vsub->() };
      croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@\n"
        if $@;
    
      # Upgrade it into a version object
      my $version = eval { _dwim_version($result) };
    
      croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@\n"
        unless defined $version; # "0" is OK!
    
      return $version;
    }
    }
    
    # Try to DWIM when things fail the lax version test in obvious ways
    {
      my @version_prep = (
        # Best case, it just works
        sub { return shift },
    
        # If we still don't have a version, try stripping any
        # trailing junk that is prohibited by lax rules
        sub {
          my $v = shift;
          $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
          return $v;
        },
    
        # Activestate apparently creates custom versions like '1.23_45_01', which
        # cause version.pm to think it's an invalid alpha.  So check for that
        # and strip them
        sub {
          my $v = shift;
          my $num_dots = () = $v =~ m{(\.)}g;
          my $num_unders = () = $v =~ m{(_)}g;
          my $leading_v = substr($v,0,1) eq 'v';
          if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
            $v =~ s{_}{}g;
            $num_unders = () = $v =~ m{(_)}g;
          }
          return $v;
        },
    
        # Worst case, try numifying it like we would have before version objects
        sub {
          my $v = shift;
          no warnings 'numeric';
          return 0 + $v;
        },
    
      );
    
      sub _dwim_version {
        my ($result) = shift;
    
        return $result if ref($result) eq 'version';
    
        my ($version, $error);
        for my $f (@version_prep) {
          $result = $f->($result);
          $version = eval { version->new($result) };
          $error ||= $@ if $@; # capture first failure
          last if defined $version;
        }
    
        croak $error unless defined $version;
    
        return $version;
      }
    }
    
    ############################################################
    
    # accessors
    sub name            { $_[0]->{module}            }
    
    sub filename        { $_[0]->{filename}          }
    sub packages_inside { @{$_[0]->{packages}}       }
    sub pod_inside      { @{$_[0]->{pod_headings}}   }
    sub contains_pod    { 0+@{$_[0]->{pod_headings}} }
    
    sub version {
        my $self = shift;
        my $mod  = shift || $self->{module};
        my $vers;
        if ( defined( $mod ) && length( $mod ) &&
    	 exists( $self->{versions}{$mod} ) ) {
    	return $self->{versions}{$mod};
        } else {
    	return undef;
        }
    }
    
    sub pod {
        my $self = shift;
        my $sect = shift;
        if ( defined( $sect ) && length( $sect ) &&
    	 exists( $self->{pod}{$sect} ) ) {
    	return $self->{pod}{$sect};
        } else {
    	return undef;
        }
    }
    
    1;
    
    =head1 NAME
    
    Module::Metadata - Gather package and POD information from perl module files
    
    =head1 SYNOPSIS
    
      use Module::Metadata;
    
      # information about a .pm file
      my $info = Module::Metadata->new_from_file( $file );
      my $version = $info->version;
    
      # CPAN META 'provides' field for .pm files in a directory
      my $provides = Module::Metadata->provides(
        dir => 'lib', version => 2
      );
    
    =head1 DESCRIPTION
    
    This module provides a standard way to gather metadata about a .pm file through
    (mostly) static analysis and (some) code execution.  When determining the
    version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
    in the CPAN toolchain.
    
    =head1 USAGE
    
    =head2 Class methods
    
    =over 4
    
    =item C<< new_from_file($filename, collect_pod => 1) >>
    
    Constructs a C<Module::Metadata> object given the path to a file.  Returns
    undef if the filename does not exist.
    
    C<collect_pod> is a optional boolean argument that determines whether POD
    data is collected and stored for reference.  POD data is not collected by
    default.  POD headings are always collected.
    
    If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
    it is skipped before processing, and the content of the file is also decoded
    appropriately starting from perl 5.8.
    
    =item C<< new_from_handle($handle, $filename, collect_pod => 1) >>
    
    This works just like C<new_from_file>, except that a handle can be provided
    as the first argument.
    
    Note that there is no validation to confirm that the handle is a handle or
    something that can act like one.  Passing something that isn't a handle will
    cause a exception when trying to read from it.  The C<filename> argument is
    mandatory or undef will be returned.
    
    You are responsible for setting the decoding layers on C<$handle> if
    required.
    
    =item C<< new_from_module($module, collect_pod => 1, inc => \@dirs) >>
    
    Constructs a C<Module::Metadata> object given a module or package name.
    Returns undef if the module cannot be found.
    
    In addition to accepting the C<collect_pod> argument as described above,
    this method accepts a C<inc> argument which is a reference to an array of
    directories to search for the module.  If none are given, the default is
    @INC.
    
    If the file that contains the module begins by an UTF-8, UTF-16BE or
    UTF-16LE byte-order mark, then it is skipped before processing, and the
    content of the file is also decoded appropriately starting from perl 5.8.
    
    =item C<< find_module_by_name($module, \@dirs) >>
    
    Returns the path to a module given the module or package name. A list
    of directories can be passed in as an optional parameter, otherwise
    @INC is searched.
    
    Can be called as either an object or a class method.
    
    =item C<< find_module_dir_by_name($module, \@dirs) >>
    
    Returns the entry in C<@dirs> (or C<@INC> by default) that contains
    the module C<$module>. A list of directories can be passed in as an
    optional parameter, otherwise @INC is searched.
    
    Can be called as either an object or a class method.
    
    =item C<< provides( %options ) >>
    
    This is a convenience wrapper around C<package_versions_from_directory>
    to generate a CPAN META C<provides> data structure.  It takes key/value
    pairs.  Valid option keys include:
    
    =over
    
    =item version B<(required)>
    
    Specifies which version of the L<CPAN::Meta::Spec> should be used as
    the format of the C<provides> output.  Currently only '1.4' and '2'
    are supported (and their format is identical).  This may change in
    the future as the definition of C<provides> changes.
    
    The C<version> option is required.  If it is omitted or if
    an unsupported version is given, then C<provides> will throw an error.
    
    =item dir
    
    Directory to search recursively for F<.pm> files.  May not be specified with
    C<files>.
    
    =item files
    
    Array reference of files to examine.  May not be specified with C<dir>.
    
    =item prefix
    
    String to prepend to the C<file> field of the resulting output. This defaults
    to F<lib>, which is the common case for most CPAN distributions with their
    F<.pm> files in F<lib>.  This option ensures the META information has the
    correct relative path even when the C<dir> or C<files> arguments are
    absolute or have relative paths from a location other than the distribution
    root.
    
    =back
    
    For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
    is a hashref of the form:
    
      {
        'Package::Name' => {
          version => '0.123',
          file => 'lib/Package/Name.pm'
        },
        'OtherPackage::Name' => ...
      }
    
    =item C<< package_versions_from_directory($dir, \@files?) >>
    
    Scans C<$dir> for .pm files (unless C<@files> is given, in which case looks
    for those files in C<$dir> - and reads each file for packages and versions,
    returning a hashref of the form:
    
      {
        'Package::Name' => {
          version => '0.123',
          file => 'Package/Name.pm'
        },
        'OtherPackage::Name' => ...
      }
    
    The C<DB> and C<main> packages are always omitted, as are any "private"
    packages that have leading underscores in the namespace (e.g.
    C<Foo::_private>)
    
    Note that the file path is relative to C<$dir> if that is specified.
    This B<must not> be used directly for CPAN META C<provides>.  See
    the C<provides> method instead.
    
    =item C<< log_info (internal) >>
    
    Used internally to perform logging; imported from Log::Contextual if
    Log::Contextual has already been loaded, otherwise simply calls warn.
    
    =back
    
    =head2 Object methods
    
    =over 4
    
    =item C<< name() >>
    
    Returns the name of the package represented by this module. If there
    are more than one packages, it makes a best guess based on the
    filename. If it's a script (i.e. not a *.pm) the package name is
    'main'.
    
    =item C<< version($package) >>
    
    Returns the version as defined by the $VERSION variable for the
    package as returned by the C<name> method if no arguments are
    given. If given the name of a package it will attempt to return the
    version of that package if it is specified in the file.
    
    =item C<< filename() >>
    
    Returns the absolute path to the file.
    
    =item C<< packages_inside() >>
    
    Returns a list of packages. Note: this is a raw list of packages
    discovered (or assumed, in the case of C<main>).  It is not
    filtered for C<DB>, C<main> or private packages the way the
    C<provides> method does.  Invalid package names are not returned,
    for example "Foo:Bar".  Strange but valid package names are
    returned, for example "Foo::Bar::", and are left up to the caller
    on how to handle.
    
    =item C<< pod_inside() >>
    
    Returns a list of POD sections.
    
    =item C<< contains_pod() >>
    
    Returns true if there is any POD in the file.
    
    =item C<< pod($section) >>
    
    Returns the POD data in the given section.
    
    =back
    
    =head1 AUTHOR
    
    Original code from Module::Build::ModuleInfo by Ken Williams
    <kwilliams@cpan.org>, Randy W. Sims <RandyS@ThePierianSpring.org>
    
    Released as Module::Metadata by Matt S Trout (mst) <mst@shadowcat.co.uk> with
    assistance from David Golden (xdg) <dagolden@cpan.org>.
    
    =head1 COPYRIGHT & LICENSE
    
    Original code Copyright (c) 2001-2011 Ken Williams.
    Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
    All rights reserved.
    
    This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.
    
    =cut
    
  MODULE_METADATA
  
  $fatpacked{"Parse/CPAN/Meta.pm"} = <<'PARSE_CPAN_META';
    use strict;
    package Parse::CPAN::Meta;
    # ABSTRACT: Parse META.yml and META.json CPAN metadata files
    our $VERSION = '1.4407'; # VERSION
    
    use Carp 'croak';
    
    # UTF Support?
    sub HAVE_UTF8 () { $] >= 5.007003 }
    sub IO_LAYER () { $] >= 5.008001 ? ":utf8" : "" }  
    
    BEGIN {
    	if ( HAVE_UTF8 ) {
    		# The string eval helps hide this from Test::MinimumVersion
    		eval "require utf8;";
    		die "Failed to load UTF-8 support" if $@;
    	}
    
    	# Class structure
    	require 5.004;
    	require Exporter;
    	@Parse::CPAN::Meta::ISA       = qw{ Exporter      };
    	@Parse::CPAN::Meta::EXPORT_OK = qw{ Load LoadFile };
    }
    
    sub load_file {
      my ($class, $filename) = @_;
    
      if ($filename =~ /\.ya?ml$/) {
        return $class->load_yaml_string(_slurp($filename));
      }
    
      if ($filename =~ /\.json$/) {
        return $class->load_json_string(_slurp($filename));
      }
    
      croak("file type cannot be determined by filename");
    }
    
    sub load_yaml_string {
      my ($class, $string) = @_;
      my $backend = $class->yaml_backend();
      my $data = eval { no strict 'refs'; &{"$backend\::Load"}($string) };
      if ( $@ ) { 
        croak $backend->can('errstr') ? $backend->errstr : $@
      }
      return $data || {}; # in case document was valid but empty
    }
    
    sub load_json_string {
      my ($class, $string) = @_;
      return $class->json_backend()->new->decode($string);
    }
    
    sub yaml_backend {
      local $Module::Load::Conditional::CHECK_INC_HASH = 1;
      if (! defined $ENV{PERL_YAML_BACKEND} ) {
        _can_load( 'CPAN::Meta::YAML', 0.002 )
          or croak "CPAN::Meta::YAML 0.002 is not available\n";
        return "CPAN::Meta::YAML";
      }
      else {
        my $backend = $ENV{PERL_YAML_BACKEND};
        _can_load( $backend )
          or croak "Could not load PERL_YAML_BACKEND '$backend'\n";
        $backend->can("Load")
          or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";
        return $backend;
      }
    }
    
    sub json_backend {
      local $Module::Load::Conditional::CHECK_INC_HASH = 1;
      if (! $ENV{PERL_JSON_BACKEND} or $ENV{PERL_JSON_BACKEND} eq 'JSON::PP') {
        _can_load( 'JSON::PP' => 2.27103 )
          or croak "JSON::PP 2.27103 is not available\n";
        return 'JSON::PP';
      }
      else {
        _can_load( 'JSON' => 2.5 )
          or croak  "JSON 2.5 is required for " .
                    "\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";
        return "JSON";
      }
    }
    
    sub _slurp {
      open my $fh, "<" . IO_LAYER, "$_[0]"
        or die "can't open $_[0] for reading: $!";
      return do { local $/; <$fh> };
    }
      
    sub _can_load {
      my ($module, $version) = @_;
      (my $file = $module) =~ s{::}{/}g;
      $file .= ".pm";
      return 1 if $INC{$file};
      return 0 if exists $INC{$file}; # prior load failed
      eval { require $file; 1 }
        or return 0;
      if ( defined $version ) {
        eval { $module->VERSION($version); 1 }
          or return 0;
      }
      return 1;
    }
    
    # Kept for backwards compatibility only
    # Create an object from a file
    sub LoadFile ($) {
      require CPAN::Meta::YAML;
      my $object = CPAN::Meta::YAML::LoadFile(shift)
        or die CPAN::Meta::YAML->errstr;
      return $object;
    }
    
    # Parse a document from a string.
    sub Load ($) {
      require CPAN::Meta::YAML;
      my $object = CPAN::Meta::YAML::Load(shift)
        or die CPAN::Meta::YAML->errstr;
      return $object;
    }
    
    1;
    
    __END__
    
    =pod
    
    =encoding utf-8
    
    =head1 NAME
    
    Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files
    
    =head1 VERSION
    
    version 1.4407
    
    =head1 SYNOPSIS
    
        #############################################
        # In your file
        
        ---
        name: My-Distribution
        version: 1.23
        resources:
          homepage: "http://example.com/dist/My-Distribution"
        
        
        #############################################
        # In your program
        
        use Parse::CPAN::Meta;
        
        my $distmeta = Parse::CPAN::Meta->load_file('META.yml');
        
        # Reading properties
        my $name     = $distmeta->{name};
        my $version  = $distmeta->{version};
        my $homepage = $distmeta->{resources}{homepage};
    
    =head1 DESCRIPTION
    
    B<Parse::CPAN::Meta> is a parser for F<META.json> and F<META.yml> files, using
    L<JSON::PP> and/or L<CPAN::Meta::YAML>.
    
    B<Parse::CPAN::Meta> provides three methods: C<load_file>, C<load_json_string>,
    and C<load_yaml_string>.  These will read and deserialize CPAN metafiles, and
    are described below in detail.
    
    B<Parse::CPAN::Meta> provides a legacy API of only two functions,
    based on the YAML functions of the same name. Wherever possible,
    identical calling semantics are used.  These may only be used with YAML sources.
    
    All error reporting is done with exceptions (die'ing).
    
    Note that META files are expected to be in UTF-8 encoding, only.  When
    converted string data, it must first be decoded from UTF-8.
    
    =for Pod::Coverage HAVE_UTF8 IO_LAYER
    
    =head1 METHODS
    
    =head2 load_file
    
      my $metadata_structure = Parse::CPAN::Meta->load_file('META.json');
    
      my $metadata_structure = Parse::CPAN::Meta->load_file('META.yml');
    
    This method will read the named file and deserialize it to a data structure,
    determining whether it should be JSON or YAML based on the filename.  On
    Perl 5.8.1 or later, the file will be read using the ":utf8" IO layer.
    
    =head2 load_yaml_string
    
      my $metadata_structure = Parse::CPAN::Meta->load_yaml_string($yaml_string);
    
    This method deserializes the given string of YAML and returns the first
    document in it.  (CPAN metadata files should always have only one document.)
    If the source was UTF-8 encoded, the string must be decoded before calling
    C<load_yaml_string>.
    
    =head2 load_json_string
    
      my $metadata_structure = Parse::CPAN::Meta->load_json_string($json_string);
    
    This method deserializes the given string of JSON and the result.  
    If the source was UTF-8 encoded, the string must be decoded before calling
    C<load_json_string>.
    
    =head2 yaml_backend
    
      my $backend = Parse::CPAN::Meta->yaml_backend;
    
    Returns the module name of the YAML serializer. See L</ENVIRONMENT>
    for details.
    
    =head2 json_backend
    
      my $backend = Parse::CPAN::Meta->json_backend;
    
    Returns the module name of the JSON serializer.  This will either
    be L<JSON::PP> or L<JSON>.  Even if C<PERL_JSON_BACKEND> is set,
    this will return L<JSON> as further delegation is handled by
    the L<JSON> module.  See L</ENVIRONMENT> for details.
    
    =head1 FUNCTIONS
    
    For maintenance clarity, no functions are exported.  These functions are
    available for backwards compatibility only and are best avoided in favor of
    C<load_file>.
    
    =head2 Load
    
      my @yaml = Parse::CPAN::Meta::Load( $string );
    
    Parses a string containing a valid YAML stream into a list of Perl data
    structures.
    
    =head2 LoadFile
    
      my @yaml = Parse::CPAN::Meta::LoadFile( 'META.yml' );
    
    Reads the YAML stream from a file instead of a string.
    
    =head1 ENVIRONMENT
    
    =head2 PERL_JSON_BACKEND
    
    By default, L<JSON::PP> will be used for deserializing JSON data. If the
    C<PERL_JSON_BACKEND> environment variable exists, is true and is not
    "JSON::PP", then the L<JSON> module (version 2.5 or greater) will be loaded and
    used to interpret C<PERL_JSON_BACKEND>.  If L<JSON> is not installed or is too
    old, an exception will be thrown.
    
    =head2 PERL_YAML_BACKEND
    
    By default, L<CPAN::Meta::YAML> will be used for deserializing YAML data. If
    the C<PERL_YAML_BACKEND> environment variable is defined, then it is interpreted
    as a module to use for deserialization.  The given module must be installed,
    must load correctly and must implement the C<Load()> function or an exception
    will be thrown.
    
    =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
    
    =head1 SUPPORT
    
    =head2 Bugs / Feature Requests
    
    Please report any bugs or feature requests through the issue tracker
    at L<http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta>.
    You will be notified automatically of any progress on your issue.
    
    =head2 Source Code
    
    This is open source software.  The code repository is available for
    public review and contribution under the terms of the license.
    
    L<https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta>
    
      git clone https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta.git
    
    =head1 AUTHORS
    
    =over 4
    
    =item *
    
    Adam Kennedy <adamk@cpan.org>
    
    =item *
    
    David Golden <dagolden@cpan.org>
    
    =back
    
    =head1 CONTRIBUTORS
    
    =over 4
    
    =item *
    
    Joshua ben Jore <jjore@cpan.org>
    
    =item *
    
    Neil Bowers <neil@bowers.com>
    
    =item *
    
    Ricardo SIGNES <rjbs@cpan.org>
    
    =item *
    
    Steffen Mller <smueller@cpan.org>
    
    =back
    
    =head1 COPYRIGHT AND LICENSE
    
    This software is copyright (c) 2013 by Adam Kennedy and Contributors.
    
    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.
    
    =cut
  PARSE_CPAN_META
  
  $fatpacked{"String/ShellQuote.pm"} = <<'STRING_SHELLQUOTE';
    # $Id: ShellQuote.pm,v 1.11 2010-06-11 20:08:57 roderick Exp $
    #
    # Copyright (c) 1997 Roderick Schertler.  All rights reserved.  This
    # program is free software; you can redistribute it and/or modify it
    # under the same terms as Perl itself.
    
    =head1 NAME
    
    String::ShellQuote - quote strings for passing through the shell
    
    =head1 SYNOPSIS
    
        $string = shell_quote @list;
        $string = shell_quote_best_effort @list;
        $string = shell_comment_quote $string;
    
    =head1 DESCRIPTION
    
    This module contains some functions which are useful for quoting strings
    which are going to pass through the shell or a shell-like object.
    
    =over
    
    =cut
    
    package String::ShellQuote;
    
    use strict;
    use vars qw($VERSION @ISA @EXPORT);
    
    require Exporter;
    
    $VERSION	= '1.04';
    @ISA		= qw(Exporter);
    @EXPORT		= qw(shell_quote shell_quote_best_effort shell_comment_quote);
    
    sub croak {
        require Carp;
        goto &Carp::croak;
    }
    
    sub _shell_quote_backend {
        my @in = @_;
        my @err = ();
    
        if (0) {
    	require RS::Handy;
    	print RS::Handy::data_dump(\@in);
        }
    
        return \@err, '' unless @in;
    
        my $ret = '';
        my $saw_non_equal = 0;
        foreach (@in) {
    	if (!defined $_ or $_ eq '') {
    	    $_ = "''";
    	    next;
    	}
    
    	if (s/\x00//g) {
    	    push @err, "No way to quote string containing null (\\000) bytes";
    	}
    
        	my $escape = 0;
    
    	# = needs quoting when it's the first element (or part of a
    	# series of such elements), as in command position it's a
    	# program-local environment setting
    
    	if (/=/) {
    	    if (!$saw_non_equal) {
    	    	$escape = 1;
    	    }
    	}
    	else {
    	    $saw_non_equal = 1;
    	}
    
    	if (m|[^\w!%+,\-./:=@^]|) {
    	    $escape = 1;
    	}
    
    	if ($escape
    		|| (!$saw_non_equal && /=/)) {
    
    	    # ' -> '\''
        	    s/'/'\\''/g;
    
    	    # make multiple ' in a row look simpler
    	    # '\'''\'''\'' -> '"'''"'
        	    s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;
    
    	    $_ = "'$_'";
    	    s/^''//;
    	    s/''$//;
    	}
        }
        continue {
    	$ret .= "$_ ";
        }
    
        chop $ret;
        return \@err, $ret;
    }
    
    =item B<shell_quote> [I<string>]...
    
    B<shell_quote> quotes strings so they can be passed through the shell.
    Each I<string> is quoted so that the shell will pass it along as a
    single argument and without further interpretation.  If no I<string>s
    are given an empty string is returned.
    
    If any I<string> can't be safely quoted B<shell_quote> will B<croak>.
    
    =cut
    
    sub shell_quote {
        my ($rerr, $s) = _shell_quote_backend @_;
    
        if (@$rerr) {
        	my %seen;
        	@$rerr = grep { !$seen{$_}++ } @$rerr;
    	my $s = join '', map { "shell_quote(): $_\n" } @$rerr;
    	chomp $s;
    	croak $s;
        }
        return $s;
    }
    
    =item B<shell_quote_best_effort> [I<string>]...
    
    This is like B<shell_quote>, excpet if the string can't be safely quoted
    it does the best it can and returns the result, instead of dying.
    
    =cut
    
    sub shell_quote_best_effort {
        my ($rerr, $s) = _shell_quote_backend @_;
    
        return $s;
    }
    
    =item B<shell_comment_quote> [I<string>]
    
    B<shell_comment_quote> quotes the I<string> so that it can safely be
    included in a shell-style comment (the current algorithm is that a sharp
    character is placed after any newlines in the string).
    
    This routine might be changed to accept multiple I<string> arguments
    in the future.  I haven't done this yet because I'm not sure if the
    I<string>s should be joined with blanks ($") or nothing ($,).  Cast
    your vote today!  Be sure to justify your answer.
    
    =cut
    
    sub shell_comment_quote {
        return '' unless @_;
        unless (@_ == 1) {
    	croak "Too many arguments to shell_comment_quote "
    	    	    . "(got " . @_ . " expected 1)";
        }
        local $_ = shift;
        s/\n/\n#/g;
        return $_;
    }
    
    1;
    
    __END__
    
    =back
    
    =head1 EXAMPLES
    
        $cmd = 'fuser 2>/dev/null ' . shell_quote @files;
        @pids = split ' ', `$cmd`;
    
        print CFG "# Configured by: ",
    		shell_comment_quote($ENV{LOGNAME}), "\n";
    
    =head1 BUGS
    
    Only Bourne shell quoting is supported.  I'd like to add other shells
    (particularly cmd.exe), but I'm not familiar with them.  It would be a
    big help if somebody supplied the details.
    
    =head1 AUTHOR
    
    Roderick Schertler <F<roderick@argon.org>>
    
    =head1 SEE ALSO
    
    perl(1).
    
    =cut
  STRING_SHELLQUOTE
  
  $fatpacked{"aliased.pm"} = <<'ALIASED';
    package aliased;
    
    our $VERSION = '0.31';
    $VERSION = eval $VERSION;
    
    require Exporter;
    @ISA    = qw(Exporter);
    @EXPORT = qw(alias prefix);
    
    use strict;
    
    sub _croak {
        require Carp;
        Carp::croak(@_);
    }
    
    sub import {
        my ( $class, $package, $alias, @import ) = @_;
    
        if ( @_ <= 1 ) {
            $class->export_to_level(1);
            return;
        }
    
        my $callpack = caller(0);
        _load_alias( $package, $callpack, @import );
        _make_alias( $package, $callpack, $alias );
    }
    
    sub _get_alias {
        my $package = shift;
        $package =~ s/.*(?:::|')//;
        return $package;
    }
    
    sub _make_alias {
        my ( $package, $callpack, $alias ) = @_;
    
        $alias ||= _get_alias($package);
    
        my $destination = $alias =~ /::/
          ? $alias
          : "$callpack\::$alias";
    
        no strict 'refs';
        *{ $destination } = sub () { $package };
    }
    
    sub _load_alias {
        my ( $package, $callpack, @import ) = @_;
    
        # We don't localize $SIG{__DIE__} here because we need to be careful about
        # restoring its value if there is a failure.  Very, very tricky.
        my $sigdie = $SIG{__DIE__};
        {
            my $code =
              @import == 0
              ? "package $callpack; use $package;"
              : "package $callpack; use $package (\@import)";
            eval $code;
            if ( my $error = $@ ) {
                $SIG{__DIE__} = $sigdie;
                _croak($error);
            }
            $sigdie = $SIG{__DIE__}
              if defined $SIG{__DIE__};
        }
    
        # Make sure a global $SIG{__DIE__} makes it out of the localization.
        $SIG{__DIE__} = $sigdie if defined $sigdie;
        return $package;
    }
    
    sub alias {
        my ( $package, @import ) = @_;
    
        my $callpack = scalar caller(0);
        return _load_alias( $package, $callpack, @import );
    }
    
    sub prefix {
        my ($class) = @_;
        return sub {
            my ($name) = @_;
            my $callpack = caller(0);
            if ( not @_ ) {
                return _load_alias( $class, $callpack );
            }
            elsif ( @_ == 1 && defined $name ) {
                return _load_alias( "${class}::$name", $callpack );
            }
            else {
                _croak("Too many arguments to prefix('$class')");
            }
        };
    }
    
    1;
    __END__
    
    =head1 NAME
    
    aliased - Use shorter versions of class names.
    
    =head1 VERSION
    
    0.31
    
    =head1 SYNOPSIS
    
      # Class name interface
      use aliased 'My::Company::Namespace::Customer';
      my $cust = Customer->new;
    
      use aliased 'My::Company::Namespace::Preferred::Customer' => 'Preferred';
      my $pref = Preferred->new;
    
    
      # Variable interface
      use aliased;
      my $Customer  = alias "My::Other::Namespace::Customer";
      my $cust      = $Customer->new;
    
      my $Preferred = alias "My::Other::Namespace::Preferred::Customer";
      my $pref      = $Preferred->new;  
    
    
    =head1 DESCRIPTION
    
    C<aliased> is simple in concept but is a rather handy module.  It loads the
    class you specify and exports into your namespace a subroutine that returns
    the class name.  You can explicitly alias the class to another name or, if you
    prefer, you can do so implicitly.  In the latter case, the name of the
    subroutine is the last part of the class name.  Thus, it does something
    similar to the following:
    
      #use aliased 'Some::Annoyingly::Long::Module::Name::Customer';
    
      use Some::Annoyingly::Long::Module::Name::Customer;
      sub Customer {
        return 'Some::Annoyingly::Long::Module::Name::Customer';
      }
      my $cust = Customer->new;
    
    This module is useful if you prefer a shorter name for a class.  It's also
    handy if a class has been renamed.
    
    (Some may object to the term "aliasing" because we're not aliasing one
    namespace to another, but it's a handy term.  Just keep in mind that this is
    done with a subroutine and not with typeglobs and weird namespace munging.)
    
    Note that this is B<only> for C<use>ing OO modules.  You cannot use this to
    load procedural modules.  See the L<Why OO Only?|Why OO Only?> section.  Also,
    don't let the version number fool you.  This code is ridiculously simple and
    is just fine for most use.
    
    =head2 Implicit Aliasing
    
    The most common use of this module is:
    
      use aliased 'Some::Module::name';
    
    C<aliased> will  allow you to reference the class by the last part of the
    class name.  Thus, C<Really::Long::Name> becomes C<Name>.  It does this by
    exporting a subroutine into your namespace with the same name as the aliased
    name.  This subroutine returns the original class name.
    
    For example:
    
      use aliased "Acme::Company::Customer";
      my $cust = Customer->find($id);
    
    Note that any class method can be called on the shorter version of the class
    name, not just the constructor.
    
    =head2 Explicit Aliasing
    
    Sometimes two class names can cause a conflict (they both end with C<Customer>
    for example), or you already have a subroutine with the same name as the
    aliased name.  In that case, you can make an explicit alias by stating the
    name you wish to alias to:
    
      use aliased 'Original::Module::Name' => 'NewName';
    
    Here's how we use C<aliased> to avoid conflicts:
    
      use aliased "Really::Long::Name";
      use aliased "Another::Really::Long::Name" => "Aname";
      my $name  = Name->new;
      my $aname = Aname->new;
    
    You can even alias to a different package:
    
      use aliased "Another::Really::Long::Name" => "Another::Name";
      my $aname = Another::Name->new;
    
    Messing around with different namespaces is a really bad idea and you probably
    don't want to do this.  However, it might prove handy if the module you are
    using has been renamed.  If the interface has not changed, this allows you to
    use the new module by only changing one line of code.
    
      use aliased "New::Module::Name" => "Old::Module::Name";
      my $thing = Old::Module::Name->new;
    
    =head2 Import Lists
    
    Sometimes, even with an OO module, you need to specify extra arguments when
    using the module.  When this happens, simply use L<Explicit Aliasing> followed
    by the import list:
    
    Snippet 1:
    
      use Some::Module::Name qw/foo bar/;
      my $o = Some::Module::Name->some_class_method; 
    
    Snippet 2 (equivalent to snippet 1):
    
      use aliased 'Some::Module::Name' => 'Name', qw/foo bar/;
      my $o = Name->some_class_method;
    
    B<Note>:  remember, you cannot use import lists with L<Implicit Aliasing>.  As
    a result, you may simply prefer to only use L<Explicit Aliasing> as a matter
    of style.
    
    =head2 alias()
    
    This function is only exported if you specify C<use aliased> with no import
    list.
    
        use aliased;
        my $alias = alias($class);
        my $alias = alias($class, @imports);
    
    alias() is an alternative to C<use aliased ...> which uses less magic and
    avoids some of the ambiguities.
    
    Like C<use aliased> it C<use>s the $class (pass in @imports, if given) but
    instead of providing an C<Alias> constant it simply returns a scalar set to
    the $class name.
    
        my $thing = alias("Some::Thing::With::A::Long::Name");
    
        # Just like Some::Thing::With::A::Long::Name->method
        $thing->method;
    
    The use of a scalar instead of a constant avoids any possible ambiguity
    when aliasing two similar names:
    
        # No ambiguity despite the fact that they both end with "Name"
        my $thing = alias("Some::Thing::With::A::Long::Name");
        my $other = alias("Some::Other::Thing::With::A::Long::Name");
    
    and there is no magic constant exported into your namespace.
    
    The only caveat is loading of the $class happens at run time.  If $class
    exports anything you might want to ensure it is loaded at compile time with:
    
        my $thing;
        BEGIN { $thing = alias("Some::Thing"); }
    
    However, since OO classes rarely export this should not be necessary.
    
    =head2 prefix() (experimental)
    
    This function is only exported if you specify C<use aliased> with no import
    list.
    
        use aliased;
    
    Sometimes you find you have a ton of packages in the same top-level namespace
    and you want to alias them, but only use them on demand.  For example:
    
        # instead of:
        MailVerwaltung::Client::Exception::REST::Response->throw()
    
        my $error = prefix('MailVerwaltung::Client::Exception');
        $error->('REST::Response')->throw();   # same as above
        $error->()->throw; # same as MailVerwaltung::Client::Exception->throw
    
    =head2 Why OO Only?
    
    Some people have asked why this code only support object-oriented modules
    (OO).  If I were to support normal subroutines, I would have to allow the
    following syntax:
    
      use aliased 'Some::Really::Long::Module::Name';
      my $data = Name::data();
    
    That causes a serious problem.  The only (reasonable) way it can be done is to
    handle the aliasing via typeglobs.  Thus, instead of a subroutine that
    provides the class name, we alias one package to another (as the
    L<namespace|namespace> module does.)  However, we really don't want to simply
    alias one package to another and wipe out namespaces willy-nilly.  By merely
    exporting a single subroutine to a namespace, we minimize the issue. 
    
    Fortunately, this doesn't seem to be that much of a problem.  Non-OO modules
    generally support exporting of the functions you need and this eliminates the
    need for a module such as this.
    
    =head1 EXPORT
    
    This modules exports a subroutine with the same name as the "aliased" name.
    
    =head1 BUGS
    
    There are no known bugs in this module, but feel free to email me reports.
    
    =head1 SEE ALSO
    
    The L<namespace> module.
    
    =head1 THANKS
    
    Many thanks to Rentrak, Inc. (http://www.rentrak.com/) for graciously allowing
    me to replicate the functionality of some of their internal code.
    
    =head1 AUTHOR
    
    Curtis Poe, C<< ovid [at] cpan [dot] org >>
    
    =head1 COPYRIGHT AND LICENSE
    
    Copyright (C) 2005 by Curtis "Ovid" Poe
    
    This library is free software; you can redistribute it and/or modify
    it under the same terms as Perl itself, either Perl version 5.8.5 or,
    at your option, any later version of Perl 5 you may have available.
    
    =cut
  ALIASED
  
  $fatpacked{"lib/core/only.pm"} = <<'LIB_CORE_ONLY';
    package lib::core::only;
    
    use strict;
    use warnings FATAL => 'all';
    use Config;
    
    sub import {
      @INC = @Config{qw(privlibexp archlibexp)};
      return
    }
    
    =head1 NAME
    
    lib::core::only - Remove all non-core paths from @INC to avoid site/vendor dirs
    
    =head1 SYNOPSIS
    
      use lib::core::only; # now @INC contains only the two core directories
    
    To get only the core directories plus the ones for the local::lib in scope:
    
      $ perl -Mlib::core::only -Mlocal::lib=~/perl5 myscript.pl
    
    To attempt to do a self-contained build (but note this will not reliably
    propagate into subprocesses, see the CAVEATS below):
    
      $ PERL5OPT='-Mlib::core::only -Mlocal::lib=~/perl5' cpan
    
    =head1 DESCRIPTION
    
    lib::core::only is simply a shortcut to say "please reduce my @INC to only
    the core lib and archlib (architecture-specific lib) directories of this perl".
    
    You might want to do this to ensure a local::lib contains only the code you
    need, or to test an L<App::FatPacker|App::FatPacker> tree, or to avoid known
    bad vendor packages.
    
    You might want to use this to try and install a self-contained tree of perl
    modules. Be warned that that probably won't work (see L</CAVEATS>).
    
    This module was extracted from L<local::lib|local::lib>'s --self-contained
    feature, and contains the only part that ever worked. I apologise to anybody
    who thought anything else did.
    
    =head1 CAVEATS
    
    This does B<not> propagate properly across perl invocations like local::lib's
    stuff does. It can't. It's only a module import, so it B<only affects the
    specific perl VM instance in which you load and import() it>.
    
    If you want to cascade it across invocations, you can set the PERL5OPT
    environment variable to '-Mlib::core::only' and it'll sort of work. But be
    aware that taint mode ignores this, so some modules' build and test code
    probably will as well.
    
    You also need to be aware that perl's command line options are not processed
    in order - -I options take effect before -M options, so
    
      perl -Mlib::core::only -Ilib
    
    is unlike to do what you want - it's exactly equivalent to:
    
      perl -Mlib::core::only
    
    If you want to combine a core-only @INC with additional paths, you need to
    add the additional paths using -M options and the L<lib|lib> module:
    
      perl -Mlib::core::only -Mlib=lib
    
      # or if you're trying to test compiled code:
    
      perl -Mlib::core::only -Mblib
    
    For more information on the impossibility of sanely propagating this across
    module builds without help from the build program, see
    L<http://www.shadowcat.co.uk/blog/matt-s-trout/tainted-love> - and for ways
    to achieve the old --self-contained feature's results, look at
    L<App::FatPacker|App::FatPacker>'s tree function, and at
    L<App::cpanminus|cpanm>'s --local-lib-contained feature.
    
    =head1 AUTHOR
    
    Matt S. Trout <mst@shadowcat.co.uk>
    
    =head1 LICENSE
    
    This library is free software under the same terms as perl itself.
    
    =head1 COPYRIGHT
    
    (c) 2010 the lib::core::only L</AUTHOR> as specified above.
    
    =cut
    
    1;
  LIB_CORE_ONLY
  
  $fatpacked{"local/lib.pm"} = <<'LOCAL_LIB';
    use strict;
    use warnings;
    
    package local::lib;
    
    use 5.008001; # probably works with earlier versions but I'm not supporting them
                  # (patches would, of course, be welcome)
    
    use File::Spec ();
    use File::Path ();
    use Config;
    
    our $VERSION = '1.008011'; # 1.8.11
    
    our @KNOWN_FLAGS = qw(--self-contained --deactivate --deactivate-all);
    
    sub DEACTIVATE_ONE () { 1 }
    sub DEACTIVATE_ALL () { 2 }
    
    sub INTERPOLATE_ENV () { 1 }
    sub LITERAL_ENV     () { 0 }
    
    sub import {
      my ($class, @args) = @_;
    
      # Remember what PERL5LIB was when we started
      my $perl5lib = $ENV{PERL5LIB} || '';
    
      my %arg_store;
      for my $arg (@args) {
        # check for lethal dash first to stop processing before causing problems
        if ($arg =~ /−/) {
          die <<'DEATH';
    WHOA THERE! It looks like you've got some fancy dashes in your commandline!
    These are *not* the traditional -- dashes that software recognizes. You
    probably got these by copy-pasting from the perldoc for this module as
    rendered by a UTF8-capable formatter. This most typically happens on an OS X
    terminal, but can happen elsewhere too. Please try again after replacing the
    dashes with normal minus signs.
    DEATH
        }
        elsif(grep { $arg eq $_ } @KNOWN_FLAGS) {
          (my $flag = $arg) =~ s/--//;
          $arg_store{$flag} = 1;
        }
        elsif($arg =~ /^--/) {
          die "Unknown import argument: $arg";
        }
        else {
          # assume that what's left is a path
          $arg_store{path} = $arg;
        }
      }
    
      if($arg_store{'self-contained'}) {
        die "FATAL: The local::lib --self-contained flag has never worked reliably and the original author, Mark Stosberg, was unable or unwilling to maintain it. As such, this flag has been removed from the local::lib codebase in order to prevent misunderstandings and potentially broken builds. The local::lib authors recommend that you look at the lib::core::only module shipped with this distribution in order to create a more robust environment that is equivalent to what --self-contained provided (although quite possibly not what you originally thought it provided due to the poor quality of the documentation, for which we apologise).\n";
      }
    
      my $deactivating = 0;
      if ($arg_store{deactivate}) {
        $deactivating = DEACTIVATE_ONE;
      }
      if ($arg_store{'deactivate-all'}) {
        $deactivating = DEACTIVATE_ALL;
      }
    
      $arg_store{path} = $class->resolve_path($arg_store{path});
      $class->setup_local_lib_for($arg_store{path}, $deactivating);
    
      for (@INC) { # Untaint @INC
        next if ref; # Skip entry if it is an ARRAY, CODE, blessed, etc.
        m/(.*)/ and $_ = $1;
      }
    }
    
    sub pipeline;
    
    sub pipeline {
      my @methods = @_;
      my $last = pop(@methods);
      if (@methods) {
        \sub {
          my ($obj, @args) = @_;
          $obj->${pipeline @methods}(
            $obj->$last(@args)
          );
        };
      } else {
        \sub {
          shift->$last(@_);
        };
      }
    }
    
    =begin testing
    
    #:: test pipeline
    
    package local::lib;
    
    { package Foo; sub foo { -$_[1] } sub bar { $_[1]+2 } sub baz { $_[1]+3 } }
    my $foo = bless({}, 'Foo');                                                 
    Test::More::ok($foo->${pipeline qw(foo bar baz)}(10) == -15);
    
    =end testing
    
    =cut
    
    sub _uniq {
        my %seen;
        grep { ! $seen{$_}++ } @_;
    }
    
    sub resolve_path {
      my ($class, $path) = @_;
      $class->${pipeline qw(
        resolve_relative_path
        resolve_home_path
        resolve_empty_path
      )}($path);
    }
    
    sub resolve_empty_path {
      my ($class, $path) = @_;
      if (defined $path) {
        $path;
      } else {
        '~/perl5';
      }
    }
    
    =begin testing
    
    #:: test classmethod setup
    
    my $c = 'local::lib';
    
    =end testing
    
    =begin testing
    
    #:: test classmethod
    
    is($c->resolve_empty_path, '~/perl5');
    is($c->resolve_empty_path('foo'), 'foo');
    
    =end testing
    
    =cut
    
    sub resolve_home_path {
      my ($class, $path) = @_;
      return $path unless ($path =~ /^~/);
      my ($user) = ($path =~ /^~([^\/]+)/); # can assume ^~ so undef for 'us'
      my $tried_file_homedir;
      my $homedir = do {
        if (eval { require File::HomeDir } && $File::HomeDir::VERSION >= 0.65) {
          $tried_file_homedir = 1;
          if (defined $user) {
            File::HomeDir->users_home($user);
          } else {
            File::HomeDir->my_home;
          }
        } else {
          if (defined $user) {
            (getpwnam $user)[7];
          } else {
            if (defined $ENV{HOME}) {
              $ENV{HOME};
            } else {
              (getpwuid $<)[7];
            }
          }
        }
      };
      unless (defined $homedir) {
        require Carp;
        Carp::croak(
          "Couldn't resolve homedir for "
          .(defined $user ? $user : 'current user')
          .($tried_file_homedir ? '' : ' - consider installing File::HomeDir')
        );
      }
      $path =~ s/^~[^\/]*/$homedir/;
      $path;
    }
    
    sub resolve_relative_path {
      my ($class, $path) = @_;
      $path = File::Spec->rel2abs($path);
    }
    
    =begin testing
    
    #:: test classmethod
    
    local *File::Spec::rel2abs = sub { shift; 'FOO'.shift; };
    is($c->resolve_relative_path('bar'),'FOObar');
    
    =end testing
    
    =cut
    
    sub setup_local_lib_for {
      my ($class, $path, $deactivating) = @_;
    
      my $interpolate = LITERAL_ENV;
      my @active_lls = $class->active_paths;
    
      $class->ensure_dir_structure_for($path);
    
      # On Win32 directories often contain spaces. But some parts of the CPAN
      # toolchain don't like that. To avoid this, GetShortPathName() gives us
      # an alternate representation that has none.
      # This only works if the directory already exists.
      $path = Win32::GetShortPathName($path) if $^O eq 'MSWin32';
    
      if (! $deactivating) {
        if (@active_lls && $active_lls[-1] eq $path) {
          exit 0 if $0 eq '-';
          return; # Asked to add what's already at the top of the stack
        } elsif (grep { $_ eq $path} @active_lls) {
          # Asked to add a dir that's lower in the stack -- so we remove it from
          # where it is, and then add it back at the top.
          $class->setup_env_hash_for($path, DEACTIVATE_ONE);
          # Which means we can no longer output "PERL5LIB=...:$PERL5LIB" stuff
          # anymore because we're taking something *out*.
          $interpolate = INTERPOLATE_ENV;
        }
      }
    
      if ($0 eq '-') {
        $class->print_environment_vars_for($path, $deactivating, $interpolate);
        exit 0;
      } else {
        $class->setup_env_hash_for($path, $deactivating);
        my $arch_dir = $Config{archname};
        @INC = _uniq(
      (
          # Inject $path/$archname for each path in PERL5LIB
          map { ( File::Spec->catdir($_, $arch_dir), $_ ) }
          split($Config{path_sep}, $ENV{PERL5LIB})
      ),
      @INC
        );
      }
    }
    
    sub install_base_bin_path {
      my ($class, $path) = @_;
      File::Spec->catdir($path, 'bin');
    }
    
    sub install_base_perl_path {
      my ($class, $path) = @_;
      File::Spec->catdir($path, 'lib', 'perl5');
    }
    
    sub install_base_arch_path {
      my ($class, $path) = @_;
      File::Spec->catdir($class->install_base_perl_path($path), $Config{archname});
    }
    
    sub ensure_dir_structure_for {
      my ($class, $path) = @_;
      unless (-d $path) {
        warn "Attempting to create directory ${path}\n";
      }
      File::Path::mkpath($path);
      return
    }
    
    sub guess_shelltype {
      my $shellbin = 'sh';
      if(defined $ENV{'SHELL'}) {
          my @shell_bin_path_parts = File::Spec->splitpath($ENV{'SHELL'});
          $shellbin = $shell_bin_path_parts[-1];
      }
      my $shelltype = do {
          local $_ = $shellbin;
          if(/csh/) {
              'csh'
          } else {
              'bourne'
          }
      };
    
      # Both Win32 and Cygwin have $ENV{COMSPEC} set.
      if (defined $ENV{'COMSPEC'} && $^O ne 'cygwin') {
          my @shell_bin_path_parts = File::Spec->splitpath($ENV{'COMSPEC'});
          $shellbin = $shell_bin_path_parts[-1];
             $shelltype = do {
                     local $_ = $shellbin;
                     if(/command\.com/) {
                             'win32'
                     } elsif(/cmd\.exe/) {
                             'win32'
                     } elsif(/4nt\.exe/) {
                             'win32'
                     } else {
                             $shelltype
                     }
             };
      }
      return $shelltype;
    }
    
    sub print_environment_vars_for {
      my ($class, $path, $deactivating, $interpolate) = @_;
      print $class->environment_vars_string_for($path, $deactivating, $interpolate);
    }
    
    sub environment_vars_string_for {
      my ($class, $path, $deactivating, $interpolate) = @_;
      my @envs = $class->build_environment_vars_for($path, $deactivating, $interpolate);
      my $out = '';
    
      # rather basic csh detection, goes on the assumption that something won't
      # call itself csh unless it really is. also, default to bourne in the
      # pathological situation where a user doesn't have $ENV{SHELL} defined.
      # note also that shells with funny names, like zoid, are assumed to be
      # bourne.
    
      my $shelltype = $class->guess_shelltype;
    
      while (@envs) {
        my ($name, $value) = (shift(@envs), shift(@envs));
        $value =~ s/(\\")/\\$1/g if defined $value;
        $out .= $class->${\"build_${shelltype}_env_declaration"}($name, $value);
      }
      return $out;
    }
    
    # simple routines that take two arguments: an %ENV key and a value. return
    # strings that are suitable for passing directly to the relevant shell to set
    # said key to said value.
    sub build_bourne_env_declaration {
      my $class = shift;
      my($name, $value) = @_;
      return defined($value) ? qq{export ${name}="${value}";\n} : qq{unset ${name};\n};
    }
    
    sub build_csh_env_declaration {
      my $class = shift;
      my($name, $value) = @_;
      return defined($value) ? qq{setenv ${name} "${value}"\n} : qq{unsetenv ${name}\n};
    }
    
    sub build_win32_env_declaration {
      my $class = shift;
      my($name, $value) = @_;
      return defined($value) ? qq{set ${name}=${value}\n} : qq{set ${name}=\n};
    }
    
    sub setup_env_hash_for {
      my ($class, $path, $deactivating) = @_;
      my %envs = $class->build_environment_vars_for($path, $deactivating, INTERPOLATE_ENV);
      @ENV{keys %envs} = values %envs;
    }
    
    sub build_environment_vars_for {
      my ($class, $path, $deactivating, $interpolate) = @_;
    
      if ($deactivating == DEACTIVATE_ONE) {
        return $class->build_deactivate_environment_vars_for($path, $interpolate);
      } elsif ($deactivating == DEACTIVATE_ALL) {
        return $class->build_deact_all_environment_vars_for($path, $interpolate);
      } else {
        return $class->build_activate_environment_vars_for($path, $interpolate);
      }
    }
    
    # Build an environment value for a variable like PATH from a list of paths.
    # References to existing variables are given as references to the variable name.
    # Duplicates are removed.
    #
    # options:
    # - interpolate: INTERPOLATE_ENV/LITERAL_ENV
    # - exists: paths are included only if they exist (default: interpolate == INTERPOLATE_ENV)
    # - filter: function to apply to each path do decide if it must be included
    # - empty: the value to return in the case of empty value
    my %ENV_LIST_VALUE_DEFAULTS = (
        interpolate => INTERPOLATE_ENV,
        exists => undef,
        filter => sub { 1 },
        empty => undef,
    );
    sub _env_list_value {
      my $options = shift;
      die(sprintf "unknown option '$_' at %s line %u\n", (caller)[1..2])
        for grep { !exists $ENV_LIST_VALUE_DEFAULTS{$_} } keys %$options;
      my %options = (%ENV_LIST_VALUE_DEFAULTS, %{ $options });
      $options{exists} = $options{interpolate} == INTERPOLATE_ENV
        unless defined $options{exists};
    
      my %seen;
    
      my $value = join($Config{path_sep}, map {
          ref $_ ? ($^O eq 'MSWin32' ? "%${$_}%" : "\$${$_}") : $_
        } grep {
          ref $_ || (defined $_
                     && length($_) > 0
                     && !$seen{$_}++
                     && $options{filter}->($_)
                     && (!$options{exists} || -e $_))
        } map {
          if (ref $_ eq 'SCALAR' && $options{interpolate} == INTERPOLATE_ENV) {
            defined $ENV{${$_}} ? (split /\Q$Config{path_sep}/, $ENV{${$_}}) : ()
          } else {
            $_
          }
        } @_);
      return length($value) ? $value : $options{empty};
    }
    
    sub build_activate_environment_vars_for {
      my ($class, $path, $interpolate) = @_;
      return (
        PERL_LOCAL_LIB_ROOT =>
                _env_list_value(
                  { interpolate => $interpolate, exists => 0, empty => '' },
                  \'PERL_LOCAL_LIB_ROOT',
                  $path,
                ),
        PERL_MB_OPT => "--install_base ${path}",
        PERL_MM_OPT => "INSTALL_BASE=${path}",
        PERL5LIB =>
                _env_list_value(
                  { interpolate => $interpolate, exists => 0, empty => '' },
                  $class->install_base_perl_path($path),
                  \'PERL5LIB',
                ),
        PATH => _env_list_value(
                  { interpolate => $interpolate, exists => 0, empty => '' },
            $class->install_base_bin_path($path),
                  \'PATH',
                ),
      )
    }
    
    sub active_paths {
      my ($class) = @_;
    
      return () unless defined $ENV{PERL_LOCAL_LIB_ROOT};
      return grep { $_ ne '' } split /\Q$Config{path_sep}/, $ENV{PERL_LOCAL_LIB_ROOT};
    }
    
    sub build_deactivate_environment_vars_for {
      my ($class, $path, $interpolate) = @_;
    
      my @active_lls = $class->active_paths;
    
      if (!grep { $_ eq $path } @active_lls) {
        warn "Tried to deactivate inactive local::lib '$path'\n";
        return ();
      }
    
      my $perl_path = $class->install_base_perl_path($path);
      my $arch_path = $class->install_base_arch_path($path);
      my $bin_path = $class->install_base_bin_path($path);
    
    
      my %env = (
        PERL_LOCAL_LIB_ROOT => _env_list_value(
          {
            exists => 0,
          },
          grep { $_ ne $path } @active_lls
        ),
        PERL5LIB => _env_list_value(
          {
            exists => 0,
            filter => sub {
              $_ ne $perl_path && $_ ne $arch_path
            },
          },
          \'PERL5LIB',
        ),
        PATH => _env_list_value(
          {
            exists => 0,
            filter => sub { $_ ne $bin_path },
          },
          \'PATH',
        ),
      );
    
      # If removing ourselves from the "top of the stack", set install paths to
      # correspond with the new top of stack.
      if ($active_lls[-1] eq $path) {
        my $new_top = $active_lls[-2];
        $env{PERL_MB_OPT} = defined($new_top) ? "--install_base ${new_top}" : undef;
        $env{PERL_MM_OPT} = defined($new_top) ? "INSTALL_BASE=${new_top}" : undef;
      }
    
      return %env;
    }
    
    sub build_deact_all_environment_vars_for {
      my ($class, $path, $interpolate) = @_;
    
      my @active_lls = $class->active_paths;
    
      my %perl_paths = map { (
          $class->install_base_perl_path($_) => 1,
          $class->install_base_arch_path($_) => 1
        ) } @active_lls;
      my %bin_paths = map { (
          $class->install_base_bin_path($_) => 1,
        ) } @active_lls;
    
      my %env = (
        PERL_LOCAL_LIB_ROOT => undef,
        PERL_MM_OPT => undef,
        PERL_MB_OPT => undef,
        PERL5LIB => _env_list_value(
          {
            exists => 0,
            filter => sub {
              ! scalar grep { exists $perl_paths{$_} } $_[0]
            },
          },
          \'PERL5LIB'
        ),
        PATH => _env_list_value(
          {
            exists => 0,
            filter => sub {
              ! scalar grep { exists $bin_paths{$_} } $_[0]
            },
          },
          \'PATH'
        ),
      );
    
      return %env;
    }
    
    =begin testing
    
    #:: test classmethod
    
    File::Path::rmtree('t/var/splat');
    
    $c->ensure_dir_structure_for('t/var/splat');
    
    ok(-d 't/var/splat');
    
    =end testing
    
    =encoding utf8
    
    =head1 NAME
    
    local::lib - create and use a local lib/ for perl modules with PERL5LIB
    
    =head1 SYNOPSIS
    
    In code -
    
      use local::lib; # sets up a local lib at ~/perl5
    
      use local::lib '~/foo'; # same, but ~/foo
    
      # Or...
      use FindBin;
      use local::lib "$FindBin::Bin/../support";  # app-local support library
    
    From the shell -
    
      # Install LWP and its missing dependencies to the '~/perl5' directory
      perl -MCPAN -Mlocal::lib -e 'CPAN::install(LWP)'
    
      # Just print out useful shell commands
      $ perl -Mlocal::lib
      export PERL_MB_OPT='--install_base /home/username/perl5'
      export PERL_MM_OPT='INSTALL_BASE=/home/username/perl5'
      export PERL5LIB='/home/username/perl5/lib/perl5/i386-linux:/home/username/perl5/lib/perl5'
      export PATH="/home/username/perl5/bin:$PATH"
    
    =head2 The bootstrapping technique
    
    A typical way to install local::lib is using what is known as the
    "bootstrapping" technique.  You would do this if your system administrator
    hasn't already installed local::lib.  In this case, you'll need to install
    local::lib in your home directory. 
    
    If you do have administrative privileges, you will still want to set up your 
    environment variables, as discussed in step 4. Without this, you would still
    install the modules into the system CPAN installation and also your Perl scripts
    will not use the lib/ path you bootstrapped with local::lib.
    
    By default local::lib installs itself and the CPAN modules into ~/perl5.
    
    Windows users must also see L</Differences when using this module under Win32>.
    
    1. Download and unpack the local::lib tarball from CPAN (search for "Download"
    on the CPAN page about local::lib).  Do this as an ordinary user, not as root
    or administrator.  Unpack the file in your home directory or in any other
    convenient location.
    
    2. Run this:
    
      perl Makefile.PL --bootstrap
    
    If the system asks you whether it should automatically configure as much
    as possible, you would typically answer yes.
    
    In order to install local::lib into a directory other than the default, you need
    to specify the name of the directory when you call bootstrap, as follows:
    
      perl Makefile.PL --bootstrap=~/foo
    
    3. Run this: (local::lib assumes you have make installed on your system)
    
      make test && make install
    
    4. Now we need to setup the appropriate environment variables, so that Perl 
    starts using our newly generated lib/ directory. If you are using bash or
    any other Bourne shells, you can add this to your shell startup script this
    way:
    
      echo 'eval $(perl -I$HOME/perl5/lib/perl5 -Mlocal::lib)' >>~/.bashrc
    
    If you are using C shell, you can do this as follows:
    
      /bin/csh
      echo $SHELL
      /bin/csh
      perl -I$HOME/perl5/lib/perl5 -Mlocal::lib >> ~/.cshrc
    
    If you passed to bootstrap a directory other than default, you also need to give that as 
    import parameter to the call of the local::lib module like this way:
    
      echo 'eval $(perl -I$HOME/foo/lib/perl5 -Mlocal::lib=$HOME/foo)' >>~/.bashrc
    
    After writing your shell configuration file, be sure to re-read it to get the
    changed settings into your current shell's environment. Bourne shells use 
    C<. ~/.bashrc> for this, whereas C shells use C<source ~/.cshrc>.
    
    If you're on a slower machine, or are operating under draconian disk space
    limitations, you can disable the automatic generation of manpages from POD when
    installing modules by using the C<--no-manpages> argument when bootstrapping:
    
      perl Makefile.PL --bootstrap --no-manpages
    
    To avoid doing several bootstrap for several Perl module environments on the 
    same account, for example if you use it for several different deployed 
    applications independently, you can use one bootstrapped local::lib 
    installation to install modules in different directories directly this way:
    
      cd ~/mydir1
      perl -Mlocal::lib=./
      eval $(perl -Mlocal::lib=./)  ### To set the environment for this shell alone
      printenv                      ### You will see that ~/mydir1 is in the PERL5LIB
      perl -MCPAN -e install ...    ### whatever modules you want
      cd ../mydir2
      ... REPEAT ...
    
    If you are working with several C<local::lib> environments, you may want to
    remove some of them from the current environment without disturbing the others.
    You can deactivate one environment like this (using bourne sh):
    
      eval $(perl -Mlocal::lib=--deactivate,~/path)
    
    which will generate and run the commands needed to remove C<~/path> from your
    various search paths. Whichever environment was B<activated most recently> will
    remain the target for module installations. That is, if you activate
    C<~/path_A> and then you activate C<~/path_B>, new modules you install will go
    in C<~/path_B>. If you deactivate C<~/path_B> then modules will be installed
    into C<~/pathA> -- but if you deactivate C<~/path_A> then they will still be
    installed in C<~/pathB> because pathB was activated later.
    
    You can also ask C<local::lib> to clean itself completely out of the current
    shell's environment with the C<--deactivate-all> option.
    For multiple environments for multiple apps you may need to include a modified
    version of the C<< use FindBin >> instructions in the "In code" sample above.
    If you did something like the above, you have a set of Perl modules at C<<
    ~/mydir1/lib >>. If you have a script at C<< ~/mydir1/scripts/myscript.pl >>,
    you need to tell it where to find the modules you installed for it at C<<
    ~/mydir1/lib >>.
    
    In C<< ~/mydir1/scripts/myscript.pl >>:
    
      use strict;
      use warnings;
      use local::lib "$FindBin::Bin/..";  ### points to ~/mydir1 and local::lib finds lib
      use lib "$FindBin::Bin/../lib";     ### points to ~/mydir1/lib
    
    Put this before any BEGIN { ... } blocks that require the modules you installed.
    
    =head2 Differences when using this module under Win32
    
    To set up the proper environment variables for your current session of
    C<CMD.exe>, you can use this:
    
      C:\>perl -Mlocal::lib
      set PERL_MB_OPT=--install_base C:\DOCUME~1\ADMINI~1\perl5
      set PERL_MM_OPT=INSTALL_BASE=C:\DOCUME~1\ADMINI~1\perl5
      set PERL5LIB=C:\DOCUME~1\ADMINI~1\perl5\lib\perl5;C:\DOCUME~1\ADMINI~1\perl5\lib\perl5\MSWin32-x86-multi-thread
      set PATH=C:\DOCUME~1\ADMINI~1\perl5\bin;%PATH%
      
      ### To set the environment for this shell alone
      C:\>perl -Mlocal::lib > %TEMP%\tmp.bat && %TEMP%\tmp.bat && del %TEMP%\tmp.bat
      ### instead of $(perl -Mlocal::lib=./)
    
    If you want the environment entries to persist, you'll need to add then to the
    Control Panel's System applet yourself or use L<App::local::lib::Win32Helper>.
    
    The "~" is translated to the user's profile directory (the directory named for
    the user under "Documents and Settings" (Windows XP or earlier) or "Users"
    (Windows Vista or later)) unless $ENV{HOME} exists. After that, the home
    directory is translated to a short name (which means the directory must exist)
    and the subdirectories are created.
    
    =head1 RATIONALE
    
    The version of a Perl package on your machine is not always the version you
    need.  Obviously, the best thing to do would be to update to the version you
    need.  However, you might be in a situation where you're prevented from doing
    this.  Perhaps you don't have system administrator privileges; or perhaps you
    are using a package management system such as Debian, and nobody has yet gotten
    around to packaging up the version you need.
    
    local::lib solves this problem by allowing you to create your own directory of
    Perl packages downloaded from CPAN (in a multi-user system, this would typically
    be within your own home directory).  The existing system Perl installation is
    not affected; you simply invoke Perl with special options so that Perl uses the
    packages in your own local package directory rather than the system packages.
    local::lib arranges things so that your locally installed version of the Perl
    packages takes precedence over the system installation.
    
    If you are using a package management system (such as Debian), you don't need to
    worry about Debian and CPAN stepping on each other's toes.  Your local version
    of the packages will be written to an entirely separate directory from those
    installed by Debian.  
    
    =head1 DESCRIPTION
    
    This module provides a quick, convenient way of bootstrapping a user-local Perl
    module library located within the user's home directory. It also constructs and
    prints out for the user the list of environment variables using the syntax
    appropriate for the user's current shell (as specified by the C<SHELL>
    environment variable), suitable for directly adding to one's shell
    configuration file.
    
    More generally, local::lib allows for the bootstrapping and usage of a
    directory containing Perl modules outside of Perl's C<@INC>. This makes it
    easier to ship an application with an app-specific copy of a Perl module, or
    collection of modules. Useful in cases like when an upstream maintainer hasn't
    applied a patch to a module of theirs that you need for your application.
    
    On import, local::lib sets the following environment variables to appropriate
    values:
    
    =over 4
    
    =item PERL_MB_OPT
    
    =item PERL_MM_OPT
    
    =item PERL5LIB
    
    =item PATH
    
    PATH is appended to, rather than clobbered.
    
    =back
    
    These values are then available for reference by any code after import.
    
    =head1 CREATING A SELF-CONTAINED SET OF MODULES
    
    See L<lib::core::only> for one way to do this - but note that
    there are a number of caveats, and the best approach is always to perform a
    build against a clean perl (i.e. site and vendor as close to empty as possible).
    
    =head1 OPTIONS
    
    Options are values that can be passed to the C<local::lib> import besides the
    directory to use. They are specified as C<use local::lib '--option'[, path];>
    or C<perl -Mlocal::lib=--option[,path]>.
    
    =head2 --deactivate
    
    Remove the chosen path (or the default path) from the module search paths if it
    was added by C<local::lib>, instead of adding it.
    
    =head2 --deactivate-all
    
    Remove all directories that were added to search paths by C<local::lib> from the
    search paths.
    
    =head1 METHODS
    
    =head2 ensure_dir_structure_for
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: None
    
    =back
    
    Attempts to create the given path, and all required parent directories. Throws
    an exception on failure.
    
    =head2 print_environment_vars_for
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: None
    
    =back
    
    Prints to standard output the variables listed above, properly set to use the
    given path as the base directory.
    
    =head2 build_environment_vars_for
    
    =over 4
    
    =item Arguments: $path, $interpolate
    
    =item Return value: \%environment_vars
    
    =back
    
    Returns a hash with the variables listed above, properly set to use the
    given path as the base directory.
    
    =head2 setup_env_hash_for
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: None
    
    =back
    
    Constructs the C<%ENV> keys for the given path, by calling
    L</build_environment_vars_for>.
    
    =head2 active_paths
    
    =over 4
    
    =item Arguments: None
    
    =item Return value: @paths
    
    =back
    
    Returns a list of active C<local::lib> paths, according to the
    C<PERL_LOCAL_LIB_ROOT> environment variable.
    
    =head2 install_base_perl_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $install_base_perl_path
    
    =back
    
    Returns a path describing where to install the Perl modules for this local
    library installation. Appends the directories C<lib> and C<perl5> to the given
    path.
    
    =head2 install_base_arch_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $install_base_arch_path
    
    =back
    
    Returns a path describing where to install the architecture-specific Perl
    modules for this local library installation. Based on the
    L</install_base_perl_path> method's return value, and appends the value of
    C<$Config{archname}>.
    
    =head2 install_base_bin_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $install_base_bin_path
    
    =back
    
    Returns a path describing where to install the executable programs for this
    local library installation. Based on the L</install_base_perl_path> method's
    return value, and appends the directory C<bin>.
    
    =head2 resolve_empty_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $base_path
    
    =back
    
    Builds and returns the base path into which to set up the local module
    installation. Defaults to C<~/perl5>.
    
    =head2 resolve_home_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $home_path
    
    =back
    
    Attempts to find the user's home directory. If installed, uses C<File::HomeDir>
    for this purpose. If no definite answer is available, throws an exception.
    
    =head2 resolve_relative_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $absolute_path
    
    =back
    
    Translates the given path into an absolute path.
    
    =head2 resolve_path
    
    =over 4
    
    =item Arguments: $path
    
    =item Return value: $absolute_path
    
    =back
    
    Calls the following in a pipeline, passing the result from the previous to the
    next, in an attempt to find where to configure the environment for a local
    library installation: L</resolve_empty_path>, L</resolve_home_path>,
    L</resolve_relative_path>. Passes the given path argument to
    L</resolve_empty_path> which then returns a result that is passed to
    L</resolve_home_path>, which then has its result passed to
    L</resolve_relative_path>. The result of this final call is returned from
    L</resolve_path>.
    
    =head1 A WARNING ABOUT UNINST=1
    
    Be careful about using local::lib in combination with "make install UNINST=1".
    The idea of this feature is that will uninstall an old version of a module
    before installing a new one. However it lacks a safety check that the old
    version and the new version will go in the same directory. Used in combination
    with local::lib, you can potentially delete a globally accessible version of a
    module while installing the new version in a local place. Only combine "make
    install UNINST=1" and local::lib if you understand these possible consequences.
    
    =head1 LIMITATIONS
    
    The perl toolchain is unable to handle directory names with spaces in it,
    so you cant put your local::lib bootstrap into a directory with spaces. What
    you can do is moving your local::lib to a directory with spaces B<after> you
    installed all modules inside your local::lib bootstrap. But be aware that you
    cant update or install CPAN modules after the move.
    
    Rather basic shell detection. Right now anything with csh in its name is
    assumed to be a C shell or something compatible, and everything else is assumed
    to be Bourne, except on Win32 systems. If the C<SHELL> environment variable is
    not set, a Bourne-compatible shell is assumed.
    
    Bootstrap is a hack and will use CPAN.pm for ExtUtils::MakeMaker even if you
    have CPANPLUS installed.
    
    Kills any existing PERL5LIB, PERL_MM_OPT or PERL_MB_OPT.
    
    Should probably auto-fixup CPAN config if not already done.
    
    Patches very much welcome for any of the above.
    
    On Win32 systems, does not have a way to write the created environment variables
    to the registry, so that they can persist through a reboot.
    
    =head1 TROUBLESHOOTING
    
    If you've configured local::lib to install CPAN modules somewhere in to your
    home directory, and at some point later you try to install a module with C<cpan
    -i Foo::Bar>, but it fails with an error like: C<Warning: You do not have
    permissions to install into /usr/lib64/perl5/site_perl/5.8.8/x86_64-linux at
    /usr/lib64/perl5/5.8.8/Foo/Bar.pm> and buried within the install log is an
    error saying C<'INSTALL_BASE' is not a known MakeMaker parameter name>, then
    you've somehow lost your updated ExtUtils::MakeMaker module.
    
    To remedy this situation, rerun the bootstrapping procedure documented above.
    
    Then, run C<rm -r ~/.cpan/build/Foo-Bar*>
    
    Finally, re-run C<cpan -i Foo::Bar> and it should install without problems.
    
    =head1 ENVIRONMENT
    
    =over 4
    
    =item SHELL
    
    =item COMSPEC
    
    local::lib looks at the user's C<SHELL> environment variable when printing out
    commands to add to the shell configuration file.
    
    On Win32 systems, C<COMSPEC> is also examined.
    
    =back
    
    =head1 SEE ALSO
    
    =over 4
    
    =item * L<Perl Advent article, 2011|http://perladvent.org/2011/2011-12-01.html>
    
    =back
    
    =head1 SUPPORT
    
    IRC:
    
        Join #local-lib on irc.perl.org.
    
    =head1 AUTHOR
    
    Matt S Trout <mst@shadowcat.co.uk> http://www.shadowcat.co.uk/
    
    auto_install fixes kindly sponsored by http://www.takkle.com/
    
    =head1 CONTRIBUTORS
    
    Patches to correctly output commands for csh style shells, as well as some
    documentation additions, contributed by Christopher Nehren <apeiron@cpan.org>.
    
    Doc patches for a custom local::lib directory, more cleanups in the english
    documentation and a L<german documentation|POD2::DE::local::lib> contributed by Torsten Raudssus
    <torsten@raudssus.de>.
    
    Hans Dieter Pearcey <hdp@cpan.org> sent in some additional tests for ensuring
    things will install properly, submitted a fix for the bug causing problems with
    writing Makefiles during bootstrapping, contributed an example program, and
    submitted yet another fix to ensure that local::lib can install and bootstrap
    properly. Many, many thanks!
    
    pattern of Freenode IRC contributed the beginnings of the Troubleshooting
    section. Many thanks!
    
    Patch to add Win32 support contributed by Curtis Jewell <csjewell@cpan.org>.
    
    Warnings for missing PATH/PERL5LIB (as when not running interactively) silenced
    by a patch from Marco Emilio Poleggi.
    
    Mark Stosberg <mark@summersault.com> provided the code for the now deleted
    '--self-contained' option.
    
    Documentation patches to make win32 usage clearer by
    David Mertens <dcmertens.perl@gmail.com> (run4flat).
    
    Brazilian L<portuguese translation|POD2::PT_BR::local::lib> and minor doc patches contributed by Breno
    G. de Oliveira <garu@cpan.org>.
    
    Improvements to stacking multiple local::lib dirs and removing them from the
    environment later on contributed by Andrew Rodland <arodland@cpan.org>.
    
    Patch for Carp version mismatch contributed by Hakim Cassimally <osfameron@cpan.org>.
    
    =head1 COPYRIGHT
    
    Copyright (c) 2007 - 2010 the local::lib L</AUTHOR> and L</CONTRIBUTORS> as
    listed above.
    
    =head1 LICENSE
    
    This library is free software and may be distributed under the same terms
    as perl itself.
    
    =cut
    
    1;
  LOCAL_LIB
  
  $fatpacked{"version.pm"} = <<'VERSION';
    #!perl -w
    package version;
    
    use 5.005_04;
    use strict;
    
    use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
    
    $VERSION = 0.9902;
    
    $CLASS = 'version';
    
    #--------------------------------------------------------------------------#
    # Version regexp components
    #--------------------------------------------------------------------------#
    
    # Fraction part of a decimal version number.  This is a common part of
    # both strict and lax decimal versions
    
    my $FRACTION_PART = qr/\.[0-9]+/;
    
    # First part of either decimal or dotted-decimal strict version number.
    # Unsigned integer with no leading zeroes (except for zero itself) to
    # avoid confusion with octal.
    
    my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
    
    # First part of either decimal or dotted-decimal lax version number.
    # Unsigned integer, but allowing leading zeros.  Always interpreted
    # as decimal.  However, some forms of the resulting syntax give odd
    # results if used as ordinary Perl expressions, due to how perl treats
    # octals.  E.g.
    #   version->new("010" ) == 10
    #   version->new( 010  ) == 8
    #   version->new( 010.2) == 82  # "8" . "2"
    
    my $LAX_INTEGER_PART = qr/[0-9]+/;
    
    # Second and subsequent part of a strict dotted-decimal version number.
    # Leading zeroes are permitted, and the number is always decimal.
    # Limited to three digits to avoid overflow when converting to decimal
    # form and also avoid problematic style with excessive leading zeroes.
    
    my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
    
    # Second and subsequent part of a lax dotted-decimal version number.
    # Leading zeroes are permitted, and the number is always decimal.  No
    # limit on the numerical value or number of digits, so there is the
    # possibility of overflow when converting to decimal form.
    
    my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
    
    # Alpha suffix part of lax version number syntax.  Acts like a
    # dotted-decimal part.
    
    my $LAX_ALPHA_PART = qr/_[0-9]+/;
    
    #--------------------------------------------------------------------------#
    # Strict version regexp definitions
    #--------------------------------------------------------------------------#
    
    # Strict decimal version number.
    
    my $STRICT_DECIMAL_VERSION =
        qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
    
    # Strict dotted-decimal version number.  Must have both leading "v" and
    # at least three parts, to avoid confusion with decimal syntax.
    
    my $STRICT_DOTTED_DECIMAL_VERSION =
        qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
    
    # Complete strict version number syntax -- should generally be used
    # anchored: qr/ \A $STRICT \z /x
    
    $STRICT =
        qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
    
    #--------------------------------------------------------------------------#
    # Lax version regexp definitions
    #--------------------------------------------------------------------------#
    
    # Lax decimal version number.  Just like the strict one except for
    # allowing an alpha suffix or allowing a leading or trailing
    # decimal-point
    
    my $LAX_DECIMAL_VERSION =
        qr/ $LAX_INTEGER_PART (?: \. | $FRACTION_PART $LAX_ALPHA_PART? )?
    	|
    	$FRACTION_PART $LAX_ALPHA_PART?
        /x;
    
    # Lax dotted-decimal version number.  Distinguished by having either
    # leading "v" or at least three non-alpha parts.  Alpha part is only
    # permitted if there are at least two non-alpha parts. Strangely
    # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
    # so when there is no "v", the leading part is optional
    
    my $LAX_DOTTED_DECIMAL_VERSION =
        qr/
    	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
    	|
    	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
        /x;
    
    # Complete lax version number syntax -- should generally be used
    # anchored: qr/ \A $LAX \z /x
    #
    # The string 'undef' is a special case to make for easier handling
    # of return values from ExtUtils::MM->parse_version
    
    $LAX =
        qr/ undef | $LAX_DECIMAL_VERSION | $LAX_DOTTED_DECIMAL_VERSION /x;
    
    #--------------------------------------------------------------------------#
    
    {
        local $SIG{'__DIE__'};
        eval "use version::vxs $VERSION";
        if ( $@ ) { # don't have the XS version installed
    	eval "use version::vpp $VERSION"; # don't tempt fate
    	die "$@" if ( $@ );
    	push @ISA, "version::vpp";
    	local $^W;
    	*version::qv = \&version::vpp::qv;
    	*version::declare = \&version::vpp::declare;
    	*version::_VERSION = \&version::vpp::_VERSION;
    	*version::vcmp = \&version::vpp::vcmp;
    	*version::new = \&version::vpp::new;
    	if ($] >= 5.009000) {
    	    no strict 'refs';
    	    *version::stringify = \&version::vpp::stringify;
    	    *{'version::(""'} = \&version::vpp::stringify;
    	    *{'version::(<=>'} = \&version::vpp::vcmp;
    	    *version::parse = \&version::vpp::parse;
    	}
        }
        else { # use XS module
    	push @ISA, "version::vxs";
    	local $^W;
    	*version::declare = \&version::vxs::declare;
    	*version::qv = \&version::vxs::qv;
    	*version::_VERSION = \&version::vxs::_VERSION;
    	*version::vcmp = \&version::vxs::VCMP;
    	*version::new = \&version::vxs::new;
    	if ($] >= 5.009000) {
    	    no strict 'refs';
    	    *version::stringify = \&version::vxs::stringify;
    	    *{'version::(""'} = \&version::vxs::stringify;
    	    *{'version::(<=>'} = \&version::vxs::VCMP;
    	    *version::parse = \&version::vxs::parse;
    	}
    
        }
    }
    
    # Preloaded methods go here.
    sub import {
        no strict 'refs';
        my ($class) = shift;
    
        # Set up any derived class
        unless ($class eq 'version') {
    	local $^W;
    	*{$class.'::declare'} =  \&version::declare;
    	*{$class.'::qv'} = \&version::qv;
        }
    
        my %args;
        if (@_) { # any remaining terms are arguments
    	map { $args{$_} = 1 } @_
        }
        else { # no parameters at all on use line
        	%args = 
    	(
    	    qv => 1,
    	    'UNIVERSAL::VERSION' => 1,
    	);
        }
    
        my $callpkg = caller();
        
        if (exists($args{declare})) {
    	*{$callpkg.'::declare'} = 
    	    sub {return $class->declare(shift) }
    	  unless defined(&{$callpkg.'::declare'});
        }
    
        if (exists($args{qv})) {
    	*{$callpkg.'::qv'} =
    	    sub {return $class->qv(shift) }
    	  unless defined(&{$callpkg.'::qv'});
        }
    
        if (exists($args{'UNIVERSAL::VERSION'})) {
    	local $^W;
    	*UNIVERSAL::VERSION 
    		= \&version::_VERSION;
        }
    
        if (exists($args{'VERSION'})) {
    	*{$callpkg.'::VERSION'} = \&version::_VERSION;
        }
    
        if (exists($args{'is_strict'})) {
    	*{$callpkg.'::is_strict'} = \&version::is_strict
    	  unless defined(&{$callpkg.'::is_strict'});
        }
    
        if (exists($args{'is_lax'})) {
    	*{$callpkg.'::is_lax'} = \&version::is_lax
    	  unless defined(&{$callpkg.'::is_lax'});
        }
    }
    
    sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
    sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
    
    1;
  VERSION
  
  $fatpacked{"version/vpp.pm"} = <<'VERSION_VPP';
    package charstar;
    # a little helper class to emulate C char* semantics in Perl
    # so that prescan_version can use the same code as in C
    
    use overload (
        '""'	=> \&thischar,
        '0+'	=> \&thischar,
        '++'	=> \&increment,
        '--'	=> \&decrement,
        '+'		=> \&plus,
        '-'		=> \&minus,
        '*'		=> \&multiply,
        'cmp'	=> \&cmp,
        '<=>'	=> \&spaceship,
        'bool'	=> \&thischar,
        '='		=> \&clone,
    );
    
    sub new {
        my ($self, $string) = @_;
        my $class = ref($self) || $self;
    
        my $obj = {
    	string  => [split(//,$string)],
    	current => 0,
        };
        return bless $obj, $class;
    }
    
    sub thischar {
        my ($self) = @_;
        my $last = $#{$self->{string}};
        my $curr = $self->{current};
        if ($curr >= 0 && $curr <= $last) {
    	return $self->{string}->[$curr];
        }
        else {
    	return '';
        }
    }
    
    sub increment {
        my ($self) = @_;
        $self->{current}++;
    }
    
    sub decrement {
        my ($self) = @_;
        $self->{current}--;
    }
    
    sub plus {
        my ($self, $offset) = @_;
        my $rself = $self->clone;
        $rself->{current} += $offset;
        return $rself;
    }
    
    sub minus {
        my ($self, $offset) = @_;
        my $rself = $self->clone;
        $rself->{current} -= $offset;
        return $rself;
    }
    
    sub multiply {
        my ($left, $right, $swapped) = @_;
        my $char = $left->thischar();
        return $char * $right;
    }
    
    sub spaceship {
        my ($left, $right, $swapped) = @_;
        unless (ref($right)) { # not an object already
    	$right = $left->new($right);
        }
        return $left->{current} <=> $right->{current};
    }
    
    sub cmp {
        my ($left, $right, $swapped) = @_;
        unless (ref($right)) { # not an object already
    	if (length($right) == 1) { # comparing single character only
    	    return $left->thischar cmp $right;
    	}
    	$right = $left->new($right);
        }
        return $left->currstr cmp $right->currstr;
    }
    
    sub bool {
        my ($self) = @_;
        my $char = $self->thischar;
        return ($char ne '');
    }
    
    sub clone {
        my ($left, $right, $swapped) = @_;
        $right = {
    	string  => [@{$left->{string}}],
    	current => $left->{current},
        };
        return bless $right, ref($left);
    }
    
    sub currstr {
        my ($self, $s) = @_;
        my $curr = $self->{current};
        my $last = $#{$self->{string}};
        if (defined($s) && $s->{current} < $last) {
    	$last = $s->{current};
        }
    
        my $string = join('', @{$self->{string}}[$curr..$last]);
        return $string;
    }
    
    package version::vpp;
    use strict;
    
    use POSIX qw/locale_h/;
    use locale;
    use vars qw ($VERSION @ISA @REGEXS);
    $VERSION = 0.9902;
    
    use overload (
        '""'       => \&stringify,
        '0+'       => \&numify,
        'cmp'      => \&vcmp,
        '<=>'      => \&vcmp,
        'bool'     => \&vbool,
        '+'        => \&vnoop,
        '-'        => \&vnoop,
        '*'        => \&vnoop,
        '/'        => \&vnoop,
        '+='        => \&vnoop,
        '-='        => \&vnoop,
        '*='        => \&vnoop,
        '/='        => \&vnoop,
        'abs'      => \&vnoop,
    );
    
    eval "use warnings";
    if ($@) {
        eval '
    	package
    	warnings;
    	sub enabled {return $^W;}
    	1;
        ';
    }
    
    my $VERSION_MAX = 0x7FFFFFFF;
    
    # implement prescan_version as closely to the C version as possible
    use constant TRUE  => 1;
    use constant FALSE => 0;
    
    sub isDIGIT {
        my ($char) = shift->thischar();
        return ($char =~ /\d/);
    }
    
    sub isALPHA {
        my ($char) = shift->thischar();
        return ($char =~ /[a-zA-Z]/);
    }
    
    sub isSPACE {
        my ($char) = shift->thischar();
        return ($char =~ /\s/);
    }
    
    sub BADVERSION {
        my ($s, $errstr, $error) = @_;
        if ($errstr) {
    	$$errstr = $error;
        }
        return $s;
    }
    
    sub prescan_version {
        my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
        my $qv          = defined $sqv          ? $$sqv          : FALSE;
        my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
        my $width       = defined $swidth       ? $$swidth       : 3;
        my $alpha       = defined $salpha       ? $$salpha       : FALSE;
    
        my $d = $s;
    
        if ($qv && isDIGIT($d)) {
    	goto dotted_decimal_version;
        }
    
        if ($d eq 'v') { # explicit v-string
    	$d++;
    	if (isDIGIT($d)) {
    	    $qv = TRUE;
    	}
    	else { # degenerate v-string
    	    # requires v1.2.3
    	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
    	}
    
    dotted_decimal_version:
    	if ($strict && $d eq '0' && isDIGIT($d+1)) {
    	    # no leading zeros allowed
    	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
    	}
    
    	while (isDIGIT($d)) { 	# integer part
    	    $d++;
    	}
    
    	if ($d eq '.')
    	{
    	    $saw_decimal++;
    	    $d++; 		# decimal point
    	}
    	else
    	{
    	    if ($strict) {
    		# require v1.2.3
    		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
    	    }
    	    else {
    		goto version_prescan_finish;
    	    }
    	}
    
    	{
    	    my $i = 0;
    	    my $j = 0;
    	    while (isDIGIT($d)) {	# just keep reading
    		$i++;
    		while (isDIGIT($d)) {
    		    $d++; $j++;
    		    # maximum 3 digits between decimal
    		    if ($strict && $j > 3) {
    			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
    		    }
    		}
    		if ($d eq '_') {
    		    if ($strict) {
    			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
    		    }
    		    if ( $alpha ) {
    			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
    		    }
    		    $d++;
    		    $alpha = TRUE;
    		}
    		elsif ($d eq '.') {
    		    if ($alpha) {
    			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
    		    }
    		    $saw_decimal++;
    		    $d++;
    		}
    		elsif (!isDIGIT($d)) {
    		    last;
    		}
    		$j = 0;
    	    }
    
    	    if ($strict && $i < 2) {
    		# requires v1.2.3
    		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
    	    }
    	}
        } 					# end if dotted-decimal
        else
        {					# decimal versions
    	my $j = 0;
    	# special $strict case for leading '.' or '0'
    	if ($strict) {
    	    if ($d eq '.') {
    		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
    	    }
    	    if ($d eq '0' && isDIGIT($d+1)) {
    		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
    	    }
    	}
    
    	# and we never support negative version numbers
    	if ($d eq '-') {
    	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
    	}
    
    	# consume all of the integer part
    	while (isDIGIT($d)) {
    	    $d++;
    	}
    
    	# look for a fractional part
    	if ($d eq '.') {
    	    # we found it, so consume it
    	    $saw_decimal++;
    	    $d++;
    	}
    	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
    	    if ( $d == $s ) {
    		# found nothing
    		return BADVERSION($s,$errstr,"Invalid version format (version required)");
    	    }
    	    # found just an integer
    	    goto version_prescan_finish;
    	}
    	elsif ( $d == $s ) {
    	    # didn't find either integer or period
    	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
    	}
    	elsif ($d eq '_') {
    	    # underscore can't come after integer part
    	    if ($strict) {
    		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
    	    }
    	    elsif (isDIGIT($d+1)) {
    		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
    	    }
    	    else {
    		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
    	    }
    	}
    	elsif ($d) {
    	    # anything else after integer part is just invalid data
    	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
    	}
    
    	# scan the fractional part after the decimal point
    	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
    		# $strict or lax-but-not-the-end
    		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
    	}
    
    	while (isDIGIT($d)) {
    	    $d++; $j++;
    	    if ($d eq '.' && isDIGIT($d-1)) {
    		if ($alpha) {
    		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
    		}
    		if ($strict) {
    		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
    		}
    		$d = $s; # start all over again
    		$qv = TRUE;
    		goto dotted_decimal_version;
    	    }
    	    if ($d eq '_') {
    		if ($strict) {
    		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
    		}
    		if ( $alpha ) {
    		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
    		}
    		if ( ! isDIGIT($d+1) ) {
    		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
    		}
    		$width = $j;
    		$d++;
    		$alpha = TRUE;
    	    }
    	}
        }
    
    version_prescan_finish:
        while (isSPACE($d)) {
    	$d++;
        }
    
        if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
    	# trailing non-numeric data
    	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
        }
    
        if (defined $sqv) {
    	$$sqv = $qv;
        }
        if (defined $swidth) {
    	$$swidth = $width;
        }
        if (defined $ssaw_decimal) {
    	$$ssaw_decimal = $saw_decimal;
        }
        if (defined $salpha) {
    	$$salpha = $alpha;
        }
        return $d;
    }
    
    sub scan_version {
        my ($s, $rv, $qv) = @_;
        my $start;
        my $pos;
        my $last;
        my $errstr;
        my $saw_decimal = 0;
        my $width = 3;
        my $alpha = FALSE;
        my $vinf = FALSE;
        my @av;
    
        $s = new charstar $s;
    
        while (isSPACE($s)) { # leading whitespace is OK
    	$s++;
        }
    
        $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
    	\$width, \$alpha);
    
        if ($errstr) {
    	# 'undef' is a special case and not an error
    	if ( $s ne 'undef') {
    	    use Carp;
    	    Carp::croak($errstr);
    	}
        }
    
        $start = $s;
        if ($s eq 'v') {
    	$s++;
        }
        $pos = $s;
    
        if ( $qv ) {
    	$$rv->{qv} = $qv;
        }
        if ( $alpha ) {
    	$$rv->{alpha} = $alpha;
        }
        if ( !$qv && $width < 3 ) {
    	$$rv->{width} = $width;
        }
    
        while (isDIGIT($pos)) {
    	$pos++;
        }
        if (!isALPHA($pos)) {
    	my $rev;
    
    	for (;;) {
    	    $rev = 0;
    	    {
      		# this is atoi() that delimits on underscores
      		my $end = $pos;
      		my $mult = 1;
    		my $orev;
    
    		#  the following if() will only be true after the decimal
    		#  point of a version originally created with a bare
    		#  floating point number, i.e. not quoted in any way
    		#
     		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
    		    $mult *= 100;
     		    while ( $s < $end ) {
    			$orev = $rev;
     			$rev += $s * $mult;
     			$mult /= 10;
    			if (   (abs($orev) > abs($rev))
    			    || (abs($rev) > $VERSION_MAX )) {
    			    warn("Integer overflow in version %d",
    					   $VERSION_MAX);
    			    $s = $end - 1;
    			    $rev = $VERSION_MAX;
    			    $vinf = 1;
    			}
     			$s++;
    			if ( $s eq '_' ) {
    			    $s++;
    			}
     		    }
      		}
     		else {
     		    while (--$end >= $s) {
    			$orev = $rev;
     			$rev += $end * $mult;
     			$mult *= 10;
    			if (   (abs($orev) > abs($rev))
    			    || (abs($rev) > $VERSION_MAX )) {
    			    warn("Integer overflow in version");
    			    $end = $s - 1;
    			    $rev = $VERSION_MAX;
    			    $vinf = 1;
    			}
     		    }
     		}
      	    }
    
      	    # Append revision
    	    push @av, $rev;
    	    if ( $vinf ) {
    		$s = $last;
    		last;
    	    }
    	    elsif ( $pos eq '.' ) {
    		$s = ++$pos;
    	    }
    	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
    		$s = ++$pos;
    	    }
    	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
    		$s = ++$pos;
    	    }
    	    elsif ( isDIGIT($pos) ) {
    		$s = $pos;
    	    }
    	    else {
    		$s = $pos;
    		last;
    	    }
    	    if ( $qv ) {
    		while ( isDIGIT($pos) ) {
    		    $pos++;
    		}
    	    }
    	    else {
    		my $digits = 0;
    		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
    		    if ( $pos ne '_' ) {
    			$digits++;
    		    }
    		    $pos++;
    		}
    	    }
    	}
        }
        if ( $qv ) { # quoted versions always get at least three terms
    	my $len = $#av;
    	#  This for loop appears to trigger a compiler bug on OS X, as it
    	#  loops infinitely. Yes, len is negative. No, it makes no sense.
    	#  Compiler in question is:
    	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
    	#  for ( len = 2 - len; len > 0; len-- )
    	#  av_push(MUTABLE_AV(sv), newSViv(0));
    	#
    	$len = 2 - $len;
    	while ($len-- > 0) {
    	    push @av, 0;
    	}
        }
    
        # need to save off the current version string for later
        if ( $vinf ) {
    	$$rv->{original} = "v.Inf";
    	$$rv->{vinf} = 1;
        }
        elsif ( $s > $start ) {
    	$$rv->{original} = $start->currstr($s);
    	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
    	    # need to insert a v to be consistent
    	    $$rv->{original} = 'v' . $$rv->{original};
    	}
        }
        else {
    	$$rv->{original} = '0';
    	push(@av, 0);
        }
    
        # And finally, store the AV in the hash
        $$rv->{version} = \@av;
    
        # fix RT#19517 - special case 'undef' as string
        if ($s eq 'undef') {
    	$s += 5;
        }
    
        return $s;
    }
    
    sub new
    {
    	my ($class, $value) = @_;
    	unless (defined $class) {
    	    require Carp;
    	    Carp::croak('Usage: version::new(class, version)');
    	}
    	my $self = bless ({}, ref ($class) || $class);
    	my $qv = FALSE;
    
    	if ( ref($value) && eval('$value->isa("version")') ) {
    	    # Can copy the elements directly
    	    $self->{version} = [ @{$value->{version} } ];
    	    $self->{qv} = 1 if $value->{qv};
    	    $self->{alpha} = 1 if $value->{alpha};
    	    $self->{original} = ''.$value->{original};
    	    return $self;
    	}
    
    	my $currlocale = setlocale(LC_ALL);
    
    	# if the current locale uses commas for decimal points, we
    	# just replace commas with decimal places, rather than changing
    	# locales
    	if ( localeconv()->{decimal_point} eq ',' ) {
    	    $value =~ tr/,/./;
    	}
    
    	if ( not defined $value or $value =~ /^undef$/ ) {
    	    # RT #19517 - special case for undef comparison
    	    # or someone forgot to pass a value
    	    push @{$self->{version}}, 0;
    	    $self->{original} = "0";
    	    return ($self);
    	}
    
    	if ( $#_ == 2 ) { # must be CVS-style
    	    $value = $_[2];
    	    $qv = TRUE;
    	}
    
    	$value = _un_vstring($value);
    
    	# exponential notation
    	if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
    	    $value = sprintf("%.9f",$value);
    	    $value =~ s/(0+)$//; # trim trailing zeros
    	}
    
    	my $s = scan_version($value, \$self, $qv);
    
    	if ($s) { # must be something left over
    	    warn("Version string '%s' contains invalid data; "
                           ."ignoring: '%s'", $value, $s);
    	}
    
    	return ($self);
    }
    
    *parse = \&new;
    
    sub numify
    {
        my ($self) = @_;
        unless (_verify($self)) {
    	require Carp;
    	Carp::croak("Invalid version object");
        }
        my $width = $self->{width} || 3;
        my $alpha = $self->{alpha} || "";
        my $len = $#{$self->{version}};
        my $digit = $self->{version}[0];
        my $string = sprintf("%d.", $digit );
    
        for ( my $i = 1 ; $i < $len ; $i++ ) {
    	$digit = $self->{version}[$i];
    	if ( $width < 3 ) {
    	    my $denom = 10**(3-$width);
    	    my $quot = int($digit/$denom);
    	    my $rem = $digit - ($quot * $denom);
    	    $string .= sprintf("%0".$width."d_%d", $quot, $rem);
    	}
    	else {
    	    $string .= sprintf("%03d", $digit);
    	}
        }
    
        if ( $len > 0 ) {
    	$digit = $self->{version}[$len];
    	if ( $alpha && $width == 3 ) {
    	    $string .= "_";
    	}
    	$string .= sprintf("%0".$width."d", $digit);
        }
        else # $len = 0
        {
    	$string .= sprintf("000");
        }
    
        return $string;
    }
    
    sub normal
    {
        my ($self) = @_;
        unless (_verify($self)) {
    	require Carp;
    	Carp::croak("Invalid version object");
        }
        my $alpha = $self->{alpha} || "";
        my $len = $#{$self->{version}};
        my $digit = $self->{version}[0];
        my $string = sprintf("v%d", $digit );
    
        for ( my $i = 1 ; $i < $len ; $i++ ) {
    	$digit = $self->{version}[$i];
    	$string .= sprintf(".%d", $digit);
        }
    
        if ( $len > 0 ) {
    	$digit = $self->{version}[$len];
    	if ( $alpha ) {
    	    $string .= sprintf("_%0d", $digit);
    	}
    	else {
    	    $string .= sprintf(".%0d", $digit);
    	}
        }
    
        if ( $len <= 2 ) {
    	for ( $len = 2 - $len; $len != 0; $len-- ) {
    	    $string .= sprintf(".%0d", 0);
    	}
        }
    
        return $string;
    }
    
    sub stringify
    {
        my ($self) = @_;
        unless (_verify($self)) {
    	require Carp;
    	Carp::croak("Invalid version object");
        }
        return exists $self->{original}
        	? $self->{original}
    	: exists $self->{qv}
    	    ? $self->normal
    	    : $self->numify;
    }
    
    sub vcmp
    {
        require UNIVERSAL;
        my ($left,$right,$swap) = @_;
        my $class = ref($left);
        unless ( UNIVERSAL::isa($right, $class) ) {
    	$right = $class->new($right);
        }
    
        if ( $swap ) {
    	($left, $right) = ($right, $left);
        }
        unless (_verify($left)) {
    	require Carp;
    	Carp::croak("Invalid version object");
        }
        unless (_verify($right)) {
    	require Carp;
    	Carp::croak("Invalid version format");
        }
        my $l = $#{$left->{version}};
        my $r = $#{$right->{version}};
        my $m = $l < $r ? $l : $r;
        my $lalpha = $left->is_alpha;
        my $ralpha = $right->is_alpha;
        my $retval = 0;
        my $i = 0;
        while ( $i <= $m && $retval == 0 ) {
    	$retval = $left->{version}[$i] <=> $right->{version}[$i];
    	$i++;
        }
    
        # tiebreaker for alpha with identical terms
        if ( $retval == 0
    	&& $l == $r
    	&& $left->{version}[$m] == $right->{version}[$m]
    	&& ( $lalpha || $ralpha ) ) {
    
    	if ( $lalpha && !$ralpha ) {
    	    $retval = -1;
    	}
    	elsif ( $ralpha && !$lalpha) {
    	    $retval = +1;
    	}
        }
    
        # possible match except for trailing 0's
        if ( $retval == 0 && $l != $r ) {
    	if ( $l < $r ) {
    	    while ( $i <= $r && $retval == 0 ) {
    		if ( $right->{version}[$i] != 0 ) {
    		    $retval = -1; # not a match after all
    		}
    		$i++;
    	    }
    	}
    	else {
    	    while ( $i <= $l && $retval == 0 ) {
    		if ( $left->{version}[$i] != 0 ) {
    		    $retval = +1; # not a match after all
    		}
    		$i++;
    	    }
    	}
        }
    
        return $retval;
    }
    
    sub vbool {
        my ($self) = @_;
        return vcmp($self,$self->new("0"),1);
    }
    
    sub vnoop {
        require Carp;
        Carp::croak("operation not supported with version object");
    }
    
    sub is_alpha {
        my ($self) = @_;
        return (exists $self->{alpha});
    }
    
    sub qv {
        my $value = shift;
        my $class = 'version';
        if (@_) {
    	$class = ref($value) || $value;
    	$value = shift;
        }
    
        $value = _un_vstring($value);
        $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
        my $obj = version->new($value);
        return bless $obj, $class;
    }
    
    *declare = \&qv;
    
    sub is_qv {
        my ($self) = @_;
        return (exists $self->{qv});
    }
    
    
    sub _verify {
        my ($self) = @_;
        if ( ref($self)
    	&& eval { exists $self->{version} }
    	&& ref($self->{version}) eq 'ARRAY'
    	) {
    	return 1;
        }
        else {
    	return 0;
        }
    }
    
    sub _is_non_alphanumeric {
        my $s = shift;
        $s = new charstar $s;
        while ($s) {
    	return 0 if isSPACE($s); # early out
    	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
    	$s++;
        }
        return 0;
    }
    
    sub _un_vstring {
        my $value = shift;
        # may be a v-string
        if ( length($value) >= 3 && $value !~ /[._]/
    	&& _is_non_alphanumeric($value)) {
    	my $tvalue;
    	if ( $] ge 5.008_001 ) {
    	    $tvalue = _find_magic_vstring($value);
    	    $value = $tvalue if length $tvalue;
    	}
    	elsif ( $] ge 5.006_000 ) {
    	    $tvalue = sprintf("v%vd",$value);
    	    if ( $tvalue =~ /^v\d+(\.\d+){2,}$/ ) {
    		# must be a v-string
    		$value = $tvalue;
    	    }
    	}
        }
        return $value;
    }
    
    sub _find_magic_vstring {
        my $value = shift;
        my $tvalue = '';
        require B;
        my $sv = B::svref_2object(\$value);
        my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
        while ( $magic ) {
    	if ( $magic->TYPE eq 'V' ) {
    	    $tvalue = $magic->PTR;
    	    $tvalue =~ s/^v?(.+)$/v$1/;
    	    last;
    	}
    	else {
    	    $magic = $magic->MOREMAGIC;
    	}
        }
        return $tvalue;
    }
    
    sub _VERSION {
        my ($obj, $req) = @_;
        my $class = ref($obj) || $obj;
    
        no strict 'refs';
        if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
    	 # file but no package
    	require Carp;
    	Carp::croak( "$class defines neither package nor VERSION"
    	    ."--version check failed");
        }
    
        my $version = eval "\$$class\::VERSION";
        if ( defined $version ) {
    	local $^W if $] <= 5.008;
    	$version = version::vpp->new($version);
        }
    
        if ( defined $req ) {
    	unless ( defined $version ) {
    	    require Carp;
    	    my $msg =  $] < 5.006
    	    ? "$class version $req required--this is only version "
    	    : "$class does not define \$$class\::VERSION"
    	      ."--version check failed";
    
    	    if ( $ENV{VERSION_DEBUG} ) {
    		Carp::confess($msg);
    	    }
    	    else {
    		Carp::croak($msg);
    	    }
    	}
    
    	$req = version::vpp->new($req);
    
    	if ( $req > $version ) {
    	    require Carp;
    	    if ( $req->is_qv ) {
    		Carp::croak(
    		    sprintf ("%s version %s required--".
    			"this is only version %s", $class,
    			$req->normal, $version->normal)
    		);
    	    }
    	    else {
    		Carp::croak(
    		    sprintf ("%s version %s required--".
    			"this is only version %s", $class,
    			$req->stringify, $version->stringify)
    		);
    	    }
    	}
        }
    
        return defined $version ? $version->stringify : undef;
    }
    
    1; #this line is important and will help the module return a true value
  VERSION_VPP
  
  s/^  //mg for values %fatpacked;
  
  unshift @INC, sub {
    if (my $fat = $fatpacked{$_[1]}) {
      if ($] < 5.008) {
        return sub {
          return 0 unless length $fat;
          $fat =~ s/^([^\n]*\n?)//;
          $_ = $1;
          return 1;
        };
      }
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return
  };
  
  } # END OF FATPACK CODE
  
  
  
  use strict;
  use App::cpanminus::script;
  
  
  unless (caller) {
      my $app = App::cpanminus::script->new;
      $app->parse_options(@ARGV);
      exit $app->doit;
  }
  
  __END__
  
  =head1 NAME
  
  cpanm - get, unpack build and install modules from CPAN
  
  =head1 SYNOPSIS
  
    cpanm Test::More                                 # install Test::More
    cpanm MIYAGAWA/Plack-0.99_05.tar.gz              # full distribution path
    cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz  # install from URL
    cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz   # install from a local file
    cpanm --interactive Task::Kensho                 # Configure interactively
    cpanm .                                          # install from local directory
    cpanm --installdeps .                            # install all the deps for the current directory
    cpanm -L extlib Plack                            # install Plack and all non-core deps into extlib
    cpanm --mirror http://cpan.cpantesters.org/ DBI  # use the fast-syncing mirror
  
  =head1 COMMANDS
  
  =over 4
  
  =item (arguments)
  
  Command line arguments can be either a module name, distribution file,
  local file path, HTTP URL or git repository URL. Following commands
  will all work as you expect.
  
      cpanm Plack
      cpanm Plack/Request.pm
      cpanm MIYAGAWA/Plack-1.0000.tar.gz
      cpanm /path/to/Plack-1.0000.tar.gz
      cpanm http://cpan.metacpan.org/authors/id/M/MI/MIYAGAWA/Plack-0.9990.tar.gz
      cpanm git://github.com/plack/Plack.git
  
  Additionally, you can use the notation using C<~> and C<@> to specify
  version for a given module. C<~> specifies the version requirement in
  the L<CPAN::Meta::Spec> format, while C<@> pins the exact version, and
  is a shortcut for C<~"== VERSION">.
  
      cpanm Plack~1.0000                 # 1.0000 or later
      cpanm Plack~">= 1.0000, < 2.0000"  # latest of 1.xxxx
      cpanm Plack@0.9990                 # specific version. same as Plack~"== 0.9990"
  
  The version query including specific version or range will be sent to
  L<MetaCPAN> to search for previous releases. The query will search for
  BackPAN archives by default, unless you specify C<--dev> option, in
  which case, archived versions will be filtered out.
  
  For a git repository, you can specify a branch, tag, or commit SHA to
  build. The default is C<master>
  
      cpanm git://github.com/plack/Plack.git@1.0000        # tag
      cpanm git://github.com/plack/Plack.git@devel         # branch
  
  =item -i, --install
  
  Installs the modules. This is a default behavior and this is just a
  compatibility option to make it work like L<cpan> or L<cpanp>.
  
  =item --self-upgrade
  
  Upgrades itself. It's just an alias for:
  
    cpanm App::cpanminus
  
  =item --info
  
  Displays the distribution information in
  C<AUTHOR/Dist-Name-ver.tar.gz> format in the standard out.
  
  =item --installdeps
  
  Installs the dependencies of the target distribution but won't build
  itself. Handy if you want to try the application from a version
  controlled repository such as git.
  
    cpanm --installdeps .
  
  =item --look
  
  Download and unpack the distribution and then open the directory with
  your shell. Handy to poke around the source code or do manual
  testing.
  
  =item -U, --uninstall
  
  B<EXPERIMENTAL>: Uninstalls the modules. Will remove the distribution
  files from your library path using the C<.packlist> file.
  
  When used with C<-l> or C<-L>, only the files under the local::lib
  directory will be removed.
  
  B<NOTE>: If you have the "dual-life" module in multiple locations
  (i.e. C<site_perl> and C<perl> library path, with perl 5.12 or later),
  only the files in C<site_perl> will be deleted.
  
  If the distribution has bin scripts and man, they will be kept in case
  the core installation still references that, although there's no
  guarantee that the script will continue working as expected with the
  older version of .pm files.
  
  =item -h, --help
  
  Displays the help message.
  
  =item -V, --version
  
  Displays the version number.
  
  =back
  
  =head1 OPTIONS
  
  You can specify the default options in C<PERL_CPANM_OPT> environment variable.
  
  =over 4
  
  =item -f, --force
  
  Force install modules even when testing failed.
  
  =item -n, --notest
  
  Skip the testing of modules. Use this only when you just want to save
  time for installing hundreds of distributions to the same perl and
  architecture you've already tested to make sure it builds fine.
  
  Defaults to false, and you can say C<--no-notest> to override when it
  is set in the default options in C<PERL_CPANM_OPT>.
  
  =item --test-only
  
  Run the tests only, and do not install the specified module or
  distributions. Handy if you want to verify the new (or even old)
  releases pass its unit tests without installing the module.
  
  Note that if you specify this option with a module or distribution
  that has dependencies, these dependencies will be installed if you
  don't currently have them.
  
  =item -S, --sudo
  
  Switch to the root user with C<sudo> when installing modules. Use this
  if you want to install modules to the system perl include path.
  
  Defaults to false, and you can say C<--no-sudo> to override when it is
  set in the default options in C<PERL_CPANM_OPT>.
  
  =item -v, --verbose
  
  Makes the output verbose. It also enables the interactive
  configuration. (See --interactive)
  
  =item -q, --quiet
  
  Makes the output even more quiet than the default. It only shows the
  successful/failed dependencies to the output.
  
  =item -l, --local-lib
  
  Sets the L<local::lib> compatible path to install modules to. You
  don't need to set this if you already configure the shell environment
  variables using L<local::lib>, but this can be used to override that
  as well.
  
  =item -L, --local-lib-contained
  
  Same with C<--local-lib> but with L<--self-contained> set.  All
  non-core dependencies will be installed even if they're already
  installed.
  
  For instance,
  
    cpanm -L extlib Plack
  
  would install Plack and all of its non-core dependencies into the
  directory C<extlib>, which can be loaded from your application with:
  
    use local::lib '/path/to/extlib';
  
  =item --self-contained
  
  When examining the dependencies, assume no non-core modules are
  installed on the system. Handy if you want to bundle application
  dependencies in one directory so you can distribute to other machines.
  
  =item --mirror
  
  Specifies the base URL for the CPAN mirror to use, such as
  C<http://cpan.cpantesters.org/> (you can omit the trailing slash). You
  can specify multiple mirror URLs by repeating the command line option.
  
  You can use a local directory that has a CPAN mirror structure
  (created by tools such as L<OrePAN> or L<Pinto>) by using a special
  URL scheme C<file://>. If the given URL begins with `/` (without any
  scheme), it is considered as a file scheme as well.
  
    cpanm --mirror file:///path/to/mirror
    cpanm --mirror ~/minicpan      # Because shell expands ~ to /home/user
  
  Defaults to C<http://www.cpan.org/>.
  
  =item --mirror-only
  
  Download the mirror's 02packages.details.txt.gz index file instead of
  querying the CPAN Meta DB. This will also effectively opt out sending
  your local perl versions to backend database servers such as CPAN Meta
  DB and MetaCPAN.
  
  Select this option if you are using a local mirror of CPAN, such as
  minicpan when you're offline, or your own CPAN index (a.k.a darkpan).
  
  B<Tip:> It might be useful if you name these mirror options with your
  shell aliases, like:
  
    alias minicpanm='cpanm --mirror ~/minicpan --mirror-only'
    alias darkpan='cpanm --mirror http://mycompany.example.com/DPAN --mirror-only'
  
  =item --mirror-index
  
  B<EXPERIMENTAL>: Specifies the file path to C<02packages.details.txt>
  for module search index.
  
  =item --cpanmetadb
  
  B<EXPERIMENTAL>: Specifies an alternate URI for CPAN MetaDB index lookups.
  
  =item --cpanfile
  
  B<EXPERIMENTAL>: Specified an alternate path for cpanfile to search for,
  when C<--installdeps> command is in use. Defaults to C<cpanfile>.
  
  =item --prompt
  
  Prompts when a test fails so that you can skip, force install, retry
  or look in the shell to see what's going wrong. It also prompts when
  one of the dependency failed if you want to proceed the installation.
  
  Defaults to false, and you can say C<--no-prompt> to override if it's
  set in the default options in C<PERL_CPANM_OPT>.
  
  =item --dev
  
  B<EXPERIMENTAL>: search for a newer developer release as well. Defaults to false.
  
  =item --reinstall
  
  cpanm, when given a module name in the command line (i.e. C<cpanm
  Plack>), checks the locally installed version first and skips if it is
  already installed. This option makes it skip the check, so:
  
    cpanm --reinstall Plack
  
  would reinstall L<Plack> even if your locally installed version is
  latest, or even newer (which would happen if you install a developer
  release from version control repositories).
  
  Defaults to false.
  
  =item --interactive
  
  Makes the configuration (such as C<Makefile.PL> and C<Build.PL>)
  interactive, so you can answer questions in the distribution that
  requires custom configuration or Task:: distributions.
  
  Defaults to false, and you can say C<--no-interactive> to override
  when it's set in the default options in C<PERL_CPANM_OPT>.
  
  =item --pp, --pureperl
  
  Prefer Pure perl build of modules by setting C<PUREPERL_ONLY=1> for
  MakeMaker and C<--pureperl-only> for Build.PL based
  distributions. Note that not all of the CPAN modules support this
  convention yet.
  
  =item --with-recommends, --with-suggests
  
  B<EXPERIMENTAL>: Installs dependencies declared as C<recommends> and
  C<suggests> respectively, per META spec. When these dependencies fail
  to install, cpanm continues the installation, since they're just
  recommendation/suggestion.
  
  Enabling this could potentially make a circular dependency for a few
  modules on CPAN, when C<recommends> adds a module that C<recommends>
  back the module in return.
  
  There's also C<--without-recommend> and C<--without-suggests> to
  override the default decision made earlier in C<PERL_CPANM_OPT>.
  
  Defaults to false for both.
  
  =item --with-develop
  
  B<EXPERIMENTAL>: Installs develop phase dependencies in META files or
  C<cpanfile> when used with C<--installdeps>. Defaults to false.
  
  =item --with-feature, --without-feature, --with-all-features
  
  B<EXPERIMENTAL>: Specifies the feature to enable, if a module supports
  optional features per META spec 2.0.
  
      cpanm --with-feature=opt_csv Spreadsheet::Read
  
  the features can also be interactively chosen when C<--interactive>
  option is enabled.
  
  C<--with-all-features> enables all the optional features, and
  C<--without-feature> can select a feature to disable.
  
  =item --configure-timeout, --build-timeout, --test-timeout
  
  Specify the timeout length (in seconds) to wait for the configure,
  build and test process. Current default values are: 60 for configure,
  3600 for build and 1800 for test.
  
  =item --configure-args, --build-args, --test-args, --install-args
  
  B<EXPERIMENTAL>: Pass arguments for configure/build/test/install
  commands respectively, for a given module to install.
  
      cpanm DBD::mysql --configure-args="--cflags=... --libs=..."
  
  The argument is only enabled for the module passed as a command line
  argument, not dependencies.
  
  =item --scandeps
  
  B<DEPRECATED>: Scans the depencencies of given modules and output the
  tree in a text format. (See C<--format> below for more options)
  
  Because this command doesn't actually install any distributions, it
  will be useful that by typing:
  
    cpanm --scandeps Catalyst::Runtime
  
  you can make sure what modules will be installed.
  
  This command takes into account which modules you already have
  installed in your system. If you want to see what modules will be
  installed against a vanilla perl installation, you might want to
  combine it with C<-L> option.
  
  =item --format
  
  B<DEPRECATED>: Determines what format to display the scanned
  dependency tree. Available options are C<tree>, C<json>, C<yaml> and
  C<dists>.
  
  =over 8
  
  =item tree
  
  Displays the tree in a plain text format. This is the default value.
  
  =item json, yaml
  
  Outputs the tree in a JSON or YAML format. L<JSON> and L<YAML> modules
  need to be installed respectively. The output tree is represented as a
  recursive tuple of:
  
    [ distribution, dependencies ]
  
  and the container is an array containing the root elements. Note that
  there may be multiple root nodes, since you can give multiple modules
  to the C<--scandeps> command.
  
  =item dists
  
  C<dists> is a special output format, where it prints the distribution
  filename in the I<depth first order> after the dependency resolution,
  like:
  
    GAAS/MIME-Base64-3.13.tar.gz
    GAAS/URI-1.58.tar.gz
    PETDANCE/HTML-Tagset-3.20.tar.gz
    GAAS/HTML-Parser-3.68.tar.gz
    GAAS/libwww-perl-5.837.tar.gz
  
  which means you can install these distributions in this order without
  extra dependencies. When combined with C<-L> option, it will be useful
  to replay installations on other machines.
  
  =back
  
  =item --save-dists
  
  Specifies the optional directory path to copy downloaded tarballs in
  the CPAN mirror compatible directory structure
  i.e. I<authors/id/A/AU/AUTHORS/Foo-Bar-version.tar.gz>
  
  If the distro tarball did not come from CPAN, for example from a local
  file or from GitHub, then it will be saved under
  I<vendor/Foo-Bar-version.tar.gz>.
  
  =item --uninst-shadows
  
  Uninstalls the shadow files of the distribution that you're
  installing. This eliminates the confusion if you're trying to install
  core (dual-life) modules from CPAN against perl 5.10 or older, or
  modules that used to be XS-based but switched to pure perl at some
  version.
  
  If you run cpanm as root and use C<INSTALL_BASE> or equivalent to
  specify custom installation path, you SHOULD disable this option so
  you won't accidentally uninstall dual-life modules from the core
  include path.
  
  Defaults to true if your perl version is smaller than 5.12, and you
  can disable that with C<--no-uninst-shadows>.
  
  B<NOTE>: Since version 1.3000 this flag is turned off by default for
  perl newer than 5.12, since with 5.12 @INC contains site_perl directory
  I<before> the perl core library path, and uninstalling shadows is not
  necessary anymore and does more harm by deleting files from the core
  library path.
  
  =item --uninstall, -U
  
  Uninstalls a module from the library path. It finds a packlist for
  given modules, and removes all the files included in the same
  distribution.
  
  If you enable local::lib, it only removes files from the local::lib
  directory.
  
  If you try to uninstall a module in C<perl> directory (i.e. core
  module), an error will be thrown.
  
  A dialog wil be prompted to confirm the files to be deleted. If you pass
  C<-f> option as well, the dialog will be skipped and uninstallation
  will be forced.
  
  =item --cascade-search
  
  B<EXPERIMENTAL>: Specifies whether to cascade search when you specify
  multiple mirrors and a mirror doesn't have a module or has a lower
  version of the module than requested. Defaults to false.
  
  =item --skip-installed
  
  Specifies whether a module given in the command line is skipped if its latest
  version is already installed. Defaults to true.
  
  B<NOTE>: The C<PERL5LIB> environment variable have to be correctly set
  for this to work with modules installed using L<local::lib>, unless
  you always use the C<-l> option.
  
  =item --skip-satisfied
  
  B<EXPERIMENTAL>: Specifies whether a module (and version) given in the
  command line is skipped if it's already installed.
  
  If you run:
  
    cpanm --skip-satisfied CGI DBI~1.2
  
  cpanm won't install them if you already have CGI (for whatever
  versions) or have DBI with version higher than 1.2. It is similar to
  C<--skip-installed> but while C<--skip-installed> checks if the
  I<latest> version of CPAN is installed, C<--skip-satisfied> checks if
  a requested version (or not, which means any version) is installed.
  
  Defaults to false.
  
  =item --verify
  
  Verify the integrity of distribution files retrieved from PAUSE using
  CHECKSUMS and SIGNATURES (if found). Defaults to false.
  
  =item --report-perl-version
  
  Whether it report the locally installed perl version to the various
  web server as part of User-Agent. Defaults to true, and you can disable
  it by using C<--no-report-perl-version>.
  
  =item --auto-cleanup
  
  Specifies the number of days in which cpanm's work directories
  expire. Defaults to 7, which means old work directories will be
  cleaned up in one week.
  
  You can set the value to C<0> to make cpan never cleanup those
  directories.
  
  =item --man-pages
  
  Generates man pages for executables (man1) and libraries (man3).
  
  Defaults to true (man pages generated) unless C<-L|--local-lib-contained>
  option is supplied in which case it's set to false. You can disable
  it with C<--no-man-pages>.
  
  =item --lwp
  
  Uses L<LWP> module to download stuff over HTTP. Defaults to true, and
  you can say C<--no-lwp> to disable using LWP, when you want to upgrade
  LWP from CPAN on some broken perl systems.
  
  =item --wget
  
  Uses GNU Wget (if available) to download stuff. Defaults to true, and
  you can say C<--no-wget> to disable using Wget (versions of Wget older
  than 1.9 don't support the C<--retry-connrefused> option used by cpanm).
  
  =item --curl
  
  Uses cURL (if available) to download stuff. Defaults to true, and
  you can say C<--no-curl> to disable using cURL.
  
  Normally with C<--lwp>, C<--wget> and C<--curl> options set to true
  (which is the default) cpanm tries L<LWP>, Wget, cURL and L<HTTP::Tiny>
  (in that order) and uses the first one available.
  
  =back
  
  =head1 SEE ALSO
  
  L<App::cpanminus>
  
  =head1 COPYRIGHT
  
  Copyright 2010 Tatsuhiko Miyagawa.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
APP_CPANMINUS_FATSCRIPT

$fatpacked{"CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta;
  our $VERSION = '2.140640'; # VERSION
  
  # =head1 SYNOPSIS
  #
  #     use v5.10;
  #     use strict;
  #     use warnings;
  #     use CPAN::Meta;
  #     use Module::Load;
  #
  #     my $meta = CPAN::Meta->load_file('META.json');
  #
  #     printf "testing requirements for %s version %s\n",
  #     $meta->name,
  #     $meta->version;
  #
  #     my $prereqs = $meta->effective_prereqs;
  #
  #     for my $phase ( qw/configure runtime build test/ ) {
  #         say "Requirements for $phase:";
  #         my $reqs = $prereqs->requirements_for($phase, "requires");
  #         for my $module ( sort $reqs->required_modules ) {
  #             my $status;
  #             if ( eval { load $module unless $module eq 'perl'; 1 } ) {
  #                 my $version = $module eq 'perl' ? $] : $module->VERSION;
  #                 $status = $reqs->accepts_module($module, $version)
  #                         ? "$version ok" : "$version not ok";
  #             } else {
  #                 $status = "missing"
  #             };
  #             say "  $module ($status)";
  #         }
  #     }
  #
  # =head1 DESCRIPTION
  #
  # Software distributions released to the CPAN include a F<META.json> or, for
  # older distributions, F<META.yml>, which describes the distribution, its
  # contents, and the requirements for building and installing the distribution.
  # The data structure stored in the F<META.json> file is described in
  # L<CPAN::Meta::Spec>.
  #
  # CPAN::Meta provides a simple class to represent this distribution metadata (or
  # I<distmeta>), along with some helpful methods for interrogating that data.
  #
  # The documentation below is only for the methods of the CPAN::Meta object.  For
  # information on the meaning of individual fields, consult the spec.
  #
  # =cut
  
  use Carp qw(carp croak);
  use CPAN::Meta::Feature;
  use CPAN::Meta::Prereqs;
  use CPAN::Meta::Converter;
  use CPAN::Meta::Validator;
  use Parse::CPAN::Meta 1.4414 ();
  
  BEGIN { *_dclone = \&CPAN::Meta::Converter::_dclone }
  
  # =head1 STRING DATA
  #
  # The following methods return a single value, which is the value for the
  # corresponding entry in the distmeta structure.  Values should be either undef
  # or strings.
  #
  # =for :list
  # * abstract
  # * description
  # * dynamic_config
  # * generated_by
  # * name
  # * release_status
  # * version
  #
  # =cut
  
  BEGIN {
    my @STRING_READERS = qw(
      abstract
      description
      dynamic_config
      generated_by
      name
      release_status
      version
    );
  
    no strict 'refs';
    for my $attr (@STRING_READERS) {
      *$attr = sub { $_[0]{ $attr } };
    }
  }
  
  # =head1 LIST DATA
  #
  # These methods return lists of string values, which might be represented in the
  # distmeta structure as arrayrefs or scalars:
  #
  # =for :list
  # * authors
  # * keywords
  # * licenses
  #
  # The C<authors> and C<licenses> methods may also be called as C<author> and
  # C<license>, respectively, to match the field name in the distmeta structure.
  #
  # =cut
  
  BEGIN {
    my @LIST_READERS = qw(
      author
      keywords
      license
    );
  
    no strict 'refs';
    for my $attr (@LIST_READERS) {
      *$attr = sub {
        my $value = $_[0]{ $attr };
        croak "$attr must be called in list context"
          unless wantarray;
        return @{ _dclone($value) } if ref $value;
        return $value;
      };
    }
  }
  
  sub authors  { $_[0]->author }
  sub licenses { $_[0]->license }
  
  # =head1 MAP DATA
  #
  # These readers return hashrefs of arbitrary unblessed data structures, each
  # described more fully in the specification:
  #
  # =for :list
  # * meta_spec
  # * resources
  # * provides
  # * no_index
  # * prereqs
  # * optional_features
  #
  # =cut
  
  BEGIN {
    my @MAP_READERS = qw(
      meta-spec
      resources
      provides
      no_index
  
      prereqs
      optional_features
    );
  
    no strict 'refs';
    for my $attr (@MAP_READERS) {
      (my $subname = $attr) =~ s/-/_/;
      *$subname = sub {
        my $value = $_[0]{ $attr };
        return _dclone($value) if $value;
        return {};
      };
    }
  }
  
  # =head1 CUSTOM DATA
  #
  # A list of custom keys are available from the C<custom_keys> method and
  # particular keys may be retrieved with the C<custom> method.
  #
  #   say $meta->custom($_) for $meta->custom_keys;
  #
  # If a custom key refers to a data structure, a deep clone is returned.
  #
  # =cut
  
  sub custom_keys {
    return grep { /^x_/i } keys %{$_[0]};
  }
  
  sub custom {
    my ($self, $attr) = @_;
    my $value = $self->{$attr};
    return _dclone($value) if ref $value;
    return $value;
  }
  
  # =method new
  #
  #   my $meta = CPAN::Meta->new($distmeta_struct, \%options);
  #
  # Returns a valid CPAN::Meta object or dies if the supplied metadata hash
  # reference fails to validate.  Older-format metadata will be up-converted to
  # version 2 if they validate against the original stated specification.
  #
  # It takes an optional hashref of options. Valid options include:
  #
  # =over
  #
  # =item *
  #
  # lazy_validation -- if true, new will attempt to convert the given metadata
  # to version 2 before attempting to validate it.  This means than any
  # fixable errors will be handled by CPAN::Meta::Converter before validation.
  # (Note that this might result in invalid optional data being silently
  # dropped.)  The default is false.
  #
  # =back
  #
  # =cut
  
  sub _new {
    my ($class, $struct, $options) = @_;
    my $self;
  
    if ( $options->{lazy_validation} ) {
      # try to convert to a valid structure; if succeeds, then return it
      my $cmc = CPAN::Meta::Converter->new( $struct );
      $self = $cmc->convert( version => 2 ); # valid or dies
      return bless $self, $class;
    }
    else {
      # validate original struct
      my $cmv = CPAN::Meta::Validator->new( $struct );
      unless ( $cmv->is_valid) {
        die "Invalid metadata structure. Errors: "
          . join(", ", $cmv->errors) . "\n";
      }
    }
  
    # up-convert older spec versions
    my $version = $struct->{'meta-spec'}{version} || '1.0';
    if ( $version == 2 ) {
      $self = $struct;
    }
    else {
      my $cmc = CPAN::Meta::Converter->new( $struct );
      $self = $cmc->convert( version => 2 );
    }
  
    return bless $self, $class;
  }
  
  sub new {
    my ($class, $struct, $options) = @_;
    my $self = eval { $class->_new($struct, $options) };
    croak($@) if $@;
    return $self;
  }
  
  # =method create
  #
  #   my $meta = CPAN::Meta->create($distmeta_struct, \%options);
  #
  # This is same as C<new()>, except that C<generated_by> and C<meta-spec> fields
  # will be generated if not provided.  This means the metadata structure is
  # assumed to otherwise follow the latest L<CPAN::Meta::Spec>.
  #
  # =cut
  
  sub create {
    my ($class, $struct, $options) = @_;
    my $version = __PACKAGE__->VERSION || 2;
    $struct->{generated_by} ||= __PACKAGE__ . " version $version" ;
    $struct->{'meta-spec'}{version} ||= int($version);
    my $self = eval { $class->_new($struct, $options) };
    croak ($@) if $@;
    return $self;
  }
  
  # =method load_file
  #
  #   my $meta = CPAN::Meta->load_file($distmeta_file, \%options);
  #
  # Given a pathname to a file containing metadata, this deserializes the file
  # according to its file suffix and constructs a new C<CPAN::Meta> object, just
  # like C<new()>.  It will die if the deserialized version fails to validate
  # against its stated specification version.
  #
  # It takes the same options as C<new()> but C<lazy_validation> defaults to
  # true.
  #
  # =cut
  
  sub load_file {
    my ($class, $file, $options) = @_;
    $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
  
    croak "load_file() requires a valid, readable filename"
      unless -r $file;
  
    my $self;
    eval {
      my $struct = Parse::CPAN::Meta->load_file( $file );
      $self = $class->_new($struct, $options);
    };
    croak($@) if $@;
    return $self;
  }
  
  # =method load_yaml_string
  #
  #   my $meta = CPAN::Meta->load_yaml_string($yaml, \%options);
  #
  # This method returns a new CPAN::Meta object using the first document in the
  # given YAML string.  In other respects it is identical to C<load_file()>.
  #
  # =cut
  
  sub load_yaml_string {
    my ($class, $yaml, $options) = @_;
    $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
  
    my $self;
    eval {
      my ($struct) = Parse::CPAN::Meta->load_yaml_string( $yaml );
      $self = $class->_new($struct, $options);
    };
    croak($@) if $@;
    return $self;
  }
  
  # =method load_json_string
  #
  #   my $meta = CPAN::Meta->load_json_string($json, \%options);
  #
  # This method returns a new CPAN::Meta object using the structure represented by
  # the given JSON string.  In other respects it is identical to C<load_file()>.
  #
  # =cut
  
  sub load_json_string {
    my ($class, $json, $options) = @_;
    $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
  
    my $self;
    eval {
      my $struct = Parse::CPAN::Meta->load_json_string( $json );
      $self = $class->_new($struct, $options);
    };
    croak($@) if $@;
    return $self;
  }
  
  # =method load_string
  #
  #   my $meta = CPAN::Meta->load_string($string, \%options);
  #
  # If you don't know if a string contains YAML or JSON, this method will use
  # L<Parse::CPAN::Meta> to guess.  In other respects it is identical to
  # C<load_file()>.
  #
  # =cut
  
  sub load_string {
    my ($class, $string, $options) = @_;
    $options->{lazy_validation} = 1 unless exists $options->{lazy_validation};
  
    my $self;
    eval {
      my $struct = Parse::CPAN::Meta->load_string( $string );
      $self = $class->_new($struct, $options);
    };
    croak($@) if $@;
    return $self;
  }
  
  # =method save
  #
  #   $meta->save($distmeta_file, \%options);
  #
  # Serializes the object as JSON and writes it to the given file.  The only valid
  # option is C<version>, which defaults to '2'. On Perl 5.8.1 or later, the file
  # is saved with UTF-8 encoding.
  #
  # For C<version> 2 (or higher), the filename should end in '.json'.  L<JSON::PP>
  # is the default JSON backend. Using another JSON backend requires L<JSON> 2.5 or
  # later and you must set the C<$ENV{PERL_JSON_BACKEND}> to a supported alternate
  # backend like L<JSON::XS>.
  #
  # For C<version> less than 2, the filename should end in '.yml'.
  # L<CPAN::Meta::Converter> is used to generate an older metadata structure, which
  # is serialized to YAML.  CPAN::Meta::YAML is the default YAML backend.  You may
  # set the C<$ENV{PERL_YAML_BACKEND}> to a supported alternative backend, though
  # this is not recommended due to subtle incompatibilities between YAML parsers on
  # CPAN.
  #
  # =cut
  
  sub save {
    my ($self, $file, $options) = @_;
  
    my $version = $options->{version} || '2';
    my $layer = $] ge '5.008001' ? ':utf8' : '';
  
    if ( $version ge '2' ) {
      carp "'$file' should end in '.json'"
        unless $file =~ m{\.json$};
    }
    else {
      carp "'$file' should end in '.yml'"
        unless $file =~ m{\.yml$};
    }
  
    my $data = $self->as_string( $options );
    open my $fh, ">$layer", $file
      or die "Error opening '$file' for writing: $!\n";
  
    print {$fh} $data;
    close $fh
      or die "Error closing '$file': $!\n";
  
    return 1;
  }
  
  # =method meta_spec_version
  #
  # This method returns the version part of the C<meta_spec> entry in the distmeta
  # structure.  It is equivalent to:
  #
  #   $meta->meta_spec->{version};
  #
  # =cut
  
  sub meta_spec_version {
    my ($self) = @_;
    return $self->meta_spec->{version};
  }
  
  # =method effective_prereqs
  #
  #   my $prereqs = $meta->effective_prereqs;
  #
  #   my $prereqs = $meta->effective_prereqs( \@feature_identifiers );
  #
  # This method returns a L<CPAN::Meta::Prereqs> object describing all the
  # prereqs for the distribution.  If an arrayref of feature identifiers is given,
  # the prereqs for the identified features are merged together with the
  # distribution's core prereqs before the CPAN::Meta::Prereqs object is returned.
  #
  # =cut
  
  sub effective_prereqs {
    my ($self, $features) = @_;
    $features ||= [];
  
    my $prereq = CPAN::Meta::Prereqs->new($self->prereqs);
  
    return $prereq unless @$features;
  
    my @other = map {; $self->feature($_)->prereqs } @$features;
  
    return $prereq->with_merged_prereqs(\@other);
  }
  
  # =method should_index_file
  #
  #   ... if $meta->should_index_file( $filename );
  #
  # This method returns true if the given file should be indexed.  It decides this
  # by checking the C<file> and C<directory> keys in the C<no_index> property of
  # the distmeta structure.
  #
  # C<$filename> should be given in unix format.
  #
  # =cut
  
  sub should_index_file {
    my ($self, $filename) = @_;
  
    for my $no_index_file (@{ $self->no_index->{file} || [] }) {
      return if $filename eq $no_index_file;
    }
  
    for my $no_index_dir (@{ $self->no_index->{directory} }) {
      $no_index_dir =~ s{$}{/} unless $no_index_dir =~ m{/\z};
      return if index($filename, $no_index_dir) == 0;
    }
  
    return 1;
  }
  
  # =method should_index_package
  #
  #   ... if $meta->should_index_package( $package );
  #
  # This method returns true if the given package should be indexed.  It decides
  # this by checking the C<package> and C<namespace> keys in the C<no_index>
  # property of the distmeta structure.
  #
  # =cut
  
  sub should_index_package {
    my ($self, $package) = @_;
  
    for my $no_index_pkg (@{ $self->no_index->{package} || [] }) {
      return if $package eq $no_index_pkg;
    }
  
    for my $no_index_ns (@{ $self->no_index->{namespace} }) {
      return if index($package, "${no_index_ns}::") == 0;
    }
  
    return 1;
  }
  
  # =method features
  #
  #   my @feature_objects = $meta->features;
  #
  # This method returns a list of L<CPAN::Meta::Feature> objects, one for each
  # optional feature described by the distribution's metadata.
  #
  # =cut
  
  sub features {
    my ($self) = @_;
  
    my $opt_f = $self->optional_features;
    my @features = map {; CPAN::Meta::Feature->new($_ => $opt_f->{ $_ }) }
                   keys %$opt_f;
  
    return @features;
  }
  
  # =method feature
  #
  #   my $feature_object = $meta->feature( $identifier );
  #
  # This method returns a L<CPAN::Meta::Feature> object for the optional feature
  # with the given identifier.  If no feature with that identifier exists, an
  # exception will be raised.
  #
  # =cut
  
  sub feature {
    my ($self, $ident) = @_;
  
    croak "no feature named $ident"
      unless my $f = $self->optional_features->{ $ident };
  
    return CPAN::Meta::Feature->new($ident, $f);
  }
  
  # =method as_struct
  #
  #   my $copy = $meta->as_struct( \%options );
  #
  # This method returns a deep copy of the object's metadata as an unblessed hash
  # reference.  It takes an optional hashref of options.  If the hashref contains
  # a C<version> argument, the copied metadata will be converted to the version
  # of the specification and returned.  For example:
  #
  #   my $old_spec = $meta->as_struct( {version => "1.4"} );
  #
  # =cut
  
  sub as_struct {
    my ($self, $options) = @_;
    my $struct = _dclone($self);
    if ( $options->{version} ) {
      my $cmc = CPAN::Meta::Converter->new( $struct );
      $struct = $cmc->convert( version => $options->{version} );
    }
    return $struct;
  }
  
  # =method as_string
  #
  #   my $string = $meta->as_string( \%options );
  #
  # This method returns a serialized copy of the object's metadata as a character
  # string.  (The strings are B<not> UTF-8 encoded.)  It takes an optional hashref
  # of options.  If the hashref contains a C<version> argument, the copied metadata
  # will be converted to the version of the specification and returned.  For
  # example:
  #
  #   my $string = $meta->as_string( {version => "1.4"} );
  #
  # For C<version> greater than or equal to 2, the string will be serialized as
  # JSON.  For C<version> less than 2, the string will be serialized as YAML.  In
  # both cases, the same rules are followed as in the C<save()> method for choosing
  # a serialization backend.
  #
  # =cut
  
  sub as_string {
    my ($self, $options) = @_;
  
    my $version = $options->{version} || '2';
  
    my $struct;
    if ( $self->meta_spec_version ne $version ) {
      my $cmc = CPAN::Meta::Converter->new( $self->as_struct );
      $struct = $cmc->convert( version => $version );
    }
    else {
      $struct = $self->as_struct;
    }
  
    my ($data, $backend);
    if ( $version ge '2' ) {
      $backend = Parse::CPAN::Meta->json_backend();
      $data = $backend->new->pretty->canonical->encode($struct);
    }
    else {
      $backend = Parse::CPAN::Meta->yaml_backend();
      $data = eval { no strict 'refs'; &{"$backend\::Dump"}($struct) };
      if ( $@ ) {
        croak $backend->can('errstr') ? $backend->errstr : $@
      }
    }
  
    return $data;
  }
  
  # Used by JSON::PP, etc. for "convert_blessed"
  sub TO_JSON {
    return { %{ $_[0] } };
  }
  
  1;
  
  # ABSTRACT: the distribution metadata for a CPAN dist
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta - the distribution metadata for a CPAN dist
  
  =head1 VERSION
  
  version 2.140640
  
  =head1 SYNOPSIS
  
      use v5.10;
      use strict;
      use warnings;
      use CPAN::Meta;
      use Module::Load;
  
      my $meta = CPAN::Meta->load_file('META.json');
  
      printf "testing requirements for %s version %s\n",
      $meta->name,
      $meta->version;
  
      my $prereqs = $meta->effective_prereqs;
  
      for my $phase ( qw/configure runtime build test/ ) {
          say "Requirements for $phase:";
          my $reqs = $prereqs->requirements_for($phase, "requires");
          for my $module ( sort $reqs->required_modules ) {
              my $status;
              if ( eval { load $module unless $module eq 'perl'; 1 } ) {
                  my $version = $module eq 'perl' ? $] : $module->VERSION;
                  $status = $reqs->accepts_module($module, $version)
                          ? "$version ok" : "$version not ok";
              } else {
                  $status = "missing"
              };
              say "  $module ($status)";
          }
      }
  
  =head1 DESCRIPTION
  
  Software distributions released to the CPAN include a F<META.json> or, for
  older distributions, F<META.yml>, which describes the distribution, its
  contents, and the requirements for building and installing the distribution.
  The data structure stored in the F<META.json> file is described in
  L<CPAN::Meta::Spec>.
  
  CPAN::Meta provides a simple class to represent this distribution metadata (or
  I<distmeta>), along with some helpful methods for interrogating that data.
  
  The documentation below is only for the methods of the CPAN::Meta object.  For
  information on the meaning of individual fields, consult the spec.
  
  =head1 METHODS
  
  =head2 new
  
    my $meta = CPAN::Meta->new($distmeta_struct, \%options);
  
  Returns a valid CPAN::Meta object or dies if the supplied metadata hash
  reference fails to validate.  Older-format metadata will be up-converted to
  version 2 if they validate against the original stated specification.
  
  It takes an optional hashref of options. Valid options include:
  
  =over
  
  =item *
  
  lazy_validation -- if true, new will attempt to convert the given metadata
  to version 2 before attempting to validate it.  This means than any
  fixable errors will be handled by CPAN::Meta::Converter before validation.
  (Note that this might result in invalid optional data being silently
  dropped.)  The default is false.
  
  =back
  
  =head2 create
  
    my $meta = CPAN::Meta->create($distmeta_struct, \%options);
  
  This is same as C<new()>, except that C<generated_by> and C<meta-spec> fields
  will be generated if not provided.  This means the metadata structure is
  assumed to otherwise follow the latest L<CPAN::Meta::Spec>.
  
  =head2 load_file
  
    my $meta = CPAN::Meta->load_file($distmeta_file, \%options);
  
  Given a pathname to a file containing metadata, this deserializes the file
  according to its file suffix and constructs a new C<CPAN::Meta> object, just
  like C<new()>.  It will die if the deserialized version fails to validate
  against its stated specification version.
  
  It takes the same options as C<new()> but C<lazy_validation> defaults to
  true.
  
  =head2 load_yaml_string
  
    my $meta = CPAN::Meta->load_yaml_string($yaml, \%options);
  
  This method returns a new CPAN::Meta object using the first document in the
  given YAML string.  In other respects it is identical to C<load_file()>.
  
  =head2 load_json_string
  
    my $meta = CPAN::Meta->load_json_string($json, \%options);
  
  This method returns a new CPAN::Meta object using the structure represented by
  the given JSON string.  In other respects it is identical to C<load_file()>.
  
  =head2 load_string
  
    my $meta = CPAN::Meta->load_string($string, \%options);
  
  If you don't know if a string contains YAML or JSON, this method will use
  L<Parse::CPAN::Meta> to guess.  In other respects it is identical to
  C<load_file()>.
  
  =head2 save
  
    $meta->save($distmeta_file, \%options);
  
  Serializes the object as JSON and writes it to the given file.  The only valid
  option is C<version>, which defaults to '2'. On Perl 5.8.1 or later, the file
  is saved with UTF-8 encoding.
  
  For C<version> 2 (or higher), the filename should end in '.json'.  L<JSON::PP>
  is the default JSON backend. Using another JSON backend requires L<JSON> 2.5 or
  later and you must set the C<$ENV{PERL_JSON_BACKEND}> to a supported alternate
  backend like L<JSON::XS>.
  
  For C<version> less than 2, the filename should end in '.yml'.
  L<CPAN::Meta::Converter> is used to generate an older metadata structure, which
  is serialized to YAML.  CPAN::Meta::YAML is the default YAML backend.  You may
  set the C<$ENV{PERL_YAML_BACKEND}> to a supported alternative backend, though
  this is not recommended due to subtle incompatibilities between YAML parsers on
  CPAN.
  
  =head2 meta_spec_version
  
  This method returns the version part of the C<meta_spec> entry in the distmeta
  structure.  It is equivalent to:
  
    $meta->meta_spec->{version};
  
  =head2 effective_prereqs
  
    my $prereqs = $meta->effective_prereqs;
  
    my $prereqs = $meta->effective_prereqs( \@feature_identifiers );
  
  This method returns a L<CPAN::Meta::Prereqs> object describing all the
  prereqs for the distribution.  If an arrayref of feature identifiers is given,
  the prereqs for the identified features are merged together with the
  distribution's core prereqs before the CPAN::Meta::Prereqs object is returned.
  
  =head2 should_index_file
  
    ... if $meta->should_index_file( $filename );
  
  This method returns true if the given file should be indexed.  It decides this
  by checking the C<file> and C<directory> keys in the C<no_index> property of
  the distmeta structure.
  
  C<$filename> should be given in unix format.
  
  =head2 should_index_package
  
    ... if $meta->should_index_package( $package );
  
  This method returns true if the given package should be indexed.  It decides
  this by checking the C<package> and C<namespace> keys in the C<no_index>
  property of the distmeta structure.
  
  =head2 features
  
    my @feature_objects = $meta->features;
  
  This method returns a list of L<CPAN::Meta::Feature> objects, one for each
  optional feature described by the distribution's metadata.
  
  =head2 feature
  
    my $feature_object = $meta->feature( $identifier );
  
  This method returns a L<CPAN::Meta::Feature> object for the optional feature
  with the given identifier.  If no feature with that identifier exists, an
  exception will be raised.
  
  =head2 as_struct
  
    my $copy = $meta->as_struct( \%options );
  
  This method returns a deep copy of the object's metadata as an unblessed hash
  reference.  It takes an optional hashref of options.  If the hashref contains
  a C<version> argument, the copied metadata will be converted to the version
  of the specification and returned.  For example:
  
    my $old_spec = $meta->as_struct( {version => "1.4"} );
  
  =head2 as_string
  
    my $string = $meta->as_string( \%options );
  
  This method returns a serialized copy of the object's metadata as a character
  string.  (The strings are B<not> UTF-8 encoded.)  It takes an optional hashref
  of options.  If the hashref contains a C<version> argument, the copied metadata
  will be converted to the version of the specification and returned.  For
  example:
  
    my $string = $meta->as_string( {version => "1.4"} );
  
  For C<version> greater than or equal to 2, the string will be serialized as
  JSON.  For C<version> less than 2, the string will be serialized as YAML.  In
  both cases, the same rules are followed as in the C<save()> method for choosing
  a serialization backend.
  
  =head1 STRING DATA
  
  The following methods return a single value, which is the value for the
  corresponding entry in the distmeta structure.  Values should be either undef
  or strings.
  
  =over 4
  
  =item *
  
  abstract
  
  =item *
  
  description
  
  =item *
  
  dynamic_config
  
  =item *
  
  generated_by
  
  =item *
  
  name
  
  =item *
  
  release_status
  
  =item *
  
  version
  
  =back
  
  =head1 LIST DATA
  
  These methods return lists of string values, which might be represented in the
  distmeta structure as arrayrefs or scalars:
  
  =over 4
  
  =item *
  
  authors
  
  =item *
  
  keywords
  
  =item *
  
  licenses
  
  =back
  
  The C<authors> and C<licenses> methods may also be called as C<author> and
  C<license>, respectively, to match the field name in the distmeta structure.
  
  =head1 MAP DATA
  
  These readers return hashrefs of arbitrary unblessed data structures, each
  described more fully in the specification:
  
  =over 4
  
  =item *
  
  meta_spec
  
  =item *
  
  resources
  
  =item *
  
  provides
  
  =item *
  
  no_index
  
  =item *
  
  prereqs
  
  =item *
  
  optional_features
  
  =back
  
  =head1 CUSTOM DATA
  
  A list of custom keys are available from the C<custom_keys> method and
  particular keys may be retrieved with the C<custom> method.
  
    say $meta->custom($_) for $meta->custom_keys;
  
  If a custom key refers to a data structure, a deep clone is returned.
  
  =for Pod::Coverage TO_JSON abstract author authors custom custom_keys description dynamic_config
  generated_by keywords license licenses meta_spec name no_index
  optional_features prereqs provides release_status resources version
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<CPAN::Meta::Converter>
  
  =item *
  
  L<CPAN::Meta::Validator>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/Perl-Toolchain-Gang/CPAN-Meta/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/Perl-Toolchain-Gang/CPAN-Meta>
  
    git clone https://github.com/Perl-Toolchain-Gang/CPAN-Meta.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Ansgar Burchardt <ansgar@cpan.org>
  
  =item *
  
  Avar Arnfjord Bjarmason <avar@cpan.org>
  
  =item *
  
  Christopher J. Madsen <cjm@cpan.org>
  
  =item *
  
  Chuck Adams <cja987@gmail.com>
  
  =item *
  
  Cory G Watson <gphat@cpan.org>
  
  =item *
  
  Damyan Ivanov <dam@cpan.org>
  
  =item *
  
  Eric Wilhelm <ewilhelm@cpan.org>
  
  =item *
  
  Gregor Hermann <gregoa@debian.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Ken Williams <kwilliams@cpan.org>
  
  =item *
  
  Kenichi Ishigaki <ishigaki@cpan.org>
  
  =item *
  
  Lars Dieckow <daxim@cpan.org>
  
  =item *
  
  Leon Timmermans <leont@cpan.org>
  
  =item *
  
  Mark Fowler <markf@cpan.org>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Olivier Mengue <dolmen@cpan.org>
  
  =item *
  
  Randy Sims <randys@thepierianspring.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden and Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META

$fatpacked{"CPAN/Meta/Converter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CONVERTER';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Converter;
  our $VERSION = '2.140640'; # VERSION
  
  # =head1 SYNOPSIS
  #
  #   my $struct = decode_json_file('META.json');
  #
  #   my $cmc = CPAN::Meta::Converter->new( $struct );
  #
  #   my $new_struct = $cmc->convert( version => "2" );
  #
  # =head1 DESCRIPTION
  #
  # This module converts CPAN Meta structures from one form to another.  The
  # primary use is to convert older structures to the most modern version of
  # the specification, but other transformations may be implemented in the
  # future as needed.  (E.g. stripping all custom fields or stripping all
  # optional fields.)
  #
  # =cut
  
  use CPAN::Meta::Validator;
  use CPAN::Meta::Requirements;
  use version 0.88 ();
  use Parse::CPAN::Meta 1.4400 ();
  use List::Util 1.33 qw/all/;
  
  sub _dclone {
    my $ref = shift;
  
    # if an object is in the data structure and doesn't specify how to
    # turn itself into JSON, we just stringify the object.  That does the
    # right thing for typical things that might be there, like version objects,
    # Path::Class objects, etc.
    no warnings 'once';
    local *UNIVERSAL::TO_JSON = sub { return "$_[0]" };
  
    my $backend = Parse::CPAN::Meta->json_backend();
    return $backend->new->utf8->decode(
      $backend->new->utf8->allow_blessed->convert_blessed->encode($ref)
    );
  }
  
  my %known_specs = (
      '2'   => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
      '1.4' => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
      '1.3' => 'http://module-build.sourceforge.net/META-spec-v1.3.html',
      '1.2' => 'http://module-build.sourceforge.net/META-spec-v1.2.html',
      '1.1' => 'http://module-build.sourceforge.net/META-spec-v1.1.html',
      '1.0' => 'http://module-build.sourceforge.net/META-spec-v1.0.html'
  );
  
  my @spec_list = sort { $a <=> $b } keys %known_specs;
  my ($LOWEST, $HIGHEST) = @spec_list[0,-1];
  
  #--------------------------------------------------------------------------#
  # converters
  #
  # called as $converter->($element, $field_name, $full_meta, $to_version)
  #
  # defined return value used for field
  # undef return value means field is skipped
  #--------------------------------------------------------------------------#
  
  sub _keep { $_[0] }
  
  sub _keep_or_one { defined($_[0]) ? $_[0] : 1 }
  
  sub _keep_or_zero { defined($_[0]) ? $_[0] : 0 }
  
  sub _keep_or_unknown { defined($_[0]) && length($_[0]) ? $_[0] : "unknown" }
  
  sub _generated_by {
    my $gen = shift;
    my $sig = __PACKAGE__ . " version " . (__PACKAGE__->VERSION || "<dev>");
  
    return $sig unless defined $gen and length $gen;
    return $gen if $gen =~ /\Q$sig/;
    return "$gen, $sig";
  }
  
  sub _listify { ! defined $_[0] ? undef : ref $_[0] eq 'ARRAY' ? $_[0] : [$_[0]] }
  
  sub _prefix_custom {
    my $key = shift;
    $key =~ s/^(?!x_)   # Unless it already starts with x_
               (?:x-?)? # Remove leading x- or x (if present)
             /x_/ix;    # and prepend x_
    return $key;
  }
  
  sub _ucfirst_custom {
    my $key = shift;
    $key = ucfirst $key unless $key =~ /[A-Z]/;
    return $key;
  }
  
  sub _no_prefix_ucfirst_custom {
    my $key = shift;
    $key =~ s/^x_//;
    return _ucfirst_custom($key);
  }
  
  sub _change_meta_spec {
    my ($element, undef, undef, $version) = @_;
    return {
      version => $version,
      url => $known_specs{$version},
    };
  }
  
  my @open_source = (
    'perl',
    'gpl',
    'apache',
    'artistic',
    'artistic_2',
    'lgpl',
    'bsd',
    'gpl',
    'mit',
    'mozilla',
    'open_source',
  );
  
  my %is_open_source = map {; $_ => 1 } @open_source;
  
  my @valid_licenses_1 = (
    @open_source,
    'unrestricted',
    'restrictive',
    'unknown',
  );
  
  my %license_map_1 = (
    ( map { $_ => $_ } @valid_licenses_1 ),
    artistic2 => 'artistic_2',
  );
  
  sub _license_1 {
    my ($element) = @_;
    return 'unknown' unless defined $element;
    if ( $license_map_1{lc $element} ) {
      return $license_map_1{lc $element};
    }
    else {
      return 'unknown';
    }
  }
  
  my @valid_licenses_2 = qw(
    agpl_3
    apache_1_1
    apache_2_0
    artistic_1
    artistic_2
    bsd
    freebsd
    gfdl_1_2
    gfdl_1_3
    gpl_1
    gpl_2
    gpl_3
    lgpl_2_1
    lgpl_3_0
    mit
    mozilla_1_0
    mozilla_1_1
    openssl
    perl_5
    qpl_1_0
    ssleay
    sun
    zlib
    open_source
    restricted
    unrestricted
    unknown
  );
  
  # The "old" values were defined by Module::Build, and were often vague.  I have
  # made the decisions below based on reading Module::Build::API and how clearly
  # it specifies the version of the license.
  my %license_map_2 = (
    (map { $_ => $_ } @valid_licenses_2),
    apache      => 'apache_2_0',  # clearly stated as 2.0
    artistic    => 'artistic_1',  # clearly stated as 1
    artistic2   => 'artistic_2',  # clearly stated as 2
    gpl         => 'open_source', # we don't know which GPL; punt
    lgpl        => 'open_source', # we don't know which LGPL; punt
    mozilla     => 'open_source', # we don't know which MPL; punt
    perl        => 'perl_5',      # clearly Perl 5
    restrictive => 'restricted',
  );
  
  sub _license_2 {
    my ($element) = @_;
    return [ 'unknown' ] unless defined $element;
    $element = [ $element ] unless ref $element eq 'ARRAY';
    my @new_list;
    for my $lic ( @$element ) {
      next unless defined $lic;
      if ( my $new = $license_map_2{lc $lic} ) {
        push @new_list, $new;
      }
    }
    return @new_list ? \@new_list : [ 'unknown' ];
  }
  
  my %license_downgrade_map = qw(
    agpl_3            open_source
    apache_1_1        apache
    apache_2_0        apache
    artistic_1        artistic
    artistic_2        artistic_2
    bsd               bsd
    freebsd           open_source
    gfdl_1_2          open_source
    gfdl_1_3          open_source
    gpl_1             gpl
    gpl_2             gpl
    gpl_3             gpl
    lgpl_2_1          lgpl
    lgpl_3_0          lgpl
    mit               mit
    mozilla_1_0       mozilla
    mozilla_1_1       mozilla
    openssl           open_source
    perl_5            perl
    qpl_1_0           open_source
    ssleay            open_source
    sun               open_source
    zlib              open_source
    open_source       open_source
    restricted        restrictive
    unrestricted      unrestricted
    unknown           unknown
  );
  
  sub _downgrade_license {
    my ($element) = @_;
    if ( ! defined $element ) {
      return "unknown";
    }
    elsif( ref $element eq 'ARRAY' ) {
      if ( @$element > 1) {
        if ( all { $is_open_source{ $license_downgrade_map{lc $_} || 'unknown' } } @$element ) {
          return 'open_source';
        }
        else {
          return 'unknown';
        }
      }
      elsif ( @$element == 1 ) {
        return $license_downgrade_map{lc $element->[0]} || "unknown";
      }
    }
    elsif ( ! ref $element ) {
      return $license_downgrade_map{lc $element} || "unknown";
    }
    return "unknown";
  }
  
  my $no_index_spec_1_2 = {
    'file' => \&_listify,
    'dir' => \&_listify,
    'package' => \&_listify,
    'namespace' => \&_listify,
  };
  
  my $no_index_spec_1_3 = {
    'file' => \&_listify,
    'directory' => \&_listify,
    'package' => \&_listify,
    'namespace' => \&_listify,
  };
  
  my $no_index_spec_2 = {
    'file' => \&_listify,
    'directory' => \&_listify,
    'package' => \&_listify,
    'namespace' => \&_listify,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _no_index_1_2 {
    my (undef, undef, $meta) = @_;
    my $no_index = $meta->{no_index} || $meta->{private};
    return unless $no_index;
  
    # cleanup wrong format
    if ( ! ref $no_index ) {
      my $item = $no_index;
      $no_index = { dir => [ $item ], file => [ $item ] };
    }
    elsif ( ref $no_index eq 'ARRAY' ) {
      my $list = $no_index;
      $no_index = { dir => [ @$list ], file => [ @$list ] };
    }
  
    # common mistake: files -> file
    if ( exists $no_index->{files} ) {
      $no_index->{file} = delete $no_index->{file};
    }
    # common mistake: modules -> module
    if ( exists $no_index->{modules} ) {
      $no_index->{module} = delete $no_index->{module};
    }
    return _convert($no_index, $no_index_spec_1_2);
  }
  
  sub _no_index_directory {
    my ($element, $key, $meta, $version) = @_;
    return unless $element;
  
    # cleanup wrong format
    if ( ! ref $element ) {
      my $item = $element;
      $element = { directory => [ $item ], file => [ $item ] };
    }
    elsif ( ref $element eq 'ARRAY' ) {
      my $list = $element;
      $element = { directory => [ @$list ], file => [ @$list ] };
    }
  
    if ( exists $element->{dir} ) {
      $element->{directory} = delete $element->{dir};
    }
    # common mistake: files -> file
    if ( exists $element->{files} ) {
      $element->{file} = delete $element->{file};
    }
    # common mistake: modules -> module
    if ( exists $element->{modules} ) {
      $element->{module} = delete $element->{module};
    }
    my $spec = $version == 2 ? $no_index_spec_2 : $no_index_spec_1_3;
    return _convert($element, $spec);
  }
  
  sub _is_module_name {
    my $mod = shift;
    return unless defined $mod && length $mod;
    return $mod =~ m{^[A-Za-z][A-Za-z0-9_]*(?:::[A-Za-z0-9_]+)*$};
  }
  
  sub _clean_version {
    my ($element) = @_;
    return 0 if ! defined $element;
  
    $element =~ s{^\s*}{};
    $element =~ s{\s*$}{};
    $element =~ s{^\.}{0.};
  
    return 0 if ! length $element;
    return 0 if ( $element eq 'undef' || $element eq '<undef>' );
  
    my $v = eval { version->new($element) };
    # XXX check defined $v and not just $v because version objects leak memory
    # in boolean context -- dagolden, 2012-02-03
    if ( defined $v ) {
      return $v->is_qv ? $v->normal : $element;
    }
    else {
      return 0;
    }
  }
  
  sub _bad_version_hook {
    my ($v) = @_;
    $v =~ s{[a-z]+$}{}; # strip trailing alphabetics
    my $vobj = eval { version->parse($v) };
    return defined($vobj) ? $vobj : version->parse(0); # or give up
  }
  
  sub _version_map {
    my ($element) = @_;
    return unless defined $element;
    if ( ref $element eq 'HASH' ) {
      # XXX turn this into CPAN::Meta::Requirements with bad version hook
      # and then turn it back into a hash
      my $new_map = CPAN::Meta::Requirements->new(
        { bad_version_hook => \&_bad_version_hook } # punt
      );
      while ( my ($k,$v) = each %$element ) {
        next unless _is_module_name($k);
        if ( !defined($v) || !length($v) || $v eq 'undef' || $v eq '<undef>'  ) {
          $v = 0;
        }
        # some weird, old META have bad yml with module => module
        # so check if value is like a module name and not like a version
        if ( _is_module_name($v) && ! version::is_lax($v) ) {
          $new_map->add_minimum($k => 0);
          $new_map->add_minimum($v => 0);
        }
        $new_map->add_string_requirement($k => $v);
      }
      return $new_map->as_string_hash;
    }
    elsif ( ref $element eq 'ARRAY' ) {
      my $hashref = { map { $_ => 0 } @$element };
      return _version_map($hashref); # cleanup any weird stuff
    }
    elsif ( ref $element eq '' && length $element ) {
      return { $element => 0 }
    }
    return;
  }
  
  sub _prereqs_from_1 {
    my (undef, undef, $meta) = @_;
    my $prereqs = {};
    for my $phase ( qw/build configure/ ) {
      my $key = "${phase}_requires";
      $prereqs->{$phase}{requires} = _version_map($meta->{$key})
        if $meta->{$key};
    }
    for my $rel ( qw/requires recommends conflicts/ ) {
      $prereqs->{runtime}{$rel} = _version_map($meta->{$rel})
        if $meta->{$rel};
    }
    return $prereqs;
  }
  
  my $prereqs_spec = {
    configure => \&_prereqs_rel,
    build     => \&_prereqs_rel,
    test      => \&_prereqs_rel,
    runtime   => \&_prereqs_rel,
    develop   => \&_prereqs_rel,
    ':custom'  => \&_prefix_custom,
  };
  
  my $relation_spec = {
    requires   => \&_version_map,
    recommends => \&_version_map,
    suggests   => \&_version_map,
    conflicts  => \&_version_map,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _cleanup_prereqs {
    my ($prereqs, $key, $meta, $to_version) = @_;
    return unless $prereqs && ref $prereqs eq 'HASH';
    return _convert( $prereqs, $prereqs_spec, $to_version );
  }
  
  sub _prereqs_rel {
    my ($relation, $key, $meta, $to_version) = @_;
    return unless $relation && ref $relation eq 'HASH';
    return _convert( $relation, $relation_spec, $to_version );
  }
  
  
  BEGIN {
    my @old_prereqs = qw(
      requires
      configure_requires
      recommends
      conflicts
    );
  
    for ( @old_prereqs ) {
      my $sub = "_get_$_";
      my ($phase,$type) = split qr/_/, $_;
      if ( ! defined $type ) {
        $type = $phase;
        $phase = 'runtime';
      }
      no strict 'refs';
      *{$sub} = sub { _extract_prereqs($_[2]->{prereqs},$phase,$type) };
    }
  }
  
  sub _get_build_requires {
    my ($data, $key, $meta) = @_;
  
    my $test_h  = _extract_prereqs($_[2]->{prereqs}, qw(test  requires)) || {};
    my $build_h = _extract_prereqs($_[2]->{prereqs}, qw(build requires)) || {};
  
    my $test_req  = CPAN::Meta::Requirements->from_string_hash($test_h);
    my $build_req = CPAN::Meta::Requirements->from_string_hash($build_h);
  
    $test_req->add_requirements($build_req)->as_string_hash;
  }
  
  sub _extract_prereqs {
    my ($prereqs, $phase, $type) = @_;
    return unless ref $prereqs eq 'HASH';
    return scalar _version_map($prereqs->{$phase}{$type});
  }
  
  sub _downgrade_optional_features {
    my (undef, undef, $meta) = @_;
    return unless exists $meta->{optional_features};
    my $origin = $meta->{optional_features};
    my $features = {};
    for my $name ( keys %$origin ) {
      $features->{$name} = {
        description => $origin->{$name}{description},
        requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','requires'),
        configure_requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','configure_requires'),
        build_requires => _extract_prereqs($origin->{$name}{prereqs},'runtime','build_requires'),
        recommends => _extract_prereqs($origin->{$name}{prereqs},'runtime','recommends'),
        conflicts => _extract_prereqs($origin->{$name}{prereqs},'runtime','conflicts'),
      };
      for my $k (keys %{$features->{$name}} ) {
        delete $features->{$name}{$k} unless defined $features->{$name}{$k};
      }
    }
    return $features;
  }
  
  sub _upgrade_optional_features {
    my (undef, undef, $meta) = @_;
    return unless exists $meta->{optional_features};
    my $origin = $meta->{optional_features};
    my $features = {};
    for my $name ( keys %$origin ) {
      $features->{$name} = {
        description => $origin->{$name}{description},
        prereqs => _prereqs_from_1(undef, undef, $origin->{$name}),
      };
      delete $features->{$name}{prereqs}{configure};
    }
    return $features;
  }
  
  my $optional_features_2_spec = {
    description => \&_keep,
    prereqs => \&_cleanup_prereqs,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _feature_2 {
    my ($element, $key, $meta, $to_version) = @_;
    return unless $element && ref $element eq 'HASH';
    _convert( $element, $optional_features_2_spec, $to_version );
  }
  
  sub _cleanup_optional_features_2 {
    my ($element, $key, $meta, $to_version) = @_;
    return unless $element && ref $element eq 'HASH';
    my $new_data = {};
    for my $k ( keys %$element ) {
      $new_data->{$k} = _feature_2( $element->{$k}, $k, $meta, $to_version );
    }
    return unless keys %$new_data;
    return $new_data;
  }
  
  sub _optional_features_1_4 {
    my ($element) = @_;
    return unless $element;
    $element = _optional_features_as_map($element);
    for my $name ( keys %$element ) {
      for my $drop ( qw/requires_packages requires_os excluded_os/ ) {
        delete $element->{$name}{$drop};
      }
    }
    return $element;
  }
  
  sub _optional_features_as_map {
    my ($element) = @_;
    return unless $element;
    if ( ref $element eq 'ARRAY' ) {
      my %map;
      for my $feature ( @$element ) {
        my (@parts) = %$feature;
        $map{$parts[0]} = $parts[1];
      }
      $element = \%map;
    }
    return $element;
  }
  
  sub _is_urlish { defined $_[0] && $_[0] =~ m{\A[-+.a-z0-9]+:.+}i }
  
  sub _url_or_drop {
    my ($element) = @_;
    return $element if _is_urlish($element);
    return;
  }
  
  sub _url_list {
    my ($element) = @_;
    return unless $element;
    $element = _listify( $element );
    $element = [ grep { _is_urlish($_) } @$element ];
    return unless @$element;
    return $element;
  }
  
  sub _author_list {
    my ($element) = @_;
    return [ 'unknown' ] unless $element;
    $element = _listify( $element );
    $element = [ map { defined $_ && length $_ ? $_ : 'unknown' } @$element ];
    return [ 'unknown' ] unless @$element;
    return $element;
  }
  
  my $resource2_upgrade = {
    license    => sub { return _is_urlish($_[0]) ? _listify( $_[0] ) : undef },
    homepage   => \&_url_or_drop,
    bugtracker => sub {
      my ($item) = @_;
      return unless $item;
      if ( $item =~ m{^mailto:(.*)$} ) { return { mailto => $1 } }
      elsif( _is_urlish($item) ) { return { web => $item } }
      else { return }
    },
    repository => sub { return _is_urlish($_[0]) ? { url => $_[0] } : undef },
    ':custom'  => \&_prefix_custom,
  };
  
  sub _upgrade_resources_2 {
    my (undef, undef, $meta, $version) = @_;
    return unless exists $meta->{resources};
    return _convert($meta->{resources}, $resource2_upgrade);
  }
  
  my $bugtracker2_spec = {
    web => \&_url_or_drop,
    mailto => \&_keep,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _repo_type {
    my ($element, $key, $meta, $to_version) = @_;
    return $element if defined $element;
    return unless exists $meta->{url};
    my $repo_url = $meta->{url};
    for my $type ( qw/git svn/ ) {
      return $type if $repo_url =~ m{\A$type};
    }
    return;
  }
  
  my $repository2_spec = {
    web => \&_url_or_drop,
    url => \&_url_or_drop,
    type => \&_repo_type,
    ':custom'  => \&_prefix_custom,
  };
  
  my $resources2_cleanup = {
    license    => \&_url_list,
    homepage   => \&_url_or_drop,
    bugtracker => sub { ref $_[0] ? _convert( $_[0], $bugtracker2_spec ) : undef },
    repository => sub { my $data = shift; ref $data ? _convert( $data, $repository2_spec ) : undef },
    ':custom'  => \&_prefix_custom,
  };
  
  sub _cleanup_resources_2 {
    my ($resources, $key, $meta, $to_version) = @_;
    return unless $resources && ref $resources eq 'HASH';
    return _convert($resources, $resources2_cleanup, $to_version);
  }
  
  my $resource1_spec = {
    license    => \&_url_or_drop,
    homepage   => \&_url_or_drop,
    bugtracker => \&_url_or_drop,
    repository => \&_url_or_drop,
    ':custom'  => \&_keep,
  };
  
  sub _resources_1_3 {
    my (undef, undef, $meta, $version) = @_;
    return unless exists $meta->{resources};
    return _convert($meta->{resources}, $resource1_spec);
  }
  
  *_resources_1_4 = *_resources_1_3;
  
  sub _resources_1_2 {
    my (undef, undef, $meta) = @_;
    my $resources = $meta->{resources} || {};
    if ( $meta->{license_url} && ! $resources->{license} ) {
      $resources->{license} = $meta->license_url
        if _is_urlish($meta->{license_url});
    }
    return unless keys %$resources;
    return _convert($resources, $resource1_spec);
  }
  
  my $resource_downgrade_spec = {
    license    => sub { return ref $_[0] ? $_[0]->[0] : $_[0] },
    homepage   => \&_url_or_drop,
    bugtracker => sub { return $_[0]->{web} },
    repository => sub { return $_[0]->{url} || $_[0]->{web} },
    ':custom'  => \&_no_prefix_ucfirst_custom,
  };
  
  sub _downgrade_resources {
    my (undef, undef, $meta, $version) = @_;
    return unless exists $meta->{resources};
    return _convert($meta->{resources}, $resource_downgrade_spec);
  }
  
  sub _release_status {
    my ($element, undef, $meta) = @_;
    return $element if $element && $element =~ m{\A(?:stable|testing|unstable)\z};
    return _release_status_from_version(undef, undef, $meta);
  }
  
  sub _release_status_from_version {
    my (undef, undef, $meta) = @_;
    my $version = $meta->{version} || '';
    return ( $version =~ /_/ ) ? 'testing' : 'stable';
  }
  
  my $provides_spec = {
    file => \&_keep,
    version => \&_keep,
  };
  
  my $provides_spec_2 = {
    file => \&_keep,
    version => \&_keep,
    ':custom'  => \&_prefix_custom,
  };
  
  sub _provides {
    my ($element, $key, $meta, $to_version) = @_;
    return unless defined $element && ref $element eq 'HASH';
    my $spec = $to_version == 2 ? $provides_spec_2 : $provides_spec;
    my $new_data = {};
    for my $k ( keys %$element ) {
      $new_data->{$k} = _convert($element->{$k}, $spec, $to_version);
      $new_data->{$k}{version} = _clean_version($element->{$k}{version})
        if exists $element->{$k}{version};
    }
    return $new_data;
  }
  
  sub _convert {
    my ($data, $spec, $to_version) = @_;
  
    my $new_data = {};
    for my $key ( keys %$spec ) {
      next if $key eq ':custom' || $key eq ':drop';
      next unless my $fcn = $spec->{$key};
      die "spec for '$key' is not a coderef"
        unless ref $fcn && ref $fcn eq 'CODE';
      my $new_value = $fcn->($data->{$key}, $key, $data, $to_version);
      $new_data->{$key} = $new_value if defined $new_value;
    }
  
    my $drop_list   = $spec->{':drop'};
    my $customizer  = $spec->{':custom'} || \&_keep;
  
    for my $key ( keys %$data ) {
      next if $drop_list && grep { $key eq $_ } @$drop_list;
      next if exists $spec->{$key}; # we handled it
      $new_data->{ $customizer->($key) } = $data->{$key};
    }
  
    return $new_data;
  }
  
  #--------------------------------------------------------------------------#
  # define converters for each conversion
  #--------------------------------------------------------------------------#
  
  # each converts from prior version
  # special ":custom" field is used for keys not recognized in spec
  my %up_convert = (
    '2-from-1.4' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_2,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # CHANGED TO MANDATORY
      'dynamic_config'      => \&_keep_or_one,
      # ADDED MANDATORY
      'release_status'      => \&_release_status_from_version,
      # PRIOR OPTIONAL
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_upgrade_optional_features,
      'provides'            => \&_provides,
      'resources'           => \&_upgrade_resources_2,
      # ADDED OPTIONAL
      'description'         => \&_keep,
      'prereqs'             => \&_prereqs_from_1,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
          build_requires
          configure_requires
          conflicts
          distribution_type
          license_url
          private
          recommends
          requires
      ) ],
  
      # other random keys need x_ prefixing
      ':custom'              => \&_prefix_custom,
    },
    '1.4-from-1.3' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_1_4,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_4,
      # ADDED OPTIONAL
      'configure_requires'  => \&_keep,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
        license_url
        private
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep
    },
    '1.3-from-1.2' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_3,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
        license_url
        private
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep
    },
    '1.2-from-1.1' => {
      # PRIOR MANDATORY
      'version'             => \&_keep,
      # CHANGED TO MANDATORY
      'license'             => \&_license_1,
      'name'                => \&_keep,
      'generated_by'        => \&_generated_by,
      # ADDED MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'meta-spec'           => \&_change_meta_spec,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      # ADDED OPTIONAL
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_1_2,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'resources'           => \&_resources_1_2,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
        license_url
        private
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep
    },
    '1.1-from-1.0' => {
      # CHANGED TO MANDATORY
      'version'             => \&_keep,
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      # ADDED OPTIONAL
      'license_url'         => \&_url_or_drop,
      'private'             => \&_keep,
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep
    },
  );
  
  my %down_convert = (
    '1.4-from-2' => {
      # MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_downgrade_license,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # OPTIONAL
      'build_requires'      => \&_get_build_requires,
      'configure_requires'  => \&_get_configure_requires,
      'conflicts'           => \&_get_conflicts,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_downgrade_optional_features,
      'provides'            => \&_provides,
      'recommends'          => \&_get_recommends,
      'requires'            => \&_get_requires,
      'resources'           => \&_downgrade_resources,
  
      # drop these unsupported fields (after conversion)
      ':drop' => [ qw(
        description
        prereqs
        release_status
      )],
  
      # custom keys will be left unchanged
      ':custom'              => \&_keep
    },
    '1.3-from-1.4' => {
      # MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_3,
  
      # drop these unsupported fields, but only after we convert
      ':drop' => [ qw(
        configure_requires
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep,
    },
    '1.2-from-1.3' => {
      # MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_1_2,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_3,
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep,
    },
    '1.1-from-1.2' => {
      # MANDATORY
      'version'             => \&_keep,
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      'meta-spec'           => \&_change_meta_spec,
      # OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'private'             => \&_keep,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
  
      # drop unsupported fields
      ':drop' => [ qw(
        abstract
        author
        provides
        no_index
        keywords
        resources
      )],
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep,
    },
    '1.0-from-1.1' => {
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      'meta-spec'           => \&_change_meta_spec,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
  
      # other random keys are OK if already valid
      ':custom'              => \&_keep,
    },
  );
  
  my %cleanup = (
    '2' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_2,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # CHANGED TO MANDATORY
      'dynamic_config'      => \&_keep_or_one,
      # ADDED MANDATORY
      'release_status'      => \&_release_status,
      # PRIOR OPTIONAL
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_cleanup_optional_features_2,
      'provides'            => \&_provides,
      'resources'           => \&_cleanup_resources_2,
      # ADDED OPTIONAL
      'description'         => \&_keep,
      'prereqs'             => \&_cleanup_prereqs,
  
      # drop these deprecated fields, but only after we convert
      ':drop' => [ qw(
          build_requires
          configure_requires
          conflicts
          distribution_type
          license_url
          private
          recommends
          requires
      ) ],
  
      # other random keys need x_ prefixing
      ':custom'              => \&_prefix_custom,
    },
    '1.4' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_1_4,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_4,
      # ADDED OPTIONAL
      'configure_requires'  => \&_keep,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep
    },
    '1.3' => {
      # PRIOR MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'meta-spec'           => \&_change_meta_spec,
      'name'                => \&_keep,
      'version'             => \&_keep,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_directory,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      'resources'           => \&_resources_1_3,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep
    },
    '1.2' => {
      # PRIOR MANDATORY
      'version'             => \&_keep,
      # CHANGED TO MANDATORY
      'license'             => \&_license_1,
      'name'                => \&_keep,
      'generated_by'        => \&_generated_by,
      # ADDED MANDATORY
      'abstract'            => \&_keep_or_unknown,
      'author'              => \&_author_list,
      'meta-spec'           => \&_change_meta_spec,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      # ADDED OPTIONAL
      'keywords'            => \&_keep,
      'no_index'            => \&_no_index_1_2,
      'optional_features'   => \&_optional_features_as_map,
      'provides'            => \&_provides,
      'resources'           => \&_resources_1_2,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep
    },
    '1.1' => {
      # CHANGED TO MANDATORY
      'version'             => \&_keep,
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      'meta-spec'           => \&_change_meta_spec,
      # PRIOR OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
      # ADDED OPTIONAL
      'license_url'         => \&_url_or_drop,
      'private'             => \&_keep,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep
    },
    '1.0' => {
      # IMPLIED MANDATORY
      'name'                => \&_keep,
      'meta-spec'           => \&_change_meta_spec,
      'version'             => \&_keep,
      # IMPLIED OPTIONAL
      'build_requires'      => \&_version_map,
      'conflicts'           => \&_version_map,
      'distribution_type'   => \&_keep,
      'dynamic_config'      => \&_keep_or_one,
      'generated_by'        => \&_generated_by,
      'license'             => \&_license_1,
      'recommends'          => \&_version_map,
      'requires'            => \&_version_map,
  
      # other random keys are OK if already valid
      ':custom'             => \&_keep,
    },
  );
  
  #--------------------------------------------------------------------------#
  # Code
  #--------------------------------------------------------------------------#
  
  # =method new
  #
  #   my $cmc = CPAN::Meta::Converter->new( $struct );
  #
  # The constructor should be passed a valid metadata structure but invalid
  # structures are accepted.  If no meta-spec version is provided, version 1.0 will
  # be assumed.
  #
  # =cut
  
  sub new {
    my ($class,$data) = @_;
  
    # create an attributes hash
    my $self = {
      'data'    => $data,
      'spec'    => _extract_spec_version($data),
    };
  
    # create the object
    return bless $self, $class;
  }
  
  sub _extract_spec_version {
      my ($data) = @_;
      my $spec = $data->{'meta-spec'};
  
      # is meta-spec there and valid?
      return "1.0" unless defined $spec && ref $spec eq 'HASH'; # before meta-spec?
  
      # does the version key look like a valid version?
      my $v = $spec->{version};
      if ( defined $v && $v =~ /^\d+(?:\.\d+)?$/ ) {
          return $v if defined $v && grep { $v eq $_ } keys %known_specs; # known spec
          return $v+0 if defined $v && grep { $v == $_ } keys %known_specs; # 2.0 => 2
      }
  
      # otherwise, use heuristics: look for 1.x vs 2.0 fields
      return "2" if exists $data->{prereqs};
      return "1.4" if exists $data->{configure_requires};
      return "1.2"; # when meta-spec was first defined
  }
  
  # =method convert
  #
  #   my $new_struct = $cmc->convert( version => "2" );
  #
  # Returns a new hash reference with the metadata converted to a different form.
  # C<convert> will die if any conversion/standardization still results in an
  # invalid structure.
  #
  # Valid parameters include:
  #
  # =over
  #
  # =item *
  #
  # C<version> -- Indicates the desired specification version (e.g. "1.0", "1.1" ... "1.4", "2").
  # Defaults to the latest version of the CPAN Meta Spec.
  #
  # =back
  #
  # Conversion proceeds through each version in turn.  For example, a version 1.2
  # structure might be converted to 1.3 then 1.4 then finally to version 2. The
  # conversion process attempts to clean-up simple errors and standardize data.
  # For example, if C<author> is given as a scalar, it will converted to an array
  # reference containing the item. (Converting a structure to its own version will
  # also clean-up and standardize.)
  #
  # When data are cleaned and standardized, missing or invalid fields will be
  # replaced with sensible defaults when possible.  This may be lossy or imprecise.
  # For example, some badly structured META.yml files on CPAN have prerequisite
  # modules listed as both keys and values:
  #
  #   requires => { 'Foo::Bar' => 'Bam::Baz' }
  #
  # These would be split and each converted to a prerequisite with a minimum
  # version of zero.
  #
  # When some mandatory fields are missing or invalid, the conversion will attempt
  # to provide a sensible default or will fill them with a value of 'unknown'.  For
  # example a missing or unrecognized C<license> field will result in a C<license>
  # field of 'unknown'.  Fields that may get an 'unknown' include:
  #
  # =for :list
  # * abstract
  # * author
  # * license
  #
  # =cut
  
  sub convert {
    my ($self, %args) = @_;
    my $args = { %args };
  
    my $new_version = $args->{version} || $HIGHEST;
  
    my ($old_version) = $self->{spec};
    my $converted = _dclone($self->{data});
  
    if ( $old_version == $new_version ) {
      $converted = _convert( $converted, $cleanup{$old_version}, $old_version );
      my $cmv = CPAN::Meta::Validator->new( $converted );
      unless ( $cmv->is_valid ) {
        my $errs = join("\n", $cmv->errors);
        die "Failed to clean-up $old_version metadata. Errors:\n$errs\n";
      }
      return $converted;
    }
    elsif ( $old_version > $new_version )  {
      my @vers = sort { $b <=> $a } keys %known_specs;
      for my $i ( 0 .. $#vers-1 ) {
        next if $vers[$i] > $old_version;
        last if $vers[$i+1] < $new_version;
        my $spec_string = "$vers[$i+1]-from-$vers[$i]";
        $converted = _convert( $converted, $down_convert{$spec_string}, $vers[$i+1] );
        my $cmv = CPAN::Meta::Validator->new( $converted );
        unless ( $cmv->is_valid ) {
          my $errs = join("\n", $cmv->errors);
          die "Failed to downconvert metadata to $vers[$i+1]. Errors:\n$errs\n";
        }
      }
      return $converted;
    }
    else {
      my @vers = sort { $a <=> $b } keys %known_specs;
      for my $i ( 0 .. $#vers-1 ) {
        next if $vers[$i] < $old_version;
        last if $vers[$i+1] > $new_version;
        my $spec_string = "$vers[$i+1]-from-$vers[$i]";
        $converted = _convert( $converted, $up_convert{$spec_string}, $vers[$i+1] );
        my $cmv = CPAN::Meta::Validator->new( $converted );
        unless ( $cmv->is_valid ) {
          my $errs = join("\n", $cmv->errors);
          die "Failed to upconvert metadata to $vers[$i+1]. Errors:\n$errs\n";
        }
      }
      return $converted;
    }
  }
  
  1;
  
  # ABSTRACT: Convert CPAN distribution metadata structures
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Converter - Convert CPAN distribution metadata structures
  
  =head1 VERSION
  
  version 2.140640
  
  =head1 SYNOPSIS
  
    my $struct = decode_json_file('META.json');
  
    my $cmc = CPAN::Meta::Converter->new( $struct );
  
    my $new_struct = $cmc->convert( version => "2" );
  
  =head1 DESCRIPTION
  
  This module converts CPAN Meta structures from one form to another.  The
  primary use is to convert older structures to the most modern version of
  the specification, but other transformations may be implemented in the
  future as needed.  (E.g. stripping all custom fields or stripping all
  optional fields.)
  
  =head1 METHODS
  
  =head2 new
  
    my $cmc = CPAN::Meta::Converter->new( $struct );
  
  The constructor should be passed a valid metadata structure but invalid
  structures are accepted.  If no meta-spec version is provided, version 1.0 will
  be assumed.
  
  =head2 convert
  
    my $new_struct = $cmc->convert( version => "2" );
  
  Returns a new hash reference with the metadata converted to a different form.
  C<convert> will die if any conversion/standardization still results in an
  invalid structure.
  
  Valid parameters include:
  
  =over
  
  =item *
  
  C<version> -- Indicates the desired specification version (e.g. "1.0", "1.1" ... "1.4", "2").
  Defaults to the latest version of the CPAN Meta Spec.
  
  =back
  
  Conversion proceeds through each version in turn.  For example, a version 1.2
  structure might be converted to 1.3 then 1.4 then finally to version 2. The
  conversion process attempts to clean-up simple errors and standardize data.
  For example, if C<author> is given as a scalar, it will converted to an array
  reference containing the item. (Converting a structure to its own version will
  also clean-up and standardize.)
  
  When data are cleaned and standardized, missing or invalid fields will be
  replaced with sensible defaults when possible.  This may be lossy or imprecise.
  For example, some badly structured META.yml files on CPAN have prerequisite
  modules listed as both keys and values:
  
    requires => { 'Foo::Bar' => 'Bam::Baz' }
  
  These would be split and each converted to a prerequisite with a minimum
  version of zero.
  
  When some mandatory fields are missing or invalid, the conversion will attempt
  to provide a sensible default or will fill them with a value of 'unknown'.  For
  example a missing or unrecognized C<license> field will result in a C<license>
  field of 'unknown'.  Fields that may get an 'unknown' include:
  
  =over 4
  
  =item *
  
  abstract
  
  =item *
  
  author
  
  =item *
  
  license
  
  =back
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden and Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META_CONVERTER

$fatpacked{"CPAN/Meta/Feature.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_FEATURE';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Feature;
  our $VERSION = '2.140640'; # VERSION
  
  use CPAN::Meta::Prereqs;
  
  # =head1 DESCRIPTION
  #
  # A CPAN::Meta::Feature object describes an optional feature offered by a CPAN
  # distribution and specified in the distribution's F<META.json> (or F<META.yml>)
  # file.
  #
  # For the most part, this class will only be used when operating on the result of
  # the C<feature> or C<features> methods on a L<CPAN::Meta> object.
  #
  # =method new
  #
  #   my $feature = CPAN::Meta::Feature->new( $identifier => \%spec );
  #
  # This returns a new Feature object.  The C<%spec> argument to the constructor
  # should be the same as the value of the C<optional_feature> entry in the
  # distmeta.  It must contain entries for C<description> and C<prereqs>.
  #
  # =cut
  
  sub new {
    my ($class, $identifier, $spec) = @_;
  
    my %guts = (
      identifier  => $identifier,
      description => $spec->{description},
      prereqs     => CPAN::Meta::Prereqs->new($spec->{prereqs}),
    );
  
    bless \%guts => $class;
  }
  
  # =method identifier
  #
  # This method returns the feature's identifier.
  #
  # =cut
  
  sub identifier  { $_[0]{identifier}  }
  
  # =method description
  #
  # This method returns the feature's long description.
  #
  # =cut
  
  sub description { $_[0]{description} }
  
  # =method prereqs
  #
  # This method returns the feature's prerequisites as a L<CPAN::Meta::Prereqs>
  # object.
  #
  # =cut
  
  sub prereqs     { $_[0]{prereqs} }
  
  1;
  
  # ABSTRACT: an optional feature provided by a CPAN distribution
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Feature - an optional feature provided by a CPAN distribution
  
  =head1 VERSION
  
  version 2.140640
  
  =head1 DESCRIPTION
  
  A CPAN::Meta::Feature object describes an optional feature offered by a CPAN
  distribution and specified in the distribution's F<META.json> (or F<META.yml>)
  file.
  
  For the most part, this class will only be used when operating on the result of
  the C<feature> or C<features> methods on a L<CPAN::Meta> object.
  
  =head1 METHODS
  
  =head2 new
  
    my $feature = CPAN::Meta::Feature->new( $identifier => \%spec );
  
  This returns a new Feature object.  The C<%spec> argument to the constructor
  should be the same as the value of the C<optional_feature> entry in the
  distmeta.  It must contain entries for C<description> and C<prereqs>.
  
  =head2 identifier
  
  This method returns the feature's identifier.
  
  =head2 description
  
  This method returns the feature's long description.
  
  =head2 prereqs
  
  This method returns the feature's prerequisites as a L<CPAN::Meta::Prereqs>
  object.
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden and Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META_FEATURE

$fatpacked{"CPAN/Meta/History.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_HISTORY';
  # vi:tw=72
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::History;
  our $VERSION = '2.140640'; # VERSION
  
  1;
  
  # ABSTRACT: history of CPAN Meta Spec changes
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::History - history of CPAN Meta Spec changes
  
  =head1 VERSION
  
  version 2.140640
  
  =head1 DESCRIPTION
  
  The CPAN Meta Spec has gone through several iterations.  It was
  originally written in HTML and later revised into POD (though published
  in HTML generated from the POD).  Fields were added, removed or changed,
  sometimes by design and sometimes to reflect real-world usage after the
  fact.
  
  This document reconstructs the history of the CPAN Meta Spec based on
  change logs, repository commit messages and the published HTML files.
  In some cases, particularly prior to version 1.2, the exact version
  when certain fields were introduced or changed is inconsistent between
  sources.  When in doubt, the published HTML files for versions 1.0 to
  1.4 as they existed when version 2 was developed are used as the
  definitive source.
  
  Starting with version 2, the specification document is part of the
  CPAN-Meta distribution and will be published on CPAN as
  L<CPAN::Meta::Spec>.
  
  Going forward, specification version numbers will be integers and
  decimal portions will correspond to a release date for the CPAN::Meta
  library.
  
  =head1 HISTORY
  
  =head2 Version 2
  
  April 2010
  
  =over
  
  =item *
  
  Revised spec examples as perl data structures rather than YAML
  
  =item *
  
  Switched to JSON serialization from YAML
  
  =item *
  
  Specified allowed version number formats
  
  =item *
  
  Replaced 'requires', 'build_requires', 'configure_requires',
  'recommends' and 'conflicts' with new 'prereqs' data structure divided
  by I<phase> (configure, build, test, runtime, etc.) and I<relationship>
  (requires, recommends, suggests, conflicts)
  
  =item *
  
  Added support for 'develop' phase for requirements for maintaining
  a list of authoring tools
  
  =item *
  
  Changed 'license' to a list and revised the set of valid licenses
  
  =item *
  
  Made 'dynamic_config' mandatory to reduce confusion
  
  =item *
  
  Changed 'resources' subkey 'repository' to a hash that clarifies
  repository type, url for browsing and url for checkout
  
  =item *
  
  Changed 'resources' subkey 'bugtracker' to a hash for either web
  or mailto resource
  
  =item *
  
  Changed specification of 'optional_features':
  
  =over
  
  =item *
  
  Added formal specification and usage guide instead of just example
  
  =item *
  
  Changed to use new prereqs data structure instead of individual keys
  
  =back
  
  =item *
  
  Clarified intended use of 'author' as generalized contact list
  
  =item *
  
  Added 'release_status' field to indicate stable, testing or unstable
  status to provide hints to indexers
  
  =item *
  
  Added 'description' field for a longer description of the distribution
  
  =item *
  
  Formalized use of "x_" or "X_" for all custom keys not listed in the
  official spec
  
  =back
  
  =head2 Version 1.4
  
  June 2008
  
  =over
  
  =item *
  
  Noted explicit support for 'perl' in prerequisites
  
  =item *
  
  Added 'configure_requires' prerequisite type
  
  =item *
  
  Changed 'optional_features'
  
  =over
  
  =item *
  
  Example corrected to show map of maps instead of list of maps
  (though descriptive text said 'map' even in v1.3)
  
  =item *
  
  Removed 'requires_packages', 'requires_os' and 'excluded_os'
  as valid subkeys
  
  =back
  
  =back
  
  =head2 Version 1.3
  
  November 2006
  
  =over
  
  =item *
  
  Added 'no_index' subkey 'directory' and removed 'dir' to match actual
  usage in the wild
  
  =item *
  
  Added a 'repository' subkey to 'resources'
  
  =back
  
  =head2 Version 1.2
  
  August 2005
  
  =over
  
  =item *
  
  Re-wrote and restructured spec in POD syntax
  
  =item *
  
  Changed 'name' to be mandatory
  
  =item *
  
  Changed 'generated_by' to be mandatory
  
  =item *
  
  Changed 'license' to be mandatory
  
  =item *
  
  Added version range specifications for prerequisites
  
  =item *
  
  Added required 'abstract' field
  
  =item *
  
  Added required 'author' field
  
  =item *
  
  Added required 'meta-spec' field to define 'version' (and 'url') of the
  CPAN Meta Spec used for metadata
  
  =item *
  
  Added 'provides' field
  
  =item *
  
  Added 'no_index' field and deprecated 'private' field.  'no_index'
  subkeys include 'file', 'dir', 'package' and 'namespace'
  
  =item *
  
  Added 'keywords' field
  
  =item *
  
  Added 'resources' field with subkeys 'homepage', 'license', and
  'bugtracker'
  
  =item *
  
  Added 'optional_features' field as an alternate under 'recommends'.
  Includes 'description', 'requires', 'build_requires', 'conflicts',
  'requires_packages', 'requires_os' and 'excluded_os' as valid subkeys
  
  =item *
  
  Removed 'license_uri' field
  
  =back
  
  =head2 Version 1.1
  
  May 2003
  
  =over
  
  =item *
  
  Changed 'version' to be mandatory
  
  =item *
  
  Added 'private' field
  
  =item *
  
  Added 'license_uri' field
  
  =back
  
  =head2 Version 1.0
  
  March 2003
  
  =over
  
  =item *
  
  Original release (in HTML format only)
  
  =item *
  
  Included 'name', 'version', 'license', 'distribution_type', 'requires',
  'recommends', 'build_requires', 'conflicts', 'dynamic_config',
  'generated_by'
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden and Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META_HISTORY

$fatpacked{"CPAN/Meta/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_PREREQS';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Prereqs;
  our $VERSION = '2.140640'; # VERSION
  
  # =head1 DESCRIPTION
  #
  # A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN
  # distribution or one of its optional features.  Each set of prereqs is
  # organized by phase and type, as described in L<CPAN::Meta::Prereqs>.
  #
  # =cut
  
  use Carp qw(confess);
  use Scalar::Util qw(blessed);
  use CPAN::Meta::Requirements 2.121;
  
  # =method new
  #
  #   my $prereq = CPAN::Meta::Prereqs->new( \%prereq_spec );
  #
  # This method returns a new set of Prereqs.  The input should look like the
  # contents of the C<prereqs> field described in L<CPAN::Meta::Spec>, meaning
  # something more or less like this:
  #
  #   my $prereq = CPAN::Meta::Prereqs->new({
  #     runtime => {
  #       requires => {
  #         'Some::Module' => '1.234',
  #         ...,
  #       },
  #       ...,
  #     },
  #     ...,
  #   });
  #
  # You can also construct an empty set of prereqs with:
  #
  #   my $prereqs = CPAN::Meta::Prereqs->new;
  #
  # This empty set of prereqs is useful for accumulating new prereqs before finally
  # dumping the whole set into a structure or string.
  #
  # =cut
  
  sub __legal_phases { qw(configure build test runtime develop)   }
  sub __legal_types  { qw(requires recommends suggests conflicts) }
  
  # expect a prereq spec from META.json -- rjbs, 2010-04-11
  sub new {
    my ($class, $prereq_spec) = @_;
    $prereq_spec ||= {};
  
    my %is_legal_phase = map {; $_ => 1 } $class->__legal_phases;
    my %is_legal_type  = map {; $_ => 1 } $class->__legal_types;
  
    my %guts;
    PHASE: for my $phase (keys %$prereq_spec) {
      next PHASE unless $phase =~ /\Ax_/i or $is_legal_phase{$phase};
  
      my $phase_spec = $prereq_spec->{ $phase };
      next PHASE unless keys %$phase_spec;
  
      TYPE: for my $type (keys %$phase_spec) {
        next TYPE unless $type =~ /\Ax_/i or $is_legal_type{$type};
  
        my $spec = $phase_spec->{ $type };
  
        next TYPE unless keys %$spec;
  
        $guts{prereqs}{$phase}{$type} = CPAN::Meta::Requirements->from_string_hash(
          $spec
        );
      }
    }
  
    return bless \%guts => $class;
  }
  
  # =method requirements_for
  #
  #   my $requirements = $prereqs->requirements_for( $phase, $type );
  #
  # This method returns a L<CPAN::Meta::Requirements> object for the given
  # phase/type combination.  If no prerequisites are registered for that
  # combination, a new CPAN::Meta::Requirements object will be returned, and it may
  # be added to as needed.
  #
  # If C<$phase> or C<$type> are undefined or otherwise invalid, an exception will
  # be raised.
  #
  # =cut
  
  sub requirements_for {
    my ($self, $phase, $type) = @_;
  
    confess "requirements_for called without phase" unless defined $phase;
    confess "requirements_for called without type"  unless defined $type;
  
    unless ($phase =~ /\Ax_/i or grep { $phase eq $_ } $self->__legal_phases) {
      confess "requested requirements for unknown phase: $phase";
    }
  
    unless ($type =~ /\Ax_/i or grep { $type eq $_ } $self->__legal_types) {
      confess "requested requirements for unknown type: $type";
    }
  
    my $req = ($self->{prereqs}{$phase}{$type} ||= CPAN::Meta::Requirements->new);
  
    $req->finalize if $self->is_finalized;
  
    return $req;
  }
  
  # =method with_merged_prereqs
  #
  #   my $new_prereqs = $prereqs->with_merged_prereqs( $other_prereqs );
  #
  #   my $new_prereqs = $prereqs->with_merged_prereqs( \@other_prereqs );
  #
  # This method returns a new CPAN::Meta::Prereqs objects in which all the
  # other prerequisites given are merged into the current set.  This is primarily
  # provided for combining a distribution's core prereqs with the prereqs of one of
  # its optional features.
  #
  # The new prereqs object has no ties to the originals, and altering it further
  # will not alter them.
  #
  # =cut
  
  sub with_merged_prereqs {
    my ($self, $other) = @_;
  
    my @other = blessed($other) ? $other : @$other;
  
    my @prereq_objs = ($self, @other);
  
    my %new_arg;
  
    for my $phase ($self->__legal_phases) {
      for my $type ($self->__legal_types) {
        my $req = CPAN::Meta::Requirements->new;
  
        for my $prereq (@prereq_objs) {
          my $this_req = $prereq->requirements_for($phase, $type);
          next unless $this_req->required_modules;
  
          $req->add_requirements($this_req);
        }
  
        next unless $req->required_modules;
  
        $new_arg{ $phase }{ $type } = $req->as_string_hash;
      }
    }
  
    return (ref $self)->new(\%new_arg);
  }
  
  # =method merged_requirements
  #
  #     my $new_reqs = $prereqs->merged_requirements( \@phases, \@types );
  #     my $new_reqs = $prereqs->merged_requirements( \@phases );
  #     my $new_reqs = $preerqs->merged_requirements();
  #
  # This method joins together all requirements across a number of phases
  # and types into a new L<CPAN::Meta::Requirements> object.  If arguments
  # are omitted, it defaults to "runtime", "build" and "test" for phases
  # and "requires" and "recommends" for types.
  #
  # =cut
  
  sub merged_requirements {
    my ($self, $phases, $types) = @_;
    $phases = [qw/runtime build test/] unless defined $phases;
    $types = [qw/requires recommends/] unless defined $types;
  
    confess "merged_requirements phases argument must be an arrayref"
      unless ref $phases eq 'ARRAY';
    confess "merged_requirements types argument must be an arrayref"
      unless ref $types eq 'ARRAY';
  
    my $req = CPAN::Meta::Requirements->new;
  
    for my $phase ( @$phases ) {
      unless ($phase =~ /\Ax_/i or grep { $phase eq $_ } $self->__legal_phases) {
          confess "requested requirements for unknown phase: $phase";
      }
      for my $type ( @$types ) {
        unless ($type =~ /\Ax_/i or grep { $type eq $_ } $self->__legal_types) {
            confess "requested requirements for unknown type: $type";
        }
        $req->add_requirements( $self->requirements_for($phase, $type) );
      }
    }
  
    $req->finalize if $self->is_finalized;
  
    return $req;
  }
  
  
  # =method as_string_hash
  #
  # This method returns a hashref containing structures suitable for dumping into a
  # distmeta data structure.  It is made up of hashes and strings, only; there will
  # be no Prereqs, CPAN::Meta::Requirements, or C<version> objects inside it.
  #
  # =cut
  
  sub as_string_hash {
    my ($self) = @_;
  
    my %hash;
  
    for my $phase ($self->__legal_phases) {
      for my $type ($self->__legal_types) {
        my $req = $self->requirements_for($phase, $type);
        next unless $req->required_modules;
  
        $hash{ $phase }{ $type } = $req->as_string_hash;
      }
    }
  
    return \%hash;
  }
  
  # =method is_finalized
  #
  # This method returns true if the set of prereqs has been marked "finalized," and
  # cannot be altered.
  #
  # =cut
  
  sub is_finalized { $_[0]{finalized} }
  
  # =method finalize
  #
  # Calling C<finalize> on a Prereqs object will close it for further modification.
  # Attempting to make any changes that would actually alter the prereqs will
  # result in an exception being thrown.
  #
  # =cut
  
  sub finalize {
    my ($self) = @_;
  
    $self->{finalized} = 1;
  
    for my $phase (keys %{ $self->{prereqs} }) {
      $_->finalize for values %{ $self->{prereqs}{$phase} };
    }
  }
  
  # =method clone
  #
  #   my $cloned_prereqs = $prereqs->clone;
  #
  # This method returns a Prereqs object that is identical to the original object,
  # but can be altered without affecting the original object.  Finalization does
  # not survive cloning, meaning that you may clone a finalized set of prereqs and
  # then modify the clone.
  #
  # =cut
  
  sub clone {
    my ($self) = @_;
  
    my $clone = (ref $self)->new( $self->as_string_hash );
  }
  
  1;
  
  # ABSTRACT: a set of distribution prerequisites by phase and type
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Prereqs - a set of distribution prerequisites by phase and type
  
  =head1 VERSION
  
  version 2.140640
  
  =head1 DESCRIPTION
  
  A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN
  distribution or one of its optional features.  Each set of prereqs is
  organized by phase and type, as described in L<CPAN::Meta::Prereqs>.
  
  =head1 METHODS
  
  =head2 new
  
    my $prereq = CPAN::Meta::Prereqs->new( \%prereq_spec );
  
  This method returns a new set of Prereqs.  The input should look like the
  contents of the C<prereqs> field described in L<CPAN::Meta::Spec>, meaning
  something more or less like this:
  
    my $prereq = CPAN::Meta::Prereqs->new({
      runtime => {
        requires => {
          'Some::Module' => '1.234',
          ...,
        },
        ...,
      },
      ...,
    });
  
  You can also construct an empty set of prereqs with:
  
    my $prereqs = CPAN::Meta::Prereqs->new;
  
  This empty set of prereqs is useful for accumulating new prereqs before finally
  dumping the whole set into a structure or string.
  
  =head2 requirements_for
  
    my $requirements = $prereqs->requirements_for( $phase, $type );
  
  This method returns a L<CPAN::Meta::Requirements> object for the given
  phase/type combination.  If no prerequisites are registered for that
  combination, a new CPAN::Meta::Requirements object will be returned, and it may
  be added to as needed.
  
  If C<$phase> or C<$type> are undefined or otherwise invalid, an exception will
  be raised.
  
  =head2 with_merged_prereqs
  
    my $new_prereqs = $prereqs->with_merged_prereqs( $other_prereqs );
  
    my $new_prereqs = $prereqs->with_merged_prereqs( \@other_prereqs );
  
  This method returns a new CPAN::Meta::Prereqs objects in which all the
  other prerequisites given are merged into the current set.  This is primarily
  provided for combining a distribution's core prereqs with the prereqs of one of
  its optional features.
  
  The new prereqs object has no ties to the originals, and altering it further
  will not alter them.
  
  =head2 merged_requirements
  
      my $new_reqs = $prereqs->merged_requirements( \@phases, \@types );
      my $new_reqs = $prereqs->merged_requirements( \@phases );
      my $new_reqs = $preerqs->merged_requirements();
  
  This method joins together all requirements across a number of phases
  and types into a new L<CPAN::Meta::Requirements> object.  If arguments
  are omitted, it defaults to "runtime", "build" and "test" for phases
  and "requires" and "recommends" for types.
  
  =head2 as_string_hash
  
  This method returns a hashref containing structures suitable for dumping into a
  distmeta data structure.  It is made up of hashes and strings, only; there will
  be no Prereqs, CPAN::Meta::Requirements, or C<version> objects inside it.
  
  =head2 is_finalized
  
  This method returns true if the set of prereqs has been marked "finalized," and
  cannot be altered.
  
  =head2 finalize
  
  Calling C<finalize> on a Prereqs object will close it for further modification.
  Attempting to make any changes that would actually alter the prereqs will
  result in an exception being thrown.
  
  =head2 clone
  
    my $cloned_prereqs = $prereqs->clone;
  
  This method returns a Prereqs object that is identical to the original object,
  but can be altered without affecting the original object.  Finalization does
  not survive cloning, meaning that you may clone a finalized set of prereqs and
  then modify the clone.
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden and Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META_PREREQS

$fatpacked{"CPAN/Meta/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_SPEC';
  # XXX RULES FOR PATCHING THIS FILE XXX
  # Patches that fix typos or formatting are acceptable.  Patches
  # that change semantics are not acceptable without prior approval
  # by David Golden or Ricardo Signes.
  
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Spec;
  our $VERSION = '2.140640'; # VERSION
  
  1;
  
  # ABSTRACT: specification for CPAN distribution metadata
  
  
  # vi:tw=72
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Spec - specification for CPAN distribution metadata
  
  =head1 VERSION
  
  version 2.140640
  
  =head1 SYNOPSIS
  
    my $distmeta = {
      name => 'Module-Build',
      abstract => 'Build and install Perl modules',
      description =>  "Module::Build is a system for "
        . "building, testing, and installing Perl modules. "
        . "It is meant to ... blah blah blah ...",
      version  => '0.36',
      release_status => 'stable',
      author   => [
        'Ken Williams <kwilliams@cpan.org>',
        'Module-Build List <module-build@perl.org>', # additional contact
      ],
      license  => [ 'perl_5' ],
      prereqs => {
        runtime => {
          requires => {
            'perl'   => '5.006',
            'ExtUtils::Install' => '0',
            'File::Basename' => '0',
            'File::Compare'  => '0',
            'IO::File'   => '0',
          },
          recommends => {
            'Archive::Tar' => '1.00',
            'ExtUtils::Install' => '0.3',
            'ExtUtils::ParseXS' => '2.02',
          },
        },
        build => {
          requires => {
            'Test::More' => '0',
          },
        }
      },
      resources => {
        license => ['http://dev.perl.org/licenses/'],
      },
      optional_features => {
        domination => {
          description => 'Take over the world',
          prereqs     => {
            develop => { requires => { 'Genius::Evil'     => '1.234' } },
            runtime => { requires => { 'Machine::Weather' => '2.0'   } },
          },
        },
      },
      dynamic_config => 1,
      keywords => [ qw/ toolchain cpan dual-life / ],
      'meta-spec' => {
        version => '2',
        url     => 'https://metacpan.org/pod/CPAN::Meta::Spec',
      },
      generated_by => 'Module::Build version 0.36',
    };
  
  =head1 DESCRIPTION
  
  This document describes version 2 of the CPAN distribution metadata
  specification, also known as the "CPAN Meta Spec".
  
  Revisions of this specification for typo corrections and prose
  clarifications may be issued as CPAN::Meta::Spec 2.I<x>.  These
  revisions will never change semantics or add or remove specified
  behavior.
  
  Distribution metadata describe important properties of Perl
  distributions. Distribution building tools like Module::Build,
  Module::Install, ExtUtils::MakeMaker or Dist::Zilla should create a
  metadata file in accordance with this specification and include it with
  the distribution for use by automated tools that index, examine, package
  or install Perl distributions.
  
  =head1 TERMINOLOGY
  
  =over 4
  
  =item distribution
  
  This is the primary object described by the metadata. In the context of
  this document it usually refers to a collection of modules, scripts,
  and/or documents that are distributed together for other developers to
  use.  Examples of distributions are C<Class-Container>, C<libwww-perl>,
  or C<DBI>.
  
  =item module
  
  This refers to a reusable library of code contained in a single file.
  Modules usually contain one or more packages and are often referred
  to by the name of a primary package that can be mapped to the file
  name. For example, one might refer to C<File::Spec> instead of
  F<File/Spec.pm>
  
  =item package
  
  This refers to a namespace declared with the Perl C<package> statement.
  In Perl, packages often have a version number property given by the
  C<$VERSION> variable in the namespace.
  
  =item consumer
  
  This refers to code that reads a metadata file, deserializes it into a
  data structure in memory, or interprets a data structure of metadata
  elements.
  
  =item producer
  
  This refers to code that constructs a metadata data structure,
  serializes into a bytestream and/or writes it to disk.
  
  =item must, should, may, etc.
  
  These terms are interpreted as described in IETF RFC 2119.
  
  =back
  
  =head1 DATA TYPES
  
  Fields in the L</STRUCTURE> section describe data elements, each of
  which has an associated data type as described herein.  There are four
  primitive types: Boolean, String, List and Map.  Other types are
  subtypes of primitives and define compound data structures or define
  constraints on the values of a data element.
  
  =head2 Boolean
  
  A I<Boolean> is used to provide a true or false value.  It B<must> be
  represented as a defined value.
  
  =head2 String
  
  A I<String> is data element containing a non-zero length sequence of
  Unicode characters, such as an ordinary Perl scalar that is not a
  reference.
  
  =head2 List
  
  A I<List> is an ordered collection of zero or more data elements.
  Elements of a List may be of mixed types.
  
  Producers B<must> represent List elements using a data structure which
  unambiguously indicates that multiple values are possible, such as a
  reference to a Perl array (an "arrayref").
  
  Consumers expecting a List B<must> consider a String as equivalent to a
  List of length 1.
  
  =head2 Map
  
  A I<Map> is an unordered collection of zero or more data elements
  ("values"), indexed by associated String elements ("keys").  The Map's
  value elements may be of mixed types.
  
  =head2 License String
  
  A I<License String> is a subtype of String with a restricted set of
  values.  Valid values are described in detail in the description of
  the L</license> field.
  
  =head2 URL
  
  I<URL> is a subtype of String containing a Uniform Resource Locator or
  Identifier.  [ This type is called URL and not URI for historical reasons. ]
  
  =head2 Version
  
  A I<Version> is a subtype of String containing a value that describes
  the version number of packages or distributions.  Restrictions on format
  are described in detail in the L</Version Formats> section.
  
  =head2 Version Range
  
  The I<Version Range> type is a subtype of String.  It describes a range
  of Versions that may be present or installed to fulfill prerequisites.
  It is specified in detail in the L</Version Ranges> section.
  
  =head1 STRUCTURE
  
  The metadata structure is a data element of type Map.  This section
  describes valid keys within the Map.
  
  Any keys not described in this specification document (whether top-level
  or within compound data structures described herein) are considered
  I<custom keys> and B<must> begin with an "x" or "X" and be followed by an
  underscore; i.e. they must match the pattern: C<< qr{\Ax_}i >>.  If a
  custom key refers to a compound data structure, subkeys within it do not
  need an "x_" or "X_" prefix.
  
  Consumers of metadata may ignore any or all custom keys.  All other keys
  not described herein are invalid and should be ignored by consumers.
  Producers must not generate or output invalid keys.
  
  For each key, an example is provided followed by a description.  The
  description begins with the version of spec in which the key was added
  or in which the definition was modified, whether the key is I<required>
  or I<optional> and the data type of the corresponding data element.
  These items are in parentheses, brackets and braces, respectively.
  
  If a data type is a Map or Map subtype, valid subkeys will be described
  as well.
  
  Some fields are marked I<Deprecated>.  These are shown for historical
  context and must not be produced in or consumed from any metadata structure
  of version 2 or higher.
  
  =head2 REQUIRED FIELDS
  
  =head3 abstract
  
  Example:
  
    abstract => 'Build and install Perl modules'
  
  (Spec 1.2) [required] {String}
  
  This is a short description of the purpose of the distribution.
  
  =head3 author
  
  Example:
  
    author => [ 'Ken Williams <kwilliams@cpan.org>' ]
  
  (Spec 1.2) [required] {List of one or more Strings}
  
  This List indicates the person(s) to contact concerning the
  distribution. The preferred form of the contact string is:
  
    contact-name <email-address>
  
  This field provides a general contact list independent of other
  structured fields provided within the L</resources> field, such as
  C<bugtracker>.  The addressee(s) can be contacted for any purpose
  including but not limited to (security) problems with the distribution,
  questions about the distribution or bugs in the distribution.
  
  A distribution's original author is usually the contact listed within
  this field.  Co-maintainers, successor maintainers or mailing lists
  devoted to the distribution may also be listed in addition to or instead
  of the original author.
  
  =head3 dynamic_config
  
  Example:
  
    dynamic_config => 1
  
  (Spec 2) [required] {Boolean}
  
  A boolean flag indicating whether a F<Build.PL> or F<Makefile.PL> (or
  similar) must be executed to determine prerequisites.
  
  This field should be set to a true value if the distribution performs
  some dynamic configuration (asking questions, sensing the environment,
  etc.) as part of its configuration.  This field should be set to a false
  value to indicate that prerequisites included in metadata may be
  considered final and valid for static analysis.
  
  This field explicitly B<does not> indicate whether installation may be
  safely performed without using a Makefile or Build file, as there may be
  special files to install or custom installation targets (e.g. for
  dual-life modules that exist on CPAN as well as in the Perl core).  This
  field only defines whether prerequisites are complete as given in the
  metadata.
  
  =head3 generated_by
  
  Example:
  
    generated_by => 'Module::Build version 0.36'
  
  (Spec 1.0) [required] {String}
  
  This field indicates the tool that was used to create this metadata.
  There are no defined semantics for this field, but it is traditional to
  use a string in the form "Generating::Package version 1.23" or the
  author's name, if the file was generated by hand.
  
  =head3 license
  
  Example:
  
    license => [ 'perl_5' ]
  
    license => [ 'apache_2_0', 'mozilla_1_0' ]
  
  (Spec 2) [required] {List of one or more License Strings}
  
  One or more licenses that apply to some or all of the files in the
  distribution.  If multiple licenses are listed, the distribution
  documentation should be consulted to clarify the interpretation of
  multiple licenses.
  
  The following list of license strings are valid:
  
   string          description
   -------------   -----------------------------------------------
   agpl_3          GNU Affero General Public License, Version 3
   apache_1_1      Apache Software License, Version 1.1
   apache_2_0      Apache License, Version 2.0
   artistic_1      Artistic License, (Version 1)
   artistic_2      Artistic License, Version 2.0
   bsd             BSD License (three-clause)
   freebsd         FreeBSD License (two-clause)
   gfdl_1_2        GNU Free Documentation License, Version 1.2
   gfdl_1_3        GNU Free Documentation License, Version 1.3
   gpl_1           GNU General Public License, Version 1
   gpl_2           GNU General Public License, Version 2
   gpl_3           GNU General Public License, Version 3
   lgpl_2_1        GNU Lesser General Public License, Version 2.1
   lgpl_3_0        GNU Lesser General Public License, Version 3.0
   mit             MIT (aka X11) License
   mozilla_1_0     Mozilla Public License, Version 1.0
   mozilla_1_1     Mozilla Public License, Version 1.1
   openssl         OpenSSL License
   perl_5          The Perl 5 License (Artistic 1 & GPL 1 or later)
   qpl_1_0         Q Public License, Version 1.0
   ssleay          Original SSLeay License
   sun             Sun Internet Standards Source License (SISSL)
   zlib            zlib License
  
  The following license strings are also valid and indicate other
  licensing not described above:
  
   string          description
   -------------   -----------------------------------------------
   open_source     Other Open Source Initiative (OSI) approved license
   restricted      Requires special permission from copyright holder
   unrestricted    Not an OSI approved license, but not restricted
   unknown         License not provided in metadata
  
  All other strings are invalid in the license field.
  
  =head3 meta-spec
  
  Example:
  
    'meta-spec' => {
      version => '2',
      url     => 'http://search.cpan.org/perldoc?CPAN::Meta::Spec',
    }
  
  (Spec 1.2) [required] {Map}
  
  This field indicates the version of the CPAN Meta Spec that should be
  used to interpret the metadata.  Consumers must check this key as soon
  as possible and abort further metadata processing if the meta-spec
  version is not supported by the consumer.
  
  The following keys are valid, but only C<version> is required.
  
  =over
  
  =item version
  
  This subkey gives the integer I<Version> of the CPAN Meta Spec against
  which the document was generated.
  
  =item url
  
  This is a I<URL> of the metadata specification document corresponding to
  the given version.  This is strictly for human-consumption and should
  not impact the interpretation of the document.
  
  For the version 2 spec, either of these are recommended:
  
  =over 4
  
  =item *
  
  C<https://metacpan.org/pod/CPAN::Meta::Spec>
  
  =item *
  
  C<http://search.cpan.org/perldoc?CPAN::Meta::Spec>
  
  =back
  
  =back
  
  =head3 name
  
  Example:
  
    name => 'Module-Build'
  
  (Spec 1.0) [required] {String}
  
  This field is the name of the distribution.  This is often created by
  taking the "main package" in the distribution and changing C<::> to
  C<->, but the name may be completely unrelated to the packages within
  the distribution.  For example, L<LWP::UserAgent> is distributed as part
  of the distribution name "libwww-perl".
  
  =head3 release_status
  
  Example:
  
    release_status => 'stable'
  
  (Spec 2) [required] {String}
  
  This field provides the  release status of this distribution.  If the
  C<version> field contains an underscore character, then
  C<release_status> B<must not> be "stable."
  
  The C<release_status> field B<must> have one of the following values:
  
  =over
  
  =item stable
  
  This indicates an ordinary, "final" release that should be indexed by PAUSE
  or other indexers.
  
  =item testing
  
  This indicates a "beta" release that is substantially complete, but has an
  elevated risk of bugs and requires additional testing.  The distribution
  should not be installed over a stable release without an explicit request
  or other confirmation from a user.  This release status may also be used
  for "release candidate" versions of a distribution.
  
  =item unstable
  
  This indicates an "alpha" release that is under active development, but has
  been released for early feedback or testing and may be missing features or
  may have serious bugs.  The distribution should not be installed over a
  stable release without an explicit request or other confirmation from a
  user.
  
  =back
  
  Consumers B<may> use this field to determine how to index the
  distribution for CPAN or other repositories in addition to or in
  replacement of heuristics based on version number or file name.
  
  =head3 version
  
  Example:
  
    version => '0.36'
  
  (Spec 1.0) [required] {Version}
  
  This field gives the version of the distribution to which the metadata
  structure refers.
  
  =head2 OPTIONAL FIELDS
  
  =head3 description
  
  Example:
  
      description =>  "Module::Build is a system for "
        . "building, testing, and installing Perl modules. "
        . "It is meant to ... blah blah blah ...",
  
  (Spec 2) [optional] {String}
  
  A longer, more complete description of the purpose or intended use of
  the distribution than the one provided by the C<abstract> key.
  
  =head3 keywords
  
  Example:
  
    keywords => [ qw/ toolchain cpan dual-life / ]
  
  (Spec 1.1) [optional] {List of zero or more Strings}
  
  A List of keywords that describe this distribution.  Keywords
  B<must not> include whitespace.
  
  =head3 no_index
  
  Example:
  
    no_index => {
      file      => [ 'My/Module.pm' ],
      directory => [ 'My/Private' ],
      package   => [ 'My::Module::Secret' ],
      namespace => [ 'My::Module::Sample' ],
    }
  
  (Spec 1.2) [optional] {Map}
  
  This Map describes any files, directories, packages, and namespaces that
  are private to the packaging or implementation of the distribution and
  should be ignored by indexing or search tools.
  
  Valid subkeys are as follows:
  
  =over
  
  =item file
  
  A I<List> of relative paths to files.  Paths B<must be> specified with
  unix conventions.
  
  =item directory
  
  A I<List> of relative paths to directories.  Paths B<must be> specified
  with unix conventions.
  
  [ Note: previous editions of the spec had C<dir> instead of C<directory> ]
  
  =item package
  
  A I<List> of package names.
  
  =item namespace
  
  A I<List> of package namespaces, where anything below the namespace
  must be ignored, but I<not> the namespace itself.
  
  In the example above for C<no_index>, C<My::Module::Sample::Foo> would
  be ignored, but C<My::Module::Sample> would not.
  
  =back
  
  =head3 optional_features
  
  Example:
  
    optional_features => {
      sqlite => {
        description => 'Provides SQLite support',
        prereqs => {
          runtime => {
            requires => {
              'DBD::SQLite' => '1.25'
            }
          }
        }
      }
    }
  
  (Spec 2) [optional] {Map}
  
  This Map describes optional features with incremental prerequisites.
  Each key of the C<optional_features> Map is a String used to identify
  the feature and each value is a Map with additional information about
  the feature.  Valid subkeys include:
  
  =over
  
  =item description
  
  This is a String describing the feature.  Every optional feature
  should provide a description
  
  =item prereqs
  
  This entry is required and has the same structure as that of the
  C<L</prereqs>> key.  It provides a list of package requirements
  that must be satisfied for the feature to be supported or enabled.
  
  There is one crucial restriction:  the prereqs of an optional feature
  B<must not> include C<configure> phase prereqs.
  
  =back
  
  Consumers B<must not> include optional features as prerequisites without
  explicit instruction from users (whether via interactive prompting,
  a function parameter or a configuration value, etc. ).
  
  If an optional feature is used by a consumer to add additional
  prerequisites, the consumer should merge the optional feature
  prerequisites into those given by the C<prereqs> key using the same
  semantics.  See L</Merging and Resolving Prerequisites> for details on
  merging prerequisites.
  
  I<Suggestion for disuse:> Because there is currently no way for a
  distribution to specify a dependency on an optional feature of another
  dependency, the use of C<optional_feature> is discouraged.  Instead,
  create a separate, installable distribution that ensures the desired
  feature is available.  For example, if C<Foo::Bar> has a C<Baz> feature,
  release a separate C<Foo-Bar-Baz> distribution that satisfies
  requirements for the feature.
  
  =head3 prereqs
  
  Example:
  
    prereqs => {
      runtime => {
        requires => {
          'perl'          => '5.006',
          'File::Spec'    => '0.86',
          'JSON'          => '2.16',
        },
        recommends => {
          'JSON::XS'      => '2.26',
        },
        suggests => {
          'Archive::Tar'  => '0',
        },
      },
      build => {
        requires => {
          'Alien::SDL'    => '1.00',
        },
      },
      test => {
        recommends => {
          'Test::Deep'    => '0.10',
        },
      }
    }
  
  (Spec 2) [optional] {Map}
  
  This is a Map that describes all the prerequisites of the distribution.
  The keys are phases of activity, such as C<configure>, C<build>, C<test>
  or C<runtime>.  Values are Maps in which the keys name the type of
  prerequisite relationship such as C<requires>, C<recommends>, or
  C<suggests> and the value provides a set of prerequisite relations.  The
  set of relations B<must> be specified as a Map of package names to
  version ranges.
  
  The full definition for this field is given in the L</Prereq Spec>
  section.
  
  =head3 provides
  
  Example:
  
    provides => {
      'Foo::Bar' => {
        file    => 'lib/Foo/Bar.pm',
        version => '0.27_02',
      },
      'Foo::Bar::Blah' => {
        file    => 'lib/Foo/Bar/Blah.pm',
      },
      'Foo::Bar::Baz' => {
        file    => 'lib/Foo/Bar/Baz.pm',
        version => '0.3',
      },
    }
  
  (Spec 1.2) [optional] {Map}
  
  This describes all packages provided by this distribution.  This
  information is used by distribution and automation mechanisms like
  PAUSE, CPAN, metacpan.org and search.cpan.org to build indexes saying in
  which distribution various packages can be found.
  
  The keys of C<provides> are package names that can be found within
  the distribution.  If a package name key is provided, it must
  have a Map with the following valid subkeys:
  
  =over
  
  =item file
  
  This field is required.  It must contain a Unix-style relative file path
  from the root of the distribution directory to a file that contains or
  generates the package.
  
  =item version
  
  If it exists, this field must contains a I<Version> String for the
  package.  If the package does not have a C<$VERSION>, this field must
  be omitted.
  
  =back
  
  =head3 resources
  
  Example:
  
    resources => {
      license     => [ 'http://dev.perl.org/licenses/' ],
      homepage    => 'http://sourceforge.net/projects/module-build',
      bugtracker  => {
        web    => 'http://rt.cpan.org/Public/Dist/Display.html?Name=CPAN-Meta',
        mailto => 'meta-bugs@example.com',
      },
      repository  => {
        url  => 'git://github.com/dagolden/cpan-meta.git',
        web  => 'http://github.com/dagolden/cpan-meta',
        type => 'git',
      },
      x_twitter   => 'http://twitter.com/cpan_linked/',
    }
  
  (Spec 2) [optional] {Map}
  
  This field describes resources related to this distribution.
  
  Valid subkeys include:
  
  =over
  
  =item homepage
  
  The official home of this project on the web.
  
  =item license
  
  A List of I<URL>'s that relate to this distribution's license.  As with the
  top-level C<license> field, distribution documentation should be consulted
  to clarify the interpretation of multiple licenses provided here.
  
  =item bugtracker
  
  This entry describes the bug tracking system for this distribution.  It
  is a Map with the following valid keys:
  
    web    - a URL pointing to a web front-end for the bug tracker
    mailto - an email address to which bugs can be sent
  
  =item repository
  
  This entry describes the source control repository for this distribution.  It
  is a Map with the following valid keys:
  
    url  - a URL pointing to the repository itself
    web  - a URL pointing to a web front-end for the repository
    type - a lowercase string indicating the VCS used
  
  Because a url like C<http://myrepo.example.com/> is ambiguous as to
  type, producers should provide a C<type> whenever a C<url> key is given.
  The C<type> field should be the name of the most common program used
  to work with the repository, e.g. C<git>, C<svn>, C<cvs>, C<darcs>,
  C<bzr> or C<hg>.
  
  =back
  
  =head2 DEPRECATED FIELDS
  
  =head3 build_requires
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head3 configure_requires
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head3 conflicts
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head3 distribution_type
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  This field indicated 'module' or 'script' but was considered
  meaningless, since many distributions are hybrids of several kinds of
  things.
  
  =head3 license_uri
  
  I<(Deprecated in Spec 1.2)> [optional] {URL}
  
  Replaced by C<license> in C<resources>
  
  =head3 private
  
  I<(Deprecated in Spec 1.2)> [optional] {Map}
  
  This field has been renamed to L</"no_index">.
  
  =head3 recommends
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head3 requires
  
  I<(Deprecated in Spec 2)> [optional] {String}
  
  Replaced by C<prereqs>
  
  =head1 VERSION NUMBERS
  
  =head2 Version Formats
  
  This section defines the Version type, used by several fields in the
  CPAN Meta Spec.
  
  Version numbers must be treated as strings, not numbers.  For
  example, C<1.200> B<must not> be serialized as C<1.2>.  Version
  comparison should be delegated to the Perl L<version> module, version
  0.80 or newer.
  
  Unless otherwise specified, version numbers B<must> appear in one of two
  formats:
  
  =over
  
  =item Decimal versions
  
  Decimal versions are regular "decimal numbers", with some limitations.
  They B<must> be non-negative and B<must> begin and end with a digit.  A
  single underscore B<may> be included, but B<must> be between two digits.
  They B<must not> use exponential notation ("1.23e-2").
  
     version => '1.234'       # OK
     version => '1.23_04'     # OK
  
     version => '1.23_04_05'  # Illegal
     version => '1.'          # Illegal
     version => '.1'          # Illegal
  
  =item Dotted-integer versions
  
  Dotted-integer (also known as dotted-decimal) versions consist of
  positive integers separated by full stop characters (i.e. "dots",
  "periods" or "decimal points").  This are equivalent in format to Perl
  "v-strings", with some additional restrictions on form.  They must be
  given in "normal" form, which has a leading "v" character and at least
  three integer components.  To retain a one-to-one mapping with decimal
  versions, all components after the first B<should> be restricted to the
  range 0 to 999.  The final component B<may> be separated by an
  underscore character instead of a period.
  
     version => 'v1.2.3'      # OK
     version => 'v1.2_3'      # OK
     version => 'v1.2.3.4'    # OK
     version => 'v1.2.3_4'    # OK
     version => 'v2009.10.31' # OK
  
     version => 'v1.2'          # Illegal
     version => '1.2.3'         # Illegal
     version => 'v1.2_3_4'      # Illegal
     version => 'v1.2009.10.31' # Not recommended
  
  =back
  
  =head2 Version Ranges
  
  Some fields (prereq, optional_features) indicate the particular
  version(s) of some other module that may be required as a prerequisite.
  This section details the Version Range type used to provide this
  information.
  
  The simplest format for a Version Range is just the version
  number itself, e.g. C<2.4>.  This means that B<at least> version 2.4
  must be present.  To indicate that B<any> version of a prerequisite is
  okay, even if the prerequisite doesn't define a version at all, use
  the version C<0>.
  
  Alternatively, a version range B<may> use the operators E<lt> (less than),
  E<lt>= (less than or equal), E<gt> (greater than), E<gt>= (greater than
  or equal), == (equal), and != (not equal).  For example, the
  specification C<E<lt> 2.0> means that any version of the prerequisite
  less than 2.0 is suitable.
  
  For more complicated situations, version specifications B<may> be AND-ed
  together using commas.  The specification C<E<gt>= 1.2, != 1.5, E<lt>
  2.0> indicates a version that must be B<at least> 1.2, B<less than> 2.0,
  and B<not equal to> 1.5.
  
  =head1 PREREQUISITES
  
  =head2 Prereq Spec
  
  The C<prereqs> key in the top-level metadata and within
  C<optional_features> define the relationship between a distribution and
  other packages.  The prereq spec structure is a hierarchical data
  structure which divides prerequisites into I<Phases> of activity in the
  installation process and I<Relationships> that indicate how
  prerequisites should be resolved.
  
  For example, to specify that C<Data::Dumper> is C<required> during the
  C<test> phase, this entry would appear in the distribution metadata:
  
    prereqs => {
      test => {
        requires => {
          'Data::Dumper' => '2.00'
        }
      }
    }
  
  =head3 Phases
  
  Requirements for regular use must be listed in the C<runtime> phase.
  Other requirements should be listed in the earliest stage in which they
  are required and consumers must accumulate and satisfy requirements
  across phases before executing the activity. For example, C<build>
  requirements must also be available during the C<test> phase.
  
    before action       requirements that must be met
    ----------------    --------------------------------
    perl Build.PL       configure
    perl Makefile.PL
  
    make                configure, runtime, build
    Build
  
    make test           configure, runtime, build, test
    Build test
  
  Consumers that install the distribution must ensure that
  I<runtime> requirements are also installed and may install
  dependencies from other phases.
  
    after action        requirements that must be met
    ----------------    --------------------------------
    make install        runtime
    Build install
  
  =over
  
  =item configure
  
  The configure phase occurs before any dynamic configuration has been
  attempted.  Libraries required by the configure phase B<must> be
  available for use before the distribution building tool has been
  executed.
  
  =item build
  
  The build phase is when the distribution's source code is compiled (if
  necessary) and otherwise made ready for installation.
  
  =item test
  
  The test phase is when the distribution's automated test suite is run.
  Any library that is needed only for testing and not for subsequent use
  should be listed here.
  
  =item runtime
  
  The runtime phase refers not only to when the distribution's contents
  are installed, but also to its continued use.  Any library that is a
  prerequisite for regular use of this distribution should be indicated
  here.
  
  =item develop
  
  The develop phase's prereqs are libraries needed to work on the
  distribution's source code as its author does.  These tools might be
  needed to build a release tarball, to run author-only tests, or to
  perform other tasks related to developing new versions of the
  distribution.
  
  =back
  
  =head3 Relationships
  
  =over
  
  =item requires
  
  These dependencies B<must> be installed for proper completion of the
  phase.
  
  =item recommends
  
  Recommended dependencies are I<strongly> encouraged and should be
  satisfied except in resource constrained environments.
  
  =item suggests
  
  These dependencies are optional, but are suggested for enhanced operation
  of the described distribution.
  
  =item conflicts
  
  These libraries cannot be installed when the phase is in operation.
  This is a very rare situation, and the C<conflicts> relationship should
  be used with great caution, or not at all.
  
  =back
  
  =head2 Merging and Resolving Prerequisites
  
  Whenever metadata consumers merge prerequisites, either from different
  phases or from C<optional_features>, they should merged in a way which
  preserves the intended semantics of the prerequisite structure.  Generally,
  this means concatenating the version specifications using commas, as
  described in the L<Version Ranges> section.
  
  Another subtle error that can occur in resolving prerequisites comes from
  the way that modules in prerequisites are indexed to distribution files on
  CPAN.  When a module is deleted from a distribution, prerequisites calling
  for that module could indicate an older distribution should be installed,
  potentially overwriting files from a newer distribution.
  
  For example, as of Oct 31, 2009, the CPAN index file contained these
  module-distribution mappings:
  
    Class::MOP                   0.94  D/DR/DROLSKY/Class-MOP-0.94.tar.gz
    Class::MOP::Class            0.94  D/DR/DROLSKY/Class-MOP-0.94.tar.gz
    Class::MOP::Class::Immutable 0.04  S/ST/STEVAN/Class-MOP-0.36.tar.gz
  
  Consider the case where "Class::MOP" 0.94 is installed.  If a
  distribution specified "Class::MOP::Class::Immutable" as a prerequisite,
  it could result in Class-MOP-0.36.tar.gz being installed, overwriting
  any files from Class-MOP-0.94.tar.gz.
  
  Consumers of metadata B<should> test whether prerequisites would result
  in installed module files being "downgraded" to an older version and
  B<may> warn users or ignore the prerequisite that would cause such a
  result.
  
  =head1 SERIALIZATION
  
  Distribution metadata should be serialized (as a hashref) as
  JSON-encoded data and packaged with distributions as the file
  F<META.json>.
  
  In the past, the distribution metadata structure had been packed with
  distributions as F<META.yml>, a file in the YAML Tiny format (for which,
  see L<YAML::Tiny>).  Tools that consume distribution metadata from disk
  should be capable of loading F<META.yml>, but should prefer F<META.json>
  if both are found.
  
  =head1 NOTES FOR IMPLEMENTORS
  
  =head2 Extracting Version Numbers from Perl Modules
  
  To get the version number from a Perl module, consumers should use the
  C<< MM->parse_version($file) >> method provided by
  L<ExtUtils::MakeMaker> or L<Module::Metadata>.  For example, for the
  module given by C<$mod>, the version may be retrieved in one of the
  following ways:
  
    # via ExtUtils::MakeMaker
    my $file = MM->_installed_file_for_module($mod);
    my $version = MM->parse_version($file)
  
  The private C<_installed_file_for_module> method may be replaced with
  other methods for locating a module in C<@INC>.
  
    # via Module::Metadata
    my $info = Module::Metadata->new_from_module($mod);
    my $version = $info->version;
  
  If only a filename is available, the following approach may be used:
  
    # via Module::Build
    my $info = Module::Metadata->new_from_file($file);
    my $version = $info->version;
  
  =head2 Comparing Version Numbers
  
  The L<version> module provides the most reliable way to compare version
  numbers in all the various ways they might be provided or might exist
  within modules.  Given two strings containing version numbers, C<$v1> and
  C<$v2>, they should be converted to C<version> objects before using
  ordinary comparison operators.  For example:
  
    use version;
    if ( version->new($v1) <=> version->new($v2) ) {
      print "Versions are not equal\n";
    }
  
  If the only comparison needed is whether an installed module is of a
  sufficiently high version, a direct test may be done using the string
  form of C<eval> and the C<use> function.  For example, for module C<$mod>
  and version prerequisite C<$prereq>:
  
    if ( eval "use $mod $prereq (); 1" ) {
      print "Module $mod version is OK.\n";
    }
  
  If the values of C<$mod> and C<$prereq> have not been scrubbed, however,
  this presents security implications.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  CPAN, L<http://www.cpan.org/>
  
  =item *
  
  JSON, L<http://json.org/>
  
  =item *
  
  YAML, L<http://www.yaml.org/>
  
  =item *
  
  L<CPAN>
  
  =item *
  
  L<CPANPLUS>
  
  =item *
  
  L<ExtUtils::MakeMaker>
  
  =item *
  
  L<Module::Build>
  
  =item *
  
  L<Module::Install>
  
  =back
  
  =head1 HISTORY
  
  Ken Williams wrote the original CPAN Meta Spec (also known as the
  "META.yml spec") in 2003 and maintained it through several revisions
  with input from various members of the community.  In 2005, Randy
  Sims redrafted it from HTML to POD for the version 1.2 release.  Ken
  continued to maintain the spec through version 1.4.
  
  In late 2009, David Golden organized the version 2 proposal review
  process.  David and Ricardo Signes drafted the final version 2 spec
  in April 2010 based on the version 1.4 spec and patches contributed
  during the proposal process.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden and Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META_SPEC

$fatpacked{"CPAN/Meta/Validator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_VALIDATOR';
  use 5.006;
  use strict;
  use warnings;
  package CPAN::Meta::Validator;
  our $VERSION = '2.140640'; # VERSION
  
  # =head1 SYNOPSIS
  #
  #   my $struct = decode_json_file('META.json');
  #
  #   my $cmv = CPAN::Meta::Validator->new( $struct );
  #
  #   unless ( $cmv->is_valid ) {
  #     my $msg = "Invalid META structure.  Errors found:\n";
  #     $msg .= join( "\n", $cmv->errors );
  #     die $msg;
  #   }
  #
  # =head1 DESCRIPTION
  #
  # This module validates a CPAN Meta structure against the version of the
  # the specification claimed in the C<meta-spec> field of the structure.
  #
  # =cut
  
  #--------------------------------------------------------------------------#
  # This code copied and adapted from Test::CPAN::Meta
  # by Barbie, <barbie@cpan.org> for Miss Barbell Productions,
  # L<http://www.missbarbell.co.uk>
  #--------------------------------------------------------------------------#
  
  #--------------------------------------------------------------------------#
  # Specification Definitions
  #--------------------------------------------------------------------------#
  
  my %known_specs = (
      '1.4' => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
      '1.3' => 'http://module-build.sourceforge.net/META-spec-v1.3.html',
      '1.2' => 'http://module-build.sourceforge.net/META-spec-v1.2.html',
      '1.1' => 'http://module-build.sourceforge.net/META-spec-v1.1.html',
      '1.0' => 'http://module-build.sourceforge.net/META-spec-v1.0.html'
  );
  my %known_urls = map {$known_specs{$_} => $_} keys %known_specs;
  
  my $module_map1 = { 'map' => { ':key' => { name => \&module, value => \&exversion } } };
  
  my $module_map2 = { 'map' => { ':key' => { name => \&module, value => \&version   } } };
  
  my $no_index_2 = {
      'map'       => { file       => { list => { value => \&string } },
                       directory  => { list => { value => \&string } },
                       'package'  => { list => { value => \&string } },
                       namespace  => { list => { value => \&string } },
                      ':key'      => { name => \&custom_2, value => \&anything },
      }
  };
  
  my $no_index_1_3 = {
      'map'       => { file       => { list => { value => \&string } },
                       directory  => { list => { value => \&string } },
                       'package'  => { list => { value => \&string } },
                       namespace  => { list => { value => \&string } },
                       ':key'     => { name => \&string, value => \&anything },
      }
  };
  
  my $no_index_1_2 = {
      'map'       => { file       => { list => { value => \&string } },
                       dir        => { list => { value => \&string } },
                       'package'  => { list => { value => \&string } },
                       namespace  => { list => { value => \&string } },
                       ':key'     => { name => \&string, value => \&anything },
      }
  };
  
  my $no_index_1_1 = {
      'map'       => { ':key'     => { name => \&string, list => { value => \&string } },
      }
  };
  
  my $prereq_map = {
    map => {
      ':key' => {
        name => \&phase,
        'map' => {
          ':key'  => {
            name => \&relation,
            %$module_map1,
          },
        },
      }
    },
  };
  
  my %definitions = (
    '2' => {
      # REQUIRED
      'abstract'            => { mandatory => 1, value => \&string  },
      'author'              => { mandatory => 1, list => { value => \&string } },
      'dynamic_config'      => { mandatory => 1, value => \&boolean },
      'generated_by'        => { mandatory => 1, value => \&string  },
      'license'             => { mandatory => 1, list => { value => \&license } },
      'meta-spec' => {
        mandatory => 1,
        'map' => {
          version => { mandatory => 1, value => \&version},
          url     => { value => \&url },
          ':key' => { name => \&custom_2, value => \&anything },
        }
      },
      'name'                => { mandatory => 1, value => \&string  },
      'release_status'      => { mandatory => 1, value => \&release_status },
      'version'             => { mandatory => 1, value => \&version },
  
      # OPTIONAL
      'description' => { value => \&string },
      'keywords'    => { list => { value => \&string } },
      'no_index'    => $no_index_2,
      'optional_features'   => {
        'map'       => {
          ':key'  => {
            name => \&string,
            'map'   => {
              description        => { value => \&string },
              prereqs => $prereq_map,
              ':key' => { name => \&custom_2, value => \&anything },
            }
          }
        }
      },
      'prereqs' => $prereq_map,
      'provides'    => {
        'map'       => {
          ':key' => {
            name  => \&module,
            'map' => {
              file    => { mandatory => 1, value => \&file },
              version => { value => \&version },
              ':key' => { name => \&custom_2, value => \&anything },
            }
          }
        }
      },
      'resources'   => {
        'map'       => {
          license    => { list => { value => \&url } },
          homepage   => { value => \&url },
          bugtracker => {
            'map' => {
              web => { value => \&url },
              mailto => { value => \&string},
              ':key' => { name => \&custom_2, value => \&anything },
            }
          },
          repository => {
            'map' => {
              web => { value => \&url },
              url => { value => \&url },
              type => { value => \&string },
              ':key' => { name => \&custom_2, value => \&anything },
            }
          },
          ':key'     => { value => \&string, name => \&custom_2 },
        }
      },
  
      # CUSTOM -- additional user defined key/value pairs
      # note we can only validate the key name, as the structure is user defined
      ':key'        => { name => \&custom_2, value => \&anything },
    },
  
  '1.4' => {
    'meta-spec'           => {
      mandatory => 1,
      'map' => {
        version => { mandatory => 1, value => \&version},
        url     => { mandatory => 1, value => \&urlspec },
        ':key'  => { name => \&string, value => \&anything },
      },
    },
  
    'name'                => { mandatory => 1, value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'abstract'            => { mandatory => 1, value => \&string  },
    'author'              => { mandatory => 1, list  => { value => \&string } },
    'license'             => { mandatory => 1, value => \&license },
    'generated_by'        => { mandatory => 1, value => \&string  },
  
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'configure_requires'  => $module_map1,
    'conflicts'           => $module_map2,
  
    'optional_features'   => {
      'map'       => {
          ':key'  => { name => \&string,
              'map'   => { description        => { value => \&string },
                           requires           => $module_map1,
                           recommends         => $module_map1,
                           build_requires     => $module_map1,
                           conflicts          => $module_map2,
                           ':key'  => { name => \&string, value => \&anything },
              }
          }
       }
    },
  
    'provides'    => {
      'map'       => {
        ':key' => { name  => \&module,
          'map' => {
            file    => { mandatory => 1, value => \&file },
            version => { value => \&version },
            ':key'  => { name => \&string, value => \&anything },
          }
        }
      }
    },
  
    'no_index'    => $no_index_1_3,
    'private'     => $no_index_1_3,
  
    'keywords'    => { list => { value => \&string } },
  
    'resources'   => {
      'map'       => { license    => { value => \&url },
                       homepage   => { value => \&url },
                       bugtracker => { value => \&url },
                       repository => { value => \&url },
                       ':key'     => { value => \&string, name => \&custom_1 },
      }
    },
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  
  '1.3' => {
    'meta-spec'           => {
      mandatory => 1,
      'map' => {
        version => { mandatory => 1, value => \&version},
        url     => { mandatory => 1, value => \&urlspec },
        ':key'  => { name => \&string, value => \&anything },
      },
    },
  
    'name'                => { mandatory => 1, value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'abstract'            => { mandatory => 1, value => \&string  },
    'author'              => { mandatory => 1, list  => { value => \&string } },
    'license'             => { mandatory => 1, value => \&license },
    'generated_by'        => { mandatory => 1, value => \&string  },
  
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'conflicts'           => $module_map2,
  
    'optional_features'   => {
      'map'       => {
          ':key'  => { name => \&string,
              'map'   => { description        => { value => \&string },
                           requires           => $module_map1,
                           recommends         => $module_map1,
                           build_requires     => $module_map1,
                           conflicts          => $module_map2,
                           ':key'  => { name => \&string, value => \&anything },
              }
          }
       }
    },
  
    'provides'    => {
      'map'       => {
        ':key' => { name  => \&module,
          'map' => {
            file    => { mandatory => 1, value => \&file },
            version => { value => \&version },
            ':key'  => { name => \&string, value => \&anything },
          }
        }
      }
    },
  
  
    'no_index'    => $no_index_1_3,
    'private'     => $no_index_1_3,
  
    'keywords'    => { list => { value => \&string } },
  
    'resources'   => {
      'map'       => { license    => { value => \&url },
                       homepage   => { value => \&url },
                       bugtracker => { value => \&url },
                       repository => { value => \&url },
                       ':key'     => { value => \&string, name => \&custom_1 },
      }
    },
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  
  # v1.2 is misleading, it seems to assume that a number of fields where created
  # within v1.1, when they were created within v1.2. This may have been an
  # original mistake, and that a v1.1 was retro fitted into the timeline, when
  # v1.2 was originally slated as v1.1. But I could be wrong ;)
  '1.2' => {
    'meta-spec'           => {
      mandatory => 1,
      'map' => {
        version => { mandatory => 1, value => \&version},
        url     => { mandatory => 1, value => \&urlspec },
        ':key'  => { name => \&string, value => \&anything },
      },
    },
  
  
    'name'                => { mandatory => 1, value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'license'             => { mandatory => 1, value => \&license },
    'generated_by'        => { mandatory => 1, value => \&string  },
    'author'              => { mandatory => 1, list => { value => \&string } },
    'abstract'            => { mandatory => 1, value => \&string  },
  
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'keywords'            => { list => { value => \&string } },
  
    'private'             => $no_index_1_2,
    '$no_index'           => $no_index_1_2,
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'conflicts'           => $module_map2,
  
    'optional_features'   => {
      'map'       => {
          ':key'  => { name => \&string,
              'map'   => { description        => { value => \&string },
                           requires           => $module_map1,
                           recommends         => $module_map1,
                           build_requires     => $module_map1,
                           conflicts          => $module_map2,
                           ':key'  => { name => \&string, value => \&anything },
              }
          }
       }
    },
  
    'provides'    => {
      'map'       => {
        ':key' => { name  => \&module,
          'map' => {
            file    => { mandatory => 1, value => \&file },
            version => { value => \&version },
            ':key'  => { name => \&string, value => \&anything },
          }
        }
      }
    },
  
    'resources'   => {
      'map'       => { license    => { value => \&url },
                       homepage   => { value => \&url },
                       bugtracker => { value => \&url },
                       repository => { value => \&url },
                       ':key'     => { value => \&string, name => \&custom_1 },
      }
    },
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  
  # note that the 1.1 spec only specifies 'version' as mandatory
  '1.1' => {
    'name'                => { value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'license'             => { value => \&license },
    'generated_by'        => { value => \&string  },
  
    'license_uri'         => { value => \&url },
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'private'             => $no_index_1_1,
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'conflicts'           => $module_map2,
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  
  # note that the 1.0 spec doesn't specify optional or mandatory fields
  # but we will treat version as mandatory since otherwise META 1.0 is
  # completely arbitrary and pointless
  '1.0' => {
    'name'                => { value => \&string  },
    'version'             => { mandatory => 1, value => \&version },
    'license'             => { value => \&license },
    'generated_by'        => { value => \&string  },
  
    'license_uri'         => { value => \&url },
    'distribution_type'   => { value => \&string  },
    'dynamic_config'      => { value => \&boolean },
  
    'requires'            => $module_map1,
    'recommends'          => $module_map1,
    'build_requires'      => $module_map1,
    'conflicts'           => $module_map2,
  
    # additional user defined key/value pairs
    # note we can only validate the key name, as the structure is user defined
    ':key'        => { name => \&string, value => \&anything },
  },
  );
  
  #--------------------------------------------------------------------------#
  # Code
  #--------------------------------------------------------------------------#
  
  # =method new
  #
  #   my $cmv = CPAN::Meta::Validator->new( $struct )
  #
  # The constructor must be passed a metadata structure.
  #
  # =cut
  
  sub new {
    my ($class,$data) = @_;
  
    # create an attributes hash
    my $self = {
      'data'    => $data,
      'spec'    => eval { $data->{'meta-spec'}{'version'} } || "1.0",
      'errors'  => undef,
    };
  
    # create the object
    return bless $self, $class;
  }
  
  # =method is_valid
  #
  #   if ( $cmv->is_valid ) {
  #     ...
  #   }
  #
  # Returns a boolean value indicating whether the metadata provided
  # is valid.
  #
  # =cut
  
  sub is_valid {
      my $self = shift;
      my $data = $self->{data};
      my $spec_version = $self->{spec};
      $self->check_map($definitions{$spec_version},$data);
      return ! $self->errors;
  }
  
  # =method errors
  #
  #   warn( join "\n", $cmv->errors );
  #
  # Returns a list of errors seen during validation.
  #
  # =cut
  
  sub errors {
      my $self = shift;
      return ()   unless(defined $self->{errors});
      return @{$self->{errors}};
  }
  
  # =begin :internals
  #
  # =head2 Check Methods
  #
  # =over
  #
  # =item *
  #
  # check_map($spec,$data)
  #
  # Checks whether a map (or hash) part of the data structure conforms to the
  # appropriate specification definition.
  #
  # =item *
  #
  # check_list($spec,$data)
  #
  # Checks whether a list (or array) part of the data structure conforms to
  # the appropriate specification definition.
  #
  # =item *
  #
  # =back
  #
  # =cut
  
  my $spec_error = "Missing validation action in specification. "
    . "Must be one of 'map', 'list', or 'value'";
  
  sub check_map {
      my ($self,$spec,$data) = @_;
  
      if(ref($spec) ne 'HASH') {
          $self->_error( "Unknown META specification, cannot validate." );
          return;
      }
  
      if(ref($data) ne 'HASH') {
          $self->_error( "Expected a map structure from string or file." );
          return;
      }
  
      for my $key (keys %$spec) {
          next    unless($spec->{$key}->{mandatory});
          next    if(defined $data->{$key});
          push @{$self->{stack}}, $key;
          $self->_error( "Missing mandatory field, '$key'" );
          pop @{$self->{stack}};
      }
  
      for my $key (keys %$data) {
          push @{$self->{stack}}, $key;
          if($spec->{$key}) {
              if($spec->{$key}{value}) {
                  $spec->{$key}{value}->($self,$key,$data->{$key});
              } elsif($spec->{$key}{'map'}) {
                  $self->check_map($spec->{$key}{'map'},$data->{$key});
              } elsif($spec->{$key}{'list'}) {
                  $self->check_list($spec->{$key}{'list'},$data->{$key});
              } else {
                  $self->_error( "$spec_error for '$key'" );
              }
  
          } elsif ($spec->{':key'}) {
              $spec->{':key'}{name}->($self,$key,$key);
              if($spec->{':key'}{value}) {
                  $spec->{':key'}{value}->($self,$key,$data->{$key});
              } elsif($spec->{':key'}{'map'}) {
                  $self->check_map($spec->{':key'}{'map'},$data->{$key});
              } elsif($spec->{':key'}{'list'}) {
                  $self->check_list($spec->{':key'}{'list'},$data->{$key});
              } else {
                  $self->_error( "$spec_error for ':key'" );
              }
  
  
          } else {
              $self->_error( "Unknown key, '$key', found in map structure" );
          }
          pop @{$self->{stack}};
      }
  }
  
  sub check_list {
      my ($self,$spec,$data) = @_;
  
      if(ref($data) ne 'ARRAY') {
          $self->_error( "Expected a list structure" );
          return;
      }
  
      if(defined $spec->{mandatory}) {
          if(!defined $data->[0]) {
              $self->_error( "Missing entries from mandatory list" );
          }
      }
  
      for my $value (@$data) {
          push @{$self->{stack}}, $value || "<undef>";
          if(defined $spec->{value}) {
              $spec->{value}->($self,'list',$value);
          } elsif(defined $spec->{'map'}) {
              $self->check_map($spec->{'map'},$value);
          } elsif(defined $spec->{'list'}) {
              $self->check_list($spec->{'list'},$value);
          } elsif ($spec->{':key'}) {
              $self->check_map($spec,$value);
          } else {
            $self->_error( "$spec_error associated with '$self->{stack}[-2]'" );
          }
          pop @{$self->{stack}};
      }
  }
  
  # =head2 Validator Methods
  #
  # =over
  #
  # =item *
  #
  # header($self,$key,$value)
  #
  # Validates that the header is valid.
  #
  # Note: No longer used as we now read the data structure, not the file.
  #
  # =item *
  #
  # url($self,$key,$value)
  #
  # Validates that a given value is in an acceptable URL format
  #
  # =item *
  #
  # urlspec($self,$key,$value)
  #
  # Validates that the URL to a META specification is a known one.
  #
  # =item *
  #
  # string_or_undef($self,$key,$value)
  #
  # Validates that the value is either a string or an undef value. Bit of a
  # catchall function for parts of the data structure that are completely user
  # defined.
  #
  # =item *
  #
  # string($self,$key,$value)
  #
  # Validates that a string exists for the given key.
  #
  # =item *
  #
  # file($self,$key,$value)
  #
  # Validate that a file is passed for the given key. This may be made more
  # thorough in the future. For now it acts like \&string.
  #
  # =item *
  #
  # exversion($self,$key,$value)
  #
  # Validates a list of versions, e.g. '<= 5, >=2, ==3, !=4, >1, <6, 0'.
  #
  # =item *
  #
  # version($self,$key,$value)
  #
  # Validates a single version string. Versions of the type '5.8.8' and '0.00_00'
  # are both valid. A leading 'v' like 'v1.2.3' is also valid.
  #
  # =item *
  #
  # boolean($self,$key,$value)
  #
  # Validates for a boolean value. Currently these values are '1', '0', 'true',
  # 'false', however the latter 2 may be removed.
  #
  # =item *
  #
  # license($self,$key,$value)
  #
  # Validates that a value is given for the license. Returns 1 if an known license
  # type, or 2 if a value is given but the license type is not a recommended one.
  #
  # =item *
  #
  # custom_1($self,$key,$value)
  #
  # Validates that the given key is in CamelCase, to indicate a user defined
  # keyword and only has characters in the class [-_a-zA-Z].  In version 1.X
  # of the spec, this was only explicitly stated for 'resources'.
  #
  # =item *
  #
  # custom_2($self,$key,$value)
  #
  # Validates that the given key begins with 'x_' or 'X_', to indicate a user
  # defined keyword and only has characters in the class [-_a-zA-Z]
  #
  # =item *
  #
  # identifier($self,$key,$value)
  #
  # Validates that key is in an acceptable format for the META specification,
  # for an identifier, i.e. any that matches the regular expression
  # qr/[a-z][a-z_]/i.
  #
  # =item *
  #
  # module($self,$key,$value)
  #
  # Validates that a given key is in an acceptable module name format, e.g.
  # 'Test::CPAN::Meta::Version'.
  #
  # =back
  #
  # =end :internals
  #
  # =cut
  
  sub header {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 1    if($value && $value =~ /^--- #YAML:1.0/);
      }
      $self->_error( "file does not have a valid YAML header." );
      return 0;
  }
  
  sub release_status {
    my ($self,$key,$value) = @_;
    if(defined $value) {
      my $version = $self->{data}{version} || '';
      if ( $version =~ /_/ ) {
        return 1 if ( $value =~ /\A(?:testing|unstable)\z/ );
        $self->_error( "'$value' for '$key' is invalid for version '$version'" );
      }
      else {
        return 1 if ( $value =~ /\A(?:stable|testing|unstable)\z/ );
        $self->_error( "'$value' for '$key' is invalid" );
      }
    }
    else {
      $self->_error( "'$key' is not defined" );
    }
    return 0;
  }
  
  # _uri_split taken from URI::Split by Gisle Aas, Copyright 2003
  sub _uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub url {
      my ($self,$key,$value) = @_;
      if(defined $value) {
        my ($scheme, $auth, $path, $query, $frag) = _uri_split($value);
        unless ( defined $scheme && length $scheme ) {
          $self->_error( "'$value' for '$key' does not have a URL scheme" );
          return 0;
        }
        unless ( defined $auth && length $auth ) {
          $self->_error( "'$value' for '$key' does not have a URL authority" );
          return 0;
        }
        return 1;
      }
      $value ||= '';
      $self->_error( "'$value' for '$key' is not a valid URL." );
      return 0;
  }
  
  sub urlspec {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 1    if($value && $known_specs{$self->{spec}} eq $value);
          if($value && $known_urls{$value}) {
              $self->_error( 'META specification URL does not match version' );
              return 0;
          }
      }
      $self->_error( 'Unknown META specification' );
      return 0;
  }
  
  sub anything { return 1 }
  
  sub string {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 1    if($value || $value =~ /^0$/);
      }
      $self->_error( "value is an undefined string" );
      return 0;
  }
  
  sub string_or_undef {
      my ($self,$key,$value) = @_;
      return 1    unless(defined $value);
      return 1    if($value || $value =~ /^0$/);
      $self->_error( "No string defined for '$key'" );
      return 0;
  }
  
  sub file {
      my ($self,$key,$value) = @_;
      return 1    if(defined $value);
      $self->_error( "No file defined for '$key'" );
      return 0;
  }
  
  sub exversion {
      my ($self,$key,$value) = @_;
      if(defined $value && ($value || $value =~ /0/)) {
          my $pass = 1;
          for(split(",",$value)) { $self->version($key,$_) or ($pass = 0); }
          return $pass;
      }
      $value = '<undef>'  unless(defined $value);
      $self->_error( "'$value' for '$key' is not a valid version." );
      return 0;
  }
  
  sub version {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 0    unless($value || $value =~ /0/);
          return 1    if($value =~ /^\s*((<|<=|>=|>|!=|==)\s*)?v?\d+((\.\d+((_|\.)\d+)?)?)/);
      } else {
          $value = '<undef>';
      }
      $self->_error( "'$value' for '$key' is not a valid version." );
      return 0;
  }
  
  sub boolean {
      my ($self,$key,$value) = @_;
      if(defined $value) {
          return 1    if($value =~ /^(0|1|true|false)$/);
      } else {
          $value = '<undef>';
      }
      $self->_error( "'$value' for '$key' is not a boolean value." );
      return 0;
  }
  
  my %v1_licenses = (
      'perl'         => 'http://dev.perl.org/licenses/',
      'gpl'          => 'http://www.opensource.org/licenses/gpl-license.php',
      'apache'       => 'http://apache.org/licenses/LICENSE-2.0',
      'artistic'     => 'http://opensource.org/licenses/artistic-license.php',
      'artistic_2'   => 'http://opensource.org/licenses/artistic-license-2.0.php',
      'lgpl'         => 'http://www.opensource.org/licenses/lgpl-license.php',
      'bsd'          => 'http://www.opensource.org/licenses/bsd-license.php',
      'gpl'          => 'http://www.opensource.org/licenses/gpl-license.php',
      'mit'          => 'http://opensource.org/licenses/mit-license.php',
      'mozilla'      => 'http://opensource.org/licenses/mozilla1.1.php',
      'open_source'  => undef,
      'unrestricted' => undef,
      'restrictive'  => undef,
      'unknown'      => undef,
  );
  
  my %v2_licenses = map { $_ => 1 } qw(
    agpl_3
    apache_1_1
    apache_2_0
    artistic_1
    artistic_2
    bsd
    freebsd
    gfdl_1_2
    gfdl_1_3
    gpl_1
    gpl_2
    gpl_3
    lgpl_2_1
    lgpl_3_0
    mit
    mozilla_1_0
    mozilla_1_1
    openssl
    perl_5
    qpl_1_0
    ssleay
    sun
    zlib
    open_source
    restricted
    unrestricted
    unknown
  );
  
  sub license {
      my ($self,$key,$value) = @_;
      my $licenses = $self->{spec} < 2 ? \%v1_licenses : \%v2_licenses;
      if(defined $value) {
          return 1    if($value && exists $licenses->{$value});
      } else {
          $value = '<undef>';
      }
      $self->_error( "License '$value' is invalid" );
      return 0;
  }
  
  sub custom_1 {
      my ($self,$key) = @_;
      if(defined $key) {
          # a valid user defined key should be alphabetic
          # and contain at least one capital case letter.
          return 1    if($key && $key =~ /^[_a-z]+$/i && $key =~ /[A-Z]/);
      } else {
          $key = '<undef>';
      }
      $self->_error( "Custom resource '$key' must be in CamelCase." );
      return 0;
  }
  
  sub custom_2 {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1    if($key && $key =~ /^x_/i);  # user defined
      } else {
          $key = '<undef>';
      }
      $self->_error( "Custom key '$key' must begin with 'x_' or 'X_'." );
      return 0;
  }
  
  sub identifier {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1    if($key && $key =~ /^([a-z][_a-z]+)$/i);    # spec 2.0 defined
      } else {
          $key = '<undef>';
      }
      $self->_error( "Key '$key' is not a legal identifier." );
      return 0;
  }
  
  sub module {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1    if($key && $key =~ /^[A-Za-z0-9_]+(::[A-Za-z0-9_]+)*$/);
      } else {
          $key = '<undef>';
      }
      $self->_error( "Key '$key' is not a legal module name." );
      return 0;
  }
  
  my @valid_phases = qw/ configure build test runtime develop /;
  sub phase {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1 if( length $key && grep { $key eq $_ } @valid_phases );
          return 1 if $key =~ /x_/i;
      } else {
          $key = '<undef>';
      }
      $self->_error( "Key '$key' is not a legal phase." );
      return 0;
  }
  
  my @valid_relations = qw/ requires recommends suggests conflicts /;
  sub relation {
      my ($self,$key) = @_;
      if(defined $key) {
          return 1 if( length $key && grep { $key eq $_ } @valid_relations );
          return 1 if $key =~ /x_/i;
      } else {
          $key = '<undef>';
      }
      $self->_error( "Key '$key' is not a legal prereq relationship." );
      return 0;
  }
  
  sub _error {
      my $self = shift;
      my $mess = shift;
  
      $mess .= ' ('.join(' -> ',@{$self->{stack}}).')'  if($self->{stack});
      $mess .= " [Validation: $self->{spec}]";
  
      push @{$self->{errors}}, $mess;
  }
  
  1;
  
  # ABSTRACT: validate CPAN distribution metadata structures
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  CPAN::Meta::Validator - validate CPAN distribution metadata structures
  
  =head1 VERSION
  
  version 2.140640
  
  =head1 SYNOPSIS
  
    my $struct = decode_json_file('META.json');
  
    my $cmv = CPAN::Meta::Validator->new( $struct );
  
    unless ( $cmv->is_valid ) {
      my $msg = "Invalid META structure.  Errors found:\n";
      $msg .= join( "\n", $cmv->errors );
      die $msg;
    }
  
  =head1 DESCRIPTION
  
  This module validates a CPAN Meta structure against the version of the
  the specification claimed in the C<meta-spec> field of the structure.
  
  =head1 METHODS
  
  =head2 new
  
    my $cmv = CPAN::Meta::Validator->new( $struct )
  
  The constructor must be passed a metadata structure.
  
  =head2 is_valid
  
    if ( $cmv->is_valid ) {
      ...
    }
  
  Returns a boolean value indicating whether the metadata provided
  is valid.
  
  =head2 errors
  
    warn( join "\n", $cmv->errors );
  
  Returns a list of errors seen during validation.
  
  =begin :internals
  
  =head2 Check Methods
  
  =over
  
  =item *
  
  check_map($spec,$data)
  
  Checks whether a map (or hash) part of the data structure conforms to the
  appropriate specification definition.
  
  =item *
  
  check_list($spec,$data)
  
  Checks whether a list (or array) part of the data structure conforms to
  the appropriate specification definition.
  
  =item *
  
  =back
  
  =head2 Validator Methods
  
  =over
  
  =item *
  
  header($self,$key,$value)
  
  Validates that the header is valid.
  
  Note: No longer used as we now read the data structure, not the file.
  
  =item *
  
  url($self,$key,$value)
  
  Validates that a given value is in an acceptable URL format
  
  =item *
  
  urlspec($self,$key,$value)
  
  Validates that the URL to a META specification is a known one.
  
  =item *
  
  string_or_undef($self,$key,$value)
  
  Validates that the value is either a string or an undef value. Bit of a
  catchall function for parts of the data structure that are completely user
  defined.
  
  =item *
  
  string($self,$key,$value)
  
  Validates that a string exists for the given key.
  
  =item *
  
  file($self,$key,$value)
  
  Validate that a file is passed for the given key. This may be made more
  thorough in the future. For now it acts like \&string.
  
  =item *
  
  exversion($self,$key,$value)
  
  Validates a list of versions, e.g. '<= 5, >=2, ==3, !=4, >1, <6, 0'.
  
  =item *
  
  version($self,$key,$value)
  
  Validates a single version string. Versions of the type '5.8.8' and '0.00_00'
  are both valid. A leading 'v' like 'v1.2.3' is also valid.
  
  =item *
  
  boolean($self,$key,$value)
  
  Validates for a boolean value. Currently these values are '1', '0', 'true',
  'false', however the latter 2 may be removed.
  
  =item *
  
  license($self,$key,$value)
  
  Validates that a value is given for the license. Returns 1 if an known license
  type, or 2 if a value is given but the license type is not a recommended one.
  
  =item *
  
  custom_1($self,$key,$value)
  
  Validates that the given key is in CamelCase, to indicate a user defined
  keyword and only has characters in the class [-_a-zA-Z].  In version 1.X
  of the spec, this was only explicitly stated for 'resources'.
  
  =item *
  
  custom_2($self,$key,$value)
  
  Validates that the given key begins with 'x_' or 'X_', to indicate a user
  defined keyword and only has characters in the class [-_a-zA-Z]
  
  =item *
  
  identifier($self,$key,$value)
  
  Validates that key is in an acceptable format for the META specification,
  for an identifier, i.e. any that matches the regular expression
  qr/[a-z][a-z_]/i.
  
  =item *
  
  module($self,$key,$value)
  
  Validates that a given key is in an acceptable module name format, e.g.
  'Test::CPAN::Meta::Version'.
  
  =back
  
  =end :internals
  
  =for Pod::Coverage anything boolean check_list custom_1 custom_2 exversion file
  identifier license module phase relation release_status string string_or_undef
  url urlspec version header check_map
  
  =head1 BUGS
  
  Please report any bugs or feature using the CPAN Request Tracker.
  Bugs can be submitted through the web interface at
  L<http://rt.cpan.org/Dist/Display.html?Queue=CPAN-Meta>
  
  When submitting a bug or request, please include a test-file or a patch to an
  existing test-file that illustrates the bug or desired feature.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by David Golden and Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
CPAN_META_VALIDATOR

$fatpacked{"Carton.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON';
  package Carton;
  use strict;
  use 5.008_005;
  use version; our $VERSION = version->declare("v1.0.12");
  
  1;
  __END__
  
  =head1 NAME
  
  Carton - Perl module dependency manager (aka Bundler for Perl)
  
  =head1 SYNOPSIS
  
    # On your development environment
    > cat cpanfile
    requires 'Plack', '0.9980';
    requires 'Starman', '0.2000';
  
    > carton install
    > git add cpanfile cpanfile.snapshot
    > git commit -m "add Plack and Starman"
  
    # Other developer's machine, or on a deployment box
    > carton install
    > carton exec starman -p 8080 myapp.psgi
  
  =head1 AVAILABILITY
  
  Carton only works with perl installation with the complete set of core
  modules. If you use perl installed by a vendor package with modules
  stripped from core, Carton is not expected to work correctly.
  
  Also, Carton requires you to run your command/application with
  C<carton exec> command, which means it's difficult or impossible to
  run in an embedded perl use case such as mod_perl.
  
  =head1 DESCRIPTION
  
  carton is a command line tool to track the Perl module dependencies
  for your Perl application. Dependencies are declared using L<cpanfile>
  format, and the managed dependencies are tracked in a
  I<cpanfile.snapshot> file, which is meant to be version controlled,
  and the snapshot file allows other developers of your application will
  have the exact same versions of the modules.
  
  For C<cpanfile> syntax, see L<cpanfile> documentation.
  
  =head1 TUTORIAL
  
  =head2 Initializing the environment
  
  carton will use the I<local> directory to install modules into. You're
  recommended to exclude these directories from the version control
  system.
  
    > echo local/ >> .gitignore
    > git add cpanfile cpanfile.snapshot
    > git commit -m "Start using carton"
  
  =head2 Tracking the dependencies
  
  You can manage the dependencies of your application via C<cpanfile>.
  
    # cpanfile
    requires 'Plack', '0.9980';
    requires 'Starman', '0.2000';
  
  And then you can install these dependencies via:
  
    > carton install
  
  The modules are installed into your I<local> directory, and the
  dependencies tree and version information are analyzed and saved into
  I<cpanfile.snapshot> in your directory.
  
  Make sure you add I<cpanfile> and I<cpanfile.snapshot> to your version
  controlled repository and commit changes as you update
  dependencies. This will ensure that other developers on your app, as
  well as your deployment environment, use exactly the same versions of
  the modules you just installed.
  
    > git add cpanfile cpanfile.snapshot
    > git commit -m "Added Plack and Starman"
  
  =head2 Deploying your application
  
  Once you've done installing all the dependencies, you can push your
  application directory to a remote machine (excluding I<local> and
  I<.carton>) and run the following command:
  
    > carton install --deployment
  
  This will look at the I<cpanfile.snapshot> and install the exact same
  versions of the dependencies into I<local>, and now your application
  is ready to run.
  
  The C<--deployment> flag makes sure that carton will only install
  modules and versions available in your snapshot, and won't fallback to
  query for CPAN Meta DB for missing modules.
  
  =head2 Bundling modules
  
  carton can bundle all the tarballs for your dependencies into a
  directory so that you can even install dependencies that are not
  available on CPAN, such as internal distribution aka DarkPAN.
  
    > carton bundle
  
  will bundle these tarballs into I<vendor/cache> directory, and
  
    > carton install --cached
  
  will install modules using this local cache. Combined with
  C<--deployment> option, you can avoid querying for a database like
  CPAN Meta DB or downloading files from CPAN mirrors upon deployment
  time.
  
  =head1 PERL VERSIONS
  
  When you take a snapshot in one perl version and deploy on another
  (different) version, you might have troubles with core modules.
  
  The simplest solution, which might not work for everybody, is to use
  the same version of perl in the development and deployment.
  
  To enforce that, you're recommended to use L<plenv> and
  C<.perl-version> to lock perl versions in development.
  
  You can also specify the minimum perl required in C<cpanfile>:
  
    requires 'perl', '5.16.3';
  
  and carton (and cpanm) will give you errors when deployed on hosts
  with perl lower than the specified version.
  
  =head1 COMMUNITY
  
  =over 4
  
  =item L<https://github.com/miyagawa/carton>
  
  Code repository, Wiki and Issue Tracker
  
  =item L<irc://irc.perl.org/#carton>
  
  IRC chat room
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 COPYRIGHT
  
  Tatsuhiko Miyagawa 2011-
  
  =head1 LICENSE
  
  This software is licensed under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<cpanm>
  
  L<cpanfile>
  
  L<Bundler|http://gembundler.com/>
  
  L<pip|http://pypi.python.org/pypi/pip>
  
  L<npm|http://npmjs.org/>
  
  L<perlrocks|https://github.com/gugod/perlrocks>
  
  L<only>
  
  =cut
CARTON

$fatpacked{"Carton/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_BUILDER';
  package Carton::Builder;
  use Moo;
  use warnings NONFATAL => 'all';
  no warnings 'once';
  
  has mirror  => (is => 'rw');
  has index   => (is => 'rw');
  has cascade => (is => 'rw', default => sub { 1 });
  has without => (is => 'rw', default => sub { [] });
  has cpanfile => (is => 'rw');
  has fatscript => (is => 'lazy');
  
  sub effective_mirrors {
      my $self = shift;
  
      # push default CPAN mirror always, as a fallback
      # TODO don't pass fallback if --cached is set?
  
      my @mirrors = ($self->mirror);
      push @mirrors, Carton::Mirror->default if $self->custom_mirror;
      push @mirrors, Carton::Mirror->new('http://backpan.perl.org/');
  
      @mirrors;
  }
  
  sub custom_mirror {
      my $self = shift;
      ! $self->mirror->is_default;
  }
  
  sub bundle {
      my($self, $path, $cache_path, $snapshot) = @_;
  
      for my $dist ($snapshot->distributions) {
          my $source = $path->child("cache/authors/id/" . $dist->pathname);
          my $target = $cache_path->child("authors/id/" . $dist->pathname);
  
          if ($source->exists) {
              warn "Copying ", $dist->pathname, "\n";
              $target->parent->mkpath;
              $source->copy($target) or warn "$target: $!";
          } else {
              warn "Couldn't find @{[ $dist->pathname ]}\n";
          }
      }
  }
  
  sub install {
      my($self, $path) = @_;
  
      $self->run_cpanm(
          "-L", $path,
          (map { ("--mirror", $_->url) } $self->effective_mirrors),
          ( $self->index ? ("--mirror-index", $self->index) : () ),
          ( $self->cascade ? "--cascade-search" : () ),
          ( $self->custom_mirror ? "--mirror-only" : () ),
          "--save-dists", "$path/cache",
          $self->groups,
          "--cpanfile", $self->cpanfile,
          "--installdeps", $self->cpanfile->dirname,
      ) or die "Installing modules failed\n";
  }
  
  sub groups {
      my $self = shift;
  
      # TODO support --without test (don't need test on deployment)
      my @options = ('--with-all-features', '--with-develop');
  
      for my $group (@{$self->without}) {
          push @options, '--without-develop' if $group eq 'develop';
          push @options, "--without-feature=$group";
      }
  
      return @options;
  }
  
  sub update {
      my($self, $path, @modules) = @_;
  
      $self->run_cpanm(
          "-L", $path,
          (map { ("--mirror", $_->url) } $self->effective_mirrors),
          ( $self->custom_mirror ? "--mirror-only" : () ),
          "--save-dists", "$path/cache",
          @modules
      ) or die "Updating modules failed\n";
  }
  
  sub _build_fatscript {
      my $self = shift;
  
      my $fatscript;
      if ($Carton::Fatpacked) {
          require Module::Reader;
          my $content = Module::Reader::module_content('App::cpanminus::fatscript')
              or die "Can't locate App::cpanminus::fatscript";
          $fatscript = Path::Tiny->tempfile;
          $fatscript->spew($content);
      } else {
          require Module::Metadata;
          $fatscript = Module::Metadata->find_module_by_name("App::cpanminus::fatscript")
              or die "Can't locate App::cpanminus::fatscript";
      }
  
      return $fatscript;
  }
  
  sub run_cpanm {
      my($self, @args) = @_;
      local $ENV{PERL_CPANM_OPT};
      !system $^X, $self->fatscript, "--quiet", "--notest", @args;
  }
  
  1;
CARTON_BUILDER

$fatpacked{"Carton/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CLI';
  package Carton::CLI;
  use Moo;
  use warnings NONFATAL => 'all';
  
  use Config;
  use Getopt::Long;
  use Path::Tiny;
  use Try::Tiny;
  use Module::CoreList;
  use Scalar::Util qw(blessed);
  
  use Carton;
  use Carton::Builder;
  use Carton::Mirror;
  use Carton::Snapshot;
  use Carton::Util;
  use Carton::Environment;
  use Carton::Error;
  
  use constant { SUCCESS => 0, INFO => 1, WARN => 2, ERROR => 3 };
  
  our $UseSystem = 0; # 1 for unit testing
  
  has verbose => (is => 'rw');
  has carton  => (is => 'lazy');
  has mirror  => (is => 'rw', builder => 1,
                  coerce => sub { Carton::Mirror->new($_[0]) });
  
  sub _build_mirror {
      my $self = shift;
      $ENV{PERL_CARTON_MIRROR} || $Carton::Mirror::DefaultMirror;
  }
  
  sub run {
      my($self, @args) = @_;
  
      my @commands;
      my $p = Getopt::Long::Parser->new(
          config => [ "no_ignore_case", "pass_through" ],
      );
      $p->getoptionsfromarray(
          \@args,
          "h|help"    => sub { unshift @commands, 'help' },
          "v|version" => sub { unshift @commands, 'version' },
          "verbose!"  => sub { $self->verbose($_[1]) },
      );
  
      push @commands, @args;
  
      my $cmd = shift @commands || 'install';
  
      my $code = try {
          my $call = $self->can("cmd_$cmd")
              or Carton::Error::CommandNotFound->throw(error => "Could not find command '$cmd'");
          $self->$call(@commands);
          return 0;
      } catch {
          die $_ unless blessed $_ && $_->can('rethrow');
  
          if ($_->isa('Carton::Error::CommandExit')) {
              return $_->code || 255;
          } elsif ($_->isa('Carton::Error::CommandNotFound')) {
              warn $_->error, "\n\n";
              $self->cmd_usage;
              return 255;
          } elsif ($_->isa('Carton::Error')) {
              warn $_->error, "\n";
              return 255;
          }
      };
  
      return $code;
  }
  
  sub commands {
      my $self = shift;
  
      no strict 'refs';
      map { s/^cmd_//; $_ }
          grep { /^cmd_.*/ && $self->can($_) } sort keys %{__PACKAGE__."::"};
  }
  
  sub cmd_usage {
      my $self = shift;
      $self->print(<<HELP);
  Usage: carton <command>
  
  where <command> is one of:
    @{[ join ", ", $self->commands ]}
  
  Run carton -h <command> for help.
  HELP
  }
  
  sub parse_options {
      my($self, $args, @spec) = @_;
      my $p = Getopt::Long::Parser->new(
          config => [ "no_auto_abbrev", "no_ignore_case" ],
      );
      $p->getoptionsfromarray($args, @spec);
  }
  
  sub parse_options_pass_through {
      my($self, $args, @spec) = @_;
  
      my $p = Getopt::Long::Parser->new(
          config => [ "no_auto_abbrev", "no_ignore_case", "pass_through" ],
      );
      $p->getoptionsfromarray($args, @spec);
  
      # with pass_through keeps -- in args
      shift @$args if $args->[0] && $args->[0] eq '--';
  }
  
  sub printf {
      my $self = shift;
      my $type = pop;
      my($temp, @args) = @_;
      $self->print(sprintf($temp, @args), $type);
  }
  
  sub print {
      my($self, $msg, $type) = @_;
      my $fh = $type && $type >= WARN ? *STDERR : *STDOUT;
      print {$fh} $msg;
  }
  
  sub error {
      my($self, $msg) = @_;
      $self->print($msg, ERROR);
      Carton::Error::CommandExit->throw;
  }
  
  sub cmd_help {
      my $self = shift;
      my $module = $_[0] ? ("Carton::Doc::" . ucfirst $_[0]) : "Carton.pm";
      system "perldoc", $module;
  }
  
  sub cmd_version {
      my $self = shift;
      $self->print("carton $Carton::VERSION\n");
  }
  
  sub cmd_bundle {
      my($self, @args) = @_;
  
      my $fatpack = 1;
      $self->parse_options(
          \@args,
          "fatpack!" => \$fatpack,
      );
  
      my $env = Carton::Environment->build;
      $env->snapshot->load;
  
      $self->print("Bundling modules using @{[$env->cpanfile]}\n");
  
      my $builder = Carton::Builder->new(
          mirror => $self->mirror,
          cpanfile => $env->cpanfile,
      );
      $builder->bundle($env->install_path, $env->vendor_cache, $env->snapshot);
  
      if ($fatpack) {
          require Carton::Packer;
          Carton::Packer->new->fatpack_carton($env->vendor_bin);
      }
  
      $self->printf("Complete! Modules were bundled into %s\n", $env->vendor_cache, SUCCESS);
  }
  
  sub cmd_install {
      my($self, @args) = @_;
  
      my($install_path, $cpanfile_path, @without);
  
      $self->parse_options(
          \@args,
          "p|path=s"    => \$install_path,
          "cpanfile=s"  => \$cpanfile_path,
          "without=s"   => sub { push @without, split /,/, $_[1] },
          "deployment!" => \my $deployment,
          "cached!"     => \my $cached,
      );
  
      my $env = Carton::Environment->build($cpanfile_path, $install_path);
      $env->snapshot->load_if_exists;
  
      if ($deployment && !$env->snapshot->loaded) {
          $self->error("--deployment requires cpanfile.snapshot: Run `carton install` and make sure cpanfile.snapshot is checked into your version control.\n");
      }
  
      my $builder = Carton::Builder->new(
          cascade => 1,
          mirror  => $self->mirror,
          without => \@without,
          cpanfile => $env->cpanfile,
      );
  
      # TODO: --without with no .lock won't fetch the groups, resulting in insufficient requirements
  
      if ($deployment) {
          $self->print("Installing modules using @{[$env->cpanfile]} (deployment mode)\n");
          $builder->cascade(0);
      } else {
          $self->print("Installing modules using @{[$env->cpanfile]}\n");
      }
  
      # TODO merge CPANfile git to mirror even if lock doesn't exist
      if ($env->snapshot->loaded) {
          my $index_file = $env->install_path->child("cache/modules/02packages.details.txt");
             $index_file->parent->mkpath;
  
          $env->snapshot->write_index($index_file);
          $builder->index($index_file);
      }
  
      if ($cached) {
          $builder->mirror(Carton::Mirror->new($env->vendor_cache));
      }
  
      $builder->install($env->install_path);
  
      unless ($deployment) {
          $env->cpanfile->load;
          $env->snapshot->find_installs($env->install_path, $env->cpanfile->requirements);
          $env->snapshot->save;
      }
  
      $self->print("Complete! Modules were installed into @{[$env->install_path]}\n", SUCCESS);
  }
  
  sub cmd_show {
      my($self, @args) = @_;
  
      my $env = Carton::Environment->build;
      $env->snapshot->load;
  
      for my $module (@args) {
          my $dist = $env->snapshot->find($module)
              or $self->error("Couldn't locate $module in cpanfile.snapshot\n");
          $self->print( $dist->name . "\n" );
      }
  }
  
  sub cmd_list {
      my($self, @args) = @_;
  
      my $format = 'name';
  
      $self->parse_options(
          \@args,
          "distfile" => sub { $format = 'distfile' },
      );
  
      my $env = Carton::Environment->build;
      $env->snapshot->load;
  
      for my $dist ($env->snapshot->distributions) {
          $self->print($dist->$format . "\n");
      }
  }
  
  sub cmd_tree {
      my($self, @args) = @_;
  
      my $env = Carton::Environment->build;
      $env->snapshot->load;
      $env->cpanfile->load;
  
      my %seen;
      my $dumper = sub {
          my($dependency, $reqs, $level) = @_;
          return if $level == 0;
          return Carton::Tree::STOP if $dependency->dist->is_core;
          return Carton::Tree::STOP if $seen{$dependency->distname}++;
          $self->printf( "%s%s (%s)\n", " " x ($level - 1), $dependency->module, $dependency->distname, INFO );
      };
  
      $env->tree->walk_down($dumper);
  }
  
  sub cmd_check {
      my($self, @args) = @_;
  
      my $cpanfile_path;
      $self->parse_options(
          \@args,
          "cpanfile=s"  => \$cpanfile_path,
      );
  
      my $env = Carton::Environment->build($cpanfile_path);
      $env->snapshot->load;
      $env->cpanfile->load;
  
      # TODO remove snapshot
      # TODO pass git spec to Requirements?
      my $merged_reqs = $env->tree->merged_requirements;
  
      my @missing;
      for my $module ($merged_reqs->required_modules) {
          my $install = $env->snapshot->find_or_core($module);
          if ($install) {
              unless ($merged_reqs->accepts_module($module => $install->version_for($module))) {
                  push @missing, [ $module, 1, $install->version_for($module) ];
              }
          } else {
              push @missing, [ $module, 0 ];
          }
      }
  
      if (@missing) {
          $self->print("Following dependencies are not satisfied.\n", INFO);
          for my $missing (@missing) {
              my($module, $unsatisfied, $version) = @$missing;
              if ($unsatisfied) {
                  $self->printf("  %s has version %s. Needs %s\n",
                                $module, $version, $merged_reqs->requirements_for_module($module), INFO);
              } else {
                  $self->printf("  %s is not installed. Needs %s\n",
                                $module, $merged_reqs->requirements_for_module($module), INFO);
              }
          }
          $self->printf("Run `carton install` to install them.\n", INFO);
          Carton::Error::CommandExit->throw;
      } else {
          $self->print("cpanfile's dependencies are satisfied.\n", INFO);
      }
  }
  
  sub cmd_update {
      my($self, @args) = @_;
  
      my $env = Carton::Environment->build;
      $env->cpanfile->load;
  
  
      my $cpanfile = Module::CPANfile->load($env->cpanfile);
      @args = grep { $_ ne 'perl' } $env->cpanfile->required_modules unless @args;
  
      $env->snapshot->load;
  
      my @modules;
      for my $module (@args) {
          my $dist = $env->snapshot->find_or_core($module)
              or $self->error("Could not find module $module.\n");
          next if $dist->is_core;
          push @modules, "$module~" . $env->cpanfile->requirements_for_module($module);
      }
  
      my $builder = Carton::Builder->new(
          mirror => $self->mirror,
          cpanfile => $env->cpanfile,
      );
      $builder->update($env->install_path, @modules);
  
      $env->snapshot->find_installs($env->install_path, $env->cpanfile->requirements);
      $env->snapshot->save;
  }
  
  sub cmd_exec {
      my($self, @args) = @_;
  
      my $env = Carton::Environment->build;
      $env->snapshot->load;
  
      # allows -Ilib
      @args = map { /^(-[I])(.+)/ ? ($1,$2) : $_ } @args;
  
      while (@args) {
          if ($args[0] eq '-I') {
              warn "exec -Ilib is deprecated. You might want to run: carton exec perl -Ilib ...\n";
              splice(@args, 0, 2);
          } else {
              last;
          }
      }
  
      $self->parse_options_pass_through(\@args); # to handle --
  
      unless (@args) {
          $self->error("carton exec needs a command to run.\n");
      }
  
      # PERL5LIB takes care of arch
      my $path = $env->install_path;
      local $ENV{PERL5LIB} = "$path/lib/perl5";
      local $ENV{PATH} = "$path/bin:$ENV{PATH}";
  
      $UseSystem ? system(@args) : exec(@args);
  }
  
  1;
CARTON_CLI

$fatpacked{"Carton/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CPANFILE';
  package Carton::CPANfile;
  use Moo;
  use warnings NONFATAL => 'all';
  use Path::Tiny ();
  use Module::CPANfile;
  
  use overload q{""} => sub { $_[0]->stringify }, fallback => 1;
  
  has path => (is => 'rw', coerce => sub { Path::Tiny->new($_[0]) }, handles => [ qw(stringify dirname) ]);
  has _cpanfile => (is => 'rw', handles => [ qw(prereqs) ]);
  has requirements => (is => 'rw', lazy => 1, builder => 1, handles => [ qw(required_modules requirements_for_module) ]);
  
  sub load {
      my $self = shift;
      $self->_cpanfile( Module::CPANfile->load($self->path) );
  }
  
  sub _build_requirements {
      my $self = shift;
      my $reqs = CPAN::Meta::Requirements->new;
      $reqs->add_requirements($self->prereqs->requirements_for($_, 'requires'))
          for qw( configure build runtime test develop );
      $reqs->clear_requirement('perl');
      $reqs;
  }
  
  1;
CARTON_CPANFILE

$fatpacked{"Carton/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DEPENDENCY';
  package Carton::Dependency;
  use Moo;
  use warnings NONFATAL => 'all';
  
  has module => (is => 'rw');
  has requirement => (is => 'rw');
  has dist => (is => 'rw', handles => [ qw(requirements) ]);
  
  sub distname {
      my $self = shift;
      $self->dist->name;
  }
  
  sub version {
      my $self = shift;
      $self->dist->version_for($self->module);
  }
  
  1;
CARTON_DEPENDENCY

$fatpacked{"Carton/Dist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST';
  package Carton::Dist;
  use Moo;
  use warnings NONFATAL => 'all';
  use CPAN::Meta;
  
  has name     => (is => 'ro');
  has pathname => (is => 'rw');
  has provides => (is => 'rw', default => sub { +{} });
  has requirements => (is => 'rw', lazy => 1, builder => 1,
                       handles => [ qw(add_string_requirement required_modules requirements_for_module) ]);
  
  sub is_core { 0 }
  
  sub distfile {
      my $self = shift;
      $self->pathname;
  }
  
  sub _build_requirements {
      CPAN::Meta::Requirements->new;
  }
  
  sub provides_module {
      my($self, $module) = @_;
      exists $self->provides->{$module};
  }
  
  sub version_for {
      my($self, $module) = @_;
      $self->provides->{$module}{version};
  }
  
  1;
CARTON_DIST

$fatpacked{"Carton/Dist/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST_CORE';
  package Carton::Dist::Core;
  use Moo;
  use warnings NONFATAL => 'all';
  extends 'Carton::Dist';
  
  has module_version => (is => 'ro');
  
  sub BUILDARGS {
      my($class, %args) = @_;
  
      # TODO represent dual-life
      $args{name} =~ s/::/-/g;
  
      \%args;
  }
  
  sub is_core { 1 }
  
  sub version_for {
      my($self, $module) = @_;
      $self->module_version;
  }
  
  1;
CARTON_DIST_CORE

$fatpacked{"Carton/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ENVIRONMENT';
  package Carton::Environment;
  use Moo;
  use warnings NONFATAL => 'all';
  
  use Carton::CPANfile;
  use Carton::Snapshot;
  use Carton::Error;
  use Carton::Tree;
  use Path::Tiny;
  
  has cpanfile => (is => 'rw');
  has snapshot => (is => 'lazy');
  has install_path => (is => 'rw', lazy => 1, builder => 1, coerce => sub { Path::Tiny->new($_[0])->absolute });
  has vendor_cache  => (is => 'lazy');
  has tree => (is => 'rw', lazy => 1, builder => 1);
  
  sub _build_snapshot {
      my $self = shift;
      Carton::Snapshot->new(path => $self->cpanfile->stringify . ".snapshot");
  }
  
  sub _build_install_path {
      my $self = shift;
      if ($ENV{PERL_CARTON_PATH}) {
          return $ENV{PERL_CARTON_PATH};
      } else {
          return $self->cpanfile->dirname . "/local";
      }
  }
  
  sub _build_vendor_cache {
      my $self = shift;
      Path::Tiny->new($self->install_path->dirname . "/vendor/cache");
  }
  
  sub _build_tree {
      my $self = shift;
      Carton::Tree->new(cpanfile => $self->cpanfile, snapshot => $self->snapshot);
  }
  
  sub vendor_bin {
      my $self = shift;
      $self->vendor_cache->parent->child('bin');
  }
  
  sub build_with {
      my($class, $cpanfile) = @_;
  
      $cpanfile = Path::Tiny->new($cpanfile)->absolute;
      if ($cpanfile->is_file) {
          return $class->new(cpanfile => Carton::CPANfile->new(path => $cpanfile));
      } else {
          Carton::Error::CPANfileNotFound->throw(error => "Can't locate cpanfile: $cpanfile");
      }
  }
  
  sub build {
      my($class, $cpanfile_path, $install_path) = @_;
  
      my $self = $class->new;
  
      $cpanfile_path &&= Path::Tiny->new($cpanfile_path)->absolute;
  
      my $cpanfile = $self->locate_cpanfile($cpanfile_path || $ENV{PERL_CARTON_CPANFILE});
      if ($cpanfile && $cpanfile->is_file) {
          $self->cpanfile( Carton::CPANfile->new(path => $cpanfile) );
      } else {
          Carton::Error::CPANfileNotFound->throw(error => "Can't locate cpanfile: (@{[ $cpanfile_path || 'cpanfile' ]})");
      }
  
      $self->install_path($install_path) if $install_path;
  
      $self;
  }
  
  sub locate_cpanfile {
      my($self, $path) = @_;
  
      if ($path) {
          return Path::Tiny->new($path)->absolute;
      }
  
      my $current  = Path::Tiny->cwd;
      my $previous = '';
  
      until ($current eq '/' or $current eq $previous) {
          # TODO support PERL_CARTON_CPANFILE
          my $try = $current->child('cpanfile');
          if ($try->is_file) {
              return $try->absolute;
          }
  
          ($previous, $current) = ($current, $current->parent);
      }
  
      return;
  }
  
  1;
  
CARTON_ENVIRONMENT

$fatpacked{"Carton/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ERROR';
  package Carton::Error;
  use strict;
  use Exception::Class (
      'Carton::Error',
      'Carton::Error::CommandNotFound' => { isa => 'Carton::Error' },
      'Carton::Error::CommandExit' => { isa => 'Carton::Error', fields => [ 'code' ] },
      'Carton::Error::CPANfileNotFound' => { isa => 'Carton::Error' },
      'Carton::Error::SnapshotParseError' => { isa => 'Carton::Error', fields => [ 'path' ] },
      'Carton::Error::SnapshotNotFound' => { isa => 'Carton::Error', fields => [ 'path' ] },
  );
  
  1;
CARTON_ERROR

$fatpacked{"Carton/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_INDEX';
  package Carton::Index;
  use Moo;
  use warnings NONFATAL => 'all';
  
  has _packages => (is => 'rw', default => sub { +{} });
  
  sub add_package {
      my($self, $package) = @_;
      $self->_packages->{$package->name} = $package; # XXX ||=
  }
  
  sub count {
      my $self = shift;
      scalar keys %{$self->_packages};
  }
  
  sub packages {
      my $self = shift;
      sort { $a->name cmp $b->name } values %{$self->_packages};
  }
  
  sub write {
      my($self, $fh) = @_;
  
      print $fh <<EOF;
  File:         02packages.details.txt
  URL:          http://www.perl.com/CPAN/modules/02packages.details.txt
  Description:  Package names found in cpanfile.snapshot
  Columns:      package name, version, path
  Intended-For: Automated fetch routines, namespace documentation.
  Written-By:   Carton $Carton::VERSION
  Line-Count:   @{[ $self->count ]}
  Last-Updated: @{[ scalar localtime ]}
  
  EOF
      for my $p ($self->packages) {
          print $fh sprintf "%s %s  %s\n", pad($p->name, 32), pad($p->version || 'undef', 10, 1), $p->pathname;
      }
  }
  
  sub pad {
      my($str, $len, $left) = @_;
  
      my $howmany = $len - length($str);
      return $str if $howmany <= 0;
  
      my $pad = " " x $howmany;
      return $left ? "$pad$str" : "$str$pad";
  }
  
  
  1;
CARTON_INDEX

$fatpacked{"Carton/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_MIRROR';
  package Carton::Mirror;
  use Moo;
  use warnings NONFATAL => 'all';
  
  our $DefaultMirror = 'http://cpan.metacpan.org/';
  
  has url => (is => 'ro');
  
  sub BUILDARGS {
      my($class, $url) = @_;
      return { url => $url };
  }
  
  sub default {
      my $class = shift;
      $class->new($DefaultMirror);
  }
  
  sub is_default {
      my $self = shift;
      $self->url eq $DefaultMirror;
  }
  
  1;
  
CARTON_MIRROR

$fatpacked{"Carton/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKAGE';
  package Carton::Package;
  use Moo;
  use warnings NONFATAL => 'all';
  
  has name     => (is => 'ro');
  has version  => (is => 'ro');
  has pathname => (is => 'ro');
  
  sub BUILDARGS {
      my($class, @args) = @_;
      return { name => $args[0], version => $args[1], pathname => $args[2] };
  }
  
  1;
  
  
CARTON_PACKAGE

$fatpacked{"Carton/Packer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKER';
  package Carton::Packer;
  use Moo;
  use warnings NONFATAL => 'all';
  use App::FatPacker;
  use File::pushd ();
  use Path::Tiny ();
  use CPAN::Meta ();
  use File::Find ();
  
  sub fatpack_carton {
      my($self, $dir) = @_;
  
      my $temp = Path::Tiny->tempdir;
      my $pushd = File::pushd::pushd $temp;
  
      my $file = $temp->child('carton.pre.pl');
  
      $file->spew(<<'EOF');
  #!/usr/bin/env perl
  use strict;
  use 5.008001;
  use Carton::CLI;
  $Carton::Fatpacked = 1;
  exit Carton::CLI->new->run(@ARGV);
  EOF
  
      my $fatpacked = $self->do_fatpack($file);
  
      my $executable = $dir->child('carton');
      warn "Bundling $executable\n";
  
      $dir->mkpath;
      $executable->spew($fatpacked);
      chmod 0755, $executable;
  }
  
  sub do_fatpack {
      my($self, $file) = @_;
  
      my $packer = App::FatPacker->new;
  
      my @modules = split /\r?\n/, $packer->trace(args => [$file], use => $self->required_modules);
      my @packlists = $packer->packlists_containing(\@modules);
      $packer->packlists_to_tree(Path::Tiny->new('fatlib')->absolute, \@packlists);
  
      my $fatpacked = do {
          local $SIG{__WARN__} = sub {};
          $packer->fatpack_file($file);
      };
  
      # HACK: File::Spec bundled into arch in < 5.16, but is loadable as pure-perl
      use Config;
      $fatpacked =~ s/\$fatpacked{"$Config{archname}\/(Cwd|File)/\$fatpacked{"$1/g;
  
      $fatpacked;
  }
  
  sub required_modules {
      my($self, $packer) = @_;
  
      my $meta = $self->installed_meta('Carton')
          or die "Couldn't find install metadata for Carton";
  
      my %excludes = (
          perl => 1,
          'ExtUtils::MakeMaker' => 1,
          'Module::Build' => 1,
      );
  
      my @requirements = grep !$excludes{$_},
          $meta->effective_prereqs->requirements_for('runtime', 'requires')->required_modules;
  
      return \@requirements;
  }
  
  sub installed_meta {
      my($self, $dist) = @_;
  
      my @meta;
      my $finder = sub {
          if (m!\b$dist-.*[\\/]MYMETA.json!) {
              my $meta = CPAN::Meta->load_file($_);
              push @meta, $meta if $meta->name eq $dist;
          }
      };
  
      File::Find::find({ wanted => $finder, no_chdir => 1 }, grep -d, map "$_/.meta", @INC);
  
      # return the latest version
      @meta = sort { version->new($b->version) cmp version->new($a->version) } @meta;
  
      return $meta[0];
  }
  
  1;
CARTON_PACKER

$fatpacked{"Carton/Snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT';
  package Carton::Snapshot;
  use Moo;
  use warnings NONFATAL => 'all';
  use Config;
  use Carton::Dist;
  use Carton::Dist::Core;
  use Carton::Error;
  use Carton::Package;
  use Carton::Index;
  use Carton::Util;
  use Carton::Snapshot::Emitter;
  use Carton::Snapshot::Parser;
  use CPAN::Meta;
  use CPAN::Meta::Requirements;
  use File::Find ();
  use Try::Tiny;
  use Path::Tiny ();
  use Module::CoreList;
  
  use constant CARTON_SNAPSHOT_VERSION => '1.0';
  
  has path    => (is => 'rw', coerce => sub { Path::Tiny->new($_[0]) });
  has version => (is => 'rw', default => sub { CARTON_SNAPSHOT_VERSION });
  has loaded  => (is => 'rw');
  has _distributions => (is => 'rw', default => sub { +[] });
  
  sub load_if_exists {
      my $self = shift;
      $self->load if $self->path->is_file;
  }
  
  sub load {
      my $self = shift;
  
      return 1 if $self->loaded;
  
      if ($self->path->is_file) {
          my $parser = Carton::Snapshot::Parser->new;
          $parser->parse($self->path->slurp_utf8, $self);
          $self->loaded(1);
  
          return 1;
      } else {
          Carton::Error::SnapshotNotFound->throw(
              error => "Can't find cpanfile.snapshot: Run `carton install` to build the snapshot file.",
              path => $self->path,
          );
      }
  }
  
  sub save {
      my $self = shift;
      $self->path->spew_utf8( Carton::Snapshot::Emitter->new->emit($self) );
  }
  
  sub find {
      my($self, $module) = @_;
      (grep $_->provides_module($module), $self->distributions)[0];
  }
  
  sub find_or_core {
      my($self, $module) = @_;
      $self->find($module) || $self->find_in_core($module);
  }
  
  sub find_in_core {
      my($self, $module) = @_;
  
      if (exists $Module::CoreList::version{$]}{$module}) {
          my $version = $Module::CoreList::version{$]}{$module}; # maybe undef
          return Carton::Dist::Core->new(name => $module, module_version => $version);
      }
  
      return;
  }
  
  sub index {
      my $self = shift;
  
      my $index = Carton::Index->new;
      for my $package ($self->packages) {
          $index->add_package($package);
      }
  
      return $index;
  }
  
  sub distributions {
      @{$_[0]->_distributions};
  }
  
  sub add_distribution {
      my($self, $dist) = @_;
      push @{$self->_distributions}, $dist;
  }
  
  sub packages {
      my $self = shift;
  
      my @packages;
      for my $dist ($self->distributions) {
          while (my($package, $provides) = each %{$dist->provides}) {
              # TODO what if duplicates?
              push @packages, Carton::Package->new($package, $provides->{version}, $dist->pathname);
          }
      }
  
      return @packages;
  }
  
  sub write_index {
      my($self, $file) = @_;
  
      open my $fh, ">", $file or die $!;
      $self->index->write($fh);
  }
  
  sub find_installs {
      my($self, $path, $reqs) = @_;
  
      my $libdir = "$path/lib/perl5/$Config{archname}/.meta";
      return {} unless -e $libdir;
  
      my @installs;
      my $wanted = sub {
          if ($_ eq 'install.json') {
              push @installs, [ $File::Find::name, "$File::Find::dir/MYMETA.json" ];
          }
      };
      File::Find::find($wanted, $libdir);
  
      my %installs;
  
      my $accepts = sub {
          my $module = shift;
  
          return 0 unless $reqs->accepts_module($module->{name}, $module->{provides}{$module->{name}}{version});
  
          if (my $exist = $installs{$module->{name}}) {
              my $old_ver = version->new($exist->{provides}{$module->{name}}{version});
              my $new_ver = version->new($module->{provides}{$module->{name}}{version});
              return $new_ver >= $old_ver;
          } else {
              return 1;
          }
      };
  
      for my $file (@installs) {
          my $module = Carton::Util::load_json($file->[0]);
          my $prereqs = -f $file->[1] ? CPAN::Meta->load_file($file->[1])->effective_prereqs : CPAN::Meta::Prereqs->new;
  
          my $reqs = CPAN::Meta::Requirements->new;
          $reqs->add_requirements($prereqs->requirements_for($_, 'requires'))
            for qw( configure build runtime );
  
          if ($accepts->($module)) {
              $installs{$module->{name}} = Carton::Dist->new(
                  name => $module->{dist},
                  pathname => $module->{pathname},
                  provides => $module->{provides},
                  version => $module->{version},
                  requirements => $reqs,
              );
          }
      }
  
      my @new_dists;
      for my $module (sort keys %installs) {
          push @new_dists, $installs{$module};
      }
  
      $self->_distributions(\@new_dists);
  }
  
  1;
CARTON_SNAPSHOT

$fatpacked{"Carton/Snapshot/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_EMITTER';
  package Carton::Snapshot::Emitter;
  use Moo;
  use warnings NONFATAL => 'all';
  
  sub emit {
      my($self, $snapshot) = @_;
  
      my $data = '';
      $data .= "# carton snapshot format: version @{[$snapshot->version]}\n";
      $data .= "DISTRIBUTIONS\n";
  
      for my $dist (sort { $a->name cmp $b->name } $snapshot->distributions) {
          $data .= "  @{[$dist->name]}\n";
          $data .= "    pathname: @{[$dist->pathname]}\n";
  
          $data .= "    provides:\n";
          for my $package (sort keys %{$dist->provides}) {
              $data .= "      $package @{[$dist->provides->{$package}{version} || 'undef' ]}\n";
          }
  
          $data .= "    requirements:\n";
          for my $module (sort $dist->required_modules) {
              $data .= "      $module @{[ $dist->requirements_for_module($module) || '0' ]}\n";
          }
      }
  
      $data;
  }
  
  1;
CARTON_SNAPSHOT_EMITTER

$fatpacked{"Carton/Snapshot/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_PARSER';
  package Carton::Snapshot::Parser;
  use Moo;
  use warnings NONFATAL => 'all';
  use Carton::Dist;
  use Carton::Error;
  
  my $machine = {
      init => [
          {
              re => qr/^\# carton snapshot format: version (1\.0)/,
              code => sub {
                  my($stash, $snapshot, $ver) = @_;
                  $snapshot->version($ver);
              },
              goto => 'section',
          },
          # TODO support pasing error and version mismatch etc.
      ],
      section => [
          {
              re => qr/^DISTRIBUTIONS$/,
              goto => 'dists',
          },
          {
              re => qr/^__EOF__$/,
              done => 1,
          },
      ],
      dists => [
          {
              re => qr/^  (\S+)$/,
              code => sub { $_[0]->{dist} = Carton::Dist->new(name => $1) },
              goto => 'distmeta',
          },
          {
              re => qr/^\S/,
              goto => 'section',
              redo => 1,
          },
      ],
      distmeta => [
          {
              re => qr/^    pathname: (.*)$/,
              code => sub { $_[0]->{dist}->pathname($1) },
          },
          {
              re => qr/^\s{4}provides:$/,
              code => sub { $_[0]->{property} = 'provides' },
              goto => 'properties',
          },
          {
              re => qr/^\s{4}requirements:$/,
              code => sub {
                  $_[0]->{property} = 'requirements';
              },
              goto => 'properties',
          },
          {
              re => qr/^\s{0,2}\S/,
              code => sub {
                  my($stash, $snapshot) = @_;
                  $snapshot->add_distribution($stash->{dist});
                  %$stash = (); # clear
              },
              goto => 'dists',
              redo => 1,
          },
      ],
      properties => [
          {
              re => qr/^\s{6}([0-9A-Za-z_:]+) ([v0-9\._,=\!<>\s]+|undef)/,
              code => sub {
                  my($stash, $snapshot, $module, $version) = @_;
  
                  if ($stash->{property} eq 'provides') {
                      $stash->{dist}->provides->{$module} = { version => $version };
                  } else {
                      $stash->{dist}->add_string_requirement($module, $version);
                  }
              },
          },
          {
              re => qr/^\s{0,4}\S/,
              goto => 'distmeta',
              redo => 1,
          },
      ],
  };
  
  sub parse {
      my($self, $data, $snapshot) = @_;
  
      my @lines = split /\r?\n/, $data;
  
      my $state = $machine->{init};
      my $stash = {};
  
      LINE:
      for my $line (@lines, '__EOF__') {
          last LINE unless @$state;
  
      STATE: {
              for my $trans (@{$state}) {
                  if (my @match = $line =~ $trans->{re}) {
                      if (my $code = $trans->{code}) {
                          $code->($stash, $snapshot, @match);
                      }
                      if (my $goto = $trans->{goto}) {
                          $state = $machine->{$goto};
                          if ($trans->{redo}) {
                              redo STATE;
                          } else {
                              next LINE;
                          }
                      }
  
                      last STATE;
                  }
              }
  
              Carton::Error::SnapshotParseError->throw(error => "Could not parse snapshot file.");
          }
      }
  }
  
  1;
CARTON_SNAPSHOT_PARSER

$fatpacked{"Carton/Tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_TREE';
  package Carton::Tree;
  use Moo;
  use warnings NONFATAL => 'all';
  use Carton::Dependency;
  
  has cpanfile => (is => 'ro');
  has snapshot => (is => 'ro');
  
  use constant STOP => -1;
  
  sub walk_down {
      my($self, $cb) = @_;
  
      my $dumper; $dumper = sub {
          my($dependency, $reqs, $level, $parent) = @_;
  
          my $ret = $cb->($dependency, $reqs, $level);
          return if $ret && $ret == STOP;
  
          local $parent->{$dependency->distname} = 1 if $dependency;
  
          for my $module (sort $reqs->required_modules) {
              my $dependency = $self->dependency_for($module, $reqs);
              if ($dependency->dist) {
                  next if $parent->{$dependency->distname};
                  $dumper->($dependency, $dependency->requirements, $level + 1, $parent);
              } else {
                  # no dist found in lock
              }
          }
      };
  
      $dumper->(undef, $self->cpanfile->requirements, 0, {});
      undef $dumper;
  }
  
  sub dependency_for {
      my($self, $module, $reqs) = @_;
  
      my $requirement = $reqs->requirements_for_module($module);
  
      my $dep = Carton::Dependency->new;
      $dep->module($module);
      $dep->requirement($requirement);
  
      if (my $dist = $self->snapshot->find_or_core($module)) {
          $dep->dist($dist);
      }
  
      return $dep;
  }
  
  sub merged_requirements {
      my $self = shift;
  
      my $merged_reqs = CPAN::Meta::Requirements->new;
  
      my %seen;
      $self->walk_down(sub {
          my($dependency, $reqs, $level) = @_;
          return Carton::Tree::STOP if $dependency && $seen{$dependency->distname}++;
          $merged_reqs->add_requirements($reqs);
      });
  
      $merged_reqs->clear_requirement('perl');
      $merged_reqs->finalize;
  
      $merged_reqs;
  }
  
  1;
CARTON_TREE

$fatpacked{"Carton/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_UTIL';
  package Carton::Util;
  use strict;
  use warnings;
  
  sub load_json {
      my $file = shift;
  
      open my $fh, "<", $file or die "$file: $!";
      from_json(join '', <$fh>);
  }
  
  sub dump_json {
      my($data, $file) = @_;
  
      open my $fh, ">", $file or die "$file: $!";
      binmode $fh;
      print $fh to_json($data);
  }
  
  sub from_json {
      require JSON;
      JSON::decode_json(@_);
  }
  
  sub to_json {
      my($data) = @_;
      require JSON;
      JSON->new->utf8->pretty->canonical->encode($data);
  }
  
  1;
CARTON_UTIL

$fatpacked{"Class/Data/Inheritable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_DATA_INHERITABLE';
  package Class::Data::Inheritable;
  
  use strict qw(vars subs);
  use vars qw($VERSION);
  $VERSION = '0.08';
  
  sub mk_classdata {
      my ($declaredclass, $attribute, $data) = @_;
  
      if( ref $declaredclass ) {
          require Carp;
          Carp::croak("mk_classdata() is a class method, not an object method");
      }
  
      my $accessor = sub {
          my $wantclass = ref($_[0]) || $_[0];
  
          return $wantclass->mk_classdata($attribute)->(@_)
            if @_>1 && $wantclass ne $declaredclass;
  
          $data = $_[1] if @_>1;
          return $data;
      };
  
      my $alias = "_${attribute}_accessor";
      *{$declaredclass.'::'.$attribute} = $accessor;
      *{$declaredclass.'::'.$alias}     = $accessor;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Data::Inheritable - Inheritable, overridable class data
  
  =head1 SYNOPSIS
  
    package Stuff;
    use base qw(Class::Data::Inheritable);
  
    # Set up DataFile as inheritable class data.
    Stuff->mk_classdata('DataFile');
  
    # Declare the location of the data file for this class.
    Stuff->DataFile('/etc/stuff/data');
  
    # Or, all in one shot:
    Stuff->mk_classdata(DataFile => '/etc/stuff/data');
  
  =head1 DESCRIPTION
  
  Class::Data::Inheritable is for creating accessor/mutators to class
  data.  That is, if you want to store something about your class as a
  whole (instead of about a single object).  This data is then inherited
  by your subclasses and can be overriden.
  
  For example:
  
    Pere::Ubu->mk_classdata('Suitcase');
  
  will generate the method Suitcase() in the class Pere::Ubu.
  
  This new method can be used to get and set a piece of class data.
  
    Pere::Ubu->Suitcase('Red');
    $suitcase = Pere::Ubu->Suitcase;
  
  The interesting part happens when a class inherits from Pere::Ubu:
  
    package Raygun;
    use base qw(Pere::Ubu);
    
    # Raygun's suitcase is Red.
    $suitcase = Raygun->Suitcase;
  
  Raygun inherits its Suitcase class data from Pere::Ubu.
  
  Inheritance of class data works analogous to method inheritance.  As
  long as Raygun does not "override" its inherited class data (by using
  Suitcase() to set a new value) it will continue to use whatever is set
  in Pere::Ubu and inherit further changes:
  
    # Both Raygun's and Pere::Ubu's suitcases are now Blue
    Pere::Ubu->Suitcase('Blue');
  
  However, should Raygun decide to set its own Suitcase() it has now
  "overridden" Pere::Ubu and is on its own, just like if it had
  overriden a method:
  
    # Raygun has an orange suitcase, Pere::Ubu's is still Blue.
    Raygun->Suitcase('Orange');
  
  Now that Raygun has overridden Pere::Ubu futher changes by Pere::Ubu
  no longer effect Raygun.
  
    # Raygun still has an orange suitcase, but Pere::Ubu is using Samsonite.
    Pere::Ubu->Suitcase('Samsonite');
  
  =head1 Methods
  
  =head2 mk_classdata
  
    Class->mk_classdata($data_accessor_name);
    Class->mk_classdata($data_accessor_name => $value);
  
  This is a class method used to declare new class data accessors.
  A new accessor will be created in the Class using the name from
  $data_accessor_name, and optionally initially setting it to the given
  value.
  
  To facilitate overriding, mk_classdata creates an alias to the
  accessor, _field_accessor().  So Suitcase() would have an alias
  _Suitcase_accessor() that does the exact same thing as Suitcase().
  This is useful if you want to alter the behavior of a single accessor
  yet still get the benefits of inheritable class data.  For example.
  
    sub Suitcase {
        my($self) = shift;
        warn "Fashion tragedy" if @_ and $_[0] eq 'Plaid';
  
        $self->_Suitcase_accessor(@_);
    }
  
  =head1 AUTHOR
  
  Original code by Damian Conway.
  
  Maintained by Michael G Schwern until September 2005.
  
  Now maintained by Tony Bowden.
  
  =head1 BUGS and QUERIES
  
  Please direct all correspondence regarding this module to:
    bug-Class-Data-Inheritable@rt.cpan.org
  
  =head1 COPYRIGHT and LICENSE
  
  Copyright (c) 2000-2005, Damian Conway and Michael G Schwern. 
  All Rights Reserved.  
  
  This module is free software. It may be used, redistributed and/or
  modified under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<perltooc> has a very elaborate discussion of class data in Perl.
  
CLASS_DATA_INHERITABLE

$fatpacked{"Devel/GlobalDestruction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.12';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_cv is set to Nullcv immediately before entering
    # global destruction and we can use B to detect that.  B::main_cv will
    # only ever be a B::CV or a B::SPECIAL that is a reference to 0
    require B;
    eval 'sub in_global_destruction () { ${B::main_cv()} == 0 }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happening you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_cv> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"Devel/StackTrace.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  $Devel::StackTrace::VERSION = '1.31';
  BEGIN {
    $Devel::StackTrace::AUTHORITY = 'cpan:DROLSKY';
  }
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use Devel::StackTrace::Frame;
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""'     => \&as_string,
      fallback => 1;
  
  sub new {
      my $class = shift;
      my %p     = @_;
  
      # Backwards compatibility - this parameter was renamed to no_refs
      # ages ago.
      $p{no_refs} = delete $p{no_object_refs}
          if exists $p{no_object_refs};
  
      my $self = bless {
          index  => undef,
          frames => [],
          raw    => [],
          %p,
      }, $class;
  
      $self->_record_caller_data();
  
      return $self;
  }
  
  sub _record_caller_data {
      my $self = shift;
  
      # We exclude this method by starting one frame back.
      my $x = 1;
      while (
          my @c
          = $self->{no_args}
          ? caller( $x++ )
          : do {
              package    # the newline keeps dzil from adding a version here
                  DB;
              @DB::args = ();
              caller( $x++ );
          }
          ) {
  
          my @args;
  
          unless ( $self->{no_args} ) {
              @args = @DB::args;
  
              if ( $self->{no_refs} ) {
                  @args = map { ref $_ ? $self->_ref_to_string($_) : $_ } @args;
              }
          }
  
          push @{ $self->{raw} },
              {
              caller => \@c,
              args   => \@args,
              };
      }
  }
  
  sub _ref_to_string {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      local $@;
      local $SIG{__DIE__};
  
      my $str = eval { $ref . '' };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames {
      my $self = shift;
  
      my $filter = $self->_make_frame_filter;
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} ) {
          next unless $filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub { 1 };
  
  sub _make_frame_filter {
      my $self = shift;
  
      my ( @i_pack_re, %i_class );
      if ( $self->{ignore_package} ) {
          local $@;
          local $SIG{__DIE__};
  
          $self->{ignore_package} = [ $self->{ignore_package} ]
              unless eval { @{ $self->{ignore_package} } };
  
          @i_pack_re
              = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} ) {
          $self->{ignore_class} = [ $self->{ignore_class} ]
              unless ref $self->{ignore_class};
          %i_class = map { $_ => 1 } @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ($user_filter) {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame {
      my $self = shift;
      my $c    = shift;
      my $p    = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, ( undef, undef ) if scalar @$c == 6;
  
      push @{ $self->{frames} },
          Devel::StackTrace::Frame->new(
          $c,
          $p,
          $self->{respect_overload},
          $self->{max_arg_length},
          $self->{message},
          $self->{indent}
          );
  }
  
  sub next_frame {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames();
      if ( defined $f[ $self->{index} + 1 ] ) {
          return $f[ ++$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub prev_frame {
      my $self = shift;
  
      my @f = $self->frames();
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 ) {
          return $f[ --$self->{index} ];
      }
      else {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer {
      my $self = shift;
  
      $self->{index} = undef;
  }
  
  sub frames {
      my $self = shift;
  
      if (@_) {
          die
              "Devel::StackTrace->frames() can only take Devel::StackTrace::Frame args\n"
              if grep { !$_->isa('Devel::StackTrace::Frame') } @_;
  
          $self->{frames} = \@_;
      }
      else {
          $self->_make_frames() if $self->{raw};
      }
  
      return @{ $self->{frames} };
  }
  
  sub frame {
      my $self = shift;
      my $i    = shift;
  
      return unless defined $i;
  
      return ( $self->frames() )[$i];
  }
  
  sub frame_count {
      my $self = shift;
  
      return scalar( $self->frames() );
  }
  
  sub as_string {
      my $self = shift;
      my $p    = shift;
  
      my $st    = '';
      my $first = 1;
      foreach my $f ( $self->frames() ) {
          $st .= $f->as_string( $first, $p ) . "\n";
          $first = 0;
      }
  
      return $st;
  }
  
  {
      package
          Devel::StackTraceFrame;
  
      our @ISA = 'Devel::StackTrace::Frame';
  }
  
  1;
  
  # ABSTRACT: An object representing a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace - An object representing a stack trace
  
  =head1 VERSION
  
  version 1.31
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new();
  
    print $trace->as_string(); # like carp
  
    # from top (most recent) of stack to bottom.
    while ( my $frame = $trace->next_frame() ) {
        print "Has args\n" if $frame->hasargs();
    }
  
    # from bottom (least recent) of stack to top.
    while ( my $frame = $trace->prev_frame() ) {
        print "Sub: ", $frame->subroutine(), "\n";
    }
  
  =head1 DESCRIPTION
  
  The C<Devel::StackTrace> module contains two classes, C,Devel::StackTrace> and
  L<Devel::StackTrace::Frame>. These objects encapsulate the information that
  can retrieved via Perl's C<caller()> function, as well as providing a simple
  interface to this data.
  
  The C<Devel::StackTrace> object contains a set of C<Devel::StackTrace::Frame>
  objects, one for each level of the stack. The frames contain all the data
  available from C<caller()>.
  
  This code was created to support my L<Exception::Class::Base> class (part of
  L<Exception::Class>) but may be useful in other contexts.
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top' and
  'bottom'. In this context, the 'top' frame on the stack is the most recent
  frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo {
       bar();
    }
  
    sub bar {
       Devel::StackTrace->new();  # top frame is here.
    }
  
  =head1 METHODS
  
  This class provide the following methods:
  
  =head2 Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 4
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the
  call to its constructor.
  
  However, you may want to filter out some frames with more granularity
  than 'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data
  for each frame. This is a hash reference with two keys, "caller", and
  "args", both of which are array references. The "caller" key is the
  raw data as returned by Perl's C<caller()> function, and the "args"
  key are the subroutine arguments found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or
  false if it should be skipped.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on
  the stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages
  (or is the same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package'
  parameter, meaning that the Devel::StackTrace package is B<ALWAYS>
  ignored. However, if you create a subclass of Devel::StackTrace it
  will not be ignored.
  
  =item * no_refs => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store
  references internally when generating stacktrace frames. This lets
  your objects go out of scope.
  
  Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * no_args => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store caller
  arguments in stack trace frames at all.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef()> to get
  the underlying string representation of an object, instead of
  respecting the object's stringification overloading. If you would
  prefer to see the overloaded representation of objects in stack
  traces, then set this parameter to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for each
  subroutine call. Setting this parameter causes truncates each subroutine
  argument's string representation if it is longer than this number of
  characters.
  
  =item * message => $string
  
  By default, Devel::StackTrace will use 'Trace begun' as the message for the
  first stack frame when you call C<as_string>. You can supply an alternative
  message using this option.
  
  =item * indent => $boolean
  
  If this parameter is true, each stack frame after the first will start with a
  tab character, just like C<Carp::confess()>.
  
  =back
  
  =head2 $trace->next_frame()
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going
  down. If this method hasn't been called before it returns the first frame. It
  returns C<undef> when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<< $trace->next_frame() >> or C<<
  $trace->prev_frame() >> will work properly.
  
  =head2 $trace->prev_frame()
  
  Returns the next L<Devel::StackTrace::Frame> object on the stack, going up. If
  this method hasn't been called before it returns the last frame. It returns
  undef when it reaches the top of the stack and then resets its pointer so the
  next call to C<< $trace->next_frame() >> or C<< $trace->prev_frame() >> will
  work properly.
  
  =head2 $trace->reset_pointer
  
  Resets the pointer so that the next call to C<< $trace->next_frame() >> or C<<
  $trace->prev_frame() >> will start at the top or bottom of the stack, as
  appropriate.
  
  =head2 $trace->frames()
  
  When this method is called with no arguments, it returns a list of
  L<Devel::StackTrace::Frame> objects. They are returned in order from top (most
  recent) to bottom.
  
  This method can also be used to set the object's frames if you pass it a list
  of L<Devel::StackTrace::Frame> objects.
  
  This is useful if you want to filter the list of frames in ways that are more
  complex than can be handled by the C<< $trace->filter_frames() >> method:
  
    $stacktrace->frames( my_filter( $stacktrace->frames() ) );
  
  =head2 $trace->frame($index)
  
  Given an index, this method returns the relevant frame, or undef if there is
  no frame at that index. The index is exactly like a Perl array. The first
  frame is 0 and negative indexes are allowed.
  
  =head2 $trace->frame_count()
  
  Returns the number of frames in the trace object.
  
  =head2 $trace->as_string(\%p)
  
  Calls C<< $frame->as_string() >> on each frame from top to bottom, producing
  output quite similar to the Carp module's cluck/confess methods.
  
  The optional C<\%p> parameter only has one option. The C<max_arg_length>
  parameter truncates each subroutine argument's string representation if it is
  longer than this number of characters.
  
  =head1 SUPPORT
  
  Please submit bugs to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel%3A%3AStackTrace
  or via email at bug-devel-stacktrace@rt.cpan.org.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/Frame.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_STACKTRACE_FRAME';
  package Devel::StackTrace::Frame;
  $Devel::StackTrace::Frame::VERSION = '1.31';
  BEGIN {
    $Devel::StackTrace::Frame::AUTHORITY = 'cpan:DROLSKY';
  }
  
  use strict;
  use warnings;
  
  # Create accessor routines
  BEGIN {
      no strict 'refs';
      foreach my $f (
          qw( package filename line subroutine hasargs
          wantarray evaltext is_require hints bitmask args )
          ) {
          next if $f eq 'args';
          *{$f} = sub { my $s = shift; return $s->{$f} };
      }
  }
  
  {
      my @fields = (
          qw( package filename line subroutine hasargs wantarray
              evaltext is_require hints bitmask )
      );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{$self}{@fields} = @{ shift() };
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          $self->{args} = shift;
  
          $self->{respect_overload} = shift;
  
          $self->{max_arg_length} = shift;
  
          $self->{message} = shift;
  
          $self->{indent} = shift;
  
          return $self;
      }
  }
  
  sub args {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string {
      my $self  = shift;
      my $first = shift;
      my $p     = shift;
  
      my $sub = $self->subroutine;
  
      # This code stolen straight from Carp.pm and then tweaked.  All
      # errors are probably my fault  -dave
      if ($first) {
          $sub
              = defined $self->{message}
              ? $self->{message}
              : 'Trace begun';
      }
      else {
  
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if ( my $eval = $self->evaltext ) {
              if ( $self->is_require ) {
                  $sub = "require $eval";
              }
              else {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ( $sub eq '(eval)' ) {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args ) {
              for (@a) {
  
                  # set args to the string "undef" if undefined
                  $_ = "undef", next unless defined $_;
  
                  # hack!
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
  
                  local $SIG{__DIE__};
                  local $@;
  
                  eval {
                      my $max_arg_length
                          = exists $p->{max_arg_length}
                          ? $p->{max_arg_length}
                          : $self->{max_arg_length};
  
                      if ( $max_arg_length
                          && length $_ > $max_arg_length ) {
                          substr( $_, $max_arg_length ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
  
                  if ( my $e = $@ ) {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join( ', ', @a ) . ')';
              $sub .= ' called';
          }
      }
  
      # If the user opted into indentation (a la Carp::confess), pre-add a tab
      my $tab = $self->{indent} && !$first ? "\t" : q{};
  
      return "${tab}$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  # ABSTRACT: A single frame in a stack trace
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Devel::StackTrace::Frame - A single frame in a stack trace
  
  =head1 VERSION
  
  version 1.31
  
  =head1 DESCRIPTION
  
  See L<Devel::StackTrace> for details.
  
  =for Pod::Coverage new
  
  =head1 METHODS
  
  See Perl's C<caller()> documentation for more information on what these
  methods return.
  
  =head2 $frame->package()
  
  =head2 $frame->filename()
  
  =head2 $frame->line()
  
  =head2 $frame->subroutine()
  
  =head2 $frame->hasargs()
  
  =head2 $frame->wantarray()
  
  =head2 $frame->evaltext()
  
  Returns undef if the frame was not part of an eval.
  
  =head2 $frame->is_require()
  
  Returns undef if the frame was not part of a require.
  
  =head2 $frame->args()
  
  Returns the arguments passed to the frame.  Note that any arguments
  that are references are returned as references, not copies.
  
  =head2 $frame->hints()
  
  =head2 $frame->bitmask()
  
  =head2 $frame->as_string()
  
  Returns a string containing a description of the frame.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
DEVEL_STACKTRACE_FRAME

$fatpacked{"Exception/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS';
  package Exception::Class;
  {
    $Exception::Class::VERSION = '1.37';
  }
  
  use 5.008001;
  
  use strict;
  
  use Exception::Class::Base;
  use Scalar::Util qw(blessed);
  
  our $BASE_EXC_CLASS;
  BEGIN { $BASE_EXC_CLASS ||= 'Exception::Class::Base'; }
  
  our %CLASSES;
  
  sub import {
      my $class = shift;
  
      local $Exception::Class::Caller = caller();
  
      my %c;
  
      my %needs_parent;
      while ( my $subclass = shift ) {
          my $def = ref $_[0] ? shift : {};
          $def->{isa}
              = $def->{isa}
              ? ( ref $def->{isa} ? $def->{isa} : [ $def->{isa} ] )
              : [];
  
          $c{$subclass} = $def;
      }
  
      # We need to sort by length because if we check for keys in the
      # Foo::Bar:: stash, this creates a "Bar::" key in the Foo:: stash!
  MAKE_CLASSES:
      foreach my $subclass ( sort { length $a <=> length $b } keys %c ) {
          my $def = $c{$subclass};
  
          # We already made this one.
          next if $CLASSES{$subclass};
  
          {
              no strict 'refs';
              foreach my $parent ( @{ $def->{isa} } ) {
                  unless ( keys %{"$parent\::"} ) {
                      $needs_parent{$subclass} = {
                          parents => $def->{isa},
                          def     => $def
                      };
                      next MAKE_CLASSES;
                  }
              }
          }
  
          $class->_make_subclass(
              subclass => $subclass,
              def      => $def || {},
          );
      }
  
      foreach my $subclass ( keys %needs_parent ) {
  
          # This will be used to spot circular references.
          my %seen;
          $class->_make_parents( \%needs_parent, $subclass, \%seen );
      }
  }
  
  sub _make_parents {
      my $class    = shift;
      my $needs    = shift;
      my $subclass = shift;
      my $seen     = shift;
      my $child    = shift;    # Just for error messages.
  
      no strict 'refs';
  
      # What if someone makes a typo in specifying their 'isa' param?
      # This should catch it.  Either it's been made because it didn't
      # have missing parents OR it's in our hash as needing a parent.
      # If neither of these is true then the _only_ place it is
      # mentioned is in the 'isa' param for some other class, which is
      # not a good enough reason to make a new class.
      die
          "Class $subclass appears to be a typo as it is only specified in the 'isa' param for $child\n"
          unless exists $needs->{$subclass}
          || $CLASSES{$subclass}
          || keys %{"$subclass\::"};
  
      foreach my $c ( @{ $needs->{$subclass}{parents} } ) {
  
          # It's been made
          next if $CLASSES{$c} || keys %{"$c\::"};
  
          die "There appears to be some circularity involving $subclass\n"
              if $seen->{$subclass};
  
          $seen->{$subclass} = 1;
  
          $class->_make_parents( $needs, $c, $seen, $subclass );
      }
  
      return if $CLASSES{$subclass} || keys %{"$subclass\::"};
  
      $class->_make_subclass(
          subclass => $subclass,
          def      => $needs->{$subclass}{def}
      );
  }
  
  sub _make_subclass {
      my $class = shift;
      my %p     = @_;
  
      my $subclass = $p{subclass};
      my $def      = $p{def};
  
      my $isa;
      if ( $def->{isa} ) {
          $isa = ref $def->{isa} ? join ' ', @{ $def->{isa} } : $def->{isa};
      }
      $isa ||= $BASE_EXC_CLASS;
  
      my $version_name = 'VERSION';
  
      my $code = <<"EOPERL";
  package $subclass;
  
  use base qw($isa);
  
  our \$$version_name = '1.1';
  
  1;
  
  EOPERL
  
      if ( $def->{description} ) {
          ( my $desc = $def->{description} ) =~ s/([\\\'])/\\$1/g;
          $code .= <<"EOPERL";
  sub description
  {
      return '$desc';
  }
  EOPERL
      }
  
      my @fields;
      if ( my $fields = $def->{fields} ) {
          @fields = UNIVERSAL::isa( $fields, 'ARRAY' ) ? @$fields : $fields;
  
          $code
              .= "sub Fields { return (\$_[0]->SUPER::Fields, "
              . join( ", ", map { "'$_'" } @fields )
              . ") }\n\n";
  
          foreach my $field (@fields) {
              $code .= sprintf( "sub %s { \$_[0]->{%s} }\n", $field, $field );
          }
      }
  
      if ( my $alias = $def->{alias} ) {
          die "Cannot make alias without caller"
              unless defined $Exception::Class::Caller;
  
          no strict 'refs';
          *{"$Exception::Class::Caller\::$alias"}
              = sub { $subclass->throw(@_) };
      }
  
      if ( my $defaults = $def->{defaults} ) {
          $code
              .= "sub _defaults { return shift->SUPER::_defaults, our \%_DEFAULTS }\n";
          no strict 'refs';
          *{"$subclass\::_DEFAULTS"} = {%$defaults};
      }
  
      eval $code;
  
      die $@ if $@;
  
      $CLASSES{$subclass} = 1;
  }
  
  sub caught {
      my $e = $@;
  
      return $e unless $_[1];
  
      return unless blessed($e) && $e->isa( $_[1] );
      return $e;
  }
  
  sub Classes { sort keys %Exception::Class::CLASSES }
  
  1;
  
  # ABSTRACT: A module that allows you to declare real exception classes in Perl
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Exception::Class - A module that allows you to declare real exception classes in Perl
  
  =head1 VERSION
  
  version 1.37
  
  =head1 SYNOPSIS
  
    use Exception::Class (
        'MyException',
  
        'AnotherException' => { isa => 'MyException' },
  
        'YetAnotherException' => {
            isa         => 'AnotherException',
            description => 'These exceptions are related to IPC'
        },
  
        'ExceptionWithFields' => {
            isa    => 'YetAnotherException',
            fields => [ 'grandiosity', 'quixotic' ],
            alias  => 'throw_fields',
        },
    );
    use Scalar::Util qw( blessed );
    use Try::Tiny;
  
    try {
        MyException->throw( error => 'I feel funny.' );
    }
    catch {
        die $_ unless blessed $_ && $_->can('rethrow');
  
        if ( $_->isa('Exception::Class') ) {
            warn $_->error, "\n", $_->trace->as_string, "\n";
            warn join ' ', $_->euid, $_->egid, $_->uid, $_->gid, $_->pid, $_->time;
  
            exit;
        }
        elsif ( $_->isa('ExceptionWithFields') ) {
            if ( $_->quixotic ) {
                handle_quixotic_exception();
            }
            else {
                handle_non_quixotic_exception();
            }
        }
        else {
            $_->rethrow;
        }
    };
  
    # without Try::Tiny
  
    eval { ... };
    if ( my $e = Exception::Class->caught() ) { ... }
  
    # use an alias - without parens subroutine name is checked at
    # compile time
    throw_fields error => "No strawberry", grandiosity => "quite a bit";
  
  =head1 DESCRIPTION
  
  B<RECOMMENDATION 1>: If you are writing modern Perl code with L<Moose> or
  L<Moo> I highly recommend using L<Throwable> instead of this module.
  
  B<RECOMMENDATION 2>: Whether or not you use L<Throwable>, you should use
  L<Try::Tiny>.
  
  Exception::Class allows you to declare exception hierarchies in your
  modules in a "Java-esque" manner.
  
  It features a simple interface allowing programmers to 'declare'
  exception classes at compile time.  It also has a base exception
  class, L<Exception::Class::Base>, that can be easily extended.
  
  It is designed to make structured exception handling simpler and
  better by encouraging people to use hierarchies of exceptions in their
  applications, as opposed to a single catch-all exception class.
  
  This module does not implement any try/catch syntax.  Please see the
  "OTHER EXCEPTION MODULES (try/catch syntax)" section for more
  information on how to get this syntax.
  
  You will also want to look at the documentation for
  L<Exception::Class::Base>, which is the default base class for all
  exception objects created by this module.
  
  =head1 DECLARING EXCEPTION CLASSES
  
  Importing C<Exception::Class> allows you to automagically create
  L<Exception::Class::Base> subclasses.  You can also create subclasses
  via the traditional means of defining your own subclass with C<@ISA>.
  These two methods may be easily combined, so that you could subclass
  an exception class defined via the automagic import, if you desired
  this.
  
  The syntax for the magic declarations is as follows:
  
  'MANDATORY CLASS NAME' => \%optional_hashref
  
  The hashref may contain the following options:
  
  =over 4
  
  =item * isa
  
  This is the class's parent class.  If this isn't provided then the
  class name in C<$Exception::Class::BASE_EXC_CLASS> is assumed to be
  the parent (see below).
  
  This parameter lets you create arbitrarily deep class hierarchies.
  This can be any other L<Exception::Class::Base> subclass in your
  declaration I<or> a subclass loaded from a module.
  
  To change the default exception class you will need to change the
  value of C<$Exception::Class::BASE_EXC_CLASS> I<before> calling
  C<import()>.  To do this simply do something like this:
  
    BEGIN { $Exception::Class::BASE_EXC_CLASS = 'SomeExceptionClass'; }
  
  If anyone can come up with a more elegant way to do this please let me
  know.
  
  CAVEAT: If you want to automagically subclass an
  L<Exception::Class::Base> subclass loaded from a file, then you
  I<must> compile the class (via use or require or some other magic)
  I<before> you import C<Exception::Class> or you'll get a compile time
  error.
  
  =item * fields
  
  This allows you to define additional attributes for your exception
  class.  Any field you define can be passed to the C<throw()> or
  C<new()> methods as additional parameters for the constructor.  In
  addition, your exception object will have an accessor method for the
  fields you define.
  
  This parameter can be either a scalar (for a single field) or an array
  reference if you need to define multiple fields.
  
  Fields will be inherited by subclasses.
  
  =item * alias
  
  Specifying an alias causes this class to create a subroutine of the
  specified name in the I<caller's> namespace.  Calling this subroutine
  is equivalent to calling C<< <class>->throw(@_) >> for the given
  exception class.
  
  Besides convenience, using aliases also allows for additional compile
  time checking.  If the alias is called I<without parentheses>, as in
  C<throw_fields "an error occurred">, then Perl checks for the
  existence of the C<throw_fields()> subroutine at compile time.  If
  instead you do C<< ExceptionWithFields->throw(...) >>, then Perl
  checks the class name at runtime, meaning that typos may sneak
  through.
  
  =item * description
  
  Each exception class has a description method that returns a fixed
  string.  This should describe the exception I<class> (as opposed to
  any particular exception object).  This may be useful for debugging if
  you start catching exceptions you weren't expecting (particularly if
  someone forgot to document them) and you don't understand the error
  messages.
  
  =back
  
  The C<Exception::Class> magic attempts to detect circular class
  hierarchies and will die if it finds one.  It also detects missing
  links in a chain, for example if you declare Bar to be a subclass of
  Foo and never declare Foo.
  
  =head1 L<Try::Tiny>
  
  If you are interested in adding try/catch/finally syntactic sugar to your code
  then I recommend you check out L<Try::Tiny>. This is a great module that helps
  you ignore some of the weirdness with C<eval> and C<$@>. Here's an example of
  how the two modules work together:
  
    use Exception::Class ( 'My::Exception' );
    use Scalar::Util qw( blessed );
    use Try::Tiny;
  
    try {
        might_throw();
    }
    catch {
        if ( blessed $_ && $_->isa('My::Exception') ) {
            handle_it();
        }
        else {
            die $_;
        }
    };
  
  Note that you B<cannot> use C<< Exception::Class->caught() >> with
  L<Try::Tiny>.
  
  =head1 Catching Exceptions Without L<Try::Tiny>
  
  C<Exception::Class> provides some syntactic sugar for catching
  exceptions in a safe manner:
  
    eval {...};
  
    if ( my $e = Exception::Class->caught('My::Error') ) {
        cleanup();
        do_something_with_exception($e);
    }
  
  The C<caught()> method takes a class name and returns an exception
  object if the last thrown exception is of the given class, or a
  subclass of that class.  If it is not given any arguments, it simply
  returns C<$@>.
  
  You should B<always> make a copy of the exception object, rather than
  using C<$@> directly.  This is necessary because if your C<cleanup()>
  function uses C<eval>, or calls something which uses it, then C<$@> is
  overwritten.  Copying the exception preserves it for the call to
  C<do_something_with_exception()>.
  
  Exception objects also provide a caught method so you can write:
  
    if ( my $e = My::Error->caught() ) {
        cleanup();
        do_something_with_exception($e);
    }
  
  =head2 Uncatchable Exceptions
  
  Internally, the C<caught()> method will call C<isa()> on the exception
  object.  You could make an exception "uncatchable" by overriding
  C<isa()> in that class like this:
  
   package Exception::Uncatchable;
  
   sub isa { shift->rethrow }
  
  Of course, this only works if you always call C<< Exception::Class->caught()
  >> after an C<eval>.
  
  =head1 USAGE RECOMMENDATION
  
  If you're creating a complex system that throws lots of different
  types of exceptions, consider putting all the exception declarations
  in one place.  For an app called Foo you might make a
  C<Foo::Exceptions> module and use that in all your code.  This module
  could just contain the code to make C<Exception::Class> do its
  automagic class creation.  Doing this allows you to more easily see
  what exceptions you have, and makes it easier to keep track of them.
  
  This might look something like this:
  
    package Foo::Bar::Exceptions;
  
    use Exception::Class (
        Foo::Bar::Exception::Senses =>
            { description => 'sense-related exception' },
  
        Foo::Bar::Exception::Smell => {
            isa         => 'Foo::Bar::Exception::Senses',
            fields      => 'odor',
            description => 'stinky!'
        },
  
        Foo::Bar::Exception::Taste => {
            isa         => 'Foo::Bar::Exception::Senses',
            fields      => [ 'taste', 'bitterness' ],
            description => 'like, gag me with a spoon!'
        },
  
        ...
    );
  
  You may want to create a real module to subclass
  L<Exception::Class::Base> as well, particularly if you want your
  exceptions to have more methods.
  
  =head2 Subclassing Exception::Class::Base
  
  As part of your usage of C<Exception::Class>, you may want to create
  your own base exception class which subclasses
  L<Exception::Class::Base>.  You should feel free to subclass any of
  the methods documented above.  For example, you may want to subclass
  C<new()> to add additional information to your exception objects.
  
  =head1 Exception::Class FUNCTIONS
  
  The C<Exception::Class> method offers one function, C<Classes()>,
  which is not exported.  This method returns a list of the classes that
  have been created by calling the C<Exception::Class> import() method.
  Note that this is I<all> the subclasses that have been created, so it
  may include subclasses created by things like CPAN modules, etc.  Also
  note that if you simply define a subclass via the normal Perl method
  of setting C<@ISA> or C<use base>, then your subclass will not be
  included.
  
  =head1 SUPPORT
  
  Please submit bugs to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Exception%3A%3AClass or
  via email at bug-exception-class@rt.cpan.org.
  
  =head1 DONATIONS
  
  If you'd like to thank me for the work I've done on this module,
  please consider making a "donation" to me via PayPal. I spend a lot of
  free time creating free software, and would appreciate any support
  you'd care to offer.
  
  Please note that B<I am not suggesting that you must do this> in order
  for me to continue working on this particular software. I will
  continue to do so, inasmuch as I have in the past, for as long as it
  interests me.
  
  Similarly, a donation made in this way will probably not make me work
  on this software much more, unless I get so many donations that I can
  consider working on free software full time, which seems unlikely at
  best.
  
  To donate, log into PayPal and send money to autarch@urth.org or use
  the button on this page:
  L<http://www.urth.org/~autarch/fs-donation.html>
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EXCEPTION_CLASS

$fatpacked{"Exception/Class/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXCEPTION_CLASS_BASE';
  package Exception::Class::Base;
  {
    $Exception::Class::Base::VERSION = '1.37';
  }
  
  use strict;
  use warnings;
  
  use Class::Data::Inheritable 0.02;
  use Devel::StackTrace 1.20;
  use Scalar::Util qw( blessed );
  
  use base qw(Class::Data::Inheritable);
  
  BEGIN {
      __PACKAGE__->mk_classdata('Trace');
      __PACKAGE__->mk_classdata('NoRefs');
      __PACKAGE__->NoRefs(1);
  
      __PACKAGE__->mk_classdata('NoContextInfo');
      __PACKAGE__->NoContextInfo(0);
  
      __PACKAGE__->mk_classdata('RespectOverload');
      __PACKAGE__->RespectOverload(0);
  
      __PACKAGE__->mk_classdata('MaxArgLength');
      __PACKAGE__->MaxArgLength(0);
  
      sub Fields { () }
  }
  
  use overload
  
      # an exception is always true
      bool => sub { 1 }, '""' => 'as_string', fallback => 1;
  
  # Create accessor routines
  BEGIN {
      my @fields = qw( message pid uid euid gid egid time trace );
  
      foreach my $f (@fields) {
          my $sub = sub { my $s = shift; return $s->{$f}; };
  
          no strict 'refs';
          *{$f} = $sub;
      }
      *error = \&message;
  
      my %trace_fields = (
          package => 'package',
          file    => 'filename',
          line    => 'line',
      );
  
      while ( my ( $f, $m ) = each %trace_fields ) {
          my $sub = sub {
              my $s = shift;
              return $s->{$f} if exists $s->{$f};
  
              my $frame = $s->trace->frame(0);
  
              return $s->{$f} = $frame ? $frame->$m() : undef;
          };
          no strict 'refs';
          *{$f} = $sub;
      }
  }
  
  1;
  
  sub Classes { Exception::Class::Classes() }
  
  sub throw {
      my $proto = shift;
  
      $proto->rethrow if ref $proto;
  
      die $proto->new(@_);
  }
  
  sub rethrow {
      my $self = shift;
  
      die $self;
  }
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self = bless {}, $class;
  
      $self->_initialize(@_);
  
      return $self;
  }
  
  sub _initialize {
      my $self = shift;
      my %p = @_ == 1 ? ( error => $_[0] ) : @_;
  
      $self->{message} = $p{message} || $p{error} || '';
  
      $self->{show_trace} = $p{show_trace} if exists $p{show_trace};
  
      if ( $self->NoContextInfo() ) {
          $self->{show_trace} = 0;
          $self->{package} = $self->{file} = $self->{line} = undef;
      }
      else {
          # CORE::time is important to fix an error with some versions of
          # Perl
          $self->{time} = CORE::time();
          $self->{pid}  = $$;
          $self->{uid}  = $<;
          $self->{euid} = $>;
          $self->{gid}  = $(;
          $self->{egid} = $);
  
          my @ignore_class   = (__PACKAGE__);
          my @ignore_package = 'Exception::Class';
  
          if ( my $i = delete $p{ignore_class} ) {
              push @ignore_class, ( ref($i) eq 'ARRAY' ? @$i : $i );
          }
  
          if ( my $i = delete $p{ignore_package} ) {
              push @ignore_package, ( ref($i) eq 'ARRAY' ? @$i : $i );
          }
  
          $self->{trace} = Devel::StackTrace->new(
              ignore_class     => \@ignore_class,
              ignore_package   => \@ignore_package,
              no_refs          => $self->NoRefs,
              respect_overload => $self->RespectOverload,
              max_arg_length   => $self->MaxArgLength,
          );
      }
  
      my %fields = map { $_ => 1 } $self->Fields;
      while ( my ( $key, $value ) = each %p ) {
          next if $key =~ /^(?:error|message|show_trace)$/;
  
          if ( $fields{$key} ) {
              $self->{$key} = $value;
          }
          else {
              Exception::Class::Base->throw(
                  error => "unknown field $key passed to constructor for class "
                      . ref $self );
          }
      }
  }
  
  sub description {
      return 'Generic exception';
  }
  
  sub show_trace {
      my $self = shift;
  
      return 0 unless $self->{trace};
  
      if (@_) {
          $self->{show_trace} = shift;
      }
  
      return exists $self->{show_trace} ? $self->{show_trace} : $self->Trace;
  }
  
  sub as_string {
      my $self = shift;
  
      my $str = $self->full_message;
      $str .= "\n\n" . $self->trace->as_string
          if $self->show_trace;
  
      return $str;
  }
  
  sub full_message { $_[0]->{message} }
  
  #
  # The %seen bit protects against circular inheritance.
  #
  eval <<'EOF' if $] == 5.006;
  sub isa {
      my ( $inheritor, $base ) = @_;
      $inheritor = ref($inheritor) if ref($inheritor);
  
      my %seen;
  
      no strict 'refs';
      my @parents = ( $inheritor, @{"$inheritor\::ISA"} );
      while ( my $class = shift @parents ) {
          return 1 if $class eq $base;
  
          push @parents, grep { !$seen{$_}++ } @{"$class\::ISA"};
      }
      return 0;
  }
  EOF
  
  sub caught {
      my $class = shift;
  
      my $e = $@;
  
      return unless defined $e && blessed($e) && $e->isa($class);
      return $e;
  }
  
  1;
  
  # ABSTRACT: A base class for exception objects
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Exception::Class::Base - A base class for exception objects
  
  =head1 VERSION
  
  version 1.37
  
  =head1 SYNOPSIS
  
    use Exception::Class 'MyException';
  
    eval { MyException->throw( error => 'I feel funny.' ) };
  
    print $@->error();
  
  =head1 DESCRIPTION
  
  This class is the base class for all exceptions created by
  L<Exception::Class>. It provides a number of methods for getting
  information about the exception.
  
  =head1 METHODS
  
  =head2 MyException->Trace($boolean)
  
  Each C<Exception::Class::Base> subclass can be set individually to
  include a stacktrace when the C<as_string> method is called.  The
  default is to not include a stacktrace.  Calling this method with a
  value changes this behavior.  It always returns the current value
  (after any change is applied).
  
  This value is inherited by any subclasses.  However, if this value is
  set for a subclass, it will thereafter be independent of the value in
  C<Exception::Class::Base>.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  This is a class method, not an object method.
  
  =head2 MyException->NoRefs($boolean)
  
  When a C<Devel::StackTrace> object is created, it walks through the
  stack and stores the arguments which were passed to each subroutine on
  the stack.  If any of these arguments are references, then that means
  that the C<Devel::StackTrace> ends up increasing the refcount of these
  references, delaying their destruction.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally,
  this method provides a way to tell C<Devel::StackTrace> not to store
  these references.  Instead, C<Devel::StackTrace> replaces references
  with their stringified representation.
  
  This method defaults to true.  As with C<Trace()>, it is inherited by
  subclasses but setting it in a subclass makes it independent
  thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  =head2 MyException->RespectOverload($boolean)
  
  When a C<Devel::StackTrace> object stringifies, by default it ignores
  stringification overloading on any objects being dealt with.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally,
  this method provides a way to tell C<Devel::StackTrace> to respect
  overloading.
  
  This method defaults to false.  As with C<Trace()>, it is inherited by
  subclasses but setting it in a subclass makes it independent
  thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  =head2 MyException->MaxArgLength($boolean)
  
  When a C<Devel::StackTrace> object stringifies, by default it displays
  the full argument for each function. This parameter can be used to
  limit the maximum length of each argument.
  
  Since C<Exception::Class::Base> uses C<Devel::StackTrace> internally,
  this method provides a way to tell C<Devel::StackTrace> to limit the
  length of arguments.
  
  This method defaults to 0. As with C<Trace()>, it is inherited by
  subclasses but setting it in a subclass makes it independent
  thereafter.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  =head2 MyException->Fields
  
  This method returns the extra fields defined for the given class, as
  an array.
  
  Do not call this on the C<Exception::Class::Base> class directly or
  you'll change it for all exception classes that use
  L<Exception::Class>, including ones created in modules you don't
  control.
  
  =head2 MyException->throw( $message )
  
  =head2 MyException->throw( message => $message )
  
  =head2 MyException->throw( error => $error )
  
  This method creates a new object with the given error message.  If no
  error message is given, this will be an empty string.  It then dies
  with this object as its argument.
  
  This method also takes a C<show_trace> parameter which indicates
  whether or not the particular exception object being created should
  show a stacktrace when its C<as_string()> method is called.  This
  overrides the value of C<Trace()> for this class if it is given.
  
  The frames included in the trace can be controlled by the C<ignore_class>
  and C<ignore_package> parameters. These are passed directly to
  Devel::Stacktrace's constructor. See C<Devel::Stacktrace> for more details.
  
  If only a single value is given to the constructor it is assumed to be
  the message parameter.
  
  Additional keys corresponding to the fields defined for the particular
  exception subclass will also be accepted.
  
  =head2 MyException->new(...)
  
  This method takes the same parameters as C<throw()>, but instead of
  dying simply returns a new exception object.
  
  This method is always called when constructing a new exception object
  via the C<throw()> method.
  
  =head2 MyException->description()
  
  Returns the description for the given C<Exception::Class::Base>
  subclass.  The C<Exception::Class::Base> class's description is
  "Generic exception" (this may change in the future).  This is also an
  object method.
  
  =head2 $exception->rethrow()
  
  Simply dies with the object as its sole argument.  It's just syntactic
  sugar.  This does not change any of the object's attribute values.
  However, it will cause C<caller()> to report the die as coming from
  within the C<Exception::Class::Base> class rather than where rethrow
  was called.
  
  Of course, you always have access to the original stacktrace for the
  exception object.
  
  =head2 $exception->message()
  
  =head2 $exception->error()
  
  Returns the error/message associated with the exception.
  
  =head2 $exception->pid()
  
  Returns the pid at the time the exception was thrown.
  
  =head2 $exception->uid()
  
  Returns the real user id at the time the exception was thrown.
  
  =head2 $exception->gid()
  
  Returns the real group id at the time the exception was thrown.
  
  =head2 $exception->euid()
  
  Returns the effective user id at the time the exception was thrown.
  
  =head2 $exception->egid()
  
  Returns the effective group id at the time the exception was thrown.
  
  =head2 $exception->time()
  
  Returns the time in seconds since the epoch at the time the exception
  was thrown.
  
  =head2 $exception->package()
  
  Returns the package from which the exception was thrown.
  
  =head2 $exception->file()
  
  Returns the file within which the exception was thrown.
  
  =head2 $exception->line()
  
  Returns the line where the exception was thrown.
  
  =head2 $exception->trace()
  
  Returns the trace object associated with the object.
  
  =head2 $exception->show_trace($boolean)
  
  This method can be used to set whether or not a stack trace is
  included when the as_string method is called or the object is
  stringified.
  
  =head2 $exception->as_string()
  
  Returns a string form of the error message (something like what you'd
  expect from die).  If the class or object is set to show traces then
  then the full trace is also included.  The result looks like
  C<Carp::confess()>.
  
  =head2 $exception->full_message()
  
  Called by the C<as_string()> method to get the message.  By default,
  this is the same as calling the C<message()> method, but may be
  overridden by a subclass.  See below for details.
  
  =head1 LIGHTWEIGHT EXCEPTIONS
  
  A lightweight exception is one which records no information about its context
  when it is created. This can be achieved by setting C<<
  $class->NoContextInfo() >> to a true value.
  
  You can make this the default for a class of exceptions by setting it after
  creating the class:
  
    use Exception::Class (
        'LightWeight',
        'HeavyWeight',
    );
  
    LightWeight->NoContextInfo(1);
  
  A lightweight exception does have a stack trace object, nor does it record the
  time, pid, uid, euid, gid, or egid. It only has a message.
  
  =head1 OVERLOADING
  
  C<Exception::Class::Base> objects are overloaded so that
  stringification produces a normal error message.  This just calls the
  C<< $exception->as_string() >> method described above.  This means
  that you can just C<print $@> after an C<eval> and not worry about
  whether or not its an actual object.  It also means an application or
  module could do this:
  
   $SIG{__DIE__} = sub { Exception::Class::Base->throw( error => join '', @_ ); };
  
  and this would probably not break anything (unless someone was
  expecting a different type of exception object from C<die()>).
  
  =head1 OVERRIDING THE as_string METHOD
  
  By default, the C<as_string()> method simply returns the value
  C<message> or C<error> param plus a stack trace, if the class's
  C<Trace()> method returns a true value or C<show_trace> was set when
  creating the exception.
  
  However, once you add new fields to a subclass, you may want to
  include those fields in the stringified error.
  
  Inside the C<as_string()> method, the message (non-stack trace)
  portion of the error is generated by calling the C<full_message()>
  method.  This can be easily overridden.  For example:
  
    sub full_message {
        my $self = shift;
  
        my $msg = $self->message;
  
        $msg .= " and foo was " . $self->foo;
  
        return $msg;
    }
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Dave Rolsky.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
EXCEPTION_CLASS_BASE

$fatpacked{"ExtUtils/Command/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_COMMAND_MM';
  package ExtUtils::Command::MM;
  
  require 5.006;
  
  use strict;
  use warnings;
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT  = qw(test_harness pod2man perllocal_install uninstall
                    warn_if_old_packlist test_s cp_nonempty);
  our $VERSION = '6.92';
  
  my $Is_VMS = $^O eq 'VMS';
  
  eval {  require Time::HiRes; die unless Time::HiRes->can("stat"); };
  *mtime = $@ ?
   sub { [             stat($_[0])]->[9] } :
   sub { [Time::HiRes::stat($_[0])]->[9] } ;
  
  =head1 NAME
  
  ExtUtils::Command::MM - Commands for the MM's to use in Makefiles
  
  =head1 SYNOPSIS
  
    perl "-MExtUtils::Command::MM" -e "function" "--" arguments...
  
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY!>  The interface is not stable.
  
  ExtUtils::Command::MM encapsulates code which would otherwise have to
  be done with large "one" liners.
  
  Any $(FOO) used in the examples are make variables, not Perl.
  
  =over 4
  
  =item B<test_harness>
  
    test_harness($verbose, @test_libs);
  
  Runs the tests on @ARGV via Test::Harness passing through the $verbose
  flag.  Any @test_libs will be unshifted onto the test's @INC.
  
  @test_libs are run in alphabetical order.
  
  =cut
  
  sub test_harness {
      require Test::Harness;
      require File::Spec;
  
      $Test::Harness::verbose = shift;
  
      # Because Windows doesn't do this for us and listing all the *.t files
      # out on the command line can blow over its exec limit.
      require ExtUtils::Command;
      my @argv = ExtUtils::Command::expand_wildcards(@ARGV);
  
      local @INC = @INC;
      unshift @INC, map { File::Spec->rel2abs($_) } @_;
      Test::Harness::runtests(sort { lc $a cmp lc $b } @argv);
  }
  
  
  
  =item B<pod2man>
  
    pod2man( '--option=value',
             $podfile1 => $manpage1,
             $podfile2 => $manpage2,
             ...
           );
  
    # or args on @ARGV
  
  pod2man() is a function performing most of the duties of the pod2man
  program.  Its arguments are exactly the same as pod2man as of 5.8.0
  with the addition of:
  
      --perm_rw   octal permission to set the resulting manpage to
  
  And the removal of:
  
      --verbose/-v
      --help/-h
  
  If no arguments are given to pod2man it will read from @ARGV.
  
  If Pod::Man is unavailable, this function will warn and return undef.
  
  =cut
  
  sub pod2man {
      local @ARGV = @_ ? @_ : @ARGV;
  
      {
          local $@;
          if( !eval { require Pod::Man } ) {
              warn "Pod::Man is not available: $@".
                   "Man pages will not be generated during this install.\n";
              return 0;
          }
      }
      require Getopt::Long;
  
      # We will cheat and just use Getopt::Long.  We fool it by putting
      # our arguments into @ARGV.  Should be safe.
      my %options = ();
      Getopt::Long::config ('bundling_override');
      Getopt::Long::GetOptions (\%options,
                  'section|s=s', 'release|r=s', 'center|c=s',
                  'date|d=s', 'fixed=s', 'fixedbold=s', 'fixeditalic=s',
                  'fixedbolditalic=s', 'official|o', 'quotes|q=s', 'lax|l',
                  'name|n=s', 'perm_rw=i'
      );
  
      # If there's no files, don't bother going further.
      return 0 unless @ARGV;
  
      # Official sets --center, but don't override things explicitly set.
      if ($options{official} && !defined $options{center}) {
          $options{center} = q[Perl Programmer's Reference Guide];
      }
  
      # This isn't a valid Pod::Man option and is only accepted for backwards
      # compatibility.
      delete $options{lax};
  
      do {{  # so 'next' works
          my ($pod, $man) = splice(@ARGV, 0, 2);
  
          next if ((-e $man) &&
                   (mtime($man) > mtime($pod)) &&
                   (mtime($man) > mtime("Makefile")));
  
          print "Manifying $man\n";
  
          my $parser = Pod::Man->new(%options);
          $parser->parse_from_file($pod, $man)
            or do { warn("Could not install $man\n");  next };
  
          if (exists $options{perm_rw}) {
              chmod(oct($options{perm_rw}), $man)
                or do { warn("chmod $options{perm_rw} $man: $!\n"); next };
          }
      }} while @ARGV;
  
      return 1;
  }
  
  
  =item B<warn_if_old_packlist>
  
    perl "-MExtUtils::Command::MM" -e warn_if_old_packlist <somefile>
  
  Displays a warning that an old packlist file was found.  Reads the
  filename from @ARGV.
  
  =cut
  
  sub warn_if_old_packlist {
      my $packlist = $ARGV[0];
  
      return unless -f $packlist;
      print <<"PACKLIST_WARNING";
  WARNING: I have found an old package in
      $packlist.
  Please make sure the two installations are not conflicting
  PACKLIST_WARNING
  
  }
  
  
  =item B<perllocal_install>
  
      perl "-MExtUtils::Command::MM" -e perllocal_install
          <type> <module name> <key> <value> ...
  
      # VMS only, key|value pairs come on STDIN
      perl "-MExtUtils::Command::MM" -e perllocal_install
          <type> <module name> < <key>|<value> ...
  
  Prints a fragment of POD suitable for appending to perllocal.pod.
  Arguments are read from @ARGV.
  
  'type' is the type of what you're installing.  Usually 'Module'.
  
  'module name' is simply the name of your module.  (Foo::Bar)
  
  Key/value pairs are extra information about the module.  Fields include:
  
      installed into      which directory your module was out into
      LINKTYPE            dynamic or static linking
      VERSION             module version number
      EXE_FILES           any executables installed in a space seperated
                          list
  
  =cut
  
  sub perllocal_install {
      my($type, $name) = splice(@ARGV, 0, 2);
  
      # VMS feeds args as a piped file on STDIN since it usually can't
      # fit all the args on a single command line.
      my @mod_info = $Is_VMS ? split /\|/, <STDIN>
                             : @ARGV;
  
      my $pod;
      $pod = sprintf <<POD, scalar localtime;
   =head2 %s: C<$type> L<$name|$name>
  
   =over 4
  
  POD
  
      do {
          my($key, $val) = splice(@mod_info, 0, 2);
  
          $pod .= <<POD
   =item *
  
   C<$key: $val>
  
  POD
  
      } while(@mod_info);
  
      $pod .= "=back\n\n";
      $pod =~ s/^ //mg;
      print $pod;
  
      return 1;
  }
  
  =item B<uninstall>
  
      perl "-MExtUtils::Command::MM" -e uninstall <packlist>
  
  A wrapper around ExtUtils::Install::uninstall().  Warns that
  uninstallation is deprecated and doesn't actually perform the
  uninstallation.
  
  =cut
  
  sub uninstall {
      my($packlist) = shift @ARGV;
  
      require ExtUtils::Install;
  
      print <<'WARNING';
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  We will show what would have been done.
  
  WARNING
  
      ExtUtils::Install::uninstall($packlist, 1, 1);
  
      print <<'WARNING';
  
  Uninstall is unsafe and deprecated, the uninstallation was not performed.
  Please check the list above carefully, there may be errors.
  Remove the appropriate files manually.
  Sorry for the inconvenience.
  
  WARNING
  
  }
  
  =item B<test_s>
  
     perl "-MExtUtils::Command::MM" -e test_s <file>
  
  Tests if a file exists and is not empty (size > 0).
  I<Exits> with 0 if it does, 1 if it does not.
  
  =cut
  
  sub test_s {
    exit(-s $ARGV[0] ? 0 : 1);
  }
  
  =item B<cp_nonempty>
  
    perl "-MExtUtils::Command::MM" -e cp_nonempty <srcfile> <dstfile> <perm>
  
  Tests if the source file exists and is not empty (size > 0). If it is not empty
  it copies it to the given destination with the given permissions.
  
  =back
  
  =cut
  
  sub cp_nonempty {
    my @args = @ARGV;
    return 0 unless -s $args[0];
    require ExtUtils::Command;
    {
      local @ARGV = @args[0,1];
      ExtUtils::Command::cp(@ARGV);
    }
    {
      local @ARGV = @args[2,1];
      ExtUtils::Command::chmod(@ARGV);
    }
  }
  
  
  1;
EXTUTILS_COMMAND_MM

$fatpacked{"ExtUtils/Liblist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST';
  package ExtUtils::Liblist;
  
  use strict;
  
  our $VERSION = '6.92';
  
  use File::Spec;
  require ExtUtils::Liblist::Kid;
  our @ISA = qw(ExtUtils::Liblist::Kid File::Spec);
  
  # Backwards compatibility with old interface.
  sub ext {
      goto &ExtUtils::Liblist::Kid::ext;
  }
  
  sub lsdir {
    shift;
    my $rex = qr/$_[1]/;
    opendir DIR, $_[0];
    my @out = grep /$rex/, readdir DIR;
    closedir DIR;
    return @out;
  }
  
  __END__
  
  =head1 NAME
  
  ExtUtils::Liblist - determine libraries to use and how to use them
  
  =head1 SYNOPSIS
  
    require ExtUtils::Liblist;
  
    $MM->ext($potential_libs, $verbose, $need_names);
  
    # Usually you can get away with:
    ExtUtils::Liblist->ext($potential_libs, $verbose, $need_names)
  
  =head1 DESCRIPTION
  
  This utility takes a list of libraries in the form C<-llib1 -llib2
  -llib3> and returns lines suitable for inclusion in an extension
  Makefile.  Extra library paths may be included with the form
  C<-L/another/path> this will affect the searches for all subsequent
  libraries.
  
  It returns an array of four or five scalar values: EXTRALIBS,
  BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to
  the array of the filenames of actual libraries.  Some of these don't
  mean anything unless on Unix.  See the details about those platform
  specifics below.  The list of the filenames is returned only if
  $need_names argument is true.
  
  Dependent libraries can be linked in one of three ways:
  
  =over 2
  
  =item * For static extensions
  
  by the ld command when the perl binary is linked with the extension
  library. See EXTRALIBS below.
  
  =item * For dynamic extensions at build/link time
  
  by the ld command when the shared object is built/linked. See
  LDLOADLIBS below.
  
  =item * For dynamic extensions at load time
  
  by the DynaLoader when the shared object is loaded. See BSLOADLIBS
  below.
  
  =back
  
  =head2 EXTRALIBS
  
  List of libraries that need to be linked with when linking a perl
  binary which includes this extension. Only those libraries that
  actually exist are included.  These are written to a file and used
  when linking perl.
  
  =head2 LDLOADLIBS and LD_RUN_PATH
  
  List of those libraries which can or must be linked into the shared
  library when created using ld. These may be static or dynamic
  libraries.  LD_RUN_PATH is a colon separated list of the directories
  in LDLOADLIBS. It is passed as an environment variable to the process
  that links the shared library.
  
  =head2 BSLOADLIBS
  
  List of those libraries that are needed but can be linked in
  dynamically at run time on this platform.  SunOS/Solaris does not need
  this because ld records the information (from LDLOADLIBS) into the
  object file.  This list is used to create a .bs (bootstrap) file.
  
  =head1 PORTABILITY
  
  This module deals with a lot of system dependencies and has quite a
  few architecture specific C<if>s in the code.
  
  =head2 VMS implementation
  
  The version of ext() which is executed under VMS differs from the
  Unix-OS/2 version in several respects:
  
  =over 2
  
  =item *
  
  Input library and path specifications are accepted with or without the
  C<-l> and C<-L> prefixes used by Unix linkers.  If neither prefix is
  present, a token is considered a directory to search if it is in fact
  a directory, and a library to search for otherwise.  Authors who wish
  their extensions to be portable to Unix or OS/2 should use the Unix
  prefixes, since the Unix-OS/2 version of ext() requires them.
  
  =item *
  
  Wherever possible, shareable images are preferred to object libraries,
  and object libraries to plain object files.  In accordance with VMS
  naming conventions, ext() looks for files named I<lib>shr and I<lib>rtl;
  it also looks for I<lib>lib and libI<lib> to accommodate Unix conventions
  used in some ported software.
  
  =item *
  
  For each library that is found, an appropriate directive for a linker options
  file is generated.  The return values are space-separated strings of
  these directives, rather than elements used on the linker command line.
  
  =item *
  
  LDLOADLIBS contains both the libraries found based on C<$potential_libs> and
  the CRTLs, if any, specified in Config.pm.  EXTRALIBS contains just those
  libraries found based on C<$potential_libs>.  BSLOADLIBS and LD_RUN_PATH
  are always empty.
  
  =back
  
  In addition, an attempt is made to recognize several common Unix library
  names, and filter them out or convert them to their VMS equivalents, as
  appropriate.
  
  In general, the VMS version of ext() should properly handle input from
  extensions originally designed for a Unix or VMS environment.  If you
  encounter problems, or discover cases where the search could be improved,
  please let us know.
  
  =head2 Win32 implementation
  
  The version of ext() which is executed under Win32 differs from the
  Unix-OS/2 version in several respects:
  
  =over 2
  
  =item *
  
  If C<$potential_libs> is empty, the return value will be empty.
  Otherwise, the libraries specified by C<$Config{perllibs}> (see Config.pm)
  will be appended to the list of C<$potential_libs>.  The libraries
  will be searched for in the directories specified in C<$potential_libs>,
  C<$Config{libpth}>, and in C<$Config{installarchlib}/CORE>.
  For each library that is found,  a space-separated list of fully qualified
  library pathnames is generated.
  
  =item *
  
  Input library and path specifications are accepted with or without the
  C<-l> and C<-L> prefixes used by Unix linkers.
  
  An entry of the form C<-La:\foo> specifies the C<a:\foo> directory to look
  for the libraries that follow.
  
  An entry of the form C<-lfoo> specifies the library C<foo>, which may be
  spelled differently depending on what kind of compiler you are using.  If
  you are using GCC, it gets translated to C<libfoo.a>, but for other win32
  compilers, it becomes C<foo.lib>.  If no files are found by those translated
  names, one more attempt is made to find them using either C<foo.a> or
  C<libfoo.lib>, depending on whether GCC or some other win32 compiler is
  being used, respectively.
  
  If neither the C<-L> or C<-l> prefix is present in an entry, the entry is
  considered a directory to search if it is in fact a directory, and a
  library to search for otherwise.  The C<$Config{lib_ext}> suffix will
  be appended to any entries that are not directories and don't already have
  the suffix.
  
  Note that the C<-L> and C<-l> prefixes are B<not required>, but authors
  who wish their extensions to be portable to Unix or OS/2 should use the
  prefixes, since the Unix-OS/2 version of ext() requires them.
  
  =item *
  
  Entries cannot be plain object files, as many Win32 compilers will
  not handle object files in the place of libraries.
  
  =item *
  
  Entries in C<$potential_libs> beginning with a colon and followed by
  alphanumeric characters are treated as flags.  Unknown flags will be ignored.
  
  An entry that matches C</:nodefault/i> disables the appending of default
  libraries found in C<$Config{perllibs}> (this should be only needed very rarely).
  
  An entry that matches C</:nosearch/i> disables all searching for
  the libraries specified after it.  Translation of C<-Lfoo> and
  C<-lfoo> still happens as appropriate (depending on compiler being used,
  as reflected by C<$Config{cc}>), but the entries are not verified to be
  valid files or directories.
  
  An entry that matches C</:search/i> reenables searching for
  the libraries specified after it.  You can put it at the end to
  enable searching for default libraries specified by C<$Config{perllibs}>.
  
  =item *
  
  The libraries specified may be a mixture of static libraries and
  import libraries (to link with DLLs).  Since both kinds are used
  pretty transparently on the Win32 platform, we do not attempt to
  distinguish between them.
  
  =item *
  
  LDLOADLIBS and EXTRALIBS are always identical under Win32, and BSLOADLIBS
  and LD_RUN_PATH are always empty (this may change in future).
  
  =item *
  
  You must make sure that any paths and path components are properly
  surrounded with double-quotes if they contain spaces. For example,
  C<$potential_libs> could be (literally):
  
  	"-Lc:\Program Files\vc\lib" msvcrt.lib "la test\foo bar.lib"
  
  Note how the first and last entries are protected by quotes in order
  to protect the spaces.
  
  =item *
  
  Since this module is most often used only indirectly from extension
  C<Makefile.PL> files, here is an example C<Makefile.PL> entry to add
  a library to the build process for an extension:
  
          LIBS => ['-lgl']
  
  When using GCC, that entry specifies that MakeMaker should first look
  for C<libgl.a> (followed by C<gl.a>) in all the locations specified by
  C<$Config{libpth}>.
  
  When using a compiler other than GCC, the above entry will search for
  C<gl.lib> (followed by C<libgl.lib>).
  
  If the library happens to be in a location not in C<$Config{libpth}>,
  you need:
  
          LIBS => ['-Lc:\gllibs -lgl']
  
  Here is a less often used example:
  
          LIBS => ['-lgl', ':nosearch -Ld:\mesalibs -lmesa -luser32']
  
  This specifies a search for library C<gl> as before.  If that search
  fails to find the library, it looks at the next item in the list. The
  C<:nosearch> flag will prevent searching for the libraries that follow,
  so it simply returns the value as C<-Ld:\mesalibs -lmesa -luser32>,
  since GCC can use that value as is with its linker.
  
  When using the Visual C compiler, the second item is returned as
  C<-libpath:d:\mesalibs mesa.lib user32.lib>.
  
  When using the Borland compiler, the second item is returned as
  C<-Ld:\mesalibs mesa.lib user32.lib>, and MakeMaker takes care of
  moving the C<-Ld:\mesalibs> to the correct place in the linker
  command line.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
EXTUTILS_LIBLIST

$fatpacked{"ExtUtils/Liblist/Kid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_LIBLIST_KID';
  package ExtUtils::Liblist::Kid;
  
  # XXX Splitting this out into its own .pm is a temporary solution.
  
  # This kid package is to be used by MakeMaker.  It will not work if
  # $self is not a Makemaker.
  
  use 5.006;
  
  # Broken out of MakeMaker from version 4.11
  
  use strict;
  use warnings;
  our $VERSION = '6.92';
  
  use ExtUtils::MakeMaker::Config;
  use Cwd 'cwd';
  use File::Basename;
  use File::Spec;
  
  sub ext {
      if    ( $^O eq 'VMS' )     { return &_vms_ext; }
      elsif ( $^O eq 'MSWin32' ) { return &_win32_ext; }
      else                       { return &_unix_os2_ext; }
  }
  
  sub _unix_os2_ext {
      my ( $self, $potential_libs, $verbose, $give_libs ) = @_;
      $verbose ||= 0;
  
      if ( $^O =~ /os2|android/ and $Config{perllibs} ) {
  
          # Dynamic libraries are not transitive, so we may need including
          # the libraries linked against perl.dll/libperl.so again.
  
          $potential_libs .= " " if $potential_libs;
          $potential_libs .= $Config{perllibs};
      }
      return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;
      warn "Potential libraries are '$potential_libs':\n" if $verbose;
  
      my ( $so ) = $Config{so};
      my ( $libs ) = defined $Config{perllibs} ? $Config{perllibs} : $Config{libs};
      my $Config_libext = $Config{lib_ext} || ".a";
      my $Config_dlext = $Config{dlext};
  
      # compute $extralibs, $bsloadlibs and $ldloadlibs from
      # $potential_libs
      # this is a rewrite of Andy Dougherty's extliblist in perl
  
      my ( @searchpath );    # from "-L/path" entries in $potential_libs
      my ( @libpath ) = split " ", $Config{'libpth'};
      my ( @ldloadlibs, @bsloadlibs, @extralibs, @ld_run_path, %ld_run_path_seen );
      my ( @libs,       %libs_seen );
      my ( $fullname,   @fullname );
      my ( $pwd )   = cwd();    # from Cwd.pm
      my ( $found ) = 0;
  
      foreach my $thislib ( split ' ', $potential_libs ) {
  
          # Handle possible linker path arguments.
          if ( $thislib =~ s/^(-[LR]|-Wl,-R|-Wl,-rpath,)// ) {    # save path flag type
              my ( $ptype ) = $1;
              unless ( -d $thislib ) {
                  warn "$ptype$thislib ignored, directory does not exist\n"
                    if $verbose;
                  next;
              }
              my ( $rtype ) = $ptype;
              if ( ( $ptype eq '-R' ) or ( $ptype =~ m!^-Wl,-[Rr]! ) ) {
                  if ( $Config{'lddlflags'} =~ /-Wl,-[Rr]/ ) {
                      $rtype = '-Wl,-R';
                  }
                  elsif ( $Config{'lddlflags'} =~ /-R/ ) {
                      $rtype = '-R';
                  }
              }
              unless ( File::Spec->file_name_is_absolute( $thislib ) ) {
                  warn "Warning: $ptype$thislib changed to $ptype$pwd/$thislib\n";
                  $thislib = $self->catdir( $pwd, $thislib );
              }
              push( @searchpath, $thislib );
              push( @extralibs,  "$ptype$thislib" );
              push( @ldloadlibs, "$rtype$thislib" );
              next;
          }
  
          if ( $thislib =~ m!^-Wl,! ) {
              push( @extralibs,  $thislib );
              push( @ldloadlibs, $thislib );
              next;
          }
  
          # Handle possible library arguments.
          unless ( $thislib =~ s/^-l// ) {
              warn "Unrecognized argument in LIBS ignored: '$thislib'\n";
              next;
          }
  
          my ( $found_lib ) = 0;
          foreach my $thispth ( @searchpath, @libpath ) {
  
              # Try to find the full name of the library.  We need this to
              # determine whether it's a dynamically-loadable library or not.
              # This tends to be subject to various os-specific quirks.
              # For gcc-2.6.2 on linux (March 1995), DLD can not load
              # .sa libraries, with the exception of libm.sa, so we
              # deliberately skip them.
              if ( @fullname = $self->lsdir( $thispth, "^\Qlib$thislib.$so.\E[0-9]+" ) ) {
  
                  # Take care that libfoo.so.10 wins against libfoo.so.9.
                  # Compare two libraries to find the most recent version
                  # number.  E.g.  if you have libfoo.so.9.0.7 and
                  # libfoo.so.10.1, first convert all digits into two
                  # decimal places.  Then we'll add ".00" to the shorter
                  # strings so that we're comparing strings of equal length
                  # Thus we'll compare libfoo.so.09.07.00 with
                  # libfoo.so.10.01.00.  Some libraries might have letters
                  # in the version.  We don't know what they mean, but will
                  # try to skip them gracefully -- we'll set any letter to
                  # '0'.  Finally, sort in reverse so we can take the
                  # first element.
  
                  #TODO: iterate through the directory instead of sorting
  
                  $fullname = "$thispth/" . (
                      sort {
                          my ( $ma ) = $a;
                          my ( $mb ) = $b;
                          $ma =~ tr/A-Za-z/0/s;
                          $ma =~ s/\b(\d)\b/0$1/g;
                          $mb =~ tr/A-Za-z/0/s;
                          $mb =~ s/\b(\d)\b/0$1/g;
                          while ( length( $ma ) < length( $mb ) ) { $ma .= ".00"; }
                          while ( length( $mb ) < length( $ma ) ) { $mb .= ".00"; }
  
                          # Comparison deliberately backwards
                          $mb cmp $ma;
                        } @fullname
                  )[0];
              }
              elsif ( -f ( $fullname = "$thispth/lib$thislib.$so" )
                  && ( ( $Config{'dlsrc'} ne "dl_dld.xs" ) || ( $thislib eq "m" ) ) )
              {
              }
              elsif (-f ( $fullname = "$thispth/lib${thislib}_s$Config_libext" )
                  && ( $Config{'archname'} !~ /RM\d\d\d-svr4/ )
                  && ( $thislib .= "_s" ) )
              {    # we must explicitly use _s version
              }
              elsif ( -f ( $fullname = "$thispth/lib$thislib$Config_libext" ) ) {
              }
              elsif ( defined( $Config_dlext )
                  && -f ( $fullname = "$thispth/lib$thislib.$Config_dlext" ) )
              {
              }
              elsif ( -f ( $fullname = "$thispth/$thislib$Config_libext" ) ) {
              }
              elsif ( -f ( $fullname = "$thispth/lib$thislib.dll$Config_libext" ) ) {
              }
              elsif ( $^O eq 'cygwin' && -f ( $fullname = "$thispth/$thislib.dll" ) ) {
              }
              elsif ( -f ( $fullname = "$thispth/Slib$thislib$Config_libext" ) ) {
              }
              elsif ($^O eq 'dgux'
                  && -l ( $fullname = "$thispth/lib$thislib$Config_libext" )
                  && readlink( $fullname ) =~ /^elink:/s )
              {
  
                  # Some of DG's libraries look like misconnected symbolic
                  # links, but development tools can follow them.  (They
                  # look like this:
                  #
                  #    libm.a -> elink:${SDE_PATH:-/usr}/sde/\
                  #    ${TARGET_BINARY_INTERFACE:-m88kdgux}/usr/lib/libm.a
                  #
                  # , the compilation tools expand the environment variables.)
              }
              else {
                  warn "$thislib not found in $thispth\n" if $verbose;
                  next;
              }
              warn "'-l$thislib' found at $fullname\n" if $verbose;
              push @libs, $fullname unless $libs_seen{$fullname}++;
              $found++;
              $found_lib++;
  
              # Now update library lists
  
              # what do we know about this library...
              my $is_dyna = ( $fullname !~ /\Q$Config_libext\E\z/ );
              my $in_perl = ( $libs =~ /\B-l\Q${thislib}\E\b/s );
  
              # include the path to the lib once in the dynamic linker path
              # but only if it is a dynamic lib and not in Perl itself
              my ( $fullnamedir ) = dirname( $fullname );
              push @ld_run_path, $fullnamedir
                if $is_dyna
                    && !$in_perl
                    && !$ld_run_path_seen{$fullnamedir}++;
  
              # Do not add it into the list if it is already linked in
              # with the main perl executable.
              # We have to special-case the NeXT, because math and ndbm
              # are both in libsys_s
              unless (
                  $in_perl
                  || ( $Config{'osname'} eq 'next'
                      && ( $thislib eq 'm' || $thislib eq 'ndbm' ) )
                )
              {
                  push( @extralibs, "-l$thislib" );
              }
  
              # We might be able to load this archive file dynamically
              if (   ( $Config{'dlsrc'} =~ /dl_next/ && $Config{'osvers'} lt '4_0' )
                  || ( $Config{'dlsrc'} =~ /dl_dld/ ) )
              {
  
                  # We push -l$thislib instead of $fullname because
                  # it avoids hardwiring a fixed path into the .bs file.
                  # Mkbootstrap will automatically add dl_findfile() to
                  # the .bs file if it sees a name in the -l format.
                  # USE THIS, when dl_findfile() is fixed:
                  # push(@bsloadlibs, "-l$thislib");
                  # OLD USE WAS while checking results against old_extliblist
                  push( @bsloadlibs, "$fullname" );
              }
              else {
                  if ( $is_dyna ) {
  
                      # For SunOS4, do not add in this shared library if
                      # it is already linked in the main perl executable
                      push( @ldloadlibs, "-l$thislib" )
                        unless ( $in_perl and $^O eq 'sunos' );
                  }
                  else {
                      push( @ldloadlibs, "-l$thislib" );
                  }
              }
              last;    # found one here so don't bother looking further
          }
          warn "Warning (mostly harmless): " . "No library found for -l$thislib\n"
            unless $found_lib > 0;
      }
  
      unless ( $found ) {
          return ( '', '', '', '', ( $give_libs ? \@libs : () ) );
      }
      else {
          return ( "@extralibs", "@bsloadlibs", "@ldloadlibs", join( ":", @ld_run_path ), ( $give_libs ? \@libs : () ) );
      }
  }
  
  sub _win32_ext {
  
      require Text::ParseWords;
  
      my ( $self, $potential_libs, $verbose, $give_libs ) = @_;
      $verbose ||= 0;
  
      # If user did not supply a list, we punt.
      # (caller should probably use the list in $Config{libs})
      return ( "", "", "", "", ( $give_libs ? [] : () ) ) unless $potential_libs;
  
      # TODO: make this use MM_Win32.pm's compiler detection
      my %libs_seen;
      my @extralibs;
      my $cc = $Config{cc} || '';
      my $VC = $cc =~ /\bcl\b/i;
      my $GC = $cc =~ /\bgcc\b/i;
  
      my $libext     = _win32_lib_extensions();
      my @searchpath = ( '' );                                    # from "-L/path" entries in $potential_libs
      my @libpath    = _win32_default_search_paths( $VC, $GC );
      my $pwd        = cwd();                                     # from Cwd.pm
      my $search     = 1;
  
      # compute @extralibs from $potential_libs
      my @lib_search_list = _win32_make_lib_search_list( $potential_libs, $verbose );
      for ( @lib_search_list ) {
  
          my $thislib = $_;
  
          # see if entry is a flag
          if ( /^:\w+$/ ) {
              $search = 0 if lc eq ':nosearch';
              $search = 1 if lc eq ':search';
              _debug( "Ignoring unknown flag '$thislib'\n", $verbose ) if !/^:(no)?(search|default)$/i;
              next;
          }
  
          # if searching is disabled, do compiler-specific translations
          unless ( $search ) {
              s/^-l(.+)$/$1.lib/ unless $GC;
              s/^-L/-libpath:/ if $VC;
              push( @extralibs, $_ );
              next;
          }
  
          # handle possible linker path arguments
          if ( s/^-L// and not -d ) {
              _debug( "$thislib ignored, directory does not exist\n", $verbose );
              next;
          }
          elsif ( -d ) {
              unless ( File::Spec->file_name_is_absolute( $_ ) ) {
                  warn "Warning: '$thislib' changed to '-L$pwd/$_'\n";
                  $_ = $self->catdir( $pwd, $_ );
              }
              push( @searchpath, $_ );
              next;
          }
  
          my @paths = ( @searchpath, @libpath );
          my ( $fullname, $path ) = _win32_search_file( $thislib, $libext, \@paths, $verbose, $GC );
  
          if ( !$fullname ) {
              warn "Warning (mostly harmless): No library found for $thislib\n";
              next;
          }
  
          _debug( "'$thislib' found as '$fullname'\n", $verbose );
          push( @extralibs, $fullname );
          $libs_seen{$fullname} = 1 if $path;    # why is this a special case?
      }
  
      my @libs = keys %libs_seen;
  
      return ( '', '', '', '', ( $give_libs ? \@libs : () ) ) unless @extralibs;
  
      # make sure paths with spaces are properly quoted
      @extralibs = map { /\s/ ? qq["$_"] : $_ } @extralibs;
      @libs      = map { /\s/ ? qq["$_"] : $_ } @libs;
  
      my $lib = join( ' ', @extralibs );
  
      # normalize back to backward slashes (to help braindead tools)
      # XXX this may break equally braindead GNU tools that don't understand
      # backslashes, either.  Seems like one can't win here.  Cursed be CP/M.
      $lib =~ s,/,\\,g;
  
      _debug( "Result: $lib\n", $verbose );
      wantarray ? ( $lib, '', $lib, '', ( $give_libs ? \@libs : () ) ) : $lib;
  }
  
  sub _win32_make_lib_search_list {
      my ( $potential_libs, $verbose ) = @_;
  
      # If Config.pm defines a set of default libs, we always
      # tack them on to the user-supplied list, unless the user
      # specified :nodefault
      my $libs = $Config{'perllibs'};
      $potential_libs = join( ' ', $potential_libs, $libs ) if $libs and $potential_libs !~ /:nodefault/i;
      _debug( "Potential libraries are '$potential_libs':\n", $verbose );
  
      $potential_libs =~ s,\\,/,g;    # normalize to forward slashes
  
      my @list = Text::ParseWords::quotewords( '\s+', 0, $potential_libs );
  
      return @list;
  }
  
  sub _win32_default_search_paths {
      my ( $VC, $GC ) = @_;
  
      my $libpth = $Config{'libpth'} || '';
      $libpth =~ s,\\,/,g;            # normalize to forward slashes
  
      my @libpath = Text::ParseWords::quotewords( '\s+', 0, $libpth );
      push @libpath, "$Config{installarchlib}/CORE";    # add "$Config{installarchlib}/CORE" to default search path
  
      push @libpath, split /;/, $ENV{LIB}          if $VC and $ENV{LIB};
      push @libpath, split /;/, $ENV{LIBRARY_PATH} if $GC and $ENV{LIBRARY_PATH};
  
      return @libpath;
  }
  
  sub _win32_search_file {
      my ( $thislib, $libext, $paths, $verbose, $GC ) = @_;
  
      my @file_list = _win32_build_file_list( $thislib, $GC, $libext );
  
      for my $lib_file ( @file_list ) {
          for my $path ( @{$paths} ) {
              my $fullname = $lib_file;
              $fullname = "$path\\$fullname" if $path;
  
              return ( $fullname, $path ) if -f $fullname;
  
              _debug( "'$thislib' not found as '$fullname'\n", $verbose );
          }
      }
  
      return;
  }
  
  sub _win32_build_file_list {
      my ( $lib, $GC, $extensions ) = @_;
  
      my @pre_fixed = _win32_build_prefixed_list( $lib, $GC );
      return map _win32_attach_extensions( $_, $extensions ), @pre_fixed;
  }
  
  sub _win32_build_prefixed_list {
      my ( $lib, $GC ) = @_;
  
      return $lib if $lib !~ s/^-l//;
      return $lib if $lib =~ /^lib/ and !$GC;
  
      ( my $no_prefix = $lib ) =~ s/^lib//i;
      $lib = "lib$lib" if $no_prefix eq $lib;
  
      return ( $lib, $no_prefix ) if $GC;
      return ( $no_prefix, $lib );
  }
  
  sub _win32_attach_extensions {
      my ( $lib, $extensions ) = @_;
      return map _win32_try_attach_extension( $lib, $_ ), @{$extensions};
  }
  
  sub _win32_try_attach_extension {
      my ( $lib, $extension ) = @_;
  
      return $lib if $lib =~ /\Q$extension\E$/i;
      return "$lib$extension";
  }
  
  sub _win32_lib_extensions {
      my @extensions;
      push @extensions, $Config{'lib_ext'} if $Config{'lib_ext'};
      push @extensions, '.dll.a' if grep { m!^\.a$! } @extensions;
      push @extensions, '.lib' unless grep { m!^\.lib$! } @extensions;
      return \@extensions;
  }
  
  sub _debug {
      my ( $message, $verbose ) = @_;
      return if !$verbose;
      warn $message;
      return;
  }
  
  sub _vms_ext {
      my ( $self, $potential_libs, $verbose, $give_libs ) = @_;
      $verbose ||= 0;
  
      my ( @crtls, $crtlstr );
      @crtls = ( ( $Config{'ldflags'} =~ m-/Debug-i ? $Config{'dbgprefix'} : '' ) . 'PerlShr/Share' );
      push( @crtls, grep { not /\(/ } split /\s+/, $Config{'perllibs'} );
      push( @crtls, grep { not /\(/ } split /\s+/, $Config{'libc'} );
  
      # In general, we pass through the basic libraries from %Config unchanged.
      # The one exception is that if we're building in the Perl source tree, and
      # a library spec could be resolved via a logical name, we go to some trouble
      # to insure that the copy in the local tree is used, rather than one to
      # which a system-wide logical may point.
      if ( $self->{PERL_SRC} ) {
          my ( $locspec, $type );
          foreach my $lib ( @crtls ) {
              if ( ( $locspec, $type ) = $lib =~ m{^([\w\$-]+)(/\w+)?} and $locspec =~ /perl/i ) {
                  if    ( lc $type eq '/share' )   { $locspec .= $Config{'exe_ext'}; }
                  elsif ( lc $type eq '/library' ) { $locspec .= $Config{'lib_ext'}; }
                  else                             { $locspec .= $Config{'obj_ext'}; }
                  $locspec = $self->catfile( $self->{PERL_SRC}, $locspec );
                  $lib = "$locspec$type" if -e $locspec;
              }
          }
      }
      $crtlstr = @crtls ? join( ' ', @crtls ) : '';
  
      unless ( $potential_libs ) {
          warn "Result:\n\tEXTRALIBS: \n\tLDLOADLIBS: $crtlstr\n" if $verbose;
          return ( '', '', $crtlstr, '', ( $give_libs ? [] : () ) );
      }
  
      my ( %found, @fndlibs, $ldlib );
      my $cwd = cwd();
      my ( $so, $lib_ext, $obj_ext ) = @Config{ 'so', 'lib_ext', 'obj_ext' };
  
      # List of common Unix library names and their VMS equivalents
      # (VMS equivalent of '' indicates that the library is automatically
      # searched by the linker, and should be skipped here.)
      my ( @flibs, %libs_seen );
      my %libmap = (
          'm'      => '',
          'f77'    => '',
          'F77'    => '',
          'V77'    => '',
          'c'      => '',
          'malloc' => '',
          'crypt'  => '',
          'resolv' => '',
          'c_s'    => '',
          'socket' => '',
          'X11'    => 'DECW$XLIBSHR',
          'Xt'     => 'DECW$XTSHR',
          'Xm'     => 'DECW$XMLIBSHR',
          'Xmu'    => 'DECW$XMULIBSHR'
      );
      if ( $Config{'vms_cc_type'} ne 'decc' ) { $libmap{'curses'} = 'VAXCCURSE'; }
  
      warn "Potential libraries are '$potential_libs'\n" if $verbose;
  
      # First, sort out directories and library names in the input
      my ( @dirs, @libs );
      foreach my $lib ( split ' ', $potential_libs ) {
          push( @dirs, $1 ),   next if $lib =~ /^-L(.*)/;
          push( @dirs, $lib ), next if $lib =~ /[:>\]]$/;
          push( @dirs, $lib ), next if -d $lib;
          push( @libs, $1 ),   next if $lib =~ /^-l(.*)/;
          push( @libs, $lib );
      }
      push( @dirs, split( ' ', $Config{'libpth'} ) );
  
      # Now make sure we've got VMS-syntax absolute directory specs
      # (We don't, however, check whether someone's hidden a relative
      # path in a logical name.)
      foreach my $dir ( @dirs ) {
          unless ( -d $dir ) {
              warn "Skipping nonexistent Directory $dir\n" if $verbose > 1;
              $dir = '';
              next;
          }
          warn "Resolving directory $dir\n" if $verbose;
          if ( File::Spec->file_name_is_absolute( $dir ) ) {
              $dir = $self->fixpath( $dir, 1 );
          }
          else {
              $dir = $self->catdir( $cwd, $dir );
          }
      }
      @dirs = grep { length( $_ ) } @dirs;
      unshift( @dirs, '' );    # Check each $lib without additions first
  
    LIB: foreach my $lib ( @libs ) {
          if ( exists $libmap{$lib} ) {
              next unless length $libmap{$lib};
              $lib = $libmap{$lib};
          }
  
          my ( @variants, $cand );
          my ( $ctype ) = '';
  
          # If we don't have a file type, consider it a possibly abbreviated name and
          # check for common variants.  We try these first to grab libraries before
          # a like-named executable image (e.g. -lperl resolves to perlshr.exe
          # before perl.exe).
          if ( $lib !~ /\.[^:>\]]*$/ ) {
              push( @variants, "${lib}shr", "${lib}rtl", "${lib}lib" );
              push( @variants, "lib$lib" ) if $lib !~ /[:>\]]/;
          }
          push( @variants, $lib );
          warn "Looking for $lib\n" if $verbose;
          foreach my $variant ( @variants ) {
              my ( $fullname, $name );
  
              foreach my $dir ( @dirs ) {
                  my ( $type );
  
                  $name = "$dir$variant";
                  warn "\tChecking $name\n" if $verbose > 2;
                  $fullname = VMS::Filespec::rmsexpand( $name );
                  if ( defined $fullname and -f $fullname ) {
  
                      # It's got its own suffix, so we'll have to figure out the type
                      if    ( $fullname =~ /(?:$so|exe)$/i )      { $type = 'SHR'; }
                      elsif ( $fullname =~ /(?:$lib_ext|olb)$/i ) { $type = 'OLB'; }
                      elsif ( $fullname =~ /(?:$obj_ext|obj)$/i ) {
                          warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
                          $type = 'OBJ';
                      }
                      else {
                          warn "Warning (mostly harmless): " . "Unknown library type for $fullname; assuming shared\n";
                          $type = 'SHR';
                      }
                  }
                  elsif (-f ( $fullname = VMS::Filespec::rmsexpand( $name, $so ) )
                      or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.exe' ) ) )
                  {
                      $type = 'SHR';
                      $name = $fullname unless $fullname =~ /exe;?\d*$/i;
                  }
                  elsif (
                      not length( $ctype ) and    # If we've got a lib already,
                                                  # don't bother
                      ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $lib_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.olb' ) ) )
                    )
                  {
                      $type = 'OLB';
                      $name = $fullname unless $fullname =~ /olb;?\d*$/i;
                  }
                  elsif (
                      not length( $ctype ) and    # If we've got a lib already,
                                                  # don't bother
                      ( -f ( $fullname = VMS::Filespec::rmsexpand( $name, $obj_ext ) ) or -f ( $fullname = VMS::Filespec::rmsexpand( $name, '.obj' ) ) )
                    )
                  {
                      warn "Warning (mostly harmless): " . "Plain object file $fullname found in library list\n";
                      $type = 'OBJ';
                      $name = $fullname unless $fullname =~ /obj;?\d*$/i;
                  }
                  if ( defined $type ) {
                      $ctype = $type;
                      $cand  = $name;
                      last if $ctype eq 'SHR';
                  }
              }
              if ( $ctype ) {
  
                  # This has to precede any other CRTLs, so just make it first
                  if ( $cand eq 'VAXCCURSE' ) { unshift @{ $found{$ctype} }, $cand; }
                  else                        { push @{ $found{$ctype} }, $cand; }
                  warn "\tFound as $cand (really $fullname), type $ctype\n"
                    if $verbose > 1;
                  push @flibs, $name unless $libs_seen{$fullname}++;
                  next LIB;
              }
          }
          warn "Warning (mostly harmless): " . "No library found for $lib\n";
      }
  
      push @fndlibs, @{ $found{OBJ} } if exists $found{OBJ};
      push @fndlibs, map { "$_/Library" } @{ $found{OLB} } if exists $found{OLB};
      push @fndlibs, map { "$_/Share" } @{ $found{SHR} }   if exists $found{SHR};
      my $lib = join( ' ', @fndlibs );
  
      $ldlib = $crtlstr ? "$lib $crtlstr" : $lib;
      warn "Result:\n\tEXTRALIBS: $lib\n\tLDLOADLIBS: $ldlib\n" if $verbose;
      wantarray ? ( $lib, '', $ldlib, '', ( $give_libs ? \@flibs : () ) ) : $lib;
  }
  
  1;
EXTUTILS_LIBLIST_KID

$fatpacked{"ExtUtils/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM';
  package ExtUtils::MM;
  
  use strict;
  use ExtUtils::MakeMaker::Config;
  
  our $VERSION = '6.92';
  
  require ExtUtils::Liblist;
  require ExtUtils::MakeMaker;
  our @ISA = qw(ExtUtils::Liblist ExtUtils::MakeMaker);
  
  =head1 NAME
  
  ExtUtils::MM - OS adjusted ExtUtils::MakeMaker subclass
  
  =head1 SYNOPSIS
  
    require ExtUtils::MM;
    my $mm = MM->new(...);
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY>
  
  ExtUtils::MM is a subclass of ExtUtils::MakeMaker which automatically
  chooses the appropriate OS specific subclass for you
  (ie. ExtUils::MM_Unix, etc...).
  
  It also provides a convenient alias via the MM class (I didn't want
  MakeMaker modules outside of ExtUtils/).
  
  This class might turn out to be a temporary solution, but MM won't go
  away.
  
  =cut
  
  {
      # Convenient alias.
      package MM;
      our @ISA = qw(ExtUtils::MM);
      sub DESTROY {}
  }
  
  sub _is_win95 {
      # miniperl might not have the Win32 functions available and we need
      # to run in miniperl.
      my $have_win32 = eval { require Win32 };
      return $have_win32 && defined &Win32::IsWin95 ? Win32::IsWin95()
                                                    : ! defined $ENV{SYSTEMROOT};
  }
  
  my %Is = ();
  $Is{VMS}    = $^O eq 'VMS';
  $Is{OS2}    = $^O eq 'os2';
  $Is{MacOS}  = $^O eq 'MacOS';
  if( $^O eq 'MSWin32' ) {
      _is_win95() ? $Is{Win95} = 1 : $Is{Win32} = 1;
  }
  $Is{UWIN}   = $^O =~ /^uwin(-nt)?$/;
  $Is{Cygwin} = $^O eq 'cygwin';
  $Is{NW5}    = $Config{osname} eq 'NetWare';  # intentional
  $Is{BeOS}   = ($^O =~ /beos/i or $^O eq 'haiku');
  $Is{DOS}    = $^O eq 'dos';
  if( $Is{NW5} ) {
      $^O = 'NetWare';
      delete $Is{Win32};
  }
  $Is{VOS}    = $^O eq 'vos';
  $Is{QNX}    = $^O eq 'qnx';
  $Is{AIX}    = $^O eq 'aix';
  $Is{Darwin} = $^O eq 'darwin';
  
  $Is{Unix}   = !grep { $_ } values %Is;
  
  map { delete $Is{$_} unless $Is{$_} } keys %Is;
  _assert( keys %Is == 1 );
  my($OS) = keys %Is;
  
  
  my $class = "ExtUtils::MM_$OS";
  eval "require $class" unless $INC{"ExtUtils/MM_$OS.pm"}; ## no critic
  die $@ if $@;
  unshift @ISA, $class;
  
  
  sub _assert {
      my $sanity = shift;
      die sprintf "Assert failed at %s line %d\n", (caller)[1,2] unless $sanity;
      return;
  }
EXTUTILS_MM

$fatpacked{"ExtUtils/MM_AIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_AIX';
  package ExtUtils::MM_AIX;
  
  use strict;
  our $VERSION = '6.92';
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  use ExtUtils::MakeMaker qw(neatvalue);
  
  
  =head1 NAME
  
  ExtUtils::MM_AIX - AIX specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  AIX.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =head3 dlsyms
  
  Define DL_FUNCS and DL_VARS and write the *.exp files.
  
  =cut
  
  sub dlsyms {
      my($self,%attribs) = @_;
  
      return '' unless $self->needs_linking();
  
      my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
      my($vars)  = $attribs{DL_VARS} || $self->{DL_VARS} || [];
      my($funclist)  = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
      my(@m);
  
      push(@m,"
  dynamic :: $self->{BASEEXT}.exp
  
  ") unless $self->{SKIPHASH}{'dynamic'}; # dynamic and static are subs, so...
  
      push(@m,"
  static :: $self->{BASEEXT}.exp
  
  ") unless $self->{SKIPHASH}{'static'};  # we avoid a warning if we tick them
  
      push(@m,"
  $self->{BASEEXT}.exp: Makefile.PL
  ",'	$(PERLRUN) -e \'use ExtUtils::Mksymlists; \\
  	Mksymlists("NAME" => "',$self->{NAME},'", "DL_FUNCS" => ',
  	neatvalue($funcs), ', "FUNCLIST" => ', neatvalue($funclist),
  	', "DL_VARS" => ', neatvalue($vars), ');\'
  ');
  
      join('',@m);
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  
  1;
EXTUTILS_MM_AIX

$fatpacked{"ExtUtils/MM_Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_ANY';
  package ExtUtils::MM_Any;
  
  use strict;
  our $VERSION = '6.92';
  
  use Carp;
  use File::Spec;
  use File::Basename;
  BEGIN { our @ISA = qw(File::Spec); }
  
  # We need $Verbose
  use ExtUtils::MakeMaker qw($Verbose);
  
  use ExtUtils::MakeMaker::Config;
  
  
  # So we don't have to keep calling the methods over and over again,
  # we have these globals to cache the values.  Faster and shrtr.
  my $Curdir  = __PACKAGE__->curdir;
  my $Rootdir = __PACKAGE__->rootdir;
  my $Updir   = __PACKAGE__->updir;
  
  
  =head1 NAME
  
  ExtUtils::MM_Any - Platform-agnostic MM methods
  
  =head1 SYNOPSIS
  
    FOR INTERNAL USE ONLY!
  
    package ExtUtils::MM_SomeOS;
  
    # Temporarily, you have to subclass both.  Put MM_Any first.
    require ExtUtils::MM_Any;
    require ExtUtils::MM_Unix;
    @ISA = qw(ExtUtils::MM_Any ExtUtils::Unix);
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY!>
  
  ExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of
  modules.  It contains methods which are either inherently
  cross-platform or are written in a cross-platform manner.
  
  Subclass off of ExtUtils::MM_Any I<and> ExtUtils::MM_Unix.  This is a
  temporary solution.
  
  B<THIS MAY BE TEMPORARY!>
  
  
  =head1 METHODS
  
  Any methods marked I<Abstract> must be implemented by subclasses.
  
  
  =head2 Cross-platform helper methods
  
  These are methods which help writing cross-platform code.
  
  
  
  =head3 os_flavor  I<Abstract>
  
      my @os_flavor = $mm->os_flavor;
  
  @os_flavor is the style of operating system this is, usually
  corresponding to the MM_*.pm file we're using.
  
  The first element of @os_flavor is the major family (ie. Unix,
  Windows, VMS, OS/2, etc...) and the rest are sub families.
  
  Some examples:
  
      Cygwin98       ('Unix',  'Cygwin', 'Cygwin9x')
      Windows        ('Win32')
      Win98          ('Win32', 'Win9x')
      Linux          ('Unix',  'Linux')
      MacOS X        ('Unix',  'Darwin', 'MacOS', 'MacOS X')
      OS/2           ('OS/2')
  
  This is used to write code for styles of operating system.
  See os_flavor_is() for use.
  
  
  =head3 os_flavor_is
  
      my $is_this_flavor = $mm->os_flavor_is($this_flavor);
      my $is_this_flavor = $mm->os_flavor_is(@one_of_these_flavors);
  
  Checks to see if the current operating system is one of the given flavors.
  
  This is useful for code like:
  
      if( $mm->os_flavor_is('Unix') ) {
          $out = `foo 2>&1`;
      }
      else {
          $out = `foo`;
      }
  
  =cut
  
  sub os_flavor_is {
      my $self = shift;
      my %flavors = map { ($_ => 1) } $self->os_flavor;
      return (grep { $flavors{$_} } @_) ? 1 : 0;
  }
  
  
  =head3 can_load_xs
  
      my $can_load_xs = $self->can_load_xs;
  
  Returns true if we have the ability to load XS.
  
  This is important because miniperl, used to build XS modules in the
  core, can not load XS.
  
  =cut
  
  sub can_load_xs {
      return defined &DynaLoader::boot_DynaLoader ? 1 : 0;
  }
  
  
  =head3 split_command
  
      my @cmds = $MM->split_command($cmd, @args);
  
  Most OS have a maximum command length they can execute at once.  Large
  modules can easily generate commands well past that limit.  Its
  necessary to split long commands up into a series of shorter commands.
  
  C<split_command> will return a series of @cmds each processing part of
  the args.  Collectively they will process all the arguments.  Each
  individual line in @cmds will not be longer than the
  $self->max_exec_len being careful to take into account macro expansion.
  
  $cmd should include any switches and repeated initial arguments.
  
  If no @args are given, no @cmds will be returned.
  
  Pairs of arguments will always be preserved in a single command, this
  is a heuristic for things like pm_to_blib and pod2man which work on
  pairs of arguments.  This makes things like this safe:
  
      $self->split_command($cmd, %pod2man);
  
  
  =cut
  
  sub split_command {
      my($self, $cmd, @args) = @_;
  
      my @cmds = ();
      return(@cmds) unless @args;
  
      # If the command was given as a here-doc, there's probably a trailing
      # newline.
      chomp $cmd;
  
      # set aside 30% for macro expansion.
      my $len_left = int($self->max_exec_len * 0.70);
      $len_left -= length $self->_expand_macros($cmd);
  
      do {
          my $arg_str = '';
          my @next_args;
          while( @next_args = splice(@args, 0, 2) ) {
              # Two at a time to preserve pairs.
              my $next_arg_str = "\t  ". join ' ', @next_args, "\n";
  
              if( !length $arg_str ) {
                  $arg_str .= $next_arg_str
              }
              elsif( length($arg_str) + length($next_arg_str) > $len_left ) {
                  unshift @args, @next_args;
                  last;
              }
              else {
                  $arg_str .= $next_arg_str;
              }
          }
          chop $arg_str;
  
          push @cmds, $self->escape_newlines("$cmd \n$arg_str");
      } while @args;
  
      return @cmds;
  }
  
  
  sub _expand_macros {
      my($self, $cmd) = @_;
  
      $cmd =~ s{\$\((\w+)\)}{
          defined $self->{$1} ? $self->{$1} : "\$($1)"
      }e;
      return $cmd;
  }
  
  
  =head3 echo
  
      my @commands = $MM->echo($text);
      my @commands = $MM->echo($text, $file);
      my @commands = $MM->echo($text, $file, \%opts);
  
  Generates a set of @commands which print the $text to a $file.
  
  If $file is not given, output goes to STDOUT.
  
  If $opts{append} is true the $file will be appended to rather than
  overwritten.  Default is to overwrite.
  
  If $opts{allow_variables} is true, make variables of the form
  C<$(...)> will not be escaped.  Other C<$> will.  Default is to escape
  all C<$>.
  
  Example of use:
  
      my $make = map "\t$_\n", $MM->echo($text, $file);
  
  =cut
  
  sub echo {
      my($self, $text, $file, $opts) = @_;
  
      # Compatibility with old options
      if( !ref $opts ) {
          my $append = $opts;
          $opts = { append => $append || 0 };
      }
      $opts->{allow_variables} = 0 unless defined $opts->{allow_variables};
  
      my $ql_opts = { allow_variables => $opts->{allow_variables} };
      my @cmds = map { '$(NOECHO) $(ECHO) '.$self->quote_literal($_, $ql_opts) }
                 split /\n/, $text;
      if( $file ) {
          my $redirect = $opts->{append} ? '>>' : '>';
          $cmds[0] .= " $redirect $file";
          $_ .= " >> $file" foreach @cmds[1..$#cmds];
      }
  
      return @cmds;
  }
  
  
  =head3 wraplist
  
    my $args = $mm->wraplist(@list);
  
  Takes an array of items and turns them into a well-formatted list of
  arguments.  In most cases this is simply something like:
  
      FOO \
      BAR \
      BAZ
  
  =cut
  
  sub wraplist {
      my $self = shift;
      return join " \\\n\t", @_;
  }
  
  
  =head3 maketext_filter
  
      my $filter_make_text = $mm->maketext_filter($make_text);
  
  The text of the Makefile is run through this method before writing to
  disk.  It allows systems a chance to make portability fixes to the
  Makefile.
  
  By default it does nothing.
  
  This method is protected and not intended to be called outside of
  MakeMaker.
  
  =cut
  
  sub maketext_filter { return $_[1] }
  
  
  =head3 cd  I<Abstract>
  
    my $subdir_cmd = $MM->cd($subdir, @cmds);
  
  This will generate a make fragment which runs the @cmds in the given
  $dir.  The rough equivalent to this, except cross platform.
  
    cd $subdir && $cmd
  
  Currently $dir can only go down one level.  "foo" is fine.  "foo/bar" is
  not.  "../foo" is right out.
  
  The resulting $subdir_cmd has no leading tab nor trailing newline.  This
  makes it easier to embed in a make string.  For example.
  
        my $make = sprintf <<'CODE', $subdir_cmd;
    foo :
        $(ECHO) what
        %s
        $(ECHO) mouche
    CODE
  
  
  =head3 oneliner  I<Abstract>
  
    my $oneliner = $MM->oneliner($perl_code);
    my $oneliner = $MM->oneliner($perl_code, \@switches);
  
  This will generate a perl one-liner safe for the particular platform
  you're on based on the given $perl_code and @switches (a -e is
  assumed) suitable for using in a make target.  It will use the proper
  shell quoting and escapes.
  
  $(PERLRUN) will be used as perl.
  
  Any newlines in $perl_code will be escaped.  Leading and trailing
  newlines will be stripped.  Makes this idiom much easier:
  
      my $code = $MM->oneliner(<<'CODE', [...switches...]);
  some code here
  another line here
  CODE
  
  Usage might be something like:
  
      # an echo emulation
      $oneliner = $MM->oneliner('print "Foo\n"');
      $make = '$oneliner > somefile';
  
  All dollar signs must be doubled in the $perl_code if you expect them
  to be interpreted normally, otherwise it will be considered a make
  macro.  Also remember to quote make macros else it might be used as a
  bareword.  For example:
  
      # Assign the value of the $(VERSION_FROM) make macro to $vf.
      $oneliner = $MM->oneliner('$$vf = "$(VERSION_FROM)"');
  
  Its currently very simple and may be expanded sometime in the figure
  to include more flexible code and switches.
  
  
  =head3 quote_literal  I<Abstract>
  
      my $safe_text = $MM->quote_literal($text);
      my $safe_text = $MM->quote_literal($text, \%options);
  
  This will quote $text so it is interpreted literally in the shell.
  
  For example, on Unix this would escape any single-quotes in $text and
  put single-quotes around the whole thing.
  
  If $options{allow_variables} is true it will leave C<'$(FOO)'> make
  variables untouched.  If false they will be escaped like any other
  C<$>.  Defaults to true.
  
  =head3 escape_dollarsigns
  
      my $escaped_text = $MM->escape_dollarsigns($text);
  
  Escapes stray C<$> so they are not interpreted as make variables.
  
  It lets by C<$(...)>.
  
  =cut
  
  sub escape_dollarsigns {
      my($self, $text) = @_;
  
      # Escape dollar signs which are not starting a variable
      $text =~ s{\$ (?!\() }{\$\$}gx;
  
      return $text;
  }
  
  
  =head3 escape_all_dollarsigns
  
      my $escaped_text = $MM->escape_all_dollarsigns($text);
  
  Escapes all C<$> so they are not interpreted as make variables.
  
  =cut
  
  sub escape_all_dollarsigns {
      my($self, $text) = @_;
  
      # Escape dollar signs
      $text =~ s{\$}{\$\$}gx;
  
      return $text;
  }
  
  
  =head3 escape_newlines  I<Abstract>
  
      my $escaped_text = $MM->escape_newlines($text);
  
  Shell escapes newlines in $text.
  
  
  =head3 max_exec_len  I<Abstract>
  
      my $max_exec_len = $MM->max_exec_len;
  
  Calculates the maximum command size the OS can exec.  Effectively,
  this is the max size of a shell command line.
  
  =for _private
  $self->{_MAX_EXEC_LEN} is set by this method, but only for testing purposes.
  
  
  =head3 make
  
      my $make = $MM->make;
  
  Returns the make variant we're generating the Makefile for.  This attempts
  to do some normalization on the information from %Config or the user.
  
  =cut
  
  sub make {
      my $self = shift;
  
      my $make = lc $self->{MAKE};
  
      # Truncate anything like foomake6 to just foomake.
      $make =~ s/^(\w+make).*/$1/;
  
      # Turn gnumake into gmake.
      $make =~ s/^gnu/g/;
  
      return $make;
  }
  
  
  =head2 Targets
  
  These are methods which produce make targets.
  
  
  =head3 all_target
  
  Generate the default target 'all'.
  
  =cut
  
  sub all_target {
      my $self = shift;
  
      return <<'MAKE_EXT';
  all :: pure_all
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  
  }
  
  
  =head3 blibdirs_target
  
      my $make_frag = $mm->blibdirs_target;
  
  Creates the blibdirs target which creates all the directories we use
  in blib/.
  
  The blibdirs.ts target is deprecated.  Depend on blibdirs instead.
  
  
  =cut
  
  sub blibdirs_target {
      my $self = shift;
  
      my @dirs = map { uc "\$(INST_$_)" } qw(libdir archlib
                                             autodir archautodir
                                             bin script
                                             man1dir man3dir
                                            );
  
      my @exists = map { $_.'$(DFSEP).exists' } @dirs;
  
      my $make = sprintf <<'MAKE', join(' ', @exists);
  blibdirs : %s
  	$(NOECHO) $(NOOP)
  
  # Backwards compat with 6.18 through 6.25
  blibdirs.ts : blibdirs
  	$(NOECHO) $(NOOP)
  
  MAKE
  
      $make .= $self->dir_target(@dirs);
  
      return $make;
  }
  
  
  =head3 clean (o)
  
  Defines the clean target.
  
  =cut
  
  sub clean {
  # --- Cleanup and Distribution Sections ---
  
      my($self, %attribs) = @_;
      my @m;
      push(@m, '
  # Delete temporary files but do not touch installed files. We don\'t delete
  # the Makefile here so a later make realclean still has a makefile to use.
  
  clean :: clean_subdirs
  ');
  
      my @files = sort values %{$self->{XS}}; # .c files from *.xs files
      my @dirs  = qw(blib);
  
      # Normally these are all under blib but they might have been
      # redefined.
      # XXX normally this would be a good idea, but the Perl core sets
      # INST_LIB = ../../lib rather than actually installing the files.
      # So a "make clean" in an ext/ directory would blow away lib.
      # Until the core is adjusted let's leave this out.
  #     push @dirs, qw($(INST_ARCHLIB) $(INST_LIB)
  #                    $(INST_BIN) $(INST_SCRIPT)
  #                    $(INST_MAN1DIR) $(INST_MAN3DIR)
  #                    $(INST_LIBDIR) $(INST_ARCHLIBDIR) $(INST_AUTODIR)
  #                    $(INST_STATIC) $(INST_DYNAMIC)
  #                 );
  
  
      if( $attribs{FILES} ) {
          # Use @dirs because we don't know what's in here.
          push @dirs, ref $attribs{FILES}                ?
                          @{$attribs{FILES}}             :
                          split /\s+/, $attribs{FILES}   ;
      }
  
      push(@files, qw[$(MAKE_APERL_FILE)
                      MYMETA.json MYMETA.yml perlmain.c tmon.out mon.out so_locations
                      blibdirs.ts pm_to_blib pm_to_blib.ts
                      *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT)
                      $(BOOTSTRAP) $(BASEEXT).bso
                      $(BASEEXT).def lib$(BASEEXT).def
                      $(BASEEXT).exp $(BASEEXT).x
                     ]);
  
      push(@files, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));
      push(@files, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.ld'));
  
      # core files
      if ($^O eq 'vos') {
          push(@files, qw[perl*.kp]);
      }
      else {
          push(@files, qw[core core.*perl.*.? *perl.core]);
      }
  
      push(@files, map { "core." . "[0-9]"x$_ } (1..5));
  
      # OS specific things to clean up.  Use @dirs since we don't know
      # what might be in here.
      push @dirs, $self->extra_clean_files;
  
      # Occasionally files are repeated several times from different sources
      { my(%f) = map { ($_ => 1) } @files; @files = sort keys %f; }
      { my(%d) = map { ($_ => 1) } @dirs;  @dirs  = sort keys %d; }
  
      push @m, map "\t$_\n", $self->split_command('- $(RM_F)',  @files);
      push @m, map "\t$_\n", $self->split_command('- $(RM_RF)', @dirs);
  
      # Leave Makefile.old around for realclean
      push @m, <<'MAKE';
  	  $(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD) $(DEV_NULL)
  MAKE
  
      push(@m, "\t$attribs{POSTOP}\n")   if $attribs{POSTOP};
  
      join("", @m);
  }
  
  
  =head3 clean_subdirs_target
  
    my $make_frag = $MM->clean_subdirs_target;
  
  Returns the clean_subdirs target.  This is used by the clean target to
  call clean on any subdirectories which contain Makefiles.
  
  =cut
  
  sub clean_subdirs_target {
      my($self) = shift;
  
      # No subdirectories, no cleaning.
      return <<'NOOP_FRAG' unless @{$self->{DIR}};
  clean_subdirs :
  	$(NOECHO) $(NOOP)
  NOOP_FRAG
  
  
      my $clean = "clean_subdirs :\n";
  
      for my $dir (@{$self->{DIR}}) {
          my $subclean = $self->oneliner(sprintf <<'CODE', $dir);
  exit 0 unless chdir '%s';  system '$(MAKE) clean' if -f '$(FIRST_MAKEFILE)';
  CODE
  
          $clean .= "\t$subclean\n";
      }
  
      return $clean;
  }
  
  
  =head3 dir_target
  
      my $make_frag = $mm->dir_target(@directories);
  
  Generates targets to create the specified directories and set its
  permission to PERM_DIR.
  
  Because depending on a directory to just ensure it exists doesn't work
  too well (the modified time changes too often) dir_target() creates a
  .exists file in the created directory.  It is this you should depend on.
  For portability purposes you should use the $(DIRFILESEP) macro rather
  than a '/' to separate the directory from the file.
  
      yourdirectory$(DIRFILESEP).exists
  
  =cut
  
  sub dir_target {
      my($self, @dirs) = @_;
  
      my $make = '';
      foreach my $dir (@dirs) {
          $make .= sprintf <<'MAKE', ($dir) x 4;
  %s$(DFSEP).exists :: Makefile.PL
  	$(NOECHO) $(MKPATH) %s
  	$(NOECHO) $(CHMOD) $(PERM_DIR) %s
  	$(NOECHO) $(TOUCH) %s$(DFSEP).exists
  
  MAKE
  
      }
  
      return $make;
  }
  
  
  =head3 distdir
  
  Defines the scratch directory target that will hold the distribution
  before tar-ing (or shar-ing).
  
  =cut
  
  # For backwards compatibility.
  *dist_dir = *distdir;
  
  sub distdir {
      my($self) = shift;
  
      my $meta_target = $self->{NO_META} ? '' : 'distmeta';
      my $sign_target = !$self->{SIGN}   ? '' : 'distsignature';
  
      return sprintf <<'MAKE_FRAG', $meta_target, $sign_target;
  create_distdir :
  	$(RM_RF) $(DISTVNAME)
  	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
  		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"
  
  distdir : create_distdir %s %s
  	$(NOECHO) $(NOOP)
  
  MAKE_FRAG
  
  }
  
  
  =head3 dist_test
  
  Defines a target that produces the distribution in the
  scratch directory, and runs 'perl Makefile.PL; make ;make test' in that
  subdirectory.
  
  =cut
  
  sub dist_test {
      my($self) = shift;
  
      my $mpl_args = join " ", map qq["$_"], @ARGV;
  
      my $test = $self->cd('$(DISTVNAME)',
                           '$(ABSPERLRUN) Makefile.PL '.$mpl_args,
                           '$(MAKE) $(PASTHRU)',
                           '$(MAKE) test $(PASTHRU)'
                          );
  
      return sprintf <<'MAKE_FRAG', $test;
  disttest : distdir
  	%s
  
  MAKE_FRAG
  
  
  }
  
  
  =head3 dynamic (o)
  
  Defines the dynamic target.
  
  =cut
  
  sub dynamic {
  # --- Dynamic Loading Sections ---
  
      my($self) = shift;
      '
  dynamic :: $(FIRST_MAKEFILE) $(BOOTSTRAP) $(INST_DYNAMIC)
  	$(NOECHO) $(NOOP)
  ';
  }
  
  
  =head3 makemakerdflt_target
  
    my $make_frag = $mm->makemakerdflt_target
  
  Returns a make fragment with the makemakerdeflt_target specified.
  This target is the first target in the Makefile, is the default target
  and simply points off to 'all' just in case any make variant gets
  confused or something gets snuck in before the real 'all' target.
  
  =cut
  
  sub makemakerdflt_target {
      return <<'MAKE_FRAG';
  makemakerdflt : all
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  
  }
  
  
  =head3 manifypods_target
  
    my $manifypods_target = $self->manifypods_target;
  
  Generates the manifypods target.  This target generates man pages from
  all POD files in MAN1PODS and MAN3PODS.
  
  =cut
  
  sub manifypods_target {
      my($self) = shift;
  
      my $man1pods      = '';
      my $man3pods      = '';
      my $dependencies  = '';
  
      # populate manXpods & dependencies:
      foreach my $name (sort keys %{$self->{MAN1PODS}}, sort keys %{$self->{MAN3PODS}}) {
          $dependencies .= " \\\n\t$name";
      }
  
      my $manify = <<END;
  manifypods : pure_all $dependencies
  END
  
      my @man_cmds;
      foreach my $section (qw(1 3)) {
          my $pods = $self->{"MAN${section}PODS"};
          push @man_cmds, $self->split_command(<<CMD, map {($_,$pods->{$_})} sort keys %$pods);
  	\$(NOECHO) \$(POD2MAN) --section=$section --perm_rw=\$(PERM_RW)
  CMD
      }
  
      $manify .= "\t\$(NOECHO) \$(NOOP)\n" unless @man_cmds;
      $manify .= join '', map { "$_\n" } @man_cmds;
  
      return $manify;
  }
  
  sub _has_cpan_meta {
      return eval {
        require CPAN::Meta;
        CPAN::Meta->VERSION(2.112150);
        1;
      };
  }
  
  =head3 metafile_target
  
      my $target = $mm->metafile_target;
  
  Generate the metafile target.
  
  Writes the file META.yml (YAML encoded meta-data) and META.json
  (JSON encoded meta-data) about the module in the distdir.
  The format follows Module::Build's as closely as possible.
  
  =cut
  
  sub metafile_target {
      my $self = shift;
      return <<'MAKE_FRAG' if $self->{NO_META} or ! _has_cpan_meta();
  metafile :
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  
      my %metadata   = $self->metafile_data(
          $self->{META_ADD}   || {},
          $self->{META_MERGE} || {},
      );
  
      _fix_metadata_before_conversion( \%metadata );
  
      # paper over validation issues, but still complain, necessary because
      # there's no guarantee that the above will fix ALL errors
      my $meta = eval { CPAN::Meta->create( \%metadata, { lazy_validation => 1 } ) };
      warn $@ if $@ and
                 $@ !~ /encountered CODE.*, but JSON can only represent references to arrays or hashes/;
  
      # use the original metadata straight if the conversion failed
      # or if it can't be stringified.
      if( !$meta                                                  ||
          !eval { $meta->as_string( { version => "1.4" } ) }      ||
          !eval { $meta->as_string }
      )
      {
          $meta = bless \%metadata, 'CPAN::Meta';
      }
  
      my @write_metayml = $self->echo(
        $meta->as_string({version => "1.4"}), 'META_new.yml'
      );
      my @write_metajson = $self->echo(
        $meta->as_string(), 'META_new.json'
      );
  
      my $metayml = join("\n\t", @write_metayml);
      my $metajson = join("\n\t", @write_metajson);
      return sprintf <<'MAKE_FRAG', $metayml, $metajson;
  metafile : create_distdir
  	$(NOECHO) $(ECHO) Generating META.yml
  	%s
  	-$(NOECHO) $(MV) META_new.yml $(DISTVNAME)/META.yml
  	$(NOECHO) $(ECHO) Generating META.json
  	%s
  	-$(NOECHO) $(MV) META_new.json $(DISTVNAME)/META.json
  MAKE_FRAG
  
  }
  
  =begin private
  
  =head3 _fix_metadata_before_conversion
  
      _fix_metadata_before_conversion( \%metadata );
  
  Fixes errors in the metadata before it's handed off to CPAN::Meta for
  conversion. This hopefully results in something that can be used further
  on, no guarantee is made though.
  
  =end private
  
  =cut
  
  sub _fix_metadata_before_conversion {
      my ( $metadata ) = @_;
  
      # we should never be called unless this already passed but
      # prefer to be defensive in case somebody else calls this
  
      return unless _has_cpan_meta;
  
      my $bad_version = $metadata->{version} &&
                        !CPAN::Meta::Validator->new->version( 'version', $metadata->{version} );
  
      # just delete all invalid versions
      if( $bad_version ) {
          warn "Can't parse version '$metadata->{version}'\n";
          $metadata->{version} = '';
      }
  
      my $validator = CPAN::Meta::Validator->new( $metadata );
      return if $validator->is_valid;
  
      # fix non-camelcase custom resource keys (only other trick we know)
      for my $error ( $validator->errors ) {
          my ( $key ) = ( $error =~ /Custom resource '(.*)' must be in CamelCase./ );
          next if !$key;
  
          # first try to remove all non-alphabetic chars
          ( my $new_key = $key ) =~ s/[^_a-zA-Z]//g;
  
          # if that doesn't work, uppercase first one
          $new_key = ucfirst $new_key if !$validator->custom_1( $new_key );
  
          # copy to new key if that worked
          $metadata->{resources}{$new_key} = $metadata->{resources}{$key}
            if $validator->custom_1( $new_key );
  
          # and delete old one in any case
          delete $metadata->{resources}{$key};
      }
  
      return;
  }
  
  
  =begin private
  
  =head3 _sort_pairs
  
      my @pairs = _sort_pairs($sort_sub, \%hash);
  
  Sorts the pairs of a hash based on keys ordered according
  to C<$sort_sub>.
  
  =end private
  
  =cut
  
  sub _sort_pairs {
      my $sort  = shift;
      my $pairs = shift;
      return map  { $_ => $pairs->{$_} }
             sort $sort
             keys %$pairs;
  }
  
  
  # Taken from Module::Build::Base
  sub _hash_merge {
      my ($self, $h, $k, $v) = @_;
      if (ref $h->{$k} eq 'ARRAY') {
          push @{$h->{$k}}, ref $v ? @$v : $v;
      } elsif (ref $h->{$k} eq 'HASH') {
          $self->_hash_merge($h->{$k}, $_, $v->{$_}) foreach keys %$v;
      } else {
          $h->{$k} = $v;
      }
  }
  
  
  =head3 metafile_data
  
      my @metadata_pairs = $mm->metafile_data(\%meta_add, \%meta_merge);
  
  Returns the data which MakeMaker turns into the META.yml file 
  and the META.json file.
  
  Values of %meta_add will overwrite any existing metadata in those
  keys.  %meta_merge will be merged with them.
  
  =cut
  
  sub metafile_data {
      my $self = shift;
      my($meta_add, $meta_merge) = @_;
  
      my %meta = (
          # required
          name         => $self->{DISTNAME},
          version      => _normalize_version($self->{VERSION}),
          abstract     => $self->{ABSTRACT} || 'unknown',
          license      => $self->{LICENSE} || 'unknown',
          dynamic_config => 1,
  
          # optional
          distribution_type => $self->{PM} ? 'module' : 'script',
  
          no_index     => {
              directory   => [qw(t inc)]
          },
  
          generated_by => "ExtUtils::MakeMaker version $ExtUtils::MakeMaker::VERSION",
          'meta-spec'  => {
              url         => 'http://module-build.sourceforge.net/META-spec-v1.4.html',
              version     => 1.4
          },
      );
  
      # The author key is required and it takes a list.
      $meta{author}   = defined $self->{AUTHOR}    ? $self->{AUTHOR} : [];
  
      {
        my $vers = _metaspec_version( $meta_add, $meta_merge );
        my $method = $vers =~ m!^2!
                 ? '_add_requirements_to_meta_v2'
                 : '_add_requirements_to_meta_v1_4';
        %meta = $self->$method( %meta );
      }
  
      while( my($key, $val) = each %$meta_add ) {
          $meta{$key} = $val;
      }
  
      while( my($key, $val) = each %$meta_merge ) {
          $self->_hash_merge(\%meta, $key, $val);
      }
  
      return %meta;
  }
  
  
  =begin private
  
  =cut
  
  sub _metaspec_version {
    my ( $meta_add, $meta_merge ) = @_;
    return $meta_add->{'meta-spec'}->{version}
      if defined $meta_add->{'meta-spec'}
         and defined $meta_add->{'meta-spec'}->{version};
    return $meta_merge->{'meta-spec'}->{version}
      if defined $meta_merge->{'meta-spec'}
         and  defined $meta_merge->{'meta-spec'}->{version};
    return '1.4';
  }
  
  sub _add_requirements_to_meta_v1_4 {
      my ( $self, %meta ) = @_;
  
      # Check the original args so we can tell between the user setting it
      # to an empty hash and it just being initialized.
      if( $self->{ARGS}{CONFIGURE_REQUIRES} ) {
          $meta{configure_requires}
              = _normalize_prereqs($self->{CONFIGURE_REQUIRES});
      } else {
          $meta{configure_requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
  
      if( $self->{ARGS}{BUILD_REQUIRES} ) {
          $meta{build_requires} = _normalize_prereqs($self->{BUILD_REQUIRES});
      } else {
          $meta{build_requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
  
      if( $self->{ARGS}{TEST_REQUIRES} ) {
          $meta{build_requires} = {
            %{ $meta{build_requires} },
            %{ _normalize_prereqs($self->{TEST_REQUIRES}) },
          };
      }
  
      $meta{requires} = _normalize_prereqs($self->{PREREQ_PM})
          if defined $self->{PREREQ_PM};
      $meta{requires}{perl} = _normalize_version($self->{MIN_PERL_VERSION})
          if $self->{MIN_PERL_VERSION};
  
      return %meta;
  }
  
  sub _add_requirements_to_meta_v2 {
      my ( $self, %meta ) = @_;
  
      # Check the original args so we can tell between the user setting it
      # to an empty hash and it just being initialized.
      if( $self->{ARGS}{CONFIGURE_REQUIRES} ) {
          $meta{prereqs}{configure}{requires}
              = _normalize_prereqs($self->{CONFIGURE_REQUIRES});
      } else {
          $meta{prereqs}{configure}{requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
  
      if( $self->{ARGS}{BUILD_REQUIRES} ) {
          $meta{prereqs}{build}{requires} = _normalize_prereqs($self->{BUILD_REQUIRES});
      } else {
          $meta{prereqs}{build}{requires} = {
              'ExtUtils::MakeMaker'       => 0,
          };
      }
  
      if( $self->{ARGS}{TEST_REQUIRES} ) {
          $meta{prereqs}{test}{requires} = _normalize_prereqs($self->{TEST_REQUIRES});
      }
  
      $meta{prereqs}{runtime}{requires} = _normalize_prereqs($self->{PREREQ_PM})
          if $self->{ARGS}{PREREQ_PM};
      $meta{prereqs}{runtime}{requires}{perl} = _normalize_version($self->{MIN_PERL_VERSION})
          if $self->{MIN_PERL_VERSION};
  
      return %meta;
  }
  
  sub _normalize_prereqs {
    my ($hash) = @_;
    my %prereqs;
    while ( my ($k,$v) = each %$hash ) {
      $prereqs{$k} = _normalize_version($v);
    }
    return \%prereqs;
  }
  
  # Adapted from Module::Build::Base
  sub _normalize_version {
    my ($version) = @_;
    $version = 0 unless defined $version;
  
    if ( ref $version eq 'version' ) { # version objects
      $version = $version->is_qv ? $version->normal : $version->stringify;
    }
    elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
      # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
      $version = "v$version";
    }
    else {
      # leave alone
    }
    return $version;
  }
  
  =head3 _dump_hash
  
      $yaml = _dump_hash(\%options, %hash);
  
  Implements a fake YAML dumper for a hash given
  as a list of pairs. No quoting/escaping is done. Keys
  are supposed to be strings. Values are undef, strings,
  hash refs or array refs of strings.
  
  Supported options are:
  
      delta => STR - indentation delta
      use_header => BOOL - whether to include a YAML header
      indent => STR - a string of spaces
            default: ''
  
      max_key_length => INT - maximum key length used to align
          keys and values of the same hash
          default: 20
      key_sort => CODE - a sort sub
              It may be undef, which means no sorting by keys
          default: sub { lc $a cmp lc $b }
  
      customs => HASH - special options for certain keys
             (whose values are hashes themselves)
          may contain: max_key_length, key_sort, customs
  
  =end private
  
  =cut
  
  sub _dump_hash {
      croak "first argument should be a hash ref" unless ref $_[0] eq 'HASH';
      my $options = shift;
      my %hash = @_;
  
      # Use a list to preserve order.
      my @pairs;
  
      my $k_sort
          = exists $options->{key_sort} ? $options->{key_sort}
                                        : sub { lc $a cmp lc $b };
      if ($k_sort) {
          croak "'key_sort' should be a coderef" unless ref $k_sort eq 'CODE';
          @pairs = _sort_pairs($k_sort, \%hash);
      } else { # list of pairs, no sorting
          @pairs = @_;
      }
  
      my $yaml     = $options->{use_header} ? "--- #YAML:1.0\n" : '';
      my $indent   = $options->{indent} || '';
      my $k_length = min(
          ($options->{max_key_length} || 20),
          max(map { length($_) + 1 } grep { !ref $hash{$_} } keys %hash)
      );
      my $customs  = $options->{customs} || {};
  
      # printf format for key
      my $k_format = "%-${k_length}s";
  
      while( @pairs ) {
          my($key, $val) = splice @pairs, 0, 2;
          $val = '~' unless defined $val;
          if(ref $val eq 'HASH') {
              if ( keys %$val ) {
                  my %k_options = ( # options for recursive call
                      delta => $options->{delta},
                      use_header => 0,
                      indent => $indent . $options->{delta},
                  );
                  if (exists $customs->{$key}) {
                      my %k_custom = %{$customs->{$key}};
                      foreach my $k (qw(key_sort max_key_length customs)) {
                          $k_options{$k} = $k_custom{$k} if exists $k_custom{$k};
                      }
                  }
                  $yaml .= $indent . "$key:\n"
                    . _dump_hash(\%k_options, %$val);
              }
              else {
                  $yaml .= $indent . "$key:  {}\n";
              }
          }
          elsif (ref $val eq 'ARRAY') {
              if( @$val ) {
                  $yaml .= $indent . "$key:\n";
  
                  for (@$val) {
                      croak "only nested arrays of non-refs are supported" if ref $_;
                      $yaml .= $indent . $options->{delta} . "- $_\n";
                  }
              }
              else {
                  $yaml .= $indent . "$key:  []\n";
              }
          }
          elsif( ref $val and !blessed($val) ) {
              croak "only nested hashes, arrays and objects are supported";
          }
          else {  # if it's an object, just stringify it
              $yaml .= $indent . sprintf "$k_format  %s\n", "$key:", $val;
          }
      };
  
      return $yaml;
  
  }
  
  sub blessed {
      return eval { $_[0]->isa("UNIVERSAL"); };
  }
  
  sub max {
      return (sort { $b <=> $a } @_)[0];
  }
  
  sub min {
      return (sort { $a <=> $b } @_)[0];
  }
  
  =head3 metafile_file
  
      my $meta_yml = $mm->metafile_file(@metadata_pairs);
  
  Turns the @metadata_pairs into YAML.
  
  This method does not implement a complete YAML dumper, being limited
  to dump a hash with values which are strings, undef's or nested hashes
  and arrays of strings. No quoting/escaping is done.
  
  =cut
  
  sub metafile_file {
      my $self = shift;
  
      my %dump_options = (
          use_header => 1,
          delta      => ' ' x 4,
          key_sort   => undef,
      );
      return _dump_hash(\%dump_options, @_);
  
  }
  
  
  =head3 distmeta_target
  
      my $make_frag = $mm->distmeta_target;
  
  Generates the distmeta target to add META.yml and META.json to the MANIFEST
  in the distdir.
  
  =cut
  
  sub distmeta_target {
      my $self = shift;
  
      my @add_meta = (
        $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd']),
  exit unless -e q{META.yml};
  eval { maniadd({q{META.yml} => q{Module YAML meta-data (added by MakeMaker)}}) }
      or print "Could not add META.yml to MANIFEST: $${'@'}\n"
  CODE
        $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd'])
  exit unless -f q{META.json};
  eval { maniadd({q{META.json} => q{Module JSON meta-data (added by MakeMaker)}}) }
      or print "Could not add META.json to MANIFEST: $${'@'}\n"
  CODE
      );
  
      my @add_meta_to_distdir = map { $self->cd('$(DISTVNAME)', $_) } @add_meta;
  
      return sprintf <<'MAKE', @add_meta_to_distdir;
  distmeta : create_distdir metafile
  	$(NOECHO) %s
  	$(NOECHO) %s
  
  MAKE
  
  }
  
  
  =head3 mymeta
  
      my $mymeta = $mm->mymeta;
  
  Generate MYMETA information as a hash either from an existing CPAN Meta file
  (META.json or META.yml) or from internal data.
  
  =cut
  
  sub mymeta {
      my $self = shift;
      my $file = shift || ''; # for testing
  
      my $mymeta = $self->_mymeta_from_meta($file);
      my $v2 = 1;
  
      unless ( $mymeta ) {
          my @metadata = $self->metafile_data(
              $self->{META_ADD}   || {},
              $self->{META_MERGE} || {},
          );
          $mymeta = {@metadata};
          $v2 = 0;
      }
  
      # Overwrite the non-configure dependency hashes
  
      my $method = $v2
                 ? '_add_requirements_to_meta_v2'
                 : '_add_requirements_to_meta_v1_4';
  
      $mymeta = { $self->$method( %$mymeta ) };
  
      $mymeta->{dynamic_config} = 0;
  
      return $mymeta;
  }
  
  
  sub _mymeta_from_meta {
      my $self = shift;
      my $metafile = shift || ''; # for testing
  
      return unless _has_cpan_meta();
  
      my $meta;
      for my $file ( $metafile, "META.json", "META.yml" ) {
        next unless -e $file;
        eval {
            $meta = CPAN::Meta->load_file($file)->as_struct( { version => 2 } );
        };
        last if $meta;
      }
      return unless $meta;
  
      # META.yml before 6.25_01 cannot be trusted.  META.yml lived in the source directory.
      # There was a good chance the author accidentally uploaded a stale META.yml if they
      # rolled their own tarball rather than using "make dist".
      if ($meta->{generated_by} &&
          $meta->{generated_by} =~ /ExtUtils::MakeMaker version ([\d\._]+)/) {
          my $eummv = do { local $^W = 0; $1+0; };
          if ($eummv < 6.2501) {
              return;
          }
      }
  
      return $meta;
  }
  
  =head3 write_mymeta
  
      $self->write_mymeta( $mymeta );
  
  Write MYMETA information to MYMETA.json and MYMETA.yml.
  
  =cut
  
  sub write_mymeta {
      my $self = shift;
      my $mymeta = shift;
  
      return unless _has_cpan_meta();
  
      _fix_metadata_before_conversion( $mymeta );
  
      # this can still blow up
      # not sure if i should just eval this and skip file creation if it
      # blows up
      my $meta_obj = CPAN::Meta->new( $mymeta, { lazy_validation => 1 } );
      $meta_obj->save( 'MYMETA.json' );
      $meta_obj->save( 'MYMETA.yml', { version => "1.4" } );
      return 1;
  }
  
  =head3 realclean (o)
  
  Defines the realclean target.
  
  =cut
  
  sub realclean {
      my($self, %attribs) = @_;
  
      my @dirs  = qw($(DISTVNAME));
      my @files = qw($(FIRST_MAKEFILE) $(MAKEFILE_OLD));
  
      # Special exception for the perl core where INST_* is not in blib.
      # This cleans up the files built from the ext/ directory (all XS).
      if( $self->{PERL_CORE} ) {
          push @dirs, qw($(INST_AUTODIR) $(INST_ARCHAUTODIR));
          push @files, values %{$self->{PM}};
      }
  
      if( $self->has_link_code ){
          push @files, qw($(OBJECT));
      }
  
      if( $attribs{FILES} ) {
          if( ref $attribs{FILES} ) {
              push @dirs, @{ $attribs{FILES} };
          }
          else {
              push @dirs, split /\s+/, $attribs{FILES};
          }
      }
  
      # Occasionally files are repeated several times from different sources
      { my(%f) = map { ($_ => 1) } @files;  @files = keys %f; }
      { my(%d) = map { ($_ => 1) } @dirs;   @dirs  = keys %d; }
  
      my $rm_cmd  = join "\n\t", map { "$_" }
                      $self->split_command('- $(RM_F)',  @files);
      my $rmf_cmd = join "\n\t", map { "$_" }
                      $self->split_command('- $(RM_RF)', @dirs);
  
      my $m = sprintf <<'MAKE', $rm_cmd, $rmf_cmd;
  # Delete temporary files (via clean) and also delete dist files
  realclean purge ::  clean realclean_subdirs
  	%s
  	%s
  MAKE
  
      $m .= "\t$attribs{POSTOP}\n" if $attribs{POSTOP};
  
      return $m;
  }
  
  
  =head3 realclean_subdirs_target
  
    my $make_frag = $MM->realclean_subdirs_target;
  
  Returns the realclean_subdirs target.  This is used by the realclean
  target to call realclean on any subdirectories which contain Makefiles.
  
  =cut
  
  sub realclean_subdirs_target {
      my $self = shift;
  
      return <<'NOOP_FRAG' unless @{$self->{DIR}};
  realclean_subdirs :
  	$(NOECHO) $(NOOP)
  NOOP_FRAG
  
      my $rclean = "realclean_subdirs :\n";
  
      foreach my $dir (@{$self->{DIR}}) {
          foreach my $makefile ('$(MAKEFILE_OLD)', '$(FIRST_MAKEFILE)' ) {
              my $subrclean .= $self->oneliner(sprintf <<'CODE', $dir, ($makefile) x 2);
  chdir '%s';  system '$(MAKE) $(USEMAKEFILE) %s realclean' if -f '%s';
  CODE
  
              $rclean .= sprintf <<'RCLEAN', $subrclean;
  	- %s
  RCLEAN
  
          }
      }
  
      return $rclean;
  }
  
  
  =head3 signature_target
  
      my $target = $mm->signature_target;
  
  Generate the signature target.
  
  Writes the file SIGNATURE with "cpansign -s".
  
  =cut
  
  sub signature_target {
      my $self = shift;
  
      return <<'MAKE_FRAG';
  signature :
  	cpansign -s
  MAKE_FRAG
  
  }
  
  
  =head3 distsignature_target
  
      my $make_frag = $mm->distsignature_target;
  
  Generates the distsignature target to add SIGNATURE to the MANIFEST in the
  distdir.
  
  =cut
  
  sub distsignature_target {
      my $self = shift;
  
      my $add_sign = $self->oneliner(<<'CODE', ['-MExtUtils::Manifest=maniadd']);
  eval { maniadd({q{SIGNATURE} => q{Public-key signature (added by MakeMaker)}}) }
      or print "Could not add SIGNATURE to MANIFEST: $${'@'}\n"
  CODE
  
      my $sign_dist        = $self->cd('$(DISTVNAME)' => 'cpansign -s');
  
      # cpansign -s complains if SIGNATURE is in the MANIFEST yet does not
      # exist
      my $touch_sig        = $self->cd('$(DISTVNAME)' => '$(TOUCH) SIGNATURE');
      my $add_sign_to_dist = $self->cd('$(DISTVNAME)' => $add_sign );
  
      return sprintf <<'MAKE', $add_sign_to_dist, $touch_sig, $sign_dist
  distsignature : create_distdir
  	$(NOECHO) %s
  	$(NOECHO) %s
  	%s
  
  MAKE
  
  }
  
  
  =head3 special_targets
  
    my $make_frag = $mm->special_targets
  
  Returns a make fragment containing any targets which have special
  meaning to make.  For example, .SUFFIXES and .PHONY.
  
  =cut
  
  sub special_targets {
      my $make_frag = <<'MAKE_FRAG';
  .SUFFIXES : .xs .c .C .cpp .i .s .cxx .cc $(OBJ_EXT)
  
  .PHONY: all config static dynamic test linkext manifest blibdirs clean realclean disttest distdir
  
  MAKE_FRAG
  
      $make_frag .= <<'MAKE_FRAG' if $ENV{CLEARCASE_ROOT};
  .NO_CONFIG_REC: Makefile
  
  MAKE_FRAG
  
      return $make_frag;
  }
  
  
  
  
  =head2 Init methods
  
  Methods which help initialize the MakeMaker object and macros.
  
  
  =head3 init_ABSTRACT
  
      $mm->init_ABSTRACT
  
  =cut
  
  sub init_ABSTRACT {
      my $self = shift;
  
      if( $self->{ABSTRACT_FROM} and $self->{ABSTRACT} ) {
          warn "Both ABSTRACT_FROM and ABSTRACT are set.  ".
               "Ignoring ABSTRACT_FROM.\n";
          return;
      }
  
      if ($self->{ABSTRACT_FROM}){
          $self->{ABSTRACT} = $self->parse_abstract($self->{ABSTRACT_FROM}) or
              carp "WARNING: Setting ABSTRACT via file ".
                   "'$self->{ABSTRACT_FROM}' failed\n";
      }
  
      if ($self->{ABSTRACT} && $self->{ABSTRACT} =~ m![[:cntrl:]]+!) {
              warn "WARNING: ABSTRACT contains control character(s),".
                   " they will be removed\n";
              $self->{ABSTRACT} =~ s![[:cntrl:]]+!!g;
              return;
      }
  }
  
  =head3 init_INST
  
      $mm->init_INST;
  
  Called by init_main.  Sets up all INST_* variables except those related
  to XS code.  Those are handled in init_xs.
  
  =cut
  
  sub init_INST {
      my($self) = shift;
  
      $self->{INST_ARCHLIB} ||= $self->catdir($Curdir,"blib","arch");
      $self->{INST_BIN}     ||= $self->catdir($Curdir,'blib','bin');
  
      # INST_LIB typically pre-set if building an extension after
      # perl has been built and installed. Setting INST_LIB allows
      # you to build directly into, say $Config{privlibexp}.
      unless ($self->{INST_LIB}){
          if ($self->{PERL_CORE}) {
              $self->{INST_LIB} = $self->{INST_ARCHLIB} = $self->{PERL_LIB};
          } else {
              $self->{INST_LIB} = $self->catdir($Curdir,"blib","lib");
          }
      }
  
      my @parentdir = split(/::/, $self->{PARENT_NAME});
      $self->{INST_LIBDIR}      = $self->catdir('$(INST_LIB)',     @parentdir);
      $self->{INST_ARCHLIBDIR}  = $self->catdir('$(INST_ARCHLIB)', @parentdir);
      $self->{INST_AUTODIR}     = $self->catdir('$(INST_LIB)', 'auto',
                                                '$(FULLEXT)');
      $self->{INST_ARCHAUTODIR} = $self->catdir('$(INST_ARCHLIB)', 'auto',
                                                '$(FULLEXT)');
  
      $self->{INST_SCRIPT}  ||= $self->catdir($Curdir,'blib','script');
  
      $self->{INST_MAN1DIR} ||= $self->catdir($Curdir,'blib','man1');
      $self->{INST_MAN3DIR} ||= $self->catdir($Curdir,'blib','man3');
  
      return 1;
  }
  
  
  =head3 init_INSTALL
  
      $mm->init_INSTALL;
  
  Called by init_main.  Sets up all INSTALL_* variables (except
  INSTALLDIRS) and *PREFIX.
  
  =cut
  
  sub init_INSTALL {
      my($self) = shift;
  
      if( $self->{ARGS}{INSTALL_BASE} and $self->{ARGS}{PREFIX} ) {
          die "Only one of PREFIX or INSTALL_BASE can be given.  Not both.\n";
      }
  
      if( $self->{ARGS}{INSTALL_BASE} ) {
          $self->init_INSTALL_from_INSTALL_BASE;
      }
      else {
          $self->init_INSTALL_from_PREFIX;
      }
  }
  
  
  =head3 init_INSTALL_from_PREFIX
  
    $mm->init_INSTALL_from_PREFIX;
  
  =cut
  
  sub init_INSTALL_from_PREFIX {
      my $self = shift;
  
      $self->init_lib2arch;
  
      # There are often no Config.pm defaults for these new man variables so
      # we fall back to the old behavior which is to use installman*dir
      foreach my $num (1, 3) {
          my $k = 'installsiteman'.$num.'dir';
  
          $self->{uc $k} ||= uc "\$(installman${num}dir)"
            unless $Config{$k};
      }
  
      foreach my $num (1, 3) {
          my $k = 'installvendorman'.$num.'dir';
  
          unless( $Config{$k} ) {
              $self->{uc $k}  ||= $Config{usevendorprefix}
                                ? uc "\$(installman${num}dir)"
                                : '';
          }
      }
  
      $self->{INSTALLSITEBIN} ||= '$(INSTALLBIN)'
        unless $Config{installsitebin};
      $self->{INSTALLSITESCRIPT} ||= '$(INSTALLSCRIPT)'
        unless $Config{installsitescript};
  
      unless( $Config{installvendorbin} ) {
          $self->{INSTALLVENDORBIN} ||= $Config{usevendorprefix}
                                      ? $Config{installbin}
                                      : '';
      }
      unless( $Config{installvendorscript} ) {
          $self->{INSTALLVENDORSCRIPT} ||= $Config{usevendorprefix}
                                         ? $Config{installscript}
                                         : '';
      }
  
  
      my $iprefix = $Config{installprefixexp} || $Config{installprefix} ||
                    $Config{prefixexp}        || $Config{prefix} || '';
      my $vprefix = $Config{usevendorprefix}  ? $Config{vendorprefixexp} : '';
      my $sprefix = $Config{siteprefixexp}    || '';
  
      # 5.005_03 doesn't have a siteprefix.
      $sprefix = $iprefix unless $sprefix;
  
  
      $self->{PREFIX}       ||= '';
  
      if( $self->{PREFIX} ) {
          @{$self}{qw(PERLPREFIX SITEPREFIX VENDORPREFIX)} =
            ('$(PREFIX)') x 3;
      }
      else {
          $self->{PERLPREFIX}   ||= $iprefix;
          $self->{SITEPREFIX}   ||= $sprefix;
          $self->{VENDORPREFIX} ||= $vprefix;
  
          # Lots of MM extension authors like to use $(PREFIX) so we
          # put something sensible in there no matter what.
          $self->{PREFIX} = '$('.uc $self->{INSTALLDIRS}.'PREFIX)';
      }
  
      my $arch    = $Config{archname};
      my $version = $Config{version};
  
      # default style
      my $libstyle = $Config{installstyle} || 'lib/perl5';
      my $manstyle = '';
  
      if( $self->{LIBSTYLE} ) {
          $libstyle = $self->{LIBSTYLE};
          $manstyle = $self->{LIBSTYLE} eq 'lib/perl5' ? 'lib/perl5' : '';
      }
  
      # Some systems, like VOS, set installman*dir to '' if they can't
      # read man pages.
      for my $num (1, 3) {
          $self->{'INSTALLMAN'.$num.'DIR'} ||= 'none'
            unless $Config{'installman'.$num.'dir'};
      }
  
      my %bin_layouts =
      (
          bin         => { s => $iprefix,
                           t => 'perl',
                           d => 'bin' },
          vendorbin   => { s => $vprefix,
                           t => 'vendor',
                           d => 'bin' },
          sitebin     => { s => $sprefix,
                           t => 'site',
                           d => 'bin' },
          script      => { s => $iprefix,
                           t => 'perl',
                           d => 'bin' },
          vendorscript=> { s => $vprefix,
                           t => 'vendor',
                           d => 'bin' },
          sitescript  => { s => $sprefix,
                           t => 'site',
                           d => 'bin' },
      );
  
      my %man_layouts =
      (
          man1dir         => { s => $iprefix,
                               t => 'perl',
                               d => 'man/man1',
                               style => $manstyle, },
          siteman1dir     => { s => $sprefix,
                               t => 'site',
                               d => 'man/man1',
                               style => $manstyle, },
          vendorman1dir   => { s => $vprefix,
                               t => 'vendor',
                               d => 'man/man1',
                               style => $manstyle, },
  
          man3dir         => { s => $iprefix,
                               t => 'perl',
                               d => 'man/man3',
                               style => $manstyle, },
          siteman3dir     => { s => $sprefix,
                               t => 'site',
                               d => 'man/man3',
                               style => $manstyle, },
          vendorman3dir   => { s => $vprefix,
                               t => 'vendor',
                               d => 'man/man3',
                               style => $manstyle, },
      );
  
      my %lib_layouts =
      (
          privlib     => { s => $iprefix,
                           t => 'perl',
                           d => '',
                           style => $libstyle, },
          vendorlib   => { s => $vprefix,
                           t => 'vendor',
                           d => '',
                           style => $libstyle, },
          sitelib     => { s => $sprefix,
                           t => 'site',
                           d => 'site_perl',
                           style => $libstyle, },
  
          archlib     => { s => $iprefix,
                           t => 'perl',
                           d => "$version/$arch",
                           style => $libstyle },
          vendorarch  => { s => $vprefix,
                           t => 'vendor',
                           d => "$version/$arch",
                           style => $libstyle },
          sitearch    => { s => $sprefix,
                           t => 'site',
                           d => "site_perl/$version/$arch",
                           style => $libstyle },
      );
  
  
      # Special case for LIB.
      if( $self->{LIB} ) {
          foreach my $var (keys %lib_layouts) {
              my $Installvar = uc "install$var";
  
              if( $var =~ /arch/ ) {
                  $self->{$Installvar} ||=
                    $self->catdir($self->{LIB}, $Config{archname});
              }
              else {
                  $self->{$Installvar} ||= $self->{LIB};
              }
          }
      }
  
      my %type2prefix = ( perl    => 'PERLPREFIX',
                          site    => 'SITEPREFIX',
                          vendor  => 'VENDORPREFIX'
                        );
  
      my %layouts = (%bin_layouts, %man_layouts, %lib_layouts);
      while( my($var, $layout) = each(%layouts) ) {
          my($s, $t, $d, $style) = @{$layout}{qw(s t d style)};
          my $r = '$('.$type2prefix{$t}.')';
  
          warn "Prefixing $var\n" if $Verbose >= 2;
  
          my $installvar = "install$var";
          my $Installvar = uc $installvar;
          next if $self->{$Installvar};
  
          $d = "$style/$d" if $style;
          $self->prefixify($installvar, $s, $r, $d);
  
          warn "  $Installvar == $self->{$Installvar}\n"
            if $Verbose >= 2;
      }
  
      # Generate these if they weren't figured out.
      $self->{VENDORARCHEXP} ||= $self->{INSTALLVENDORARCH};
      $self->{VENDORLIBEXP}  ||= $self->{INSTALLVENDORLIB};
  
      return 1;
  }
  
  
  =head3 init_from_INSTALL_BASE
  
      $mm->init_from_INSTALL_BASE
  
  =cut
  
  my %map = (
             lib      => [qw(lib perl5)],
             arch     => [('lib', 'perl5', $Config{archname})],
             bin      => [qw(bin)],
             man1dir  => [qw(man man1)],
             man3dir  => [qw(man man3)]
            );
  $map{script} = $map{bin};
  
  sub init_INSTALL_from_INSTALL_BASE {
      my $self = shift;
  
      @{$self}{qw(PREFIX VENDORPREFIX SITEPREFIX PERLPREFIX)} =
                                                           '$(INSTALL_BASE)';
  
      my %install;
      foreach my $thing (keys %map) {
          foreach my $dir (('', 'SITE', 'VENDOR')) {
              my $uc_thing = uc $thing;
              my $key = "INSTALL".$dir.$uc_thing;
  
              $install{$key} ||=
                $self->catdir('$(INSTALL_BASE)', @{$map{$thing}});
          }
      }
  
      # Adjust for variable quirks.
      $install{INSTALLARCHLIB} ||= delete $install{INSTALLARCH};
      $install{INSTALLPRIVLIB} ||= delete $install{INSTALLLIB};
  
      foreach my $key (keys %install) {
          $self->{$key} ||= $install{$key};
      }
  
      return 1;
  }
  
  
  =head3 init_VERSION  I<Abstract>
  
      $mm->init_VERSION
  
  Initialize macros representing versions of MakeMaker and other tools
  
  MAKEMAKER: path to the MakeMaker module.
  
  MM_VERSION: ExtUtils::MakeMaker Version
  
  MM_REVISION: ExtUtils::MakeMaker version control revision (for backwards
               compat)
  
  VERSION: version of your module
  
  VERSION_MACRO: which macro represents the version (usually 'VERSION')
  
  VERSION_SYM: like version but safe for use as an RCS revision number
  
  DEFINE_VERSION: -D line to set the module version when compiling
  
  XS_VERSION: version in your .xs file.  Defaults to $(VERSION)
  
  XS_VERSION_MACRO: which macro represents the XS version.
  
  XS_DEFINE_VERSION: -D line to set the xs version when compiling.
  
  Called by init_main.
  
  =cut
  
  sub init_VERSION {
      my($self) = shift;
  
      $self->{MAKEMAKER}  = $ExtUtils::MakeMaker::Filename;
      $self->{MM_VERSION} = $ExtUtils::MakeMaker::VERSION;
      $self->{MM_REVISION}= $ExtUtils::MakeMaker::Revision;
      $self->{VERSION_FROM} ||= '';
  
      if ($self->{VERSION_FROM}){
          $self->{VERSION} = $self->parse_version($self->{VERSION_FROM});
          if( $self->{VERSION} eq 'undef' ) {
              carp("WARNING: Setting VERSION via file ".
                   "'$self->{VERSION_FROM}' failed\n");
          }
      }
  
      if (defined $self->{VERSION}) {
          if ( $self->{VERSION} !~ /^\s*v?[\d_\.]+\s*$/ ) {
            require version;
            my $normal = eval { version->parse( $self->{VERSION} ) };
            $self->{VERSION} = $normal if defined $normal;
          }
          $self->{VERSION} =~ s/^\s+//;
          $self->{VERSION} =~ s/\s+$//;
      }
      else {
          $self->{VERSION} = '';
      }
  
  
      $self->{VERSION_MACRO}  = 'VERSION';
      ($self->{VERSION_SYM} = $self->{VERSION}) =~ s/\W/_/g;
      $self->{DEFINE_VERSION} = '-D$(VERSION_MACRO)=\"$(VERSION)\"';
  
  
      # Graham Barr and Paul Marquess had some ideas how to ensure
      # version compatibility between the *.pm file and the
      # corresponding *.xs file. The bottom line was, that we need an
      # XS_VERSION macro that defaults to VERSION:
      $self->{XS_VERSION} ||= $self->{VERSION};
  
      $self->{XS_VERSION_MACRO}  = 'XS_VERSION';
      $self->{XS_DEFINE_VERSION} = '-D$(XS_VERSION_MACRO)=\"$(XS_VERSION)\"';
  
  }
  
  
  =head3 init_tools
  
      $MM->init_tools();
  
  Initializes the simple macro definitions used by tools_other() and
  places them in the $MM object.  These use conservative cross platform
  versions and should be overridden with platform specific versions for
  performance.
  
  Defines at least these macros.
  
    Macro             Description
  
    NOOP              Do nothing
    NOECHO            Tell make not to display the command itself
  
    SHELL             Program used to run shell commands
  
    ECHO              Print text adding a newline on the end
    RM_F              Remove a file
    RM_RF             Remove a directory
    TOUCH             Update a file's timestamp
    TEST_F            Test for a file's existence
    TEST_S            Test the size of a file
    CP                Copy a file
    CP_NONEMPTY       Copy a file if it is not empty
    MV                Move a file
    CHMOD             Change permissions on a file
    FALSE             Exit with non-zero
    TRUE              Exit with zero
  
    UMASK_NULL        Nullify umask
    DEV_NULL          Suppress all command output
  
  =cut
  
  sub init_tools {
      my $self = shift;
  
      $self->{ECHO}     ||= $self->oneliner('print qq{@ARGV}', ['-l']);
      $self->{ECHO_N}   ||= $self->oneliner('print qq{@ARGV}');
  
      $self->{TOUCH}    ||= $self->oneliner('touch', ["-MExtUtils::Command"]);
      $self->{CHMOD}    ||= $self->oneliner('chmod', ["-MExtUtils::Command"]);
      $self->{RM_F}     ||= $self->oneliner('rm_f',  ["-MExtUtils::Command"]);
      $self->{RM_RF}    ||= $self->oneliner('rm_rf', ["-MExtUtils::Command"]);
      $self->{TEST_F}   ||= $self->oneliner('test_f', ["-MExtUtils::Command"]);
      $self->{TEST_S}   ||= $self->oneliner('test_s', ["-MExtUtils::Command::MM"]);
      $self->{CP_NONEMPTY} ||= $self->oneliner('cp_nonempty', ["-MExtUtils::Command::MM"]);
      $self->{FALSE}    ||= $self->oneliner('exit 1');
      $self->{TRUE}     ||= $self->oneliner('exit 0');
  
      $self->{MKPATH}   ||= $self->oneliner('mkpath', ["-MExtUtils::Command"]);
  
      $self->{CP}       ||= $self->oneliner('cp', ["-MExtUtils::Command"]);
      $self->{MV}       ||= $self->oneliner('mv', ["-MExtUtils::Command"]);
  
      $self->{MOD_INSTALL} ||=
        $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
  install([ from_to => {@ARGV}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
      $self->{DOC_INSTALL} ||= $self->oneliner('perllocal_install', ["-MExtUtils::Command::MM"]);
      $self->{UNINSTALL}   ||= $self->oneliner('uninstall', ["-MExtUtils::Command::MM"]);
      $self->{WARN_IF_OLD_PACKLIST} ||=
        $self->oneliner('warn_if_old_packlist', ["-MExtUtils::Command::MM"]);
      $self->{FIXIN}       ||= $self->oneliner('MY->fixin(shift)', ["-MExtUtils::MY"]);
      $self->{EQUALIZE_TIMESTAMP} ||= $self->oneliner('eqtime', ["-MExtUtils::Command"]);
  
      $self->{UNINST}     ||= 0;
      $self->{VERBINST}   ||= 0;
  
      $self->{SHELL}              ||= $Config{sh};
  
      # UMASK_NULL is not used by MakeMaker but some CPAN modules
      # make use of it.
      $self->{UMASK_NULL}         ||= "umask 0";
  
      # Not the greatest default, but its something.
      $self->{DEV_NULL}           ||= "> /dev/null 2>&1";
  
      $self->{NOOP}               ||= '$(TRUE)';
      $self->{NOECHO}             = '@' unless defined $self->{NOECHO};
  
      $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE} || 'Makefile';
      $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE};
      $self->{MAKEFILE_OLD}       ||= $self->{MAKEFILE}.'.old';
      $self->{MAKE_APERL_FILE}    ||= $self->{MAKEFILE}.'.aperl';
  
      # Not everybody uses -f to indicate "use this Makefile instead"
      $self->{USEMAKEFILE}        ||= '-f';
  
      # Some makes require a wrapper around macros passed in on the command
      # line.
      $self->{MACROSTART}         ||= '';
      $self->{MACROEND}           ||= '';
  
      return;
  }
  
  
  =head3 init_others
  
      $MM->init_others();
  
  Initializes the macro definitions having to do with compiling and
  linking used by tools_other() and places them in the $MM object.
  
  If there is no description, its the same as the parameter to
  WriteMakefile() documented in ExtUtils::MakeMaker.
  
  =cut
  
  sub init_others {
      my $self = shift;
  
      $self->{LD_RUN_PATH} = "";
  
      $self->{LIBS} = $self->_fix_libs($self->{LIBS});
  
      # Compute EXTRALIBS, BSLOADLIBS and LDLOADLIBS from $self->{LIBS}
      foreach my $libs ( @{$self->{LIBS}} ){
          $libs =~ s/^\s*(.*\S)\s*$/$1/; # remove leading and trailing whitespace
          my(@libs) = $self->extliblist($libs);
          if ($libs[0] or $libs[1] or $libs[2]){
              # LD_RUN_PATH now computed by ExtUtils::Liblist
              ($self->{EXTRALIBS},  $self->{BSLOADLIBS},
               $self->{LDLOADLIBS}, $self->{LD_RUN_PATH}) = @libs;
              last;
          }
      }
  
      if ( $self->{OBJECT} ) {
          $self->{OBJECT} = join(" ", @{$self->{OBJECT}}) if ref $self->{OBJECT};
          $self->{OBJECT} =~ s!\.o(bj)?\b!\$(OBJ_EXT)!g;
      } elsif ( $self->{MAGICXS} && @{$self->{O_FILES}||[]} ) {
          $self->{OBJECT} = join(" ", @{$self->{O_FILES}});
          $self->{OBJECT} =~ s!\.o(bj)?\b!\$(OBJ_EXT)!g;
      } else {
          # init_dirscan should have found out, if we have C files
          $self->{OBJECT} = "";
          $self->{OBJECT} = '$(BASEEXT)$(OBJ_EXT)' if @{$self->{C}||[]};
      }
      $self->{OBJECT} =~ s/\n+/ \\\n\t/g;
  
      $self->{BOOTDEP}  = (-f "$self->{BASEEXT}_BS") ? "$self->{BASEEXT}_BS" : "";
      $self->{PERLMAINCC} ||= '$(CC)';
      $self->{LDFROM} = '$(OBJECT)' unless $self->{LDFROM};
  
      # Sanity check: don't define LINKTYPE = dynamic if we're skipping
      # the 'dynamic' section of MM.  We don't have this problem with
      # 'static', since we either must use it (%Config says we can't
      # use dynamic loading) or the caller asked for it explicitly.
      if (!$self->{LINKTYPE}) {
         $self->{LINKTYPE} = $self->{SKIPHASH}{'dynamic'}
                          ? 'static'
                          : ($Config{usedl} ? 'dynamic' : 'static');
      }
  
      return;
  }
  
  
  # Lets look at $self->{LIBS} carefully: It may be an anon array, a string or
  # undefined. In any case we turn it into an anon array
  sub _fix_libs {
      my($self, $libs) = @_;
  
      return !defined $libs       ? ['']          :
             !ref $libs           ? [$libs]       :
             !defined $libs->[0]  ? ['']          :
                                    $libs         ;
  }
  
  
  =head3 tools_other
  
      my $make_frag = $MM->tools_other;
  
  Returns a make fragment containing definitions for the macros init_others()
  initializes.
  
  =cut
  
  sub tools_other {
      my($self) = shift;
      my @m;
  
      # We set PM_FILTER as late as possible so it can see all the earlier
      # on macro-order sensitive makes such as nmake.
      for my $tool (qw{ SHELL CHMOD CP MV NOOP NOECHO RM_F RM_RF TEST_F TOUCH
                        UMASK_NULL DEV_NULL MKPATH EQUALIZE_TIMESTAMP
                        FALSE TRUE
                        ECHO ECHO_N
                        UNINST VERBINST
                        MOD_INSTALL DOC_INSTALL UNINSTALL
                        WARN_IF_OLD_PACKLIST
                        MACROSTART MACROEND
                        USEMAKEFILE
                        PM_FILTER
                        FIXIN
                        CP_NONEMPTY
                      } )
      {
          next unless defined $self->{$tool};
          push @m, "$tool = $self->{$tool}\n";
      }
  
      return join "", @m;
  }
  
  
  =head3 init_DIRFILESEP  I<Abstract>
  
    $MM->init_DIRFILESEP;
    my $dirfilesep = $MM->{DIRFILESEP};
  
  Initializes the DIRFILESEP macro which is the separator between the
  directory and filename in a filepath.  ie. / on Unix, \ on Win32 and
  nothing on VMS.
  
  For example:
  
      # instead of $(INST_ARCHAUTODIR)/extralibs.ld
      $(INST_ARCHAUTODIR)$(DIRFILESEP)extralibs.ld
  
  Something of a hack but it prevents a lot of code duplication between
  MM_* variants.
  
  Do not use this as a separator between directories.  Some operating
  systems use different separators between subdirectories as between
  directories and filenames (for example:  VOLUME:[dir1.dir2]file on VMS).
  
  =head3 init_linker  I<Abstract>
  
      $mm->init_linker;
  
  Initialize macros which have to do with linking.
  
  PERL_ARCHIVE: path to libperl.a equivalent to be linked to dynamic
  extensions.
  
  PERL_ARCHIVE_AFTER: path to a library which should be put on the
  linker command line I<after> the external libraries to be linked to
  dynamic extensions.  This may be needed if the linker is one-pass, and
  Perl includes some overrides for C RTL functions, such as malloc().
  
  EXPORT_LIST: name of a file that is passed to linker to define symbols
  to be exported.
  
  Some OSes do not need these in which case leave it blank.
  
  
  =head3 init_platform
  
      $mm->init_platform
  
  Initialize any macros which are for platform specific use only.
  
  A typical one is the version number of your OS specific module.
  (ie. MM_Unix_VERSION or MM_VMS_VERSION).
  
  =cut
  
  sub init_platform {
      return '';
  }
  
  
  =head3 init_MAKE
  
      $mm->init_MAKE
  
  Initialize MAKE from either a MAKE environment variable or $Config{make}.
  
  =cut
  
  sub init_MAKE {
      my $self = shift;
  
      $self->{MAKE} ||= $ENV{MAKE} || $Config{make};
  }
  
  
  =head2 Tools
  
  A grab bag of methods to generate specific macros and commands.
  
  
  
  =head3 manifypods
  
  Defines targets and routines to translate the pods into manpages and
  put them into the INST_* directories.
  
  =cut
  
  sub manifypods {
      my $self          = shift;
  
      my $POD2MAN_macro = $self->POD2MAN_macro();
      my $manifypods_target = $self->manifypods_target();
  
      return <<END_OF_TARGET;
  
  $POD2MAN_macro
  
  $manifypods_target
  
  END_OF_TARGET
  
  }
  
  
  =head3 POD2MAN_macro
  
    my $pod2man_macro = $self->POD2MAN_macro
  
  Returns a definition for the POD2MAN macro.  This is a program
  which emulates the pod2man utility.  You can add more switches to the
  command by simply appending them on the macro.
  
  Typical usage:
  
      $(POD2MAN) --section=3 --perm_rw=$(PERM_RW) podfile1 man_page1 ...
  
  =cut
  
  sub POD2MAN_macro {
      my $self = shift;
  
  # Need the trailing '--' so perl stops gobbling arguments and - happens
  # to be an alternative end of line separator on VMS so we quote it
      return <<'END_OF_DEF';
  POD2MAN_EXE = $(PERLRUN) "-MExtUtils::Command::MM" -e pod2man "--"
  POD2MAN = $(POD2MAN_EXE)
  END_OF_DEF
  }
  
  
  =head3 test_via_harness
  
    my $command = $mm->test_via_harness($perl, $tests);
  
  Returns a $command line which runs the given set of $tests with
  Test::Harness and the given $perl.
  
  Used on the t/*.t files.
  
  =cut
  
  sub test_via_harness {
      my($self, $perl, $tests) = @_;
  
      return qq{\t$perl "-MExtUtils::Command::MM" "-MTest::Harness" }.
             qq{"-e" "undef *Test::Harness::Switches; test_harness(\$(TEST_VERBOSE), '\$(INST_LIB)', '\$(INST_ARCHLIB)')" $tests\n};
  }
  
  =head3 test_via_script
  
    my $command = $mm->test_via_script($perl, $script);
  
  Returns a $command line which just runs a single test without
  Test::Harness.  No checks are done on the results, they're just
  printed.
  
  Used for test.pl, since they don't always follow Test::Harness
  formatting.
  
  =cut
  
  sub test_via_script {
      my($self, $perl, $script) = @_;
      return qq{\t$perl "-I\$(INST_LIB)" "-I\$(INST_ARCHLIB)" $script\n};
  }
  
  
  =head3 tool_autosplit
  
  Defines a simple perl call that runs autosplit. May be deprecated by
  pm_to_blib soon.
  
  =cut
  
  sub tool_autosplit {
      my($self, %attribs) = @_;
  
      my $maxlen = $attribs{MAXLEN} ? '$$AutoSplit::Maxlen=$attribs{MAXLEN};'
                                    : '';
  
      my $asplit = $self->oneliner(sprintf <<'PERL_CODE', $maxlen);
  use AutoSplit; %s autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1)
  PERL_CODE
  
      return sprintf <<'MAKE_FRAG', $asplit;
  # Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto
  AUTOSPLITFILE = %s
  
  MAKE_FRAG
  
  }
  
  
  =head3 arch_check
  
      my $arch_ok = $mm->arch_check(
          $INC{"Config.pm"},
          File::Spec->catfile($Config{archlibexp}, "Config.pm")
      );
  
  A sanity check that what Perl thinks the architecture is and what
  Config thinks the architecture is are the same.  If they're not it
  will return false and show a diagnostic message.
  
  When building Perl it will always return true, as nothing is installed
  yet.
  
  The interface is a bit odd because this is the result of a
  quick refactoring.  Don't rely on it.
  
  =cut
  
  sub arch_check {
      my $self = shift;
      my($pconfig, $cconfig) = @_;
  
      return 1 if $self->{PERL_SRC};
  
      my($pvol, $pthinks) = $self->splitpath($pconfig);
      my($cvol, $cthinks) = $self->splitpath($cconfig);
  
      $pthinks = $self->canonpath($pthinks);
      $cthinks = $self->canonpath($cthinks);
  
      my $ret = 1;
      if ($pthinks ne $cthinks) {
          print "Have $pthinks\n";
          print "Want $cthinks\n";
  
          $ret = 0;
  
          my $arch = (grep length, $self->splitdir($pthinks))[-1];
  
          print <<END unless $self->{UNINSTALLED_PERL};
  Your perl and your Config.pm seem to have different ideas about the
  architecture they are running on.
  Perl thinks: [$arch]
  Config says: [$Config{archname}]
  This may or may not cause problems. Please check your installation of perl
  if you have problems building this extension.
  END
      }
  
      return $ret;
  }
  
  
  
  =head2 File::Spec wrappers
  
  ExtUtils::MM_Any is a subclass of File::Spec.  The methods noted here
  override File::Spec.
  
  
  
  =head3 catfile
  
  File::Spec <= 0.83 has a bug where the file part of catfile is not
  canonicalized.  This override fixes that bug.
  
  =cut
  
  sub catfile {
      my $self = shift;
      return $self->canonpath($self->SUPER::catfile(@_));
  }
  
  
  
  =head2 Misc
  
  Methods I can't really figure out where they should go yet.
  
  
  =head3 find_tests
  
    my $test = $mm->find_tests;
  
  Returns a string suitable for feeding to the shell to return all
  tests in t/*.t.
  
  =cut
  
  sub find_tests {
      my($self) = shift;
      return -d 't' ? 't/*.t' : '';
  }
  
  =head3 find_tests_recursive
  
    my $tests = $mm->find_tests_recursive;
  
  Returns a string suitable for feeding to the shell to return all
  tests in t/ but recursively.
  
  =cut
  
  sub find_tests_recursive {
      my($self) = shift;
      return '' unless -d 't';
  
      require File::Find;
  
      my %testfiles;
  
      my $wanted = sub {
          return unless m!\.t$!;
          my ($volume,$directories,$file) =
              File::Spec->splitpath( $File::Find::name  );
          my @dirs = File::Spec->splitdir( $directories );
          for ( @dirs ) {
            next if $_ eq 't';
            unless ( $_ ) {
              $_ = '*.t';
              next;
            }
            $_ = '*';
          }
          my $testfile = join '/', @dirs;
          $testfiles{ $testfile } = 1;
      };
  
      File::Find::find( $wanted, 't' );
  
      return join ' ', sort keys %testfiles;
  }
  
  =head3 extra_clean_files
  
      my @files_to_clean = $MM->extra_clean_files;
  
  Returns a list of OS specific files to be removed in the clean target in
  addition to the usual set.
  
  =cut
  
  # An empty method here tickled a perl 5.8.1 bug and would return its object.
  sub extra_clean_files {
      return;
  }
  
  
  =head3 installvars
  
      my @installvars = $mm->installvars;
  
  A list of all the INSTALL* variables without the INSTALL prefix.  Useful
  for iteration or building related variable sets.
  
  =cut
  
  sub installvars {
      return qw(PRIVLIB SITELIB  VENDORLIB
                ARCHLIB SITEARCH VENDORARCH
                BIN     SITEBIN  VENDORBIN
                SCRIPT  SITESCRIPT  VENDORSCRIPT
                MAN1DIR SITEMAN1DIR VENDORMAN1DIR
                MAN3DIR SITEMAN3DIR VENDORMAN3DIR
               );
  }
  
  
  =head3 libscan
  
    my $wanted = $self->libscan($path);
  
  Takes a path to a file or dir and returns an empty string if we don't
  want to include this file in the library.  Otherwise it returns the
  the $path unchanged.
  
  Mainly used to exclude version control administrative directories from
  installation.
  
  =cut
  
  sub libscan {
      my($self,$path) = @_;
      my($dirs,$file) = ($self->splitpath($path))[1,2];
      return '' if grep /^(?:RCS|CVS|SCCS|\.svn|_darcs)$/,
                       $self->splitdir($dirs), $file;
  
      return $path;
  }
  
  
  =head3 platform_constants
  
      my $make_frag = $mm->platform_constants
  
  Returns a make fragment defining all the macros initialized in
  init_platform() rather than put them in constants().
  
  =cut
  
  sub platform_constants {
      return '';
  }
  
  =begin private
  
  =head3 _PREREQ_PRINT
  
      $self->_PREREQ_PRINT;
  
  Implements PREREQ_PRINT.
  
  Refactored out of MakeMaker->new().
  
  =end private
  
  =cut
  
  sub _PREREQ_PRINT {
      my $self = shift;
  
      require Data::Dumper;
      my @what = ('PREREQ_PM');
      push @what, 'MIN_PERL_VERSION' if $self->{MIN_PERL_VERSION};
      push @what, 'BUILD_REQUIRES'   if $self->{BUILD_REQUIRES};
      print Data::Dumper->Dump([@{$self}{@what}], \@what);
      exit 0;
  }
  
  
  =begin private
  
  =head3 _PRINT_PREREQ
  
    $mm->_PRINT_PREREQ;
  
  Implements PRINT_PREREQ, a slightly different version of PREREQ_PRINT
  added by Redhat to, I think, support generating RPMs from Perl modules.
  
  Should not include BUILD_REQUIRES as RPMs do not incluide them.
  
  Refactored out of MakeMaker->new().
  
  =end private
  
  =cut
  
  sub _PRINT_PREREQ {
      my $self = shift;
  
      my $prereqs= $self->{PREREQ_PM};
      my @prereq = map { [$_, $prereqs->{$_}] } keys %$prereqs;
  
      if ( $self->{MIN_PERL_VERSION} ) {
          push @prereq, ['perl' => $self->{MIN_PERL_VERSION}];
      }
  
      print join(" ", map { "perl($_->[0])>=$_->[1] " }
                   sort { $a->[0] cmp $b->[0] } @prereq), "\n";
      exit 0;
  }
  
  
  =begin private
  
  =head3 _all_prereqs
  
    my $prereqs = $self->_all_prereqs;
  
  Returns a hash ref of both PREREQ_PM and BUILD_REQUIRES.
  
  =end private
  
  =cut
  
  sub _all_prereqs {
      my $self = shift;
  
      return { %{$self->{PREREQ_PM}}, %{$self->{BUILD_REQUIRES}} };
  }
  
  =begin private
  
  =head3 _perl_header_files
  
    my $perl_header_files= $self->_perl_header_files;
  
  returns a sorted list of header files as found in PERL_SRC or $archlibexp/CORE.
  
  Used by perldepend() in MM_Unix and MM_VMS via _perl_header_files_fragment()
  
  =end private
  
  =cut
  
  sub _perl_header_files {
      my $self = shift;
  
      my $header_dir = $self->{PERL_SRC} || $self->catdir($Config{archlibexp}, 'CORE');
      opendir my $dh, $header_dir
          or die "Failed to opendir '$header_dir' to find header files: $!";
  
      # we need to use a temporary here as the sort in scalar context would have undefined results.
      my @perl_headers= sort grep { /\.h\z/ } readdir($dh);
  
      closedir $dh;
  
      return @perl_headers;
  }
  
  =begin private
  
  =head3 _perl_header_files_fragment ($o, $separator)
  
    my $perl_header_files_fragment= $self->_perl_header_files_fragment("/");
  
  return a Makefile fragment which holds the list of perl header files which
  XS code depends on $(PERL_INC), and sets up the dependency for the $(OBJECT) file.
  
  The $separator argument defaults to "". MM_VMS will set it to "" and MM_UNIX to "/"
  in perldepend(). This reason child subclasses need to control this is that in
  VMS the $(PERL_INC) directory will already have delimiters in it, but in
  UNIX $(PERL_INC) will need a slash between it an the filename. Hypothetically
  win32 could use "\\" (but it doesn't need to).
  
  =end private
  
  =cut
  
  sub _perl_header_files_fragment {
      my ($self, $separator)= @_;
      $separator ||= "";
      return join("\\\n",
                  "PERL_HDRS = ",
                  map {
                      sprintf( "        \$(PERL_INC)%s%s            ", $separator, $_ )
                  } $self->_perl_header_files()
             ) . "\n\n"
             . "\$(OBJECT) : \$(PERL_HDRS)\n";
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> and the denizens of
  makemaker@perl.org with code from ExtUtils::MM_Unix and
  ExtUtils::MM_Win32.
  
  
  =cut
  
  1;
EXTUTILS_MM_ANY

$fatpacked{"ExtUtils/MM_BeOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_BEOS';
  package ExtUtils::MM_BeOS;
  
  use strict;
  
  =head1 NAME
  
  ExtUtils::MM_BeOS - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_BeOS;	# Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =cut
  
  use ExtUtils::MakeMaker::Config;
  use File::Spec;
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  our $VERSION = '6.92';
  
  
  =item os_flavor
  
  BeOS is BeOS.
  
  =cut
  
  sub os_flavor {
      return('BeOS');
  }
  
  =item init_linker
  
  libperl.a equivalent to be linked to dynamic extensions.
  
  =cut
  
  sub init_linker {
      my($self) = shift;
  
      $self->{PERL_ARCHIVE} ||=
        File::Spec->catdir('$(PERL_INC)',$Config{libperl});
      $self->{PERL_ARCHIVE_AFTER} ||= '';
      $self->{EXPORT_LIST}  ||= '';
  }
  
  =back
  
  1;
  __END__
  
EXTUTILS_MM_BEOS

$fatpacked{"ExtUtils/MM_Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_CYGWIN';
  package ExtUtils::MM_Cygwin;
  
  use strict;
  
  use ExtUtils::MakeMaker::Config;
  use File::Spec;
  
  require ExtUtils::MM_Unix;
  require ExtUtils::MM_Win32;
  our @ISA = qw( ExtUtils::MM_Unix );
  
  our $VERSION = '6.92';
  
  
  =head1 NAME
  
  ExtUtils::MM_Cygwin - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_Cygwin; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided there.
  
  =over 4
  
  =item os_flavor
  
  We're Unix and Cygwin.
  
  =cut
  
  sub os_flavor {
      return('Unix', 'Cygwin');
  }
  
  =item cflags
  
  if configured for dynamic loading, triggers #define EXT in EXTERN.h
  
  =cut
  
  sub cflags {
      my($self,$libperl)=@_;
      return $self->{CFLAGS} if $self->{CFLAGS};
      return '' unless $self->needs_linking();
  
      my $base = $self->SUPER::cflags($libperl);
      foreach (split /\n/, $base) {
          /^(\S*)\s*=\s*(\S*)$/ and $self->{$1} = $2;
      };
      $self->{CCFLAGS} .= " -DUSEIMPORTLIB" if ($Config{useshrplib} eq 'true');
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  };
  
  }
  
  
  =item replace_manpage_separator
  
  replaces strings '::' with '.' in MAN*POD man page names
  
  =cut
  
  sub replace_manpage_separator {
      my($self, $man) = @_;
      $man =~ s{/+}{.}g;
      return $man;
  }
  
  =item init_linker
  
  points to libperl.a
  
  =cut
  
  sub init_linker {
      my $self = shift;
  
      if ($Config{useshrplib} eq 'true') {
          my $libperl = '$(PERL_INC)' .'/'. "$Config{libperl}";
          if( $] >= 5.006002 ) {
              $libperl =~ s/a$/dll.a/;
          }
          $self->{PERL_ARCHIVE} = $libperl;
      } else {
          $self->{PERL_ARCHIVE} =
            '$(PERL_INC)' .'/'. ("$Config{libperl}" or "libperl.a");
      }
  
      $self->{PERL_ARCHIVE_AFTER} ||= '';
      $self->{EXPORT_LIST}  ||= '';
  }
  
  =item maybe_command
  
  Determine whether a file is native to Cygwin by checking whether it
  resides inside the Cygwin installation (using Windows paths). If so,
  use C<ExtUtils::MM_Unix> to determine if it may be a command.
  Otherwise use the tests from C<ExtUtils::MM_Win32>.
  
  =cut
  
  sub maybe_command {
      my ($self, $file) = @_;
  
      my $cygpath = Cygwin::posix_to_win_path('/', 1);
      my $filepath = Cygwin::posix_to_win_path($file, 1);
  
      return (substr($filepath,0,length($cygpath)) eq $cygpath)
      ? $self->SUPER::maybe_command($file) # Unix
      : ExtUtils::MM_Win32->maybe_command($file); # Win32
  }
  
  =item dynamic_lib
  
  Use the default to produce the *.dll's.
  But for new archdir dll's use the same rebase address if the old exists.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      my $s = ExtUtils::MM_Unix::dynamic_lib($self, %attribs);
      my $ori = "$self->{INSTALLARCHLIB}/auto/$self->{FULLEXT}/$self->{BASEEXT}.$self->{DLEXT}";
      if (-e $ori) {
          my $imagebase = `/bin/objdump -p $ori | /bin/grep ImageBase | /bin/cut -c12-`;
          chomp $imagebase;
          if ($imagebase gt "40000000") {
              my $LDDLFLAGS = $self->{LDDLFLAGS};
              $LDDLFLAGS =~ s/-Wl,--enable-auto-image-base/-Wl,--image-base=0x$imagebase/;
              $s =~ s/ \$\(LDDLFLAGS\) / $LDDLFLAGS /m;
          }
      }
      $s;
  }
  
  =item all_target
  
  Build man pages, too
  
  =cut
  
  sub all_target {
      ExtUtils::MM_Unix::all_target(shift);
  }
  
  =back
  
  =cut
  
  1;
EXTUTILS_MM_CYGWIN

$fatpacked{"ExtUtils/MM_DOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DOS';
  package ExtUtils::MM_DOS;
  
  use strict;
  
  our $VERSION = '6.92';
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  
  
  =head1 NAME
  
  ExtUtils::MM_DOS - DOS specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality
  for DOS.
  
  Unless otherwise stated, it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =over 4
  
  =item os_flavor
  
  =cut
  
  sub os_flavor {
      return('DOS');
  }
  
  =item B<replace_manpage_separator>
  
  Generates Foo__Bar.3 style man page names
  
  =cut
  
  sub replace_manpage_separator {
      my($self, $man) = @_;
  
      $man =~ s,/+,__,g;
      return $man;
  }
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MM_Unix>, L<ExtUtils::MakeMaker>
  
  =cut
  
  1;
EXTUTILS_MM_DOS

$fatpacked{"ExtUtils/MM_Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_DARWIN';
  package ExtUtils::MM_Darwin;
  
  use strict;
  
  BEGIN {
      require ExtUtils::MM_Unix;
      our @ISA = qw( ExtUtils::MM_Unix );
  }
  
  our $VERSION = '6.92';
  
  
  =head1 NAME
  
  ExtUtils::MM_Darwin - special behaviors for OS X
  
  =head1 SYNOPSIS
  
      For internal MakeMaker use only
  
  =head1 DESCRIPTION
  
  See L<ExtUtils::MM_Unix> for L<ExtUtils::MM_Any> for documentation on the
  methods overridden here.
  
  =head2 Overriden Methods
  
  =head3 init_dist
  
  Turn off Apple tar's tendency to copy resource forks as "._foo" files.
  
  =cut
  
  sub init_dist {
      my $self = shift;
  
      # Thank you, Apple, for breaking tar and then breaking the work around.
      # 10.4 wants COPY_EXTENDED_ATTRIBUTES_DISABLE while 10.5 wants
      # COPYFILE_DISABLE.  I'm not going to push my luck and instead just
      # set both.
      $self->{TAR} ||=
          'COPY_EXTENDED_ATTRIBUTES_DISABLE=1 COPYFILE_DISABLE=1 tar';
  
      $self->SUPER::init_dist(@_);
  }
  
  1;
EXTUTILS_MM_DARWIN

$fatpacked{"ExtUtils/MM_MacOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_MACOS';
  package ExtUtils::MM_MacOS;
  
  use strict;
  
  our $VERSION = '6.92';
  
  sub new {
      die <<'UNSUPPORTED';
  MacOS Classic (MacPerl) is no longer supported by MakeMaker.
  Please use Module::Build instead.
  UNSUPPORTED
  }
  
  =head1 NAME
  
  ExtUtils::MM_MacOS - once produced Makefiles for MacOS Classic
  
  =head1 SYNOPSIS
  
    # MM_MacOS no longer contains any code.  This is just a stub.
  
  =head1 DESCRIPTION
  
  Once upon a time, MakeMaker could produce an approximation of a correct
  Makefile on MacOS Classic (MacPerl).  Due to a lack of maintainers, this
  fell out of sync with the rest of MakeMaker and hadn't worked in years.
  Since there's little chance of it being repaired, MacOS Classic is fading
  away, and the code was icky to begin with, the code has been deleted to
  make maintenance easier.
  
  Those interested in writing modules for MacPerl should use Module::Build
  which works better than MakeMaker ever did.
  
  Anyone interested in resurrecting this file should pull the old version
  from the MakeMaker CVS repository and contact makemaker@perl.org, but we
  really encourage you to work on Module::Build instead.
  
  =cut
  
  1;
EXTUTILS_MM_MACOS

$fatpacked{"ExtUtils/MM_NW5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_NW5';
  package ExtUtils::MM_NW5;
  
  =head1 NAME
  
  ExtUtils::MM_NW5 - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_NW5; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over
  
  =cut
  
  use strict;
  use ExtUtils::MakeMaker::Config;
  use File::Basename;
  
  our $VERSION = '6.92';
  
  require ExtUtils::MM_Win32;
  our @ISA = qw(ExtUtils::MM_Win32);
  
  use ExtUtils::MakeMaker qw( &neatvalue );
  
  $ENV{EMXSHELL} = 'sh'; # to run `commands`
  
  my $BORLAND  = $Config{'cc'} =~ /^bcc/i;
  my $GCC      = $Config{'cc'} =~ /^gcc/i;
  
  
  =item os_flavor
  
  We're Netware in addition to being Windows.
  
  =cut
  
  sub os_flavor {
      my $self = shift;
      return ($self->SUPER::os_flavor, 'Netware');
  }
  
  =item init_platform
  
  Add Netware macros.
  
  LIBPTH, BASE_IMPORT, NLM_VERSION, MPKTOOL, TOOLPATH, BOOT_SYMBOL,
  NLM_SHORT_NAME, INCLUDE, PATH, MM_NW5_REVISION
  
  
  =item platform_constants
  
  Add Netware macros initialized above to the Makefile.
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      # To get Win32's setup.
      $self->SUPER::init_platform;
  
      # incpath is copied to makefile var INCLUDE in constants sub, here just
      # make it empty
      my $libpth = $Config{'libpth'};
      $libpth =~ s( )(;);
      $self->{'LIBPTH'} = $libpth;
  
      $self->{'BASE_IMPORT'} = $Config{'base_import'};
  
      # Additional import file specified from Makefile.pl
      if($self->{'base_import'}) {
          $self->{'BASE_IMPORT'} .= ', ' . $self->{'base_import'};
      }
  
      $self->{'NLM_VERSION'} = $Config{'nlm_version'};
      $self->{'MPKTOOL'}	= $Config{'mpktool'};
      $self->{'TOOLPATH'}	= $Config{'toolpath'};
  
      (my $boot = $self->{'NAME'}) =~ s/:/_/g;
      $self->{'BOOT_SYMBOL'}=$boot;
  
      # If the final binary name is greater than 8 chars,
      # truncate it here.
      if(length($self->{'BASEEXT'}) > 8) {
          $self->{'NLM_SHORT_NAME'} = substr($self->{'BASEEXT'},0,8);
      }
  
      # Get the include path and replace the spaces with ;
      # Copy this to makefile as INCLUDE = d:\...;d:\;
      ($self->{INCLUDE} = $Config{'incpath'}) =~ s/([ ]*)-I/;/g;
  
      # Set the path to CodeWarrior binaries which might not have been set in
      # any other place
      $self->{PATH} = '$(PATH);$(TOOLPATH)';
  
      $self->{MM_NW5_VERSION} = $VERSION;
  }
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      # Setup Win32's constants.
      $make_frag .= $self->SUPER::platform_constants;
  
      foreach my $macro (qw(LIBPTH BASE_IMPORT NLM_VERSION MPKTOOL
                            TOOLPATH BOOT_SYMBOL NLM_SHORT_NAME INCLUDE PATH
                            MM_NW5_VERSION
                        ))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item const_cccmd
  
  =cut
  
  sub const_cccmd {
      my($self,$libperl)=@_;
      return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
      return '' unless $self->needs_linking();
      return $self->{CONST_CCCMD} = <<'MAKE_FRAG';
  CCCMD = $(CC) $(CCFLAGS) $(INC) $(OPTIMIZE) \
  	$(PERLTYPE) $(MPOLLUTE) -o $@ \
  	-DVERSION=\"$(VERSION)\" -DXS_VERSION=\"$(XS_VERSION)\"
  MAKE_FRAG
  
  }
  
  
  =item static_lib
  
  =cut
  
  sub static_lib {
      my($self) = @_;
  
      return '' unless $self->has_link_code;
  
      my $m = <<'END';
  $(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(RM_RF) $@
  END
  
      # If this extension has it's own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      $m .= <<'END'  if $self->{MYEXTLIB};
  	$self->{CP} $(MYEXTLIB) $@
  END
  
      my $ar_arg;
      if( $BORLAND ) {
          $ar_arg = '$@ $(OBJECT:^"+")';
      }
      elsif( $GCC ) {
          $ar_arg = '-ru $@ $(OBJECT)';
      }
      else {
          $ar_arg = '-type library -o $@ $(OBJECT)';
      }
  
      $m .= sprintf <<'END', $ar_arg;
  	$(AR) %s
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)\extralibs.ld
  	$(CHMOD) 755 $@
  END
  
      $m .= <<'END' if $self->{PERL_SRC};
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)\ext.libs
  
  
  END
      return $m;
  }
  
  =item dynamic_lib
  
  Defines how to produce the *.so (or equivalent) files.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      return '' unless $self->needs_linking(); #might be because of a subdir
  
      return '' unless $self->has_link_code;
  
      my($otherldflags) = $attribs{OTHERLDFLAGS} || ($BORLAND ? 'c0d32.obj': '');
      my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
      my($ldfrom) = '$(LDFROM)';
  
      (my $boot = $self->{NAME}) =~ s/:/_/g;
  
      my $m = <<'MAKE_FRAG';
  # This section creates the dynamically loadable $(INST_DYNAMIC)
  # from $(OBJECT) and possibly $(MYEXTLIB).
  OTHERLDFLAGS = '.$otherldflags.'
  INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
  
  # Create xdc data for an MT safe NLM in case of mpk build
  $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(NOECHO) $(ECHO) Export boot_$(BOOT_SYMBOL) > $(BASEEXT).def
  	$(NOECHO) $(ECHO) $(BASE_IMPORT) >> $(BASEEXT).def
  	$(NOECHO) $(ECHO) Import @$(PERL_INC)\perl.imp >> $(BASEEXT).def
  MAKE_FRAG
  
  
      if ( $self->{CCFLAGS} =~ m/ -DMPK_ON /) {
          $m .= <<'MAKE_FRAG';
  	$(MPKTOOL) $(XDCFLAGS) $(BASEEXT).xdc
  	$(NOECHO) $(ECHO) xdcdata $(BASEEXT).xdc >> $(BASEEXT).def
  MAKE_FRAG
      }
  
      # Reconstruct the X.Y.Z version.
      my $version = join '.', map { sprintf "%d", $_ }
                                $] =~ /(\d)\.(\d{3})(\d{2})/;
      $m .= sprintf '	$(LD) $(LDFLAGS) $(OBJECT:.obj=.obj) -desc "Perl %s Extension ($(BASEEXT))  XS_VERSION: $(XS_VERSION)" -nlmversion $(NLM_VERSION)', $version;
  
      # Taking care of long names like FileHandle, ByteLoader, SDBM_File etc
      if($self->{NLM_SHORT_NAME}) {
          # In case of nlms with names exceeding 8 chars, build nlm in the
          # current dir, rename and move to auto\lib.
          $m .= q{ -o $(NLM_SHORT_NAME).$(DLEXT)}
      } else {
          $m .= q{ -o $(INST_AUTODIR)\\$(BASEEXT).$(DLEXT)}
      }
  
      # Add additional lib files if any (SDBM_File)
      $m .= q{ $(MYEXTLIB) } if $self->{MYEXTLIB};
  
      $m .= q{ $(PERL_INC)\Main.lib -commandfile $(BASEEXT).def}."\n";
  
      if($self->{NLM_SHORT_NAME}) {
          $m .= <<'MAKE_FRAG';
  	if exist $(INST_AUTODIR)\$(NLM_SHORT_NAME).$(DLEXT) del $(INST_AUTODIR)\$(NLM_SHORT_NAME).$(DLEXT)
  	move $(NLM_SHORT_NAME).$(DLEXT) $(INST_AUTODIR)
  MAKE_FRAG
      }
  
      $m .= <<'MAKE_FRAG';
  
  	$(CHMOD) 755 $@
  MAKE_FRAG
  
      return $m;
  }
  
  
  1;
  __END__
  
  =back
  
  =cut
  
  
EXTUTILS_MM_NW5

$fatpacked{"ExtUtils/MM_OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_OS2';
  package ExtUtils::MM_OS2;
  
  use strict;
  
  use ExtUtils::MakeMaker qw(neatvalue);
  use File::Spec;
  
  our $VERSION = '6.92';
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Any ExtUtils::MM_Unix);
  
  =pod
  
  =head1 NAME
  
  ExtUtils::MM_OS2 - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_OS2; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =head1 METHODS
  
  =over 4
  
  =item init_dist
  
  Define TO_UNIX to convert OS2 linefeeds to Unix style.
  
  =cut
  
  sub init_dist {
      my($self) = @_;
  
      $self->{TO_UNIX} ||= <<'MAKE_TEXT';
  $(NOECHO) $(TEST_F) tmp.zip && $(RM_F) tmp.zip; $(ZIP) -ll -mr tmp.zip $(DISTVNAME) && unzip -o tmp.zip && $(RM_F) tmp.zip
  MAKE_TEXT
  
      $self->SUPER::init_dist;
  }
  
  sub dlsyms {
      my($self,%attribs) = @_;
  
      my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
      my($vars)  = $attribs{DL_VARS} || $self->{DL_VARS} || [];
      my($funclist) = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
      my($imports)  = $attribs{IMPORTS} || $self->{IMPORTS} || {};
      my(@m);
      (my $boot = $self->{NAME}) =~ s/:/_/g;
  
      if (not $self->{SKIPHASH}{'dynamic'}) {
  	push(@m,"
  $self->{BASEEXT}.def: Makefile.PL
  ",
       '	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e \'use ExtUtils::Mksymlists; \\
       Mksymlists("NAME" => "$(NAME)", "DLBASE" => "$(DLBASE)", ',
       '"VERSION" => "$(VERSION)", "DISTNAME" => "$(DISTNAME)", ',
       '"INSTALLDIRS" => "$(INSTALLDIRS)", ',
       '"DL_FUNCS" => ',neatvalue($funcs),
       ', "FUNCLIST" => ',neatvalue($funclist),
       ', "IMPORTS" => ',neatvalue($imports),
       ', "DL_VARS" => ', neatvalue($vars), ');\'
  ');
      }
      if ($self->{IMPORTS} && %{$self->{IMPORTS}}) {
  	# Make import files (needed for static build)
  	-d 'tmp_imp' or mkdir 'tmp_imp', 0777 or die "Can't mkdir tmp_imp";
  	open my $imp, '>', 'tmpimp.imp' or die "Can't open tmpimp.imp";
  	while (my($name, $exp) = each %{$self->{IMPORTS}}) {
  	    my ($lib, $id) = ($exp =~ /(.*)\.(.*)/) or die "Malformed IMPORT `$exp'";
  	    print $imp "$name $lib $id ?\n";
  	}
  	close $imp or die "Can't close tmpimp.imp";
  	# print "emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp\n";
  	system "emximp -o tmpimp$Config::Config{lib_ext} tmpimp.imp"
  	    and die "Cannot make import library: $!, \$?=$?";
  	# May be running under miniperl, so have no glob...
  	eval { unlink <tmp_imp/*>; 1 } or system "rm tmp_imp/*";
  	system "cd tmp_imp; $Config::Config{ar} x ../tmpimp$Config::Config{lib_ext}"
  	    and die "Cannot extract import objects: $!, \$?=$?";
      }
      join('',@m);
  }
  
  sub static_lib {
      my($self) = @_;
      my $old = $self->ExtUtils::MM_Unix::static_lib();
      return $old unless $self->{IMPORTS} && %{$self->{IMPORTS}};
  
      my @chunks = split /\n{2,}/, $old;
      shift @chunks unless length $chunks[0]; # Empty lines at the start
      $chunks[0] .= <<'EOC';
  
  	$(AR) $(AR_STATIC_ARGS) $@ tmp_imp/* && $(RANLIB) $@
  EOC
      return join "\n\n". '', @chunks;
  }
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
      $man =~ s,/+,.,g;
      $man;
  }
  
  sub maybe_command {
      my($self,$file) = @_;
      $file =~ s,[/\\]+,/,g;
      return $file if -x $file && ! -d _;
      return "$file.exe" if -x "$file.exe" && ! -d _;
      return "$file.cmd" if -x "$file.cmd" && ! -d _;
      return;
  }
  
  =item init_linker
  
  =cut
  
  sub init_linker {
      my $self = shift;
  
      $self->{PERL_ARCHIVE} = "\$(PERL_INC)/libperl\$(LIB_EXT)";
  
      $self->{PERL_ARCHIVE_AFTER} = $OS2::is_aout
        ? ''
        : '$(PERL_INC)/libperl_override$(LIB_EXT)';
      $self->{EXPORT_LIST} = '$(BASEEXT).def';
  }
  
  =item os_flavor
  
  OS/2 is OS/2
  
  =cut
  
  sub os_flavor {
      return('OS/2');
  }
  
  =back
  
  =cut
  
  1;
EXTUTILS_MM_OS2

$fatpacked{"ExtUtils/MM_QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_QNX';
  package ExtUtils::MM_QNX;
  
  use strict;
  our $VERSION = '6.92';
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  
  =head1 NAME
  
  ExtUtils::MM_QNX - QNX specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  QNX.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =head3 extra_clean_files
  
  Add .err files corresponding to each .c file.
  
  =cut
  
  sub extra_clean_files {
      my $self = shift;
  
      my @errfiles = @{$self->{C}};
      for ( @errfiles ) {
  	s/.c$/.err/;
      }
  
      return( @errfiles, 'perlmain.err' );
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  
  1;
EXTUTILS_MM_QNX

$fatpacked{"ExtUtils/MM_UWIN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UWIN';
  package ExtUtils::MM_UWIN;
  
  use strict;
  our $VERSION = '6.92';
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  
  =head1 NAME
  
  ExtUtils::MM_UWIN - U/WIN specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  the AT&T U/WIN UNIX on Windows environment.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =over 4
  
  =item os_flavor
  
  In addition to being Unix, we're U/WIN.
  
  =cut
  
  sub os_flavor {
      return('Unix', 'U/WIN');
  }
  
  
  =item B<replace_manpage_separator>
  
  =cut
  
  sub replace_manpage_separator {
      my($self, $man) = @_;
  
      $man =~ s,/+,.,g;
      return $man;
  }
  
  =back
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MM_Win32>, L<ExtUtils::MakeMaker>
  
  =cut
  
  1;
EXTUTILS_MM_UWIN

$fatpacked{"ExtUtils/MM_Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_UNIX';
  package ExtUtils::MM_Unix;
  
  require 5.006;
  
  use strict;
  
  use Carp;
  use ExtUtils::MakeMaker::Config;
  use File::Basename qw(basename dirname);
  use DirHandle;
  
  our %Config_Override;
  
  use ExtUtils::MakeMaker qw($Verbose neatvalue);
  
  # If we make $VERSION an our variable parse_version() breaks
  use vars qw($VERSION);
  $VERSION = '6.92';
  $VERSION = eval $VERSION;  ## no critic [BuiltinFunctions::ProhibitStringyEval]
  
  require ExtUtils::MM_Any;
  our @ISA = qw(ExtUtils::MM_Any);
  
  my %Is;
  BEGIN {
      $Is{OS2}     = $^O eq 'os2';
      $Is{Win32}   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
      $Is{Dos}     = $^O eq 'dos';
      $Is{VMS}     = $^O eq 'VMS';
      $Is{OSF}     = $^O eq 'dec_osf';
      $Is{IRIX}    = $^O eq 'irix';
      $Is{NetBSD}  = $^O eq 'netbsd';
      $Is{Interix} = $^O eq 'interix';
      $Is{SunOS4}  = $^O eq 'sunos';
      $Is{Solaris} = $^O eq 'solaris';
      $Is{SunOS}   = $Is{SunOS4} || $Is{Solaris};
      $Is{BSD}     = ($^O =~ /^(?:free|net|open)bsd$/ or
                     grep( $^O eq $_, qw(bsdos interix dragonfly) )
                    );
      $Is{Android} = $^O =~ /android/;
  }
  
  BEGIN {
      if( $Is{VMS} ) {
          # For things like vmsify()
          require VMS::Filespec;
          VMS::Filespec->import;
      }
  }
  
  
  =head1 NAME
  
  ExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
  C<require ExtUtils::MM_Unix;>
  
  =head1 DESCRIPTION
  
  The methods provided by this package are designed to be used in
  conjunction with ExtUtils::MakeMaker. When MakeMaker writes a
  Makefile, it creates one or more objects that inherit their methods
  from a package C<MM>. MM itself doesn't provide any methods, but it
  ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating
  specific packages take the responsibility for all the methods provided
  by MM_Unix. We are trying to reduce the number of the necessary
  overrides by defining rather primitive operations within
  ExtUtils::MM_Unix.
  
  If you are going to write a platform specific MM package, please try
  to limit the necessary overrides to primitive methods, and if it is not
  possible to do so, let's work out how to achieve that gain.
  
  If you are overriding any of these methods in your Makefile.PL (in the
  MY class), please report that to the makemaker mailing list. We are
  trying to minimize the necessary method overrides and switch to data
  driven Makefile.PLs wherever possible. In the long run less methods
  will be overridable via the MY class.
  
  =head1 METHODS
  
  The following description of methods is still under
  development. Please refer to the code for not suitably documented
  sections and complain loudly to the makemaker@perl.org mailing list.
  Better yet, provide a patch.
  
  Not all of the methods below are overridable in a
  Makefile.PL. Overridable methods are marked as (o). All methods are
  overridable by a platform specific MM_*.pm file.
  
  Cross-platform methods are being moved into MM_Any.  If you can't find
  something that used to be in here, look in MM_Any.
  
  =cut
  
  # So we don't have to keep calling the methods over and over again,
  # we have these globals to cache the values.  Faster and shrtr.
  my $Curdir  = __PACKAGE__->curdir;
  my $Rootdir = __PACKAGE__->rootdir;
  my $Updir   = __PACKAGE__->updir;
  
  
  =head2 Methods
  
  =over 4
  
  =item os_flavor
  
  Simply says that we're Unix.
  
  =cut
  
  sub os_flavor {
      return('Unix');
  }
  
  
  =item c_o (o)
  
  Defines the suffix rules to compile different flavors of C files to
  object files.
  
  =cut
  
  sub c_o {
  # --- Translation Sections ---
  
      my($self) = shift;
      return '' unless $self->needs_linking();
      my(@m);
  
      my $command = '$(CCCMD)';
      my $flags   = '$(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE)';
  
      if (my $cpp = $Config{cpprun}) {
          my $cpp_cmd = $self->const_cccmd;
          $cpp_cmd =~ s/^CCCMD\s*=\s*\$\(CC\)/$cpp/;
          push @m, qq{
  .c.i:
  	$cpp_cmd $flags \$*.c > \$*.i
  };
      }
  
      push @m, qq{
  .c.s:
  	$command -S $flags \$*.c
  
  .c\$(OBJ_EXT):
  	$command $flags \$*.c
  
  .cpp\$(OBJ_EXT):
  	$command $flags \$*.cpp
  
  .cxx\$(OBJ_EXT):
  	$command $flags \$*.cxx
  
  .cc\$(OBJ_EXT):
  	$command $flags \$*.cc
  };
  
      push @m, qq{
  .C\$(OBJ_EXT):
  	$command $flags \$*.C
  } if !$Is{OS2} and !$Is{Win32} and !$Is{Dos}; #Case-specific
  
      return join "", @m;
  }
  
  =item cflags (o)
  
  Does very much the same as the cflags script in the perl
  distribution. It doesn't return the whole compiler command line, but
  initializes all of its parts. The const_cccmd method then actually
  returns the definition of the CCCMD macro which uses these parts.
  
  =cut
  
  #'
  
  sub cflags {
      my($self,$libperl)=@_;
      return $self->{CFLAGS} if $self->{CFLAGS};
      return '' unless $self->needs_linking();
  
      my($prog, $uc, $perltype, %cflags);
      $libperl ||= $self->{LIBPERL_A} || "libperl$self->{LIB_EXT}" ;
      $libperl =~ s/\.\$\(A\)$/$self->{LIB_EXT}/;
  
      @cflags{qw(cc ccflags optimize shellflags)}
  	= @Config{qw(cc ccflags optimize shellflags)};
      my($optdebug) = "";
  
      $cflags{shellflags} ||= '';
  
      my(%map) =  (
  		D =>   '-DDEBUGGING',
  		E =>   '-DEMBED',
  		DE =>  '-DDEBUGGING -DEMBED',
  		M =>   '-DEMBED -DMULTIPLICITY',
  		DM =>  '-DDEBUGGING -DEMBED -DMULTIPLICITY',
  		);
  
      if ($libperl =~ /libperl(\w*)\Q$self->{LIB_EXT}/){
  	$uc = uc($1);
      } else {
  	$uc = ""; # avoid warning
      }
      $perltype = $map{$uc} ? $map{$uc} : "";
  
      if ($uc =~ /^D/) {
  	$optdebug = "-g";
      }
  
  
      my($name);
      ( $name = $self->{NAME} . "_cflags" ) =~ s/:/_/g ;
      if ($prog = $Config{$name}) {
  	# Expand hints for this extension via the shell
  	print "Processing $name hint:\n" if $Verbose;
  	my(@o)=`cc=\"$cflags{cc}\"
  	  ccflags=\"$cflags{ccflags}\"
  	  optimize=\"$cflags{optimize}\"
  	  perltype=\"$cflags{perltype}\"
  	  optdebug=\"$cflags{optdebug}\"
  	  eval '$prog'
  	  echo cc=\$cc
  	  echo ccflags=\$ccflags
  	  echo optimize=\$optimize
  	  echo perltype=\$perltype
  	  echo optdebug=\$optdebug
  	  `;
  	foreach my $line (@o){
  	    chomp $line;
  	    if ($line =~ /(.*?)=\s*(.*)\s*$/){
  		$cflags{$1} = $2;
  		print "	$1 = $2\n" if $Verbose;
  	    } else {
  		print "Unrecognised result from hint: '$line'\n";
  	    }
  	}
      }
  
      if ($optdebug) {
  	$cflags{optimize} = $optdebug;
      }
  
      for (qw(ccflags optimize perltype)) {
          $cflags{$_} ||= '';
  	$cflags{$_} =~ s/^\s+//;
  	$cflags{$_} =~ s/\s+/ /g;
  	$cflags{$_} =~ s/\s+$//;
  	$self->{uc $_} ||= $cflags{$_};
      }
  
      if ($self->{POLLUTE}) {
  	$self->{CCFLAGS} .= ' -DPERL_POLLUTE ';
      }
  
      my $pollute = '';
      if ($Config{usemymalloc} and not $Config{bincompat5005}
  	and not $Config{ccflags} =~ /-DPERL_POLLUTE_MALLOC\b/
  	and $self->{PERL_MALLOC_OK}) {
  	$pollute = '$(PERL_MALLOC_DEF)';
      }
  
      $self->{CCFLAGS}  = quote_paren($self->{CCFLAGS});
      $self->{OPTIMIZE} = quote_paren($self->{OPTIMIZE});
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  MPOLLUTE = $pollute
  };
  
  }
  
  
  =item const_cccmd (o)
  
  Returns the full compiler call for C programs and stores the
  definition in CONST_CCCMD.
  
  =cut
  
  sub const_cccmd {
      my($self,$libperl)=@_;
      return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
      return '' unless $self->needs_linking();
      return $self->{CONST_CCCMD} =
  	q{CCCMD = $(CC) -c $(PASTHRU_INC) $(INC) \\
  	$(CCFLAGS) $(OPTIMIZE) \\
  	$(PERLTYPE) $(MPOLLUTE) $(DEFINE_VERSION) \\
  	$(XS_DEFINE_VERSION)};
  }
  
  =item const_config (o)
  
  Defines a couple of constants in the Makefile that are imported from
  %Config.
  
  =cut
  
  sub const_config {
  # --- Constants Sections ---
  
      my($self) = shift;
      my @m = <<"END";
  
  # These definitions are from config.sh (via $INC{'Config.pm'}).
  # They may have been overridden via Makefile.PL or on the command line.
  END
  
      my(%once_only);
      foreach my $key (@{$self->{CONFIG}}){
          # SITE*EXP macros are defined in &constants; avoid duplicates here
          next if $once_only{$key};
          $self->{uc $key} = quote_paren($self->{uc $key});
          push @m, uc($key) , ' = ' , $self->{uc $key}, "\n";
          $once_only{$key} = 1;
      }
      join('', @m);
  }
  
  =item const_loadlibs (o)
  
  Defines EXTRALIBS, LDLOADLIBS, BSLOADLIBS, LD_RUN_PATH. See
  L<ExtUtils::Liblist> for details.
  
  =cut
  
  sub const_loadlibs {
      my($self) = shift;
      return "" unless $self->needs_linking;
      my @m;
      push @m, qq{
  # $self->{NAME} might depend on some other libraries:
  # See ExtUtils::Liblist for details
  #
  };
      for my $tmp (qw/
           EXTRALIBS LDLOADLIBS BSLOADLIBS
           /) {
          next unless defined $self->{$tmp};
          push @m, "$tmp = $self->{$tmp}\n";
      }
      # don't set LD_RUN_PATH if empty
      for my $tmp (qw/
           LD_RUN_PATH
           /) {
          next unless $self->{$tmp};
          push @m, "$tmp = $self->{$tmp}\n";
      }
      return join "", @m;
  }
  
  =item constants (o)
  
    my $make_frag = $mm->constants;
  
  Prints out macros for lots of constants.
  
  =cut
  
  sub constants {
      my($self) = @_;
      my @m = ();
  
      $self->{DFSEP} = '$(DIRFILESEP)';  # alias for internal use
  
      for my $macro (qw(
  
                AR_STATIC_ARGS DIRFILESEP DFSEP
                NAME NAME_SYM
                VERSION    VERSION_MACRO    VERSION_SYM DEFINE_VERSION
                XS_VERSION XS_VERSION_MACRO             XS_DEFINE_VERSION
                INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB
                INST_MAN1DIR INST_MAN3DIR
                MAN1EXT      MAN3EXT
                INSTALLDIRS INSTALL_BASE DESTDIR PREFIX
                PERLPREFIX      SITEPREFIX      VENDORPREFIX
                     ),
                     (map { ("INSTALL".$_,
                            "DESTINSTALL".$_)
                          } $self->installvars),
                     qw(
                PERL_LIB
                PERL_ARCHLIB
                LIBPERL_A MYEXTLIB
                FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE
                PERLMAINCC PERL_SRC PERL_INC
                PERL            FULLPERL          ABSPERL
                PERLRUN         FULLPERLRUN       ABSPERLRUN
                PERLRUNINST     FULLPERLRUNINST   ABSPERLRUNINST
                PERL_CORE
                PERM_DIR PERM_RW PERM_RWX
  
  	      ) )
      {
  	next unless defined $self->{$macro};
  
          # pathnames can have sharp signs in them; escape them so
          # make doesn't think it is a comment-start character.
          $self->{$macro} =~ s/#/\\#/g;
  	push @m, "$macro = $self->{$macro}\n";
      }
  
      push @m, qq{
  MAKEMAKER   = $self->{MAKEMAKER}
  MM_VERSION  = $self->{MM_VERSION}
  MM_REVISION = $self->{MM_REVISION}
  };
  
      push @m, q{
  # FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).
  # BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)
  # PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)
  # DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.
  };
  
      for my $macro (qw/
                MAKE
  	      FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT
  	      LDFROM LINKTYPE BOOTDEP
  	      /	)
      {
  	next unless defined $self->{$macro};
  	push @m, "$macro = $self->{$macro}\n";
      }
  
      push @m, "
  # Handy lists of source code files:
  XS_FILES = ".$self->wraplist(sort keys %{$self->{XS}})."
  C_FILES  = ".$self->wraplist(@{$self->{C}})."
  O_FILES  = ".$self->wraplist(@{$self->{O_FILES}})."
  H_FILES  = ".$self->wraplist(@{$self->{H}})."
  MAN1PODS = ".$self->wraplist(sort keys %{$self->{MAN1PODS}})."
  MAN3PODS = ".$self->wraplist(sort keys %{$self->{MAN3PODS}})."
  ";
  
  
      push @m, q{
  # Where is the Config information that we are using/depend on
  CONFIGDEP = $(PERL_ARCHLIB)$(DFSEP)Config.pm $(PERL_INC)$(DFSEP)config.h
  } if -e File::Spec->catfile( $self->{PERL_INC}, 'config.h' );
  
  
      push @m, qq{
  # Where to build things
  INST_LIBDIR      = $self->{INST_LIBDIR}
  INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}
  
  INST_AUTODIR     = $self->{INST_AUTODIR}
  INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}
  
  INST_STATIC      = $self->{INST_STATIC}
  INST_DYNAMIC     = $self->{INST_DYNAMIC}
  INST_BOOT        = $self->{INST_BOOT}
  };
  
  
      push @m, qq{
  # Extra linker info
  EXPORT_LIST        = $self->{EXPORT_LIST}
  PERL_ARCHIVE       = $self->{PERL_ARCHIVE}
  PERL_ARCHIVE_AFTER = $self->{PERL_ARCHIVE_AFTER}
  };
  
      push @m, "
  
  TO_INST_PM = ".$self->wraplist(sort keys %{$self->{PM}})."
  
  PM_TO_BLIB = ".$self->wraplist(map { ($_ => $self->{PM}->{$_}) } sort keys %{$self->{PM}})."
  ";
  
      join('',@m);
  }
  
  
  =item depend (o)
  
  Same as macro for the depend attribute.
  
  =cut
  
  sub depend {
      my($self,%attribs) = @_;
      my(@m,$key,$val);
      while (($key,$val) = each %attribs){
  	last unless defined $key;
  	push @m, "$key : $val\n";
      }
      join "", @m;
  }
  
  
  =item init_DEST
  
    $mm->init_DEST
  
  Defines the DESTDIR and DEST* variables paralleling the INSTALL*.
  
  =cut
  
  sub init_DEST {
      my $self = shift;
  
      # Initialize DESTDIR
      $self->{DESTDIR} ||= '';
  
      # Make DEST variables.
      foreach my $var ($self->installvars) {
          my $destvar = 'DESTINSTALL'.$var;
          $self->{$destvar} ||= '$(DESTDIR)$(INSTALL'.$var.')';
      }
  }
  
  
  =item init_dist
  
    $mm->init_dist;
  
  Defines a lot of macros for distribution support.
  
    macro         description                     default
  
    TAR           tar command to use              tar
    TARFLAGS      flags to pass to TAR            cvf
  
    ZIP           zip command to use              zip
    ZIPFLAGS      flags to pass to ZIP            -r
  
    COMPRESS      compression command to          gzip --best
                  use for tarfiles
    SUFFIX        suffix to put on                .gz
                  compressed files
  
    SHAR          shar command to use             shar
  
    PREOP         extra commands to run before
                  making the archive
    POSTOP        extra commands to run after
                  making the archive
  
    TO_UNIX       a command to convert linefeeds
                  to Unix style in your archive
  
    CI            command to checkin your         ci -u
                  sources to version control
    RCS_LABEL     command to label your sources   rcs -Nv$(VERSION_SYM): -q
                  just after CI is run
  
    DIST_CP       $how argument to manicopy()     best
                  when the distdir is created
  
    DIST_DEFAULT  default target to use to        tardist
                  create a distribution
  
    DISTVNAME     name of the resulting archive   $(DISTNAME)-$(VERSION)
                  (minus suffixes)
  
  =cut
  
  sub init_dist {
      my $self = shift;
  
      $self->{TAR}      ||= 'tar';
      $self->{TARFLAGS} ||= 'cvf';
      $self->{ZIP}      ||= 'zip';
      $self->{ZIPFLAGS} ||= '-r';
      $self->{COMPRESS} ||= 'gzip --best';
      $self->{SUFFIX}   ||= '.gz';
      $self->{SHAR}     ||= 'shar';
      $self->{PREOP}    ||= '$(NOECHO) $(NOOP)'; # eg update MANIFEST
      $self->{POSTOP}   ||= '$(NOECHO) $(NOOP)'; # eg remove the distdir
      $self->{TO_UNIX}  ||= '$(NOECHO) $(NOOP)';
  
      $self->{CI}       ||= 'ci -u';
      $self->{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';
      $self->{DIST_CP}  ||= 'best';
      $self->{DIST_DEFAULT} ||= 'tardist';
  
      ($self->{DISTNAME} = $self->{NAME}) =~ s{::}{-}g unless $self->{DISTNAME};
      $self->{DISTVNAME} ||= $self->{DISTNAME}.'-'.$self->{VERSION};
  }
  
  =item dist (o)
  
    my $dist_macros = $mm->dist(%overrides);
  
  Generates a make fragment defining all the macros initialized in
  init_dist.
  
  %overrides can be used to override any of the above.
  
  =cut
  
  sub dist {
      my($self, %attribs) = @_;
  
      my $make = '';
      if ( $attribs{SUFFIX} && $attribs{SUFFIX} !~ m!^\.! ) {
        $attribs{SUFFIX} = '.' . $attribs{SUFFIX};
      }
      foreach my $key (qw(
              TAR TARFLAGS ZIP ZIPFLAGS COMPRESS SUFFIX SHAR
              PREOP POSTOP TO_UNIX
              CI RCS_LABEL DIST_CP DIST_DEFAULT
              DISTNAME DISTVNAME
             ))
      {
          my $value = $attribs{$key} || $self->{$key};
          $make .= "$key = $value\n";
      }
  
      return $make;
  }
  
  =item dist_basics (o)
  
  Defines the targets distclean, distcheck, skipcheck, manifest, veryclean.
  
  =cut
  
  sub dist_basics {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  distclean :: realclean distcheck
  	$(NOECHO) $(NOOP)
  
  distcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck
  
  skipcheck :
  	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck
  
  manifest :
  	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
  
  veryclean : realclean
  	$(RM_F) *~ */*~ *.orig */*.orig *.bak */*.bak *.old */*.old
  
  MAKE_FRAG
  
  }
  
  =item dist_ci (o)
  
  Defines a check in target for RCS.
  
  =cut
  
  sub dist_ci {
      my($self) = shift;
      return q{
  ci :
  	$(PERLRUN) "-MExtUtils::Manifest=maniread" \\
  	  -e "@all = keys %{ maniread() };" \\
  	  -e "print(qq{Executing $(CI) @all\n}); system(qq{$(CI) @all});" \\
  	  -e "print(qq{Executing $(RCS_LABEL) ...\n}); system(qq{$(RCS_LABEL) @all});"
  };
  }
  
  =item dist_core (o)
  
    my $dist_make_fragment = $MM->dist_core;
  
  Puts the targets necessary for 'make dist' together into one make
  fragment.
  
  =cut
  
  sub dist_core {
      my($self) = shift;
  
      my $make_frag = '';
      foreach my $target (qw(dist tardist uutardist tarfile zipdist zipfile
                             shdist))
      {
          my $method = $target.'_target';
          $make_frag .= "\n";
          $make_frag .= $self->$method();
      }
  
      return $make_frag;
  }
  
  
  =item B<dist_target>
  
    my $make_frag = $MM->dist_target;
  
  Returns the 'dist' target to make an archive for distribution.  This
  target simply checks to make sure the Makefile is up-to-date and
  depends on $(DIST_DEFAULT).
  
  =cut
  
  sub dist_target {
      my($self) = shift;
  
      my $date_check = $self->oneliner(<<'CODE', ['-l']);
  print 'Warning: Makefile possibly out of date with $(VERSION_FROM)'
      if -e '$(VERSION_FROM)' and -M '$(VERSION_FROM)' < -M '$(FIRST_MAKEFILE)';
  CODE
  
      return sprintf <<'MAKE_FRAG', $date_check;
  dist : $(DIST_DEFAULT) $(FIRST_MAKEFILE)
  	$(NOECHO) %s
  MAKE_FRAG
  }
  
  =item B<tardist_target>
  
    my $make_frag = $MM->tardist_target;
  
  Returns the 'tardist' target which is simply so 'make tardist' works.
  The real work is done by the dynamically named tardistfile_target()
  method, tardist should have that as a dependency.
  
  =cut
  
  sub tardist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  tardist : $(DISTVNAME).tar$(SUFFIX)
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  }
  
  =item B<zipdist_target>
  
    my $make_frag = $MM->zipdist_target;
  
  Returns the 'zipdist' target which is simply so 'make zipdist' works.
  The real work is done by the dynamically named zipdistfile_target()
  method, zipdist should have that as a dependency.
  
  =cut
  
  sub zipdist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  zipdist : $(DISTVNAME).zip
  	$(NOECHO) $(NOOP)
  MAKE_FRAG
  }
  
  =item B<tarfile_target>
  
    my $make_frag = $MM->tarfile_target;
  
  The name of this target is the name of the tarball generated by
  tardist.  This target does the actual work of turning the distdir into
  a tarball.
  
  =cut
  
  sub tarfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
  	$(TAR) $(TARFLAGS) $(DISTVNAME).tar $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)'
  	$(POSTOP)
  MAKE_FRAG
  }
  
  =item zipfile_target
  
    my $make_frag = $MM->zipfile_target;
  
  The name of this target is the name of the zip file generated by
  zipdist.  This target does the actual work of turning the distdir into
  a zip file.
  
  =cut
  
  sub zipfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) $(ZIPFLAGS) $(DISTVNAME).zip $(DISTVNAME)
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).zip'
  	$(POSTOP)
  MAKE_FRAG
  }
  
  =item uutardist_target
  
    my $make_frag = $MM->uutardist_target;
  
  Converts the tarfile into a uuencoded file
  
  =cut
  
  sub uutardist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  uutardist : $(DISTVNAME).tar$(SUFFIX)
  	uuencode $(DISTVNAME).tar$(SUFFIX) $(DISTVNAME).tar$(SUFFIX) > $(DISTVNAME).tar$(SUFFIX)_uu
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).tar$(SUFFIX)_uu'
  MAKE_FRAG
  }
  
  
  =item shdist_target
  
    my $make_frag = $MM->shdist_target;
  
  Converts the distdir into a shell archive.
  
  =cut
  
  sub shdist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  shdist : distdir
  	$(PREOP)
  	$(SHAR) $(DISTVNAME) > $(DISTVNAME).shar
  	$(RM_RF) $(DISTVNAME)
  	$(NOECHO) $(ECHO) 'Created $(DISTVNAME).shar'
  	$(POSTOP)
  MAKE_FRAG
  }
  
  
  =item dlsyms (o)
  
  Used by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.
  
  Normally just returns an empty string.
  
  =cut
  
  sub dlsyms {
      return '';
  }
  
  
  =item dynamic_bs (o)
  
  Defines targets for bootstrap files.
  
  =cut
  
  sub dynamic_bs {
      my($self, %attribs) = @_;
      return '
  BOOTSTRAP =
  ' unless $self->has_link_code();
  
      my $target = $Is{VMS} ? '$(MMS$TARGET)' : '$@';
  
      return sprintf <<'MAKE_FRAG', ($target) x 2;
  BOOTSTRAP = $(BASEEXT).bs
  
  # As Mkbootstrap might not write a file (if none is required)
  # we use touch to prevent make continually trying to remake it.
  # The DynaLoader only reads a non-empty file.
  $(BOOTSTRAP) : $(FIRST_MAKEFILE) $(BOOTDEP) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(NOECHO) $(ECHO) "Running Mkbootstrap for $(NAME) ($(BSLOADLIBS))"
  	$(NOECHO) $(PERLRUN) \
  		"-MExtUtils::Mkbootstrap" \
  		-e "Mkbootstrap('$(BASEEXT)','$(BSLOADLIBS)');"
  	$(NOECHO) $(TOUCH) %s
  	$(CHMOD) $(PERM_RW) %s
  MAKE_FRAG
  }
  
  =item dynamic_lib (o)
  
  Defines how to produce the *.so (or equivalent) files.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      return '' unless $self->needs_linking(); #might be because of a subdir
  
      return '' unless $self->has_link_code;
  
      my($otherldflags) = $attribs{OTHERLDFLAGS} || "";
      my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
      my($armaybe) = $attribs{ARMAYBE} || $self->{ARMAYBE} || ":";
      my($ldfrom) = '$(LDFROM)';
      $armaybe = 'ar' if ($Is{OSF} and $armaybe eq ':');
      my(@m);
      my $ld_opt = $Is{OS2} ? '$(OPTIMIZE) ' : '';	# Useful on other systems too?
      my $ld_fix = $Is{OS2} ? '|| ( $(RM_F) $@ && sh -c false )' : '';
      push(@m,'
  # This section creates the dynamically loadable $(INST_DYNAMIC)
  # from $(OBJECT) and possibly $(MYEXTLIB).
  ARMAYBE = '.$armaybe.'
  OTHERLDFLAGS = '.$ld_opt.$otherldflags.'
  INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
  INST_DYNAMIC_FIX = '.$ld_fix.'
  
  $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
  ');
      if ($armaybe ne ':'){
  	$ldfrom = 'tmp$(LIB_EXT)';
  	push(@m,'	$(ARMAYBE) cr '.$ldfrom.' $(OBJECT)'."\n");
  	push(@m,'	$(RANLIB) '."$ldfrom\n");
      }
      $ldfrom = "-all $ldfrom -none" if $Is{OSF};
  
      # The IRIX linker doesn't use LD_RUN_PATH
      my $ldrun = $Is{IRIX} && $self->{LD_RUN_PATH} ?
                         qq{-rpath "$self->{LD_RUN_PATH}"} : '';
  
      # For example in AIX the shared objects/libraries from previous builds
      # linger quite a while in the shared dynalinker cache even when nobody
      # is using them.  This is painful if one for instance tries to restart
      # a failed build because the link command will fail unnecessarily 'cos
      # the shared object/library is 'busy'.
      push(@m,'	$(RM_F) $@
  ');
  
      my $libs = '$(LDLOADLIBS)';
  
      if (($Is{NetBSD} || $Is{Interix} || $Is{Android}) && $Config{'useshrplib'} eq 'true') {
  	# Use nothing on static perl platforms, and to the flags needed
  	# to link against the shared libperl library on shared perl
  	# platforms.  We peek at lddlflags to see if we need -Wl,-R
  	# or -R to add paths to the run-time library search path.
          if ($Config{'lddlflags'} =~ /-Wl,-R/) {
              $libs .= ' -L$(PERL_INC) -Wl,-R$(INSTALLARCHLIB)/CORE -Wl,-R$(PERL_ARCHLIB)/CORE -lperl';
          } elsif ($Config{'lddlflags'} =~ /-R/) {
              $libs .= ' -L$(PERL_INC) -R$(INSTALLARCHLIB)/CORE -R$(PERL_ARCHLIB)/CORE -lperl';
          } elsif ( $Is{Android} ) {
              # The Android linker will not recognize symbols from
              # libperl unless the module explicitly depends on it.
              $libs .= ' -L$(PERL_INC) -lperl';
          }
      }
  
      my $ld_run_path_shell = "";
      if ($self->{LD_RUN_PATH} ne "") {
  	$ld_run_path_shell = 'LD_RUN_PATH="$(LD_RUN_PATH)" ';
      }
  
      push @m, sprintf <<'MAKE', $ld_run_path_shell, $ldrun, $ldfrom, $libs;
  	%s$(LD) %s $(LDDLFLAGS) %s $(OTHERLDFLAGS) -o $@ $(MYEXTLIB)	\
  	  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)	\
  	  $(INST_DYNAMIC_FIX)
  MAKE
  
      push @m, <<'MAKE';
  	$(CHMOD) $(PERM_RWX) $@
  	$(NOECHO) $(RM_RF) $(BOOTSTRAP)
  	- $(CP_NONEMPTY) $(BOOTSTRAP) $(INST_BOOT) $(PERM_RW)
  MAKE
  
      return join('',@m);
  }
  
  =item exescan
  
  Deprecated method. Use libscan instead.
  
  =cut
  
  sub exescan {
      my($self,$path) = @_;
      $path;
  }
  
  =item extliblist
  
  Called by init_others, and calls ext ExtUtils::Liblist. See
  L<ExtUtils::Liblist> for details.
  
  =cut
  
  sub extliblist {
      my($self,$libs) = @_;
      require ExtUtils::Liblist;
      $self->ext($libs, $Verbose);
  }
  
  =item find_perl
  
  Finds the executables PERL and FULLPERL
  
  =cut
  
  sub find_perl {
      my($self, $ver, $names, $dirs, $trace) = @_;
  
      if ($trace >= 2){
          print "Looking for perl $ver by these names:
  @$names
  in these dirs:
  @$dirs
  ";
      }
  
      my $stderr_duped = 0;
      local *STDERR_COPY;
  
      unless ($Is{BSD}) {
          # >& and lexical filehandles together give 5.6.2 indigestion
          if( open(STDERR_COPY, '>&STDERR') ) {  ## no critic
              $stderr_duped = 1;
          }
          else {
              warn <<WARNING;
  find_perl() can't dup STDERR: $!
  You might see some garbage while we search for Perl
  WARNING
          }
      }
  
      foreach my $name (@$names){
          foreach my $dir (@$dirs){
              next unless defined $dir; # $self->{PERL_SRC} may be undefined
              my ($abs, $val);
              if ($self->file_name_is_absolute($name)) {     # /foo/bar
                  $abs = $name;
              } elsif ($self->canonpath($name) eq
                       $self->canonpath(basename($name))) {  # foo
                  $abs = $self->catfile($dir, $name);
              } else {                                            # foo/bar
                  $abs = $self->catfile($Curdir, $name);
              }
              print "Checking $abs\n" if ($trace >= 2);
              next unless $self->maybe_command($abs);
              print "Executing $abs\n" if ($trace >= 2);
  
              my $version_check = qq{$abs -le "require $ver; print qq{VER_OK}"};
  
              # To avoid using the unportable 2>&1 to suppress STDERR,
              # we close it before running the command.
              # However, thanks to a thread library bug in many BSDs
              # ( http://www.freebsd.org/cgi/query-pr.cgi?pr=51535 )
              # we cannot use the fancier more portable way in here
              # but instead need to use the traditional 2>&1 construct.
              if ($Is{BSD}) {
                  $val = `$version_check 2>&1`;
              } else {
                  close STDERR if $stderr_duped;
                  $val = `$version_check`;
  
                  # 5.6.2's 3-arg open doesn't work with >&
                  open STDERR, ">&STDERR_COPY"  ## no critic
                          if $stderr_duped;
              }
  
              if ($val =~ /^VER_OK/m) {
                  print "Using PERL=$abs\n" if $trace;
                  return $abs;
              } elsif ($trace >= 2) {
                  print "Result: '$val' ".($? >> 8)."\n";
              }
          }
      }
      print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";
      0; # false and not empty
  }
  
  
  =item fixin
  
    $mm->fixin(@files);
  
  Inserts the sharpbang or equivalent magic number to a set of @files.
  
  =cut
  
  sub fixin {    # stolen from the pink Camel book, more or less
      my ( $self, @files ) = @_;
  
      for my $file (@files) {
          my $file_new = "$file.new";
          my $file_bak = "$file.bak";
  
          open( my $fixin, '<', $file ) or croak "Can't process '$file': $!";
          local $/ = "\n";
          chomp( my $line = <$fixin> );
          next unless $line =~ s/^\s*\#!\s*//;    # Not a shebang file.
  
          my $shb = $self->_fixin_replace_shebang( $file, $line );
          next unless defined $shb;
  
          open( my $fixout, ">", "$file_new" ) or do {
              warn "Can't create new $file: $!\n";
              next;
          };
  
          # Print out the new #! line (or equivalent).
          local $\;
          local $/;
          print $fixout $shb, <$fixin>;
          close $fixin;
          close $fixout;
  
          chmod 0666, $file_bak;
          unlink $file_bak;
          unless ( _rename( $file, $file_bak ) ) {
              warn "Can't rename $file to $file_bak: $!";
              next;
          }
          unless ( _rename( $file_new, $file ) ) {
              warn "Can't rename $file_new to $file: $!";
              unless ( _rename( $file_bak, $file ) ) {
                  warn "Can't rename $file_bak back to $file either: $!";
                  warn "Leaving $file renamed as $file_bak\n";
              }
              next;
          }
          unlink $file_bak;
      }
      continue {
          system("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
      }
  }
  
  
  sub _rename {
      my($old, $new) = @_;
  
      foreach my $file ($old, $new) {
          if( $Is{VMS} and basename($file) !~ /\./ ) {
              # rename() in 5.8.0 on VMS will not rename a file if it
              # does not contain a dot yet it returns success.
              $file = "$file.";
          }
      }
  
      return rename($old, $new);
  }
  
  sub _fixin_replace_shebang {
      my ( $self, $file, $line ) = @_;
  
      # Now figure out the interpreter name.
      my ( $cmd, $arg ) = split ' ', $line, 2;
      $cmd =~ s!^.*/!!;
  
      # Now look (in reverse) for interpreter in absolute PATH (unless perl).
      my $interpreter;
      if ( $cmd =~ m{^perl(?:\z|[^a-z])} ) {
          if ( $Config{startperl} =~ m,^\#!.*/perl, ) {
              $interpreter = $Config{startperl};
              $interpreter =~ s,^\#!,,;
          }
          else {
              $interpreter = $Config{perlpath};
          }
      }
      else {
          my (@absdirs)
              = reverse grep { $self->file_name_is_absolute($_) } $self->path;
          $interpreter = '';
  
           foreach my $dir (@absdirs) {
              if ( $self->maybe_command($cmd) ) {
                  warn "Ignoring $interpreter in $file\n"
                      if $Verbose && $interpreter;
                  $interpreter = $self->catfile( $dir, $cmd );
              }
          }
      }
  
      # Figure out how to invoke interpreter on this machine.
  
      my ($does_shbang) = $Config{'sharpbang'} =~ /^\s*\#\!/;
      my ($shb) = "";
      if ($interpreter) {
          print "Changing sharpbang in $file to $interpreter"
              if $Verbose;
           # this is probably value-free on DOSISH platforms
          if ($does_shbang) {
              $shb .= "$Config{'sharpbang'}$interpreter";
              $shb .= ' ' . $arg if defined $arg;
              $shb .= "\n";
          }
          $shb .= qq{
  eval 'exec $interpreter $arg -S \$0 \${1+"\$\@"}'
      if 0; # not running under some shell
  } unless $Is{Win32};    # this won't work on win32, so don't
      }
      else {
          warn "Can't find $cmd in PATH, $file unchanged"
              if $Verbose;
          return;
      }
      return $shb
  }
  
  =item force (o)
  
  Writes an empty FORCE: target.
  
  =cut
  
  sub force {
      my($self) = shift;
      '# Phony target to force checking subdirectories.
  FORCE :
  	$(NOECHO) $(NOOP)
  ';
  }
  
  =item guess_name
  
  Guess the name of this package by examining the working directory's
  name. MakeMaker calls this only if the developer has not supplied a
  NAME attribute.
  
  =cut
  
  # ';
  
  sub guess_name {
      my($self) = @_;
      use Cwd 'cwd';
      my $name = basename(cwd());
      $name =~ s|[\-_][\d\.\-]+\z||;  # this is new with MM 5.00, we
                                      # strip minus or underline
                                      # followed by a float or some such
      print "Warning: Guessing NAME [$name] from current directory name.\n";
      $name;
  }
  
  =item has_link_code
  
  Returns true if C, XS, MYEXTLIB or similar objects exist within this
  object that need a compiler. Does not descend into subdirectories as
  needs_linking() does.
  
  =cut
  
  sub has_link_code {
      my($self) = shift;
      return $self->{HAS_LINK_CODE} if defined $self->{HAS_LINK_CODE};
      if ($self->{OBJECT} or @{$self->{C} || []} or $self->{MYEXTLIB}){
  	$self->{HAS_LINK_CODE} = 1;
  	return 1;
      }
      return $self->{HAS_LINK_CODE} = 0;
  }
  
  
  =item init_dirscan
  
  Scans the directory structure and initializes DIR, XS, XS_FILES,
  C, C_FILES, O_FILES, H, H_FILES, PL_FILES, EXE_FILES.
  
  Called by init_main.
  
  =cut
  
  sub init_dirscan {	# --- File and Directory Lists (.xs .pm .pod etc)
      my($self) = @_;
      my(%dir, %xs, %c, %o, %h, %pl_files, %pm);
  
      my %ignore = map {( $_ => 1 )} qw(Makefile.PL Build.PL test.pl t);
  
      # ignore the distdir
      $Is{VMS} ? $ignore{"$self->{DISTVNAME}.dir"} = 1
              : $ignore{$self->{DISTVNAME}} = 1;
  
      my $distprefix = $Is{VMS} ? qr/^\Q$self->{DISTNAME}\E-.*\.dir$/i
                                : qr/^\Q$self->{DISTNAME}-/;
  
      @ignore{map lc, keys %ignore} = values %ignore if $Is{VMS};
  
      if ( defined $self->{XS} and !defined $self->{C} ) {
  	my @c_files = grep { m/\.c(pp|xx)?\z/i } values %{$self->{XS}};
  	my @o_files = grep { m/(?:.(?:o(?:bj)?)|\$\(OBJ_EXT\))\z/i } values %{$self->{XS}};
  	%c = map { $_ => 1 } @c_files;
  	%o = map { $_ => 1 } @o_files;
      }
  
      foreach my $name ($self->lsdir($Curdir)){
  	next if $name =~ /\#/;
  	next if $name =~ $distprefix;
  	$name = lc($name) if $Is{VMS};
  	next if $name eq $Curdir or $name eq $Updir or $ignore{$name};
  	next unless $self->libscan($name);
  	if (-d $name){
  	    next if -l $name; # We do not support symlinks at all
              next if $self->{NORECURS};
  	    $dir{$name} = $name if (-f $self->catfile($name,"Makefile.PL"));
  	} elsif ($name =~ /\.xs\z/){
  	    my($c); ($c = $name) =~ s/\.xs\z/.c/;
  	    $xs{$name} = $c;
  	    $c{$c} = 1;
  	} elsif ($name =~ /\.c(pp|xx|c)?\z/i){  # .c .C .cpp .cxx .cc
  	    $c{$name} = 1
  		unless $name =~ m/perlmain\.c/; # See MAP_TARGET
  	} elsif ($name =~ /\.h\z/i){
  	    $h{$name} = 1;
  	} elsif ($name =~ /\.PL\z/) {
  	    ($pl_files{$name} = $name) =~ s/\.PL\z// ;
  	} elsif (($Is{VMS} || $Is{Dos}) && $name =~ /[._]pl$/i) {
  	    # case-insensitive filesystem, one dot per name, so foo.h.PL
  	    # under Unix appears as foo.h_pl under VMS or fooh.pl on Dos
  	    local($/); open(my $pl, '<', $name); my $txt = <$pl>; close $pl;
  	    if ($txt =~ /Extracting \S+ \(with variable substitutions/) {
  		($pl_files{$name} = $name) =~ s/[._]pl\z//i ;
  	    }
  	    else {
                  $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);
              }
  	} elsif ($name =~ /\.(p[ml]|pod)\z/){
  	    $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);
  	}
      }
  
      $self->{PL_FILES}   ||= \%pl_files;
      $self->{DIR}        ||= [sort keys %dir];
      $self->{XS}         ||= \%xs;
      $self->{C}          ||= [sort keys %c];
      $self->{H}          ||= [sort keys %h];
      $self->{PM}         ||= \%pm;
  
      my @o_files = @{$self->{C}};
      %o = (%o, map { $_ => 1 } grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i, @o_files);
      $self->{O_FILES} = [sort keys %o];
  }
  
  
  =item init_MANPODS
  
  Determines if man pages should be generated and initializes MAN1PODS
  and MAN3PODS as appropriate.
  
  =cut
  
  sub init_MANPODS {
      my $self = shift;
  
      # Set up names of manual pages to generate from pods
      foreach my $man (qw(MAN1 MAN3)) {
          if ( $self->{"${man}PODS"}
               or $self->{"INSTALL${man}DIR"} =~ /^(none|\s*)$/
          ) {
              $self->{"${man}PODS"} ||= {};
          }
          else {
              my $init_method = "init_${man}PODS";
              $self->$init_method();
          }
      }
  }
  
  
  sub _has_pod {
      my($self, $file) = @_;
  
      my($ispod)=0;
      if (open( my $fh, '<', $file )) {
          while (<$fh>) {
              if (/^=(?:head\d+|item|pod)\b/) {
                  $ispod=1;
                  last;
              }
          }
          close $fh;
      } else {
          # If it doesn't exist yet, we assume, it has pods in it
          $ispod = 1;
      }
  
      return $ispod;
  }
  
  
  =item init_MAN1PODS
  
  Initializes MAN1PODS from the list of EXE_FILES.
  
  =cut
  
  sub init_MAN1PODS {
      my($self) = @_;
  
      if ( exists $self->{EXE_FILES} ) {
  	foreach my $name (@{$self->{EXE_FILES}}) {
  	    next unless $self->_has_pod($name);
  
  	    $self->{MAN1PODS}->{$name} =
  		$self->catfile("\$(INST_MAN1DIR)",
  			       basename($name).".\$(MAN1EXT)");
  	}
      }
  }
  
  
  =item init_MAN3PODS
  
  Initializes MAN3PODS from the list of PM files.
  
  =cut
  
  sub init_MAN3PODS {
      my $self = shift;
  
      my %manifypods = (); # we collect the keys first, i.e. the files
                           # we have to convert to pod
  
      foreach my $name (keys %{$self->{PM}}) {
  	if ($name =~ /\.pod\z/ ) {
  	    $manifypods{$name} = $self->{PM}{$name};
  	} elsif ($name =~ /\.p[ml]\z/ ) {
  	    if( $self->_has_pod($name) ) {
  		$manifypods{$name} = $self->{PM}{$name};
  	    }
  	}
      }
  
      my $parentlibs_re = join '|', @{$self->{PMLIBPARENTDIRS}};
  
      # Remove "Configure.pm" and similar, if it's not the only pod listed
      # To force inclusion, just name it "Configure.pod", or override
      # MAN3PODS
      foreach my $name (keys %manifypods) {
  	if ($self->{PERL_CORE} and $name =~ /(config|setup).*\.pm/is) {
  	    delete $manifypods{$name};
  	    next;
  	}
  	my($manpagename) = $name;
  	$manpagename =~ s/\.p(od|m|l)\z//;
  	# everything below lib is ok
  	unless($manpagename =~ s!^\W*($parentlibs_re)\W+!!s) {
  	    $manpagename = $self->catfile(
  	        split(/::/,$self->{PARENT_NAME}),$manpagename
  	    );
  	}
  	$manpagename = $self->replace_manpage_separator($manpagename);
  	$self->{MAN3PODS}->{$name} =
  	    $self->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
      }
  }
  
  
  =item init_PM
  
  Initializes PMLIBDIRS and PM from PMLIBDIRS.
  
  =cut
  
  sub init_PM {
      my $self = shift;
  
      # Some larger extensions often wish to install a number of *.pm/pl
      # files into the library in various locations.
  
      # The attribute PMLIBDIRS holds an array reference which lists
      # subdirectories which we should search for library files to
      # install. PMLIBDIRS defaults to [ 'lib', $self->{BASEEXT} ].  We
      # recursively search through the named directories (skipping any
      # which don't exist or contain Makefile.PL files).
  
      # For each *.pm or *.pl file found $self->libscan() is called with
      # the default installation path in $_[1]. The return value of
      # libscan defines the actual installation location.  The default
      # libscan function simply returns the path.  The file is skipped
      # if libscan returns false.
  
      # The default installation location passed to libscan in $_[1] is:
      #
      #  ./*.pm		=> $(INST_LIBDIR)/*.pm
      #  ./xyz/...	=> $(INST_LIBDIR)/xyz/...
      #  ./lib/...	=> $(INST_LIB)/...
      #
      # In this way the 'lib' directory is seen as the root of the actual
      # perl library whereas the others are relative to INST_LIBDIR
      # (which includes PARENT_NAME). This is a subtle distinction but one
      # that's important for nested modules.
  
      unless( $self->{PMLIBDIRS} ) {
          if( $Is{VMS} ) {
              # Avoid logical name vs directory collisions
              $self->{PMLIBDIRS} = ['./lib', "./$self->{BASEEXT}"];
          }
          else {
              $self->{PMLIBDIRS} = ['lib', $self->{BASEEXT}];
          }
      }
  
      #only existing directories that aren't in $dir are allowed
  
      # Avoid $_ wherever possible:
      # @{$self->{PMLIBDIRS}} = grep -d && !$dir{$_}, @{$self->{PMLIBDIRS}};
      my (@pmlibdirs) = @{$self->{PMLIBDIRS}};
      @{$self->{PMLIBDIRS}} = ();
      my %dir = map { ($_ => $_) } @{$self->{DIR}};
      foreach my $pmlibdir (@pmlibdirs) {
  	-d $pmlibdir && !$dir{$pmlibdir} && push @{$self->{PMLIBDIRS}}, $pmlibdir;
      }
  
      unless( $self->{PMLIBPARENTDIRS} ) {
  	@{$self->{PMLIBPARENTDIRS}} = ('lib');
      }
  
      return if $self->{PM} and $self->{ARGS}{PM};
  
      if (@{$self->{PMLIBDIRS}}){
  	print "Searching PMLIBDIRS: @{$self->{PMLIBDIRS}}\n"
  	    if ($Verbose >= 2);
  	require File::Find;
          File::Find::find(sub {
              if (-d $_){
                  unless ($self->libscan($_)){
                      $File::Find::prune = 1;
                  }
                  return;
              }
              return if /\#/;
              return if /~$/;             # emacs temp files
              return if /,v$/;            # RCS files
              return if m{\.swp$};        # vim swap files
  
  	    my $path   = $File::Find::name;
              my $prefix = $self->{INST_LIBDIR};
              my $striplibpath;
  
  	    my $parentlibs_re = join '|', @{$self->{PMLIBPARENTDIRS}};
  	    $prefix =  $self->{INST_LIB}
                  if ($striplibpath = $path) =~ s{^(\W*)($parentlibs_re)\W}
  	                                       {$1}i;
  
  	    my($inst) = $self->catfile($prefix,$striplibpath);
  	    local($_) = $inst; # for backwards compatibility
  	    $inst = $self->libscan($inst);
  	    print "libscan($path) => '$inst'\n" if ($Verbose >= 2);
  	    return unless $inst;
  	    $self->{PM}{$path} = $inst;
  	}, @{$self->{PMLIBDIRS}});
      }
  }
  
  
  =item init_DIRFILESEP
  
  Using / for Unix.  Called by init_main.
  
  =cut
  
  sub init_DIRFILESEP {
      my($self) = shift;
  
      $self->{DIRFILESEP} = '/';
  }
  
  
  =item init_main
  
  Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE,
  EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*,
  INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME,
  OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB,
  PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION,
  VERSION_SYM, XS_VERSION.
  
  =cut
  
  sub init_main {
      my($self) = @_;
  
      # --- Initialize Module Name and Paths
  
      # NAME    = Foo::Bar::Oracle
      # FULLEXT = Foo/Bar/Oracle
      # BASEEXT = Oracle
      # PARENT_NAME = Foo::Bar
  ### Only UNIX:
  ###    ($self->{FULLEXT} =
  ###     $self->{NAME}) =~ s!::!/!g ; #eg. BSD/Foo/Socket
      $self->{FULLEXT} = $self->catdir(split /::/, $self->{NAME});
  
  
      # Copied from DynaLoader:
  
      my(@modparts) = split(/::/,$self->{NAME});
      my($modfname) = $modparts[-1];
  
      # Some systems have restrictions on files names for DLL's etc.
      # mod2fname returns appropriate file base name (typically truncated)
      # It may also edit @modparts if required.
      # We require DynaLoader to make sure that mod2fname is loaded
      eval { require DynaLoader };
      if (defined &DynaLoader::mod2fname) {
          $modfname = &DynaLoader::mod2fname(\@modparts);
      }
  
      ($self->{PARENT_NAME}, $self->{BASEEXT}) = $self->{NAME} =~ m!(?:([\w:]+)::)?(\w+)\z! ;
      $self->{PARENT_NAME} ||= '';
  
      if (defined &DynaLoader::mod2fname) {
  	# As of 5.001m, dl_os2 appends '_'
  	$self->{DLBASE} = $modfname;
      } else {
  	$self->{DLBASE} = '$(BASEEXT)';
      }
  
  
      # --- Initialize PERL_LIB, PERL_SRC
  
      # *Real* information: where did we get these two from? ...
      my $inc_config_dir = dirname($INC{'Config.pm'});
      my $inc_carp_dir   = dirname($INC{'Carp.pm'});
  
      unless ($self->{PERL_SRC}){
          foreach my $dir_count (1..8) { # 8 is the VMS limit for nesting
              my $dir = $self->catdir(($Updir) x $dir_count);
  
              if (-f $self->catfile($dir,"config_h.SH")   &&
                  -f $self->catfile($dir,"perl.h")        &&
                  -f $self->catfile($dir,"lib","strict.pm")
              ) {
                  $self->{PERL_SRC}=$dir ;
                  last;
              }
          }
      }
  
      warn "PERL_CORE is set but I can't find your PERL_SRC!\n" if
        $self->{PERL_CORE} and !$self->{PERL_SRC};
  
      if ($self->{PERL_SRC}){
  	$self->{PERL_LIB}     ||= $self->catdir("$self->{PERL_SRC}","lib");
  
          $self->{PERL_ARCHLIB} = $self->{PERL_LIB};
          $self->{PERL_INC}     = ($Is{Win32}) ?
              $self->catdir($self->{PERL_LIB},"CORE") : $self->{PERL_SRC};
  
  	# catch a situation that has occurred a few times in the past:
  	unless (
  		-s $self->catfile($self->{PERL_SRC},'cflags')
  		or
  		$Is{VMS}
  		&&
  		-s $self->catfile($self->{PERL_SRC},'vmsish.h')
  		or
  		$Is{Win32}
  	       ){
  	    warn qq{
  You cannot build extensions below the perl source tree after executing
  a 'make clean' in the perl source tree.
  
  To rebuild extensions distributed with the perl source you should
  simply Configure (to include those extensions) and then build perl as
  normal. After installing perl the source tree can be deleted. It is
  not needed for building extensions by running 'perl Makefile.PL'
  usually without extra arguments.
  
  It is recommended that you unpack and build additional extensions away
  from the perl source tree.
  };
  	}
      } else {
  	# we should also consider $ENV{PERL5LIB} here
          my $old = $self->{PERL_LIB} || $self->{PERL_ARCHLIB} || $self->{PERL_INC};
  	$self->{PERL_LIB}     ||= $Config{privlibexp};
  	$self->{PERL_ARCHLIB} ||= $Config{archlibexp};
  	$self->{PERL_INC}     = $self->catdir("$self->{PERL_ARCHLIB}","CORE"); # wild guess for now
  	my $perl_h;
  
  	if (not -f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h"))
  	    and not $old){
  	    # Maybe somebody tries to build an extension with an
  	    # uninstalled Perl outside of Perl build tree
  	    my $lib;
  	    for my $dir (@INC) {
  	      $lib = $dir, last if -e $self->catfile($dir, "Config.pm");
  	    }
  	    if ($lib) {
                # Win32 puts its header files in /perl/src/lib/CORE.
                # Unix leaves them in /perl/src.
  	      my $inc = $Is{Win32} ? $self->catdir($lib, "CORE" )
                                    : dirname $lib;
  	      if (-e $self->catfile($inc, "perl.h")) {
  		$self->{PERL_LIB}	   = $lib;
  		$self->{PERL_ARCHLIB}	   = $lib;
  		$self->{PERL_INC}	   = $inc;
  		$self->{UNINSTALLED_PERL}  = 1;
  		print <<EOP;
  ... Detected uninstalled Perl.  Trying to continue.
  EOP
  	      }
  	    }
  	}
      }
  
      if ($Is{Android}) {
      	# Android fun times!
      	# ../../perl -I../../lib -MFile::Glob -e1 works
      	# ../../../perl -I../../../lib -MFile::Glob -e1 fails to find
      	# the .so for File::Glob.
      	# This always affects core perl, but may also affect an installed
      	# perl built with -Duserelocatableinc.
      	$self->{PERL_LIB} = File::Spec->rel2abs($self->{PERL_LIB});
      	$self->{PERL_ARCHLIB} = File::Spec->rel2abs($self->{PERL_ARCHLIB});
      }
  
      # We get SITELIBEXP and SITEARCHEXP directly via
      # Get_from_Config. When we are running standard modules, these
      # won't matter, we will set INSTALLDIRS to "perl". Otherwise we
      # set it to "site". I prefer that INSTALLDIRS be set from outside
      # MakeMaker.
      $self->{INSTALLDIRS} ||= "site";
  
      $self->{MAN1EXT} ||= $Config{man1ext};
      $self->{MAN3EXT} ||= $Config{man3ext};
  
      # Get some stuff out of %Config if we haven't yet done so
      print "CONFIG must be an array ref\n"
          if ($self->{CONFIG} and ref $self->{CONFIG} ne 'ARRAY');
      $self->{CONFIG} = [] unless (ref $self->{CONFIG});
      push(@{$self->{CONFIG}}, @ExtUtils::MakeMaker::Get_from_Config);
      push(@{$self->{CONFIG}}, 'shellflags') if $Config{shellflags};
      my(%once_only);
      foreach my $m (@{$self->{CONFIG}}){
          next if $once_only{$m};
          print "CONFIG key '$m' does not exist in Config.pm\n"
                  unless exists $Config{$m};
          $self->{uc $m} ||= $Config{$m};
          $once_only{$m} = 1;
      }
  
  # This is too dangerous:
  #    if ($^O eq "next") {
  #	$self->{AR} = "libtool";
  #	$self->{AR_STATIC_ARGS} = "-o";
  #    }
  # But I leave it as a placeholder
  
      $self->{AR_STATIC_ARGS} ||= "cr";
  
      # These should never be needed
      $self->{OBJ_EXT} ||= '.o';
      $self->{LIB_EXT} ||= '.a';
  
      $self->{MAP_TARGET} ||= "perl";
  
      $self->{LIBPERL_A} ||= "libperl$self->{LIB_EXT}";
  
      # make a simple check if we find strict
      warn "Warning: PERL_LIB ($self->{PERL_LIB}) seems not to be a perl library directory
          (strict.pm not found)"
          unless -f $self->catfile("$self->{PERL_LIB}","strict.pm") ||
                 $self->{NAME} eq "ExtUtils::MakeMaker";
  }
  
  =item init_tools
  
  Initializes tools to use their common (and faster) Unix commands.
  
  =cut
  
  sub init_tools {
      my $self = shift;
  
      $self->{ECHO}       ||= 'echo';
      $self->{ECHO_N}     ||= 'echo -n';
      $self->{RM_F}       ||= "rm -f";
      $self->{RM_RF}      ||= "rm -rf";
      $self->{TOUCH}      ||= "touch";
      $self->{TEST_F}     ||= "test -f";
      $self->{TEST_S}     ||= "test -s";
      $self->{CP}         ||= "cp";
      $self->{MV}         ||= "mv";
      $self->{CHMOD}      ||= "chmod";
      $self->{FALSE}      ||= 'false';
      $self->{TRUE}       ||= 'true';
  
      $self->{LD}         ||= 'ld';
  
      return $self->SUPER::init_tools(@_);
  
      # After SUPER::init_tools so $Config{shell} has a
      # chance to get set.
      $self->{SHELL}      ||= '/bin/sh';
  
      return;
  }
  
  
  =item init_linker
  
  Unix has no need of special linker flags.
  
  =cut
  
  sub init_linker {
      my($self) = shift;
      $self->{PERL_ARCHIVE} ||= '';
      $self->{PERL_ARCHIVE_AFTER} ||= '';
      $self->{EXPORT_LIST}  ||= '';
  }
  
  
  =begin _protected
  
  =item init_lib2arch
  
      $mm->init_lib2arch
  
  =end _protected
  
  =cut
  
  sub init_lib2arch {
      my($self) = shift;
  
      # The user who requests an installation directory explicitly
      # should not have to tell us an architecture installation directory
      # as well. We look if a directory exists that is named after the
      # architecture. If not we take it as a sign that it should be the
      # same as the requested installation directory. Otherwise we take
      # the found one.
      for my $libpair ({l=>"privlib",   a=>"archlib"},
                       {l=>"sitelib",   a=>"sitearch"},
                       {l=>"vendorlib", a=>"vendorarch"},
                      )
      {
          my $lib = "install$libpair->{l}";
          my $Lib = uc $lib;
          my $Arch = uc "install$libpair->{a}";
          if( $self->{$Lib} && ! $self->{$Arch} ){
              my($ilib) = $Config{$lib};
  
              $self->prefixify($Arch,$ilib,$self->{$Lib});
  
              unless (-d $self->{$Arch}) {
                  print "Directory $self->{$Arch} not found\n"
                    if $Verbose;
                  $self->{$Arch} = $self->{$Lib};
              }
              print "Defaulting $Arch to $self->{$Arch}\n" if $Verbose;
          }
      }
  }
  
  
  =item init_PERL
  
      $mm->init_PERL;
  
  Called by init_main.  Sets up ABSPERL, PERL, FULLPERL and all the
  *PERLRUN* permutations.
  
      PERL is allowed to be miniperl
      FULLPERL must be a complete perl
  
      ABSPERL is PERL converted to an absolute path
  
      *PERLRUN contains everything necessary to run perl, find it's
           libraries, etc...
  
      *PERLRUNINST is *PERLRUN + everything necessary to find the
           modules being built.
  
  =cut
  
  sub init_PERL {
      my($self) = shift;
  
      my @defpath = ();
      foreach my $component ($self->{PERL_SRC}, $self->path(),
                             $Config{binexp})
      {
  	push @defpath, $component if defined $component;
      }
  
      # Build up a set of file names (not command names).
      my $thisperl = $self->canonpath($^X);
      $thisperl .= $Config{exe_ext} unless
                  # VMS might have a file version # at the end
        $Is{VMS} ? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i
                : $thisperl =~ m/$Config{exe_ext}$/i;
  
      # We need a relative path to perl when in the core.
      $thisperl = $self->abs2rel($thisperl) if $self->{PERL_CORE};
  
      my @perls = ($thisperl);
      push @perls, map { "$_$Config{exe_ext}" }
                       ("perl$Config{version}", 'perl5', 'perl');
  
      # miniperl has priority over all but the canonical perl when in the
      # core.  Otherwise its a last resort.
      my $miniperl = "miniperl$Config{exe_ext}";
      if( $self->{PERL_CORE} ) {
          splice @perls, 1, 0, $miniperl;
      }
      else {
          push @perls, $miniperl;
      }
  
      $self->{PERL} ||=
          $self->find_perl(5.0, \@perls, \@defpath, $Verbose );
      # don't check if perl is executable, maybe they have decided to
      # supply switches with perl
  
      # When built for debugging, VMS doesn't create perl.exe but ndbgperl.exe.
      my $perl_name = 'perl';
      $perl_name = 'ndbgperl' if $Is{VMS} &&
        defined $Config{usevmsdebug} && $Config{usevmsdebug} eq 'define';
  
      # XXX This logic is flawed.  If "miniperl" is anywhere in the path
      # it will get confused.  It should be fixed to work only on the filename.
      # Define 'FULLPERL' to be a non-miniperl (used in test: target)
      ($self->{FULLPERL} = $self->{PERL}) =~ s/\Q$miniperl\E$/$perl_name$Config{exe_ext}/i
  	unless $self->{FULLPERL};
  
      # Little hack to get around VMS's find_perl putting "MCR" in front
      # sometimes.
      $self->{ABSPERL} = $self->{PERL};
      my $has_mcr = $self->{ABSPERL} =~ s/^MCR\s*//;
      if( $self->file_name_is_absolute($self->{ABSPERL}) ) {
          $self->{ABSPERL} = '$(PERL)';
      }
      else {
          $self->{ABSPERL} = $self->rel2abs($self->{ABSPERL});
  
          # Quote the perl command if it contains whitespace
          $self->{ABSPERL} = $self->quote_literal($self->{ABSPERL})
            if $self->{ABSPERL} =~ /\s/;
  
          $self->{ABSPERL} = 'MCR '.$self->{ABSPERL} if $has_mcr;
      }
  
      # Are we building the core?
      $self->{PERL_CORE} = $ENV{PERL_CORE} unless exists $self->{PERL_CORE};
      $self->{PERL_CORE} = 0               unless defined $self->{PERL_CORE};
  
      # How do we run perl?
      foreach my $perl (qw(PERL FULLPERL ABSPERL)) {
          my $run  = $perl.'RUN';
  
          $self->{$run}  = "\$($perl)";
  
          # Make sure perl can find itself before it's installed.
          $self->{$run} .= q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"}
            if $self->{UNINSTALLED_PERL} || $self->{PERL_CORE};
  
          $self->{$perl.'RUNINST'} =
            sprintf q{$(%sRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"}, $perl;
      }
  
      return 1;
  }
  
  
  =item init_platform
  
  =item platform_constants
  
  Add MM_Unix_VERSION.
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      $self->{MM_Unix_VERSION} = $VERSION;
      $self->{PERL_MALLOC_DEF} = '-DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc '.
                                 '-Dfree=Perl_mfree -Drealloc=Perl_realloc '.
                                 '-Dcalloc=Perl_calloc';
  
  }
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      foreach my $macro (qw(MM_Unix_VERSION PERL_MALLOC_DEF))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item init_PERM
  
    $mm->init_PERM
  
  Called by init_main.  Initializes PERL_*
  
  =cut
  
  sub init_PERM {
      my($self) = shift;
  
      $self->{PERM_DIR} = 755  unless defined $self->{PERM_DIR};
      $self->{PERM_RW}  = 644  unless defined $self->{PERM_RW};
      $self->{PERM_RWX} = 755  unless defined $self->{PERM_RWX};
  
      return 1;
  }
  
  
  =item init_xs
  
      $mm->init_xs
  
  Sets up macros having to do with XS code.  Currently just INST_STATIC,
  INST_DYNAMIC and INST_BOOT.
  
  =cut
  
  sub init_xs {
      my $self = shift;
  
      if ($self->has_link_code()) {
          $self->{INST_STATIC}  =
            $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT)$(LIB_EXT)');
          $self->{INST_DYNAMIC} =
            $self->catfile('$(INST_ARCHAUTODIR)', '$(DLBASE).$(DLEXT)');
          $self->{INST_BOOT}    =
            $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT).bs');
      } else {
          $self->{INST_STATIC}  = '';
          $self->{INST_DYNAMIC} = '';
          $self->{INST_BOOT}    = '';
      }
  }
  
  =item install (o)
  
  Defines the install target.
  
  =cut
  
  sub install {
      my($self, %attribs) = @_;
      my(@m);
  
      push @m, q{
  install :: pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  install_vendor :: pure_vendor_install doc_vendor_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
  
  pure_perl_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };
  
      push @m,
  q{		read }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
  		write }.$self->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
  } unless $self->{NO_PACKLIST};
  
      push @m,
  q{		$(INST_LIB) $(DESTINSTALLPRIVLIB) \
  		$(INST_ARCHLIB) $(DESTINSTALLARCHLIB) \
  		$(INST_BIN) $(DESTINSTALLBIN) \
  		$(INST_SCRIPT) $(DESTINSTALLSCRIPT) \
  		$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) \
  		$(INST_MAN3DIR) $(DESTINSTALLMAN3DIR)
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{
  
  
  pure_site_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };
      push @m,
  q{		read }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
  		write }.$self->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{ \
  } unless $self->{NO_PACKLIST};
  
      push @m,
  q{		$(INST_LIB) $(DESTINSTALLSITELIB) \
  		$(INST_ARCHLIB) $(DESTINSTALLSITEARCH) \
  		$(INST_BIN) $(DESTINSTALLSITEBIN) \
  		$(INST_SCRIPT) $(DESTINSTALLSITESCRIPT) \
  		$(INST_MAN1DIR) $(DESTINSTALLSITEMAN1DIR) \
  		$(INST_MAN3DIR) $(DESTINSTALLSITEMAN3DIR)
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
  		}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{
  
  pure_vendor_install :: all
  	$(NOECHO) $(MOD_INSTALL) \
  };
      push @m,
  q{		read }.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
  		write }.$self->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').q{ \
  } unless $self->{NO_PACKLIST};
  
      push @m,
  q{		$(INST_LIB) $(DESTINSTALLVENDORLIB) \
  		$(INST_ARCHLIB) $(DESTINSTALLVENDORARCH) \
  		$(INST_BIN) $(DESTINSTALLVENDORBIN) \
  		$(INST_SCRIPT) $(DESTINSTALLVENDORSCRIPT) \
  		$(INST_MAN1DIR) $(DESTINSTALLVENDORMAN1DIR) \
  		$(INST_MAN3DIR) $(DESTINSTALLVENDORMAN3DIR)
  
  };
  
      push @m, q{
  doc_perl_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_site_install :: all
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install :: all
  	$(NOECHO) $(NOOP)
  
  } if $self->{NO_PERLLOCAL};
  
      push @m, q{
  doc_perl_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
  	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLPRIVLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
  
  doc_site_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
  	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLSITELIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
  
  doc_vendor_install :: all
  	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
  	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Module" "$(NAME)" \
  		"installed into" "$(INSTALLVENDORLIB)" \
  		LINKTYPE "$(LINKTYPE)" \
  		VERSION "$(VERSION)" \
  		EXE_FILES "$(EXE_FILES)" \
  		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
  
  } unless $self->{NO_PERLLOCAL};
  
      push @m, q{
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{
  
  uninstall_from_vendordirs ::
  	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{
  };
  
      join("",@m);
  }
  
  =item installbin (o)
  
  Defines targets to make and to install EXE_FILES.
  
  =cut
  
  sub installbin {
      my($self) = shift;
  
      return "" unless $self->{EXE_FILES} && ref $self->{EXE_FILES} eq "ARRAY";
      my @exefiles = @{$self->{EXE_FILES}};
      return "" unless @exefiles;
  
      @exefiles = map vmsify($_), @exefiles if $Is{VMS};
  
      my %fromto;
      for my $from (@exefiles) {
  	my($path)= $self->catfile('$(INST_SCRIPT)', basename($from));
  
  	local($_) = $path; # for backwards compatibility
  	my $to = $self->libscan($path);
  	print "libscan($from) => '$to'\n" if ($Verbose >=2);
  
          $to = vmsify($to) if $Is{VMS};
  	$fromto{$from} = $to;
      }
      my @to   = values %fromto;
  
      my @m;
      push(@m, qq{
  EXE_FILES = @exefiles
  
  pure_all :: @to
  	\$(NOECHO) \$(NOOP)
  
  realclean ::
  });
  
      # realclean can get rather large.
      push @m, map "\t$_\n", $self->split_command('$(RM_F)', @to);
      push @m, "\n";
  
  
      # A target for each exe file.
      while (my($from,$to) = each %fromto) {
  	last unless defined $from;
  
  	push @m, sprintf <<'MAKE', $to, $from, $to, $from, $to, $to, $to;
  %s : %s $(FIRST_MAKEFILE) $(INST_SCRIPT)$(DFSEP).exists $(INST_BIN)$(DFSEP).exists
  	$(NOECHO) $(RM_F) %s
  	$(CP) %s %s
  	$(FIXIN) %s
  	-$(NOECHO) $(CHMOD) $(PERM_RWX) %s
  
  MAKE
  
      }
  
      join "", @m;
  }
  
  
  =item linkext (o)
  
  Defines the linkext target which in turn defines the LINKTYPE.
  
  =cut
  
  sub linkext {
      my($self, %attribs) = @_;
      # LINKTYPE => static or dynamic or ''
      my($linktype) = defined $attribs{LINKTYPE} ?
        $attribs{LINKTYPE} : '$(LINKTYPE)';
      "
  linkext :: $linktype
  	\$(NOECHO) \$(NOOP)
  ";
  }
  
  =item lsdir
  
  Takes as arguments a directory name and a regular expression. Returns
  all entries in the directory that match the regular expression.
  
  =cut
  
  sub lsdir {
      my($self) = shift;
      my($dir, $regex) = @_;
      my(@ls);
      my $dh = new DirHandle;
      $dh->open($dir || ".") or return ();
      @ls = $dh->read;
      $dh->close;
      @ls = grep(/$regex/, @ls) if $regex;
      @ls;
  }
  
  =item macro (o)
  
  Simple subroutine to insert the macros defined by the macro attribute
  into the Makefile.
  
  =cut
  
  sub macro {
      my($self,%attribs) = @_;
      my(@m,$key,$val);
      while (($key,$val) = each %attribs){
  	last unless defined $key;
  	push @m, "$key = $val\n";
      }
      join "", @m;
  }
  
  =item makeaperl (o)
  
  Called by staticmake. Defines how to write the Makefile to produce a
  static new perl.
  
  By default the Makefile produced includes all the static extensions in
  the perl library. (Purified versions of library files, e.g.,
  DynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)
  
  =cut
  
  sub makeaperl {
      my($self, %attribs) = @_;
      my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmp, $libperl) =
  	@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};
      my(@m);
      push @m, "
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  FULLPERL      = $self->{FULLPERL}
  ";
      return join '', @m if $self->{PARENT};
  
      my($dir) = join ":", @{$self->{DIR}};
  
      unless ($self->{MAKEAPERL}) {
  	push @m, q{
  $(MAP_TARGET) :: static $(MAKE_APERL_FILE)
  	$(MAKE) $(USEMAKEFILE) $(MAKE_APERL_FILE) $@
  
  $(MAKE_APERL_FILE) : $(FIRST_MAKEFILE) pm_to_blib
  	$(NOECHO) $(ECHO) Writing \"$(MAKE_APERL_FILE)\" for this $(MAP_TARGET)
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR=}, $dir, q{ \
  		MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 CCCDLFLAGS=};
  
  	foreach (@ARGV){
  		if( /\s/ ){
  			s/=(.*)/='$1'/;
  		}
  		push @m, " \\\n\t\t$_";
  	}
  #	push @m, map( " \\\n\t\t$_", @ARGV );
  	push @m, "\n";
  
  	return join '', @m;
      }
  
  
  
      my($cccmd, $linkcmd, $lperl);
  
  
      $cccmd = $self->const_cccmd($libperl);
      $cccmd =~ s/^CCCMD\s*=\s*//;
      $cccmd =~ s/\$\(INC\)/ "-I$self->{PERL_INC}" /;
      $cccmd .= " $Config{cccdlflags}"
  	if ($Config{useshrplib} eq 'true');
      $cccmd =~ s/\(CC\)/\(PERLMAINCC\)/;
  
      # The front matter of the linkcommand...
      $linkcmd = join ' ', "\$(CC)",
  	    grep($_, @Config{qw(ldflags ccdlflags)});
      $linkcmd =~ s/\s+/ /g;
      $linkcmd =~ s,(perl\.exp),\$(PERL_INC)/$1,;
  
      # Which *.a files could we make use of...
      my %static;
      require File::Find;
      File::Find::find(sub {
  	return unless m/\Q$self->{LIB_EXT}\E$/;
  
          # Skip perl's libraries.
          return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;
  
  	# Skip purified versions of libraries
          # (e.g., DynaLoader_pure_p1_c0_032.a)
  	return if m/_pure_\w+_\w+_\w+\.\w+$/ and -f "$File::Find::dir/.pure";
  
  	if( exists $self->{INCLUDE_EXT} ){
  		my $found = 0;
  
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything not explicitly marked for inclusion.
  		# DynaLoader is implied.
  		foreach my $incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){
  			if( $xx eq $incl ){
  				$found++;
  				last;
  			}
  		}
  		return unless $found;
  	}
  	elsif( exists $self->{EXCLUDE_EXT} ){
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything explicitly marked for exclusion
  		foreach my $excl (@{$self->{EXCLUDE_EXT}}){
  			return if( $xx eq $excl );
  		}
  	}
  
  	# don't include the installed version of this extension. I
  	# leave this line here, although it is not necessary anymore:
  	# I patched minimod.PL instead, so that Miniperl.pm won't
  	# include duplicates
  
  	# Once the patch to minimod.PL is in the distribution, I can
  	# drop it
  	return if $File::Find::name =~ m:auto/$self->{FULLEXT}/$self->{BASEEXT}$self->{LIB_EXT}\z:;
  	use Cwd 'cwd';
  	$static{cwd() . "/" . $_}++;
      }, grep( -d $_, @{$searchdirs || []}) );
  
      # We trust that what has been handed in as argument, will be buildable
      $static = [] unless $static;
      @static{@{$static}} = (1) x @{$static};
  
      $extra = [] unless $extra && ref $extra eq 'ARRAY';
      for (sort keys %static) {
  	next unless /\Q$self->{LIB_EXT}\E\z/;
  	$_ = dirname($_) . "/extralibs.ld";
  	push @$extra, $_;
      }
  
      s/^(.*)/"-I$1"/ for @{$perlinc || []};
  
      $target ||= "perl";
      $tmp    ||= ".";
  
  # MAP_STATIC doesn't look into subdirs yet. Once "all" is made and we
  # regenerate the Makefiles, MAP_STATIC and the dependencies for
  # extralibs.all are computed correctly
      push @m, "
  MAP_LINKCMD   = $linkcmd
  MAP_PERLINC   = @{$perlinc || []}
  MAP_STATIC    = ",
  join(" \\\n\t", reverse sort keys %static), "
  
  MAP_PRELIBS   = $Config{perllibs} $Config{cryptlib}
  ";
  
      if (defined $libperl) {
  	($lperl = $libperl) =~ s/\$\(A\)/$self->{LIB_EXT}/;
      }
      unless ($libperl && -f $lperl) { # Ilya's code...
  	my $dir = $self->{PERL_SRC} || "$self->{PERL_ARCHLIB}/CORE";
  	$dir = "$self->{PERL_ARCHLIB}/.." if $self->{UNINSTALLED_PERL};
  	$libperl ||= "libperl$self->{LIB_EXT}";
  	$libperl   = "$dir/$libperl";
  	$lperl   ||= "libperl$self->{LIB_EXT}";
  	$lperl     = "$dir/$lperl";
  
          if (! -f $libperl and ! -f $lperl) {
            # We did not find a static libperl. Maybe there is a shared one?
            if ($Is{SunOS}) {
              $lperl  = $libperl = "$dir/$Config{libperl}";
              # SUNOS ld does not take the full path to a shared library
              $libperl = '' if $Is{SunOS4};
            }
          }
  
  	print "Warning: $libperl not found
      If you're going to build a static perl binary, make sure perl is installed
      otherwise ignore this warning\n"
  		unless (-f $lperl || defined($self->{PERL_SRC}));
      }
  
      # SUNOS ld does not take the full path to a shared library
      my $llibperl = $libperl ? '$(MAP_LIBPERL)' : '-lperl';
  
      push @m, "
  MAP_LIBPERL = $libperl
  LLIBPERL    = $llibperl
  ";
  
      push @m, '
  $(INST_ARCHAUTODIR)/extralibs.all : $(INST_ARCHAUTODIR)$(DFSEP).exists '.join(" \\\n\t", @$extra).'
  	$(NOECHO) $(RM_F)  $@
  	$(NOECHO) $(TOUCH) $@
  ';
  
      foreach my $catfile (@$extra){
  	push @m, "\tcat $catfile >> \$\@\n";
      }
  
  push @m, "
  \$(MAP_TARGET) :: $tmp/perlmain\$(OBJ_EXT) \$(MAP_LIBPERL) \$(MAP_STATIC) \$(INST_ARCHAUTODIR)/extralibs.all
  	\$(MAP_LINKCMD) -o \$\@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) \$(LDFROM) \$(MAP_STATIC) \$(LLIBPERL) `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
  	\$(NOECHO) \$(ECHO) 'To install the new \"\$(MAP_TARGET)\" binary, call'
  	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename inst_perl MAP_TARGET=\$(MAP_TARGET)'
  	\$(NOECHO) \$(ECHO) 'To remove the intermediate files say'
  	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename map_clean'
  
  $tmp/perlmain\$(OBJ_EXT): $tmp/perlmain.c
  ";
      push @m, "\t".$self->cd($tmp, qq[$cccmd "-I\$(PERL_INC)" perlmain.c])."\n";
  
      push @m, qq{
  $tmp/perlmain.c: $makefilename}, q{
  	$(NOECHO) $(ECHO) Writing $@
  	$(NOECHO) $(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \\
  		-e "writemain(grep s#.*/auto/##s, split(q| |, q|$(MAP_STATIC)|))" > $@t && $(MV) $@t $@
  
  };
      push @m, "\t", q{$(NOECHO) $(PERL) $(INSTALLSCRIPT)/fixpmain
  } if (defined (&Dos::UseLFN) && Dos::UseLFN()==0);
  
  
      push @m, q{
  doc_inst_perl :
  	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
  	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	-$(NOECHO) $(DOC_INSTALL) \
  		"Perl binary" "$(MAP_TARGET)" \
  		MAP_STATIC "$(MAP_STATIC)" \
  		MAP_EXTRA "`cat $(INST_ARCHAUTODIR)/extralibs.all`" \
  		MAP_LIBPERL "$(MAP_LIBPERL)" \
  		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
  
  };
  
      push @m, q{
  inst_perl : pure_inst_perl doc_inst_perl
  
  pure_inst_perl : $(MAP_TARGET)
  	}.$self->{CP}.q{ $(MAP_TARGET) }.$self->catfile('$(DESTINSTALLBIN)','$(MAP_TARGET)').q{
  
  clean :: map_clean
  
  map_clean :
  	}.$self->{RM_F}.qq{ $tmp/perlmain\$(OBJ_EXT) $tmp/perlmain.c \$(MAP_TARGET) $makefilename \$(INST_ARCHAUTODIR)/extralibs.all
  };
  
      join '', @m;
  }
  
  =item makefile (o)
  
  Defines how to rewrite the Makefile.
  
  =cut
  
  sub makefile {
      my($self) = shift;
      my $m;
      # We do not know what target was originally specified so we
      # must force a manual rerun to be sure. But as it should only
      # happen very rarely it is not a significant problem.
      $m = '
  $(OBJECT) : $(FIRST_MAKEFILE)
  
  ' if $self->{OBJECT};
  
      my $newer_than_target = $Is{VMS} ? '$(MMS$SOURCE_LIST)' : '$?';
      my $mpl_args = join " ", map qq["$_"], @ARGV;
      my $cross = '';
      if (defined $::Cross::platform) {
          # Inherited from win32/buildext.pl
          $cross = "-MCross=$::Cross::platform ";
      }
      $m .= sprintf <<'MAKE_FRAG', $newer_than_target, $cross, $mpl_args;
  # We take a very conservative approach here, but it's worth it.
  # We move Makefile to Makefile.old here to avoid gnu make looping.
  $(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
  	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to %s"
  	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding Makefile..."
  	-$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
  	-$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
  	- $(MAKE) $(USEMAKEFILE) $(MAKEFILE_OLD) clean $(DEV_NULL)
  	$(PERLRUN) %sMakefile.PL %s
  	$(NOECHO) $(ECHO) "==> Your Makefile has been rebuilt. <=="
  	$(NOECHO) $(ECHO) "==> Please rerun the $(MAKE) command.  <=="
  	$(FALSE)
  
  MAKE_FRAG
  
      return $m;
  }
  
  
  =item maybe_command
  
  Returns true, if the argument is likely to be a command.
  
  =cut
  
  sub maybe_command {
      my($self,$file) = @_;
      return $file if -x $file && ! -d $file;
      return;
  }
  
  
  =item needs_linking (o)
  
  Does this module need linking? Looks into subdirectory objects (see
  also has_link_code())
  
  =cut
  
  sub needs_linking {
      my($self) = shift;
  
      my $caller = (caller(0))[3];
      confess("needs_linking called too early") if
        $caller =~ /^ExtUtils::MakeMaker::/;
      return $self->{NEEDS_LINKING} if defined $self->{NEEDS_LINKING};
      if ($self->has_link_code or $self->{MAKEAPERL}){
  	$self->{NEEDS_LINKING} = 1;
  	return 1;
      }
      foreach my $child (keys %{$self->{CHILDREN}}) {
  	if ($self->{CHILDREN}->{$child}->needs_linking) {
  	    $self->{NEEDS_LINKING} = 1;
  	    return 1;
  	}
      }
      return $self->{NEEDS_LINKING} = 0;
  }
  
  
  =item parse_abstract
  
  parse a file and return what you think is the ABSTRACT
  
  =cut
  
  sub parse_abstract {
      my($self,$parsefile) = @_;
      my $result;
  
      local $/ = "\n";
      open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
      my $inpod = 0;
      my $package = $self->{DISTNAME};
      $package =~ s/-/::/g;
      while (<$fh>) {
          $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
          next if !$inpod;
          chop;
          if ( /^($package(?:\.pm)? \s+ -+ \s+)(.*)/x ) {
            $result = $2;
            next;
          }
          next unless $result;
          if ( $result && ( /^\s*$/ || /^\=/ ) ) {
            last;
          }
          $result = join ' ', $result, $_;
      }
      close $fh;
  
      return $result;
  }
  
  =item parse_version
  
      my $version = MM->parse_version($file);
  
  Parse a $file and return what $VERSION is set to by the first assignment.
  It will return the string "undef" if it can't figure out what $VERSION
  is. $VERSION should be for all to see, so C<our $VERSION> or plain $VERSION
  are okay, but C<my $VERSION> is not.
  
  C<<package Foo VERSION>> is also checked for.  The first version
  declaration found is used, but this may change as it differs from how
  Perl does it.
  
  parse_version() will try to C<use version> before checking for
  C<$VERSION> so the following will work.
  
      $VERSION = qv(1.2.3);
  
  =cut
  
  sub parse_version {
      my($self,$parsefile) = @_;
      my $result;
  
      local $/ = "\n";
      local $_;
      open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
      my $inpod = 0;
      while (<$fh>) {
          $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
          next if $inpod || /^\s*#/;
          chop;
          next if /^\s*(if|unless|elsif)/;
          if ( m{^ \s* package \s+ \w[\w\:\']* \s+ (v?[0-9._]+) \s* ;  }x ) {
              local $^W = 0;
              $result = $1;
          }
          elsif ( m{(?<!\\) ([\$*]) (([\w\:\']*) \bVERSION)\b .* (?<![<>=!])\=[^=]}x ) {
  			$result = $self->get_version($parsefile, $1, $2);
          }
          else {
            next;
          }
          last if defined $result;
      }
      close $fh;
  
      if ( defined $result && $result !~ /^v?[\d_\.]+$/ ) {
        require version;
        my $normal = eval { version->parse( $result ) };
        $result = $normal if defined $normal;
      }
      $result = "undef" unless defined $result;
      return $result;
  }
  
  sub get_version
  {
  	my ($self, $parsefile, $sigil, $name) = @_;
  	my $eval = qq{
  		package ExtUtils::MakeMaker::_version;
  		no strict;
  		BEGIN { eval {
  			# Ensure any version() routine which might have leaked
  			# into this package has been deleted.  Interferes with
  			# version->import()
  			undef *version;
  			require version;
  			"version"->import;
  		} }
  
  		local $sigil$name;
  		\$$name=undef;
  		do {
  			$_
  		};
  		\$$name;
  	};
    $eval = $1 if $eval =~ m{^(.+)}s;
  	local $^W = 0;
  	my $result = eval($eval);  ## no critic
  	warn "Could not eval '$eval' in $parsefile: $@" if $@;
  	$result;
  }
  
  
  =item pasthru (o)
  
  Defines the string that is passed to recursive make calls in
  subdirectories.
  
  =cut
  
  sub pasthru {
      my($self) = shift;
      my(@m);
  
      my(@pasthru);
      my($sep) = $Is{VMS} ? ',' : '';
      $sep .= "\\\n\t";
  
      foreach my $key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE
                       PREFIX INSTALL_BASE)
                   )
      {
          next unless defined $self->{$key};
  	push @pasthru, "$key=\"\$($key)\"";
      }
  
      foreach my $key (qw(DEFINE INC)) {
          next unless defined $self->{$key};
  	push @pasthru, "PASTHRU_$key=\"\$(PASTHRU_$key)\"";
      }
  
      push @m, "\nPASTHRU = ", join ($sep, @pasthru), "\n";
      join "", @m;
  }
  
  =item perl_script
  
  Takes one argument, a file name, and returns the file name, if the
  argument is likely to be a perl script. On MM_Unix this is true for
  any ordinary, readable file.
  
  =cut
  
  sub perl_script {
      my($self,$file) = @_;
      return $file if -r $file && -f _;
      return;
  }
  
  =item perldepend (o)
  
  Defines the dependency from all *.h files that come with the perl
  distribution.
  
  =cut
  
  sub perldepend {
      my($self) = shift;
      my(@m);
  
      my $make_config = $self->cd('$(PERL_SRC)', '$(MAKE) lib/Config.pm');
  
      push @m, sprintf <<'MAKE_FRAG', $make_config if $self->{PERL_SRC};
  # Check for unpropogated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INC)/config.h: $(PERL_SRC)/config.sh
  	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; $(FALSE)
  
  $(PERL_ARCHLIB)/Config.pm: $(PERL_SRC)/config.sh
  	$(NOECHO) $(ECHO) "Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh"
  	%s
  MAKE_FRAG
  
      return join "", @m unless $self->needs_linking;
  
      if ($self->{OBJECT}) {
          # Need to add an object file dependency on the perl headers.
          # this is very important for XS modules in perl.git development.
          push @m, $self->_perl_header_files_fragment("/"); # Directory separator between $(PERL_INC)/header.h
      }
  
      push @m, join(" ", values %{$self->{XS}})." : \$(XSUBPPDEPS)\n"  if %{$self->{XS}};
  
      return join "\n", @m;
  }
  
  
  =item pm_to_blib
  
  Defines target that copies all files in the hash PM to their
  destination and autosplits them. See L<ExtUtils::Install/DESCRIPTION>
  
  =cut
  
  sub pm_to_blib {
      my $self = shift;
      my($autodir) = $self->catdir('$(INST_LIB)','auto');
      my $r = q{
  pm_to_blib : $(FIRST_MAKEFILE) $(TO_INST_PM)
  };
  
      # VMS will swallow '' and PM_FILTER is often empty.  So use q[]
      my $pm_to_blib = $self->oneliner(<<CODE, ['-MExtUtils::Install']);
  pm_to_blib({\@ARGV}, '$autodir', q[\$(PM_FILTER)], '\$(PERM_DIR)')
  CODE
  
      my @cmds = $self->split_command($pm_to_blib,
                    map { ($_, $self->{PM}->{$_}) } sort keys %{$self->{PM}});
  
      $r .= join '', map { "\t\$(NOECHO) $_\n" } @cmds;
      $r .= qq{\t\$(NOECHO) \$(TOUCH) pm_to_blib\n};
  
      return $r;
  }
  
  =item post_constants (o)
  
  Returns an empty string per default. Dedicated to overrides from
  within Makefile.PL after all constants have been defined.
  
  =cut
  
  sub post_constants{
      "";
  }
  
  =item post_initialize (o)
  
  Returns an empty string per default. Used in Makefile.PLs to add some
  chunk of text to the Makefile after the object is initialized.
  
  =cut
  
  sub post_initialize {
      "";
  }
  
  =item postamble (o)
  
  Returns an empty string. Can be used in Makefile.PLs to write some
  text to the Makefile at the end.
  
  =cut
  
  sub postamble {
      "";
  }
  
  # transform dot-separated version string into comma-separated quadruple
  # examples:  '1.2.3.4.5' => '1,2,3,4'
  #            '1.2.3'     => '1,2,3,0'
  sub _ppd_version {
      my ($self, $string) = @_;
      return join ',', ((split /\./, $string), (0) x 4)[0..3];
  }
  
  =item ppd
  
  Defines target that creates a PPD (Perl Package Description) file
  for a binary distribution.
  
  =cut
  
  sub ppd {
      my($self) = @_;
  
      my $abstract = $self->{ABSTRACT} || '';
      $abstract =~ s/\n/\\n/sg;
      $abstract =~ s/</&lt;/g;
      $abstract =~ s/>/&gt;/g;
  
      my $author = join(', ',@{$self->{AUTHOR} || []});
      $author =~ s/</&lt;/g;
      $author =~ s/>/&gt;/g;
  
      my $ppd_file = '$(DISTNAME).ppd';
  
      my @ppd_cmds = $self->echo(<<'PPD_HTML', $ppd_file, { append => 0, allow_variables => 1 });
  <SOFTPKG NAME="$(DISTNAME)" VERSION="$(VERSION)">
  PPD_HTML
  
      my $ppd_xml = sprintf <<'PPD_HTML', $abstract, $author;
      <ABSTRACT>%s</ABSTRACT>
      <AUTHOR>%s</AUTHOR>
  PPD_HTML
  
      $ppd_xml .= "    <IMPLEMENTATION>\n";
      if ( $self->{MIN_PERL_VERSION} ) {
          my $min_perl_version = $self->_ppd_version($self->{MIN_PERL_VERSION});
          $ppd_xml .= sprintf <<'PPD_PERLVERS', $min_perl_version;
          <PERLCORE VERSION="%s" />
  PPD_PERLVERS
  
      }
  
      # Don't add "perl" to requires.  perl dependencies are
      # handles by ARCHITECTURE.
      my %prereqs = %{$self->{PREREQ_PM}};
      delete $prereqs{perl};
  
      # Build up REQUIRE
      foreach my $prereq (sort keys %prereqs) {
          my $name = $prereq;
          $name .= '::' unless $name =~ /::/;
          my $version = $prereqs{$prereq}+0;  # force numification
  
          my %attrs = ( NAME => $name );
          $attrs{VERSION} = $version if $version;
          my $attrs = join " ", map { qq[$_="$attrs{$_}"] } keys %attrs;
          $ppd_xml .= qq(        <REQUIRE $attrs />\n);
      }
  
      my $archname = $Config{archname};
      if ($] >= 5.008) {
          # archname did not change from 5.6 to 5.8, but those versions may
          # not be not binary compatible so now we append the part of the
          # version that changes when binary compatibility may change
          $archname .= "-$Config{PERL_REVISION}.$Config{PERL_VERSION}";
      }
      $ppd_xml .= sprintf <<'PPD_OUT', $archname;
          <ARCHITECTURE NAME="%s" />
  PPD_OUT
  
      if ($self->{PPM_INSTALL_SCRIPT}) {
          if ($self->{PPM_INSTALL_EXEC}) {
              $ppd_xml .= sprintf qq{        <INSTALL EXEC="%s">%s</INSTALL>\n},
                    $self->{PPM_INSTALL_EXEC}, $self->{PPM_INSTALL_SCRIPT};
          }
          else {
              $ppd_xml .= sprintf qq{        <INSTALL>%s</INSTALL>\n},
                    $self->{PPM_INSTALL_SCRIPT};
          }
      }
  
      if ($self->{PPM_UNINSTALL_SCRIPT}) {
          if ($self->{PPM_UNINSTALL_EXEC}) {
              $ppd_xml .= sprintf qq{        <UNINSTALL EXEC="%s">%s</UNINSTALL>\n},
                    $self->{PPM_UNINSTALL_EXEC}, $self->{PPM_UNINSTALL_SCRIPT};
          }
          else {
              $ppd_xml .= sprintf qq{        <UNINSTALL>%s</UNINSTALL>\n},
                    $self->{PPM_UNINSTALL_SCRIPT};
          }
      }
  
      my ($bin_location) = $self->{BINARY_LOCATION} || '';
      $bin_location =~ s/\\/\\\\/g;
  
      $ppd_xml .= sprintf <<'PPD_XML', $bin_location;
          <CODEBASE HREF="%s" />
      </IMPLEMENTATION>
  </SOFTPKG>
  PPD_XML
  
      push @ppd_cmds, $self->echo($ppd_xml, $ppd_file, { append => 1 });
  
      return sprintf <<'PPD_OUT', join "\n\t", @ppd_cmds;
  # Creates a PPD (Perl Package Description) for a binary distribution.
  ppd :
  	%s
  PPD_OUT
  
  }
  
  =item prefixify
  
    $MM->prefixify($var, $prefix, $new_prefix, $default);
  
  Using either $MM->{uc $var} || $Config{lc $var}, it will attempt to
  replace it's $prefix with a $new_prefix.
  
  Should the $prefix fail to match I<AND> a PREFIX was given as an
  argument to WriteMakefile() it will set it to the $new_prefix +
  $default.  This is for systems whose file layouts don't neatly fit into
  our ideas of prefixes.
  
  This is for heuristics which attempt to create directory structures
  that mirror those of the installed perl.
  
  For example:
  
      $MM->prefixify('installman1dir', '/usr', '/home/foo', 'man/man1');
  
  this will attempt to remove '/usr' from the front of the
  $MM->{INSTALLMAN1DIR} path (initializing it to $Config{installman1dir}
  if necessary) and replace it with '/home/foo'.  If this fails it will
  simply use '/home/foo/man/man1'.
  
  =cut
  
  sub prefixify {
      my($self,$var,$sprefix,$rprefix,$default) = @_;
  
      my $path = $self->{uc $var} ||
                 $Config_Override{lc $var} || $Config{lc $var} || '';
  
      $rprefix .= '/' if $sprefix =~ m|/$|;
  
      warn "  prefixify $var => $path\n" if $Verbose >= 2;
      warn "    from $sprefix to $rprefix\n" if $Verbose >= 2;
  
      if( $self->{ARGS}{PREFIX} &&
          $path !~ s{^\Q$sprefix\E\b}{$rprefix}s )
      {
  
          warn "    cannot prefix, using default.\n" if $Verbose >= 2;
          warn "    no default!\n" if !$default && $Verbose >= 2;
  
          $path = $self->catdir($rprefix, $default) if $default;
      }
  
      print "    now $path\n" if $Verbose >= 2;
      return $self->{uc $var} = $path;
  }
  
  
  =item processPL (o)
  
  Defines targets to run *.PL files.
  
  =cut
  
  sub processPL {
      my $self = shift;
      my $pl_files = $self->{PL_FILES};
  
      return "" unless $pl_files;
  
      my $m = '';
      foreach my $plfile (sort keys %$pl_files) {
          my $list = ref($pl_files->{$plfile})
                       ?  $pl_files->{$plfile}
  		     : [$pl_files->{$plfile}];
  
  	foreach my $target (@$list) {
              if( $Is{VMS} ) {
                  $plfile = vmsify($self->eliminate_macros($plfile));
                  $target = vmsify($self->eliminate_macros($target));
              }
  
  	    # Normally a .PL file runs AFTER pm_to_blib so it can have
  	    # blib in its @INC and load the just built modules.  BUT if
  	    # the generated module is something in $(TO_INST_PM) which
  	    # pm_to_blib depends on then it can't depend on pm_to_blib
  	    # else we have a dependency loop.
  	    my $pm_dep;
  	    my $perlrun;
  	    if( defined $self->{PM}{$target} ) {
  		$pm_dep  = '';
  		$perlrun = 'PERLRUN';
  	    }
  	    else {
  		$pm_dep  = 'pm_to_blib';
  		$perlrun = 'PERLRUNINST';
  	    }
  
              $m .= <<MAKE_FRAG;
  
  all :: $target
  	\$(NOECHO) \$(NOOP)
  
  $target :: $plfile $pm_dep
  	\$($perlrun) $plfile $target
  MAKE_FRAG
  
  	}
      }
  
      return $m;
  }
  
  =item quote_paren
  
  Backslashes parentheses C<()> in command line arguments.
  Doesn't handle recursive Makefile C<$(...)> constructs,
  but handles simple ones.
  
  =cut
  
  sub quote_paren {
      my $arg = shift;
      $arg =~ s{\$\((.+?)\)}{\$\\\\($1\\\\)}g;	# protect $(...)
      $arg =~ s{(?<!\\)([()])}{\\$1}g;		# quote unprotected
      $arg =~ s{\$\\\\\((.+?)\\\\\)}{\$($1)}g;	# unprotect $(...)
      return $arg;
  }
  
  =item replace_manpage_separator
  
    my $man_name = $MM->replace_manpage_separator($file_path);
  
  Takes the name of a package, which may be a nested package, in the
  form 'Foo/Bar.pm' and replaces the slash with C<::> or something else
  safe for a man page file name.  Returns the replacement.
  
  =cut
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
  
      $man =~ s,/+,::,g;
      return $man;
  }
  
  
  =item cd
  
  =cut
  
  sub cd {
      my($self, $dir, @cmds) = @_;
  
      # No leading tab and no trailing newline makes for easier embedding
      my $make_frag = join "\n\t", map { "cd $dir && $_" } @cmds;
  
      return $make_frag;
  }
  
  =item oneliner
  
  =cut
  
  sub oneliner {
      my($self, $cmd, $switches) = @_;
      $switches = [] unless defined $switches;
  
      # Strip leading and trailing newlines
      $cmd =~ s{^\n+}{};
      $cmd =~ s{\n+$}{};
  
      my @cmds = split /\n/, $cmd;
      $cmd = join " \n\t  -e ", map $self->quote_literal($_), @cmds;
      $cmd = $self->escape_newlines($cmd);
  
      $switches = join ' ', @$switches;
  
      return qq{\$(ABSPERLRUN) $switches -e $cmd --};
  }
  
  
  =item quote_literal
  
  =cut
  
  sub quote_literal {
      my($self, $text, $opts) = @_;
      $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};
  
      # Quote single quotes
      $text =~ s{'}{'\\''}g;
  
      $text = $opts->{allow_variables}
        ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);
  
      return "'$text'";
  }
  
  
  =item escape_newlines
  
  =cut
  
  sub escape_newlines {
      my($self, $text) = @_;
  
      $text =~ s{\n}{\\\n}g;
  
      return $text;
  }
  
  
  =item max_exec_len
  
  Using POSIX::ARG_MAX.  Otherwise falling back to 4096.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      if (!defined $self->{_MAX_EXEC_LEN}) {
          if (my $arg_max = eval { require POSIX;  &POSIX::ARG_MAX }) {
              $self->{_MAX_EXEC_LEN} = $arg_max;
          }
          else {      # POSIX minimum exec size
              $self->{_MAX_EXEC_LEN} = 4096;
          }
      }
  
      return $self->{_MAX_EXEC_LEN};
  }
  
  
  =item static (o)
  
  Defines the static target.
  
  =cut
  
  sub static {
  # --- Static Loading Sections ---
  
      my($self) = shift;
      '
  ## $(INST_PM) has been moved to the all: target.
  ## It remains here for awhile to allow for old usage: "make static"
  static :: $(FIRST_MAKEFILE) $(INST_STATIC)
  	$(NOECHO) $(NOOP)
  ';
  }
  
  =item static_lib (o)
  
  Defines how to produce the *.a (or equivalent) files.
  
  =cut
  
  sub static_lib {
      my($self) = @_;
      return '' unless $self->has_link_code;
  
      my(@m);
      push(@m, <<'END');
  
  $(INST_STATIC) : $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(RM_RF) $@
  END
  
      # If this extension has its own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      push(@m, <<'MAKE_FRAG') if $self->{MYEXTLIB};
  	$(CP) $(MYEXTLIB) $@
  MAKE_FRAG
  
      my $ar;
      if (exists $self->{FULL_AR} && -x $self->{FULL_AR}) {
          # Prefer the absolute pathed ar if available so that PATH
          # doesn't confuse us.  Perl itself is built with the full_ar.
          $ar = 'FULL_AR';
      } else {
          $ar = 'AR';
      }
      push @m, sprintf <<'MAKE_FRAG', $ar;
  	$(%s) $(AR_STATIC_ARGS) $@ $(OBJECT) && $(RANLIB) $@
  	$(CHMOD) $(PERM_RWX) $@
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)/extralibs.ld
  MAKE_FRAG
  
      # Old mechanism - still available:
      push @m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)/ext.libs
  MAKE_FRAG
  
      join('', @m);
  }
  
  =item staticmake (o)
  
  Calls makeaperl.
  
  =cut
  
  sub staticmake {
      my($self, %attribs) = @_;
      my(@static);
  
      my(@searchdirs)=($self->{PERL_ARCHLIB}, $self->{SITEARCHEXP},  $self->{INST_ARCHLIB});
  
      # And as it's not yet built, we add the current extension
      # but only if it has some C code (or XS code, which implies C code)
      if (@{$self->{C}}) {
  	@static = $self->catfile($self->{INST_ARCHLIB},
  				 "auto",
  				 $self->{FULLEXT},
  				 "$self->{BASEEXT}$self->{LIB_EXT}"
  				);
      }
  
      # Either we determine now, which libraries we will produce in the
      # subdirectories or we do it at runtime of the make.
  
      # We could ask all subdir objects, but I cannot imagine, why it
      # would be necessary.
  
      # Instead we determine all libraries for the new perl at
      # runtime.
      my(@perlinc) = ($self->{INST_ARCHLIB}, $self->{INST_LIB}, $self->{PERL_ARCHLIB}, $self->{PERL_LIB});
  
      $self->makeaperl(MAKE	=> $self->{MAKEFILE},
  		     DIRS	=> \@searchdirs,
  		     STAT	=> \@static,
  		     INCL	=> \@perlinc,
  		     TARGET	=> $self->{MAP_TARGET},
  		     TMP	=> "",
  		     LIBPERL	=> $self->{LIBPERL_A}
  		    );
  }
  
  =item subdir_x (o)
  
  Helper subroutine for subdirs
  
  =cut
  
  sub subdir_x {
      my($self, $subdir) = @_;
  
      my $subdir_cmd = $self->cd($subdir,
        '$(MAKE) $(USEMAKEFILE) $(FIRST_MAKEFILE) all $(PASTHRU)'
      );
      return sprintf <<'EOT', $subdir_cmd;
  
  subdirs ::
  	$(NOECHO) %s
  EOT
  
  }
  
  =item subdirs (o)
  
  Defines targets to process subdirectories.
  
  =cut
  
  sub subdirs {
  # --- Sub-directory Sections ---
      my($self) = shift;
      my(@m);
      # This method provides a mechanism to automatically deal with
      # subdirectories containing further Makefile.PL scripts.
      # It calls the subdir_x() method for each subdirectory.
      foreach my $dir (@{$self->{DIR}}){
  	push(@m, $self->subdir_x($dir));
  ####	print "Including $dir subdirectory\n";
      }
      if (@m){
  	unshift(@m, "
  # The default clean, realclean and test targets in this Makefile
  # have automatically been given entries for each subdir.
  
  ");
      } else {
  	push(@m, "\n# none")
      }
      join('',@m);
  }
  
  =item test (o)
  
  Defines the test targets.
  
  =cut
  
  sub test {
  # --- Test and Installation Sections ---
  
      my($self, %attribs) = @_;
      my $tests = $attribs{TESTS} || '';
      if (!$tests && -d 't' && defined $attribs{RECURSIVE_TEST_FILES}) {
          $tests = $self->find_tests_recursive;
      }
      elsif (!$tests && -d 't') {
          $tests = $self->find_tests;
      }
      # note: 'test.pl' name is also hardcoded in init_dirscan()
      my(@m);
      push(@m,"
  TEST_VERBOSE=0
  TEST_TYPE=test_\$(LINKTYPE)
  TEST_FILE = test.pl
  TEST_FILES = $tests
  TESTDB_SW = -d
  
  testdb :: testdb_\$(LINKTYPE)
  
  test :: \$(TEST_TYPE) subdirs-test
  
  subdirs-test ::
  	\$(NOECHO) \$(NOOP)
  
  ");
  
      foreach my $dir (@{ $self->{DIR} }) {
          my $test = $self->cd($dir, '$(MAKE) test $(PASTHRU)');
  
          push @m, <<END
  subdirs-test ::
  	\$(NOECHO) $test
  
  END
      }
  
      push(@m, "\t\$(NOECHO) \$(ECHO) 'No tests defined for \$(NAME) extension.'\n")
  	unless $tests or -f "test.pl" or @{$self->{DIR}};
      push(@m, "\n");
  
      push(@m, "test_dynamic :: pure_all\n");
      push(@m, $self->test_via_harness('$(FULLPERLRUN)', '$(TEST_FILES)'))
        if $tests;
      push(@m, $self->test_via_script('$(FULLPERLRUN)', '$(TEST_FILE)'))
        if -f "test.pl";
      push(@m, "\n");
  
      push(@m, "testdb_dynamic :: pure_all\n");
      push(@m, $self->test_via_script('$(FULLPERLRUN) $(TESTDB_SW)',
                                      '$(TEST_FILE)'));
      push(@m, "\n");
  
      # Occasionally we may face this degenerate target:
      push @m, "test_ : test_dynamic\n\n";
  
      if ($self->needs_linking()) {
  	push(@m, "test_static :: pure_all \$(MAP_TARGET)\n");
  	push(@m, $self->test_via_harness('./$(MAP_TARGET)', '$(TEST_FILES)')) if $tests;
  	push(@m, $self->test_via_script('./$(MAP_TARGET)', '$(TEST_FILE)')) if -f "test.pl";
  	push(@m, "\n");
  	push(@m, "testdb_static :: pure_all \$(MAP_TARGET)\n");
  	push(@m, $self->test_via_script('./$(MAP_TARGET) $(TESTDB_SW)', '$(TEST_FILE)'));
  	push(@m, "\n");
      } else {
  	push @m, "test_static :: test_dynamic\n";
  	push @m, "testdb_static :: testdb_dynamic\n";
      }
      join("", @m);
  }
  
  =item test_via_harness (override)
  
  For some reason which I forget, Unix machines like to have
  PERL_DL_NONLAZY set for tests.
  
  =cut
  
  sub test_via_harness {
      my($self, $perl, $tests) = @_;
      return $self->SUPER::test_via_harness("PERL_DL_NONLAZY=1 $perl", $tests);
  }
  
  =item test_via_script (override)
  
  Again, the PERL_DL_NONLAZY thing.
  
  =cut
  
  sub test_via_script {
      my($self, $perl, $script) = @_;
      return $self->SUPER::test_via_script("PERL_DL_NONLAZY=1 $perl", $script);
  }
  
  
  =item tool_xsubpp (o)
  
  Determines typemaps, xsubpp version, prototype behaviour.
  
  =cut
  
  sub tool_xsubpp {
      my($self) = shift;
      return "" unless $self->needs_linking;
  
      my $xsdir;
      my @xsubpp_dirs = @INC;
  
      # Make sure we pick up the new xsubpp if we're building perl.
      unshift @xsubpp_dirs, $self->{PERL_LIB} if $self->{PERL_CORE};
  
      my $foundxsubpp = 0;
      foreach my $dir (@xsubpp_dirs) {
          $xsdir = $self->catdir($dir, 'ExtUtils');
          if( -r $self->catfile($xsdir, "xsubpp") ) {
              $foundxsubpp = 1;
              last;
          }
      }
      die "ExtUtils::MM_Unix::tool_xsubpp : Can't find xsubpp" if !$foundxsubpp;
  
      my $tmdir   = File::Spec->catdir($self->{PERL_LIB},"ExtUtils");
      my(@tmdeps) = $self->catfile($tmdir,'typemap');
      if( $self->{TYPEMAPS} ){
          foreach my $typemap (@{$self->{TYPEMAPS}}){
              if( ! -f  $typemap ) {
                  warn "Typemap $typemap not found.\n";
              }
              else {
                  push(@tmdeps,  $typemap);
              }
          }
      }
      push(@tmdeps, "typemap") if -f "typemap";
      my(@tmargs) = map("-typemap $_", @tmdeps);
      if( exists $self->{XSOPT} ){
          unshift( @tmargs, $self->{XSOPT} );
      }
  
      if ($Is{VMS}                          &&
          $Config{'ldflags'}               &&
          $Config{'ldflags'} =~ m!/Debug!i &&
          (!exists($self->{XSOPT}) || $self->{XSOPT} !~ /linenumbers/)
         )
      {
          unshift(@tmargs,'-nolinenumbers');
      }
  
  
      $self->{XSPROTOARG} = "" unless defined $self->{XSPROTOARG};
  
      return qq{
  XSUBPPDIR = $xsdir
  XSUBPP = \$(XSUBPPDIR)\$(DFSEP)xsubpp
  XSUBPPRUN = \$(PERLRUN) \$(XSUBPP)
  XSPROTOARG = $self->{XSPROTOARG}
  XSUBPPDEPS = @tmdeps \$(XSUBPP)
  XSUBPPARGS = @tmargs
  XSUBPP_EXTRA_ARGS =
  };
  };
  
  
  =item all_target
  
  Build man pages, too
  
  =cut
  
  sub all_target {
      my $self = shift;
  
      return <<'MAKE_EXT';
  all :: pure_all manifypods
  	$(NOECHO) $(NOOP)
  MAKE_EXT
  }
  
  =item top_targets (o)
  
  Defines the targets all, subdirs, config, and O_FILES
  
  =cut
  
  sub top_targets {
  # --- Target Sections ---
  
      my($self) = shift;
      my(@m);
  
      push @m, $self->all_target, "\n" unless $self->{SKIPHASH}{'all'};
  
      push @m, '
  pure_all :: config pm_to_blib subdirs linkext
  	$(NOECHO) $(NOOP)
  
  subdirs :: $(MYEXTLIB)
  	$(NOECHO) $(NOOP)
  
  config :: $(FIRST_MAKEFILE) blibdirs
  	$(NOECHO) $(NOOP)
  ';
  
      push @m, '
  $(O_FILES): $(H_FILES)
  ' if @{$self->{O_FILES} || []} && @{$self->{H} || []};
  
      push @m, q{
  help :
  	perldoc ExtUtils::MakeMaker
  };
  
      join('',@m);
  }
  
  =item writedoc
  
  Obsolete, deprecated method. Not used since Version 5.21.
  
  =cut
  
  sub writedoc {
  # --- perllocal.pod section ---
      my($self,$what,$name,@attribs)=@_;
      my $time = localtime;
      print "=head2 $time: $what C<$name>\n\n=over 4\n\n=item *\n\n";
      print join "\n\n=item *\n\n", map("C<$_>",@attribs);
      print "\n\n=back\n\n";
  }
  
  =item xs_c (o)
  
  Defines the suffix rules to compile XS files to C.
  
  =cut
  
  sub xs_c {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.c:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
  ';
  }
  
  =item xs_cpp (o)
  
  Defines the suffix rules to compile XS files to C++.
  
  =cut
  
  sub xs_cpp {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.cpp:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.cpp
  ';
  }
  
  =item xs_o (o)
  
  Defines suffix rules to go from XS to object files directly. This is
  only intended for broken make implementations.
  
  =cut
  
  sub xs_o {	# many makes are too dumb to use xs_c then c_o
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs$(OBJ_EXT):
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
  	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c
  ';
  }
  
  
  1;
  
  =back
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  __END__
EXTUTILS_MM_UNIX

$fatpacked{"ExtUtils/MM_VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VMS';
  package ExtUtils::MM_VMS;
  
  use strict;
  
  use ExtUtils::MakeMaker::Config;
  require Exporter;
  
  BEGIN {
      # so we can compile the thing on non-VMS platforms.
      if( $^O eq 'VMS' ) {
          require VMS::Filespec;
          VMS::Filespec->import;
      }
  }
  
  use File::Basename;
  
  our $VERSION = '6.92';
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  
  use ExtUtils::MakeMaker qw($Verbose neatvalue);
  our $Revision = $ExtUtils::MakeMaker::Revision;
  
  
  =head1 NAME
  
  ExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
    Do not use this directly.
    Instead, use ExtUtils::MM and it will figure out which MM_*
    class to use for you.
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =head2 Methods always loaded
  
  =over 4
  
  =item wraplist
  
  Converts a list into a string wrapped at approximately 80 columns.
  
  =cut
  
  sub wraplist {
      my($self) = shift;
      my($line,$hlen) = ('',0);
  
      foreach my $word (@_) {
        # Perl bug -- seems to occasionally insert extra elements when
        # traversing array (scalar(@array) doesn't show them, but
        # foreach(@array) does) (5.00307)
        next unless $word =~ /\w/;
        $line .= ' ' if length($line);
        if ($hlen > 80) { $line .= "\\\n\t"; $hlen = 0; }
        $line .= $word;
        $hlen += length($word) + 2;
      }
      $line;
  }
  
  
  # This isn't really an override.  It's just here because ExtUtils::MM_VMS
  # appears in @MM::ISA before ExtUtils::Liblist::Kid, so if there isn't an ext()
  # in MM_VMS, then AUTOLOAD is called, and bad things happen.  So, we just
  # mimic inheritance here and hand off to ExtUtils::Liblist::Kid.
  # XXX This hackery will die soon. --Schwern
  sub ext {
      require ExtUtils::Liblist::Kid;
      goto &ExtUtils::Liblist::Kid::ext;
  }
  
  =back
  
  =head2 Methods
  
  Those methods which override default MM_Unix methods are marked
  "(override)", while methods unique to MM_VMS are marked "(specific)".
  For overridden methods, documentation is limited to an explanation
  of why this method overrides the MM_Unix method; see the ExtUtils::MM_Unix
  documentation for more details.
  
  =over 4
  
  =item guess_name (override)
  
  Try to determine name of extension being built.  We begin with the name
  of the current directory.  Since VMS filenames are case-insensitive,
  however, we look for a F<.pm> file whose name matches that of the current
  directory (presumably the 'main' F<.pm> file for this extension), and try
  to find a C<package> statement from which to obtain the Mixed::Case
  package name.
  
  =cut
  
  sub guess_name {
      my($self) = @_;
      my($defname,$defpm,@pm,%xs);
      local *PM;
  
      $defname = basename(fileify($ENV{'DEFAULT'}));
      $defname =~ s![\d\-_]*\.dir.*$!!;  # Clip off .dir;1 suffix, and package version
      $defpm = $defname;
      # Fallback in case for some reason a user has copied the files for an
      # extension into a working directory whose name doesn't reflect the
      # extension's name.  We'll use the name of a unique .pm file, or the
      # first .pm file with a matching .xs file.
      if (not -e "${defpm}.pm") {
        @pm = glob('*.pm');
        s/.pm$// for @pm;
        if (@pm == 1) { ($defpm = $pm[0]) =~ s/.pm$//; }
        elsif (@pm) {
          %xs = map { s/.xs$//; ($_,1) } glob('*.xs');  ## no critic
          if (keys %xs) {
              foreach my $pm (@pm) {
                  $defpm = $pm, last if exists $xs{$pm};
              }
          }
        }
      }
      if (open(my $pm, '<', "${defpm}.pm")){
          while (<$pm>) {
              if (/^\s*package\s+([^;]+)/i) {
                  $defname = $1;
                  last;
              }
          }
          print "Warning (non-fatal): Couldn't find package name in ${defpm}.pm;\n\t",
                       "defaulting package name to $defname\n"
              if eof($pm);
          close $pm;
      }
      else {
          print "Warning (non-fatal): Couldn't find ${defpm}.pm;\n\t",
                       "defaulting package name to $defname\n";
      }
      $defname =~ s#[\d.\-_]+$##;
      $defname;
  }
  
  =item find_perl (override)
  
  Use VMS file specification syntax and CLI commands to find and
  invoke Perl images.
  
  =cut
  
  sub find_perl {
      my($self, $ver, $names, $dirs, $trace) = @_;
      my($vmsfile,@sdirs,@snames,@cand);
      my($rslt);
      my($inabs) = 0;
      local *TCF;
  
      if( $self->{PERL_CORE} ) {
          # Check in relative directories first, so we pick up the current
          # version of Perl if we're running MakeMaker as part of the main build.
          @sdirs = sort { my($absa) = $self->file_name_is_absolute($a);
                          my($absb) = $self->file_name_is_absolute($b);
                          if ($absa && $absb) { return $a cmp $b }
                          else { return $absa ? 1 : ($absb ? -1 : ($a cmp $b)); }
                        } @$dirs;
          # Check miniperl before perl, and check names likely to contain
          # version numbers before "generic" names, so we pick up an
          # executable that's less likely to be from an old installation.
          @snames = sort { my($ba) = $a =~ m!([^:>\]/]+)$!;  # basename
                           my($bb) = $b =~ m!([^:>\]/]+)$!;
                           my($ahasdir) = (length($a) - length($ba) > 0);
                           my($bhasdir) = (length($b) - length($bb) > 0);
                           if    ($ahasdir and not $bhasdir) { return 1; }
                           elsif ($bhasdir and not $ahasdir) { return -1; }
                           else { $bb =~ /\d/ <=> $ba =~ /\d/
                                    or substr($ba,0,1) cmp substr($bb,0,1)
                                    or length($bb) <=> length($ba) } } @$names;
      }
      else {
          @sdirs  = @$dirs;
          @snames = @$names;
      }
  
      # Image names containing Perl version use '_' instead of '.' under VMS
      s/\.(\d+)$/_$1/ for @snames;
      if ($trace >= 2){
          print "Looking for perl $ver by these names:\n";
          print "\t@snames,\n";
          print "in these dirs:\n";
          print "\t@sdirs\n";
      }
      foreach my $dir (@sdirs){
          next unless defined $dir; # $self->{PERL_SRC} may be undefined
          $inabs++ if $self->file_name_is_absolute($dir);
          if ($inabs == 1) {
              # We've covered relative dirs; everything else is an absolute
              # dir (probably an installed location).  First, we'll try
              # potential command names, to see whether we can avoid a long
              # MCR expression.
              foreach my $name (@snames) {
                  push(@cand,$name) if $name =~ /^[\w\-\$]+$/;
              }
              $inabs++; # Should happen above in next $dir, but just in case...
          }
          foreach my $name (@snames){
              push @cand, ($name !~ m![/:>\]]!) ? $self->catfile($dir,$name)
                                                : $self->fixpath($name,0);
          }
      }
      foreach my $name (@cand) {
          print "Checking $name\n" if $trace >= 2;
          # If it looks like a potential command, try it without the MCR
          if ($name =~ /^[\w\-\$]+$/) {
              open(my $tcf, ">", "temp_mmvms.com")
                  or die('unable to open temp file');
              print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
              print $tcf "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";
              close $tcf;
              $rslt = `\@temp_mmvms.com` ;
              unlink('temp_mmvms.com');
              if ($rslt =~ /VER_OK/) {
                  print "Using PERL=$name\n" if $trace;
                  return $name;
              }
          }
          next unless $vmsfile = $self->maybe_command($name);
          $vmsfile =~ s/;[\d\-]*$//;  # Clip off version number; we can use a newer version as well
          print "Executing $vmsfile\n" if ($trace >= 2);
          open(my $tcf, '>', "temp_mmvms.com")
                  or die('unable to open temp file');
          print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
          print $tcf "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";
          close $tcf;
          $rslt = `\@temp_mmvms.com`;
          unlink('temp_mmvms.com');
          if ($rslt =~ /VER_OK/) {
              print "Using PERL=MCR $vmsfile\n" if $trace;
              return "MCR $vmsfile";
          }
      }
      print "Unable to find a perl $ver (by these names: @$names, in these dirs: @$dirs)\n";
      0; # false and not empty
  }
  
  =item _fixin_replace_shebang (override)
  
  Helper routine for MM->fixin(), overridden because there's no such thing as an
  actual shebang line that will be interpreted by the shell, so we just prepend
  $Config{startperl} and preserve the shebang line argument for any switches it
  may contain.
  
  =cut
  
  sub _fixin_replace_shebang {
      my ( $self, $file, $line ) = @_;
  
      my ( undef, $arg ) = split ' ', $line, 2;
  
      return $Config{startperl} . "\n" . $Config{sharpbang} . "perl $arg\n";
  }
  
  =item maybe_command (override)
  
  Follows VMS naming conventions for executable files.
  If the name passed in doesn't exactly match an executable file,
  appends F<.Exe> (or equivalent) to check for executable image, and F<.Com>
  to check for DCL procedure.  If this fails, checks directories in DCL$PATH
  and finally F<Sys$System:> for an executable file having the name specified,
  with or without the F<.Exe>-equivalent suffix.
  
  =cut
  
  sub maybe_command {
      my($self,$file) = @_;
      return $file if -x $file && ! -d _;
      my(@dirs) = ('');
      my(@exts) = ('',$Config{'exe_ext'},'.exe','.com');
  
      if ($file !~ m![/:>\]]!) {
          for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
              my $dir = $ENV{"DCL\$PATH;$i"};
              $dir .= ':' unless $dir =~ m%[\]:]$%;
              push(@dirs,$dir);
          }
          push(@dirs,'Sys$System:');
          foreach my $dir (@dirs) {
              my $sysfile = "$dir$file";
              foreach my $ext (@exts) {
                  return $file if -x "$sysfile$ext" && ! -d _;
              }
          }
      }
      return 0;
  }
  
  
  =item pasthru (override)
  
  VMS has $(MMSQUALIFIERS) which is a listing of all the original command line
  options.  This is used in every invocation of make in the VMS Makefile so
  PASTHRU should not be necessary.  Using PASTHRU tends to blow commands past
  the 256 character limit.
  
  =cut
  
  sub pasthru {
      return "PASTHRU=\n";
  }
  
  
  =item pm_to_blib (override)
  
  VMS wants a dot in every file so we can't have one called 'pm_to_blib',
  it becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when
  you have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.
  
  So in VMS its pm_to_blib.ts.
  
  =cut
  
  sub pm_to_blib {
      my $self = shift;
  
      my $make = $self->SUPER::pm_to_blib;
  
      $make =~ s{^pm_to_blib :}{pm_to_blib.ts :}m;
      $make =~ s{\$\(TOUCH\) pm_to_blib}{\$(TOUCH) pm_to_blib.ts};
  
      $make = <<'MAKE' . $make;
  # Dummy target to match Unix target name; we use pm_to_blib.ts as
  # timestamp file to avoid repeated invocations under VMS
  pm_to_blib : pm_to_blib.ts
  	$(NOECHO) $(NOOP)
  
  MAKE
  
      return $make;
  }
  
  
  =item perl_script (override)
  
  If name passed in doesn't specify a readable file, appends F<.com> or
  F<.pl> and tries again, since it's customary to have file types on all files
  under VMS.
  
  =cut
  
  sub perl_script {
      my($self,$file) = @_;
      return $file if -r $file && ! -d _;
      return "$file.com" if -r "$file.com";
      return "$file.pl" if -r "$file.pl";
      return '';
  }
  
  
  =item replace_manpage_separator
  
  Use as separator a character which is legal in a VMS-syntax file name.
  
  =cut
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
      $man = unixify($man);
      $man =~ s#/+#__#g;
      $man;
  }
  
  =item init_DEST
  
  (override) Because of the difficulty concatenating VMS filepaths we
  must pre-expand the DEST* variables.
  
  =cut
  
  sub init_DEST {
      my $self = shift;
  
      $self->SUPER::init_DEST;
  
      # Expand DEST variables.
      foreach my $var ($self->installvars) {
          my $destvar = 'DESTINSTALL'.$var;
          $self->{$destvar} = $self->eliminate_macros($self->{$destvar});
      }
  }
  
  
  =item init_DIRFILESEP
  
  No separator between a directory path and a filename on VMS.
  
  =cut
  
  sub init_DIRFILESEP {
      my($self) = shift;
  
      $self->{DIRFILESEP} = '';
      return 1;
  }
  
  
  =item init_main (override)
  
  
  =cut
  
  sub init_main {
      my($self) = shift;
  
      $self->SUPER::init_main;
  
      $self->{DEFINE} ||= '';
      if ($self->{DEFINE} ne '') {
          my(@terms) = split(/\s+/,$self->{DEFINE});
          my(@defs,@udefs);
          foreach my $def (@terms) {
              next unless $def;
              my $targ = \@defs;
              if ($def =~ s/^-([DU])//) {    # If it was a Unix-style definition
                  $targ = \@udefs if $1 eq 'U';
                  $def =~ s/='(.*)'$/=$1/;  # then remove shell-protection ''
                  $def =~ s/^'(.*)'$/$1/;   # from entire term or argument
              }
              if ($def =~ /=/) {
                  $def =~ s/"/""/g;  # Protect existing " from DCL
                  $def = qq["$def"]; # and quote to prevent parsing of =
              }
              push @$targ, $def;
          }
  
          $self->{DEFINE} = '';
          if (@defs)  {
              $self->{DEFINE}  = '/Define=(' . join(',',@defs)  . ')';
          }
          if (@udefs) {
              $self->{DEFINE} .= '/Undef=('  . join(',',@udefs) . ')';
          }
      }
  }
  
  =item init_tools (override)
  
  Provide VMS-specific forms of various utility commands.
  
  Sets DEV_NULL to nothing because I don't know how to do it on VMS.
  
  Changes EQUALIZE_TIMESTAMP to set revision date of target file to
  one second later than source file, since MMK interprets precisely
  equal revision dates for a source and target file as a sign that the
  target needs to be updated.
  
  =cut
  
  sub init_tools {
      my($self) = @_;
  
      $self->{NOOP}               = 'Continue';
      $self->{NOECHO}             ||= '@ ';
  
      $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE} || 'Descrip.MMS';
      $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE};
      $self->{MAKE_APERL_FILE}    ||= 'Makeaperl.MMS';
      $self->{MAKEFILE_OLD}       ||= $self->eliminate_macros('$(FIRST_MAKEFILE)_old');
  #
  #   If an extension is not specified, then MMS/MMK assumes an
  #   an extension of .MMS.  If there really is no extension,
  #   then a trailing "." needs to be appended to specify a
  #   a null extension.
  #
      $self->{MAKEFILE} .= '.' unless $self->{MAKEFILE} =~ m/\./;
      $self->{FIRST_MAKEFILE} .= '.' unless $self->{FIRST_MAKEFILE} =~ m/\./;
      $self->{MAKE_APERL_FILE} .= '.' unless $self->{MAKE_APERL_FILE} =~ m/\./;
      $self->{MAKEFILE_OLD} .= '.' unless $self->{MAKEFILE_OLD} =~ m/\./;
  
      $self->{MACROSTART}         ||= '/Macro=(';
      $self->{MACROEND}           ||= ')';
      $self->{USEMAKEFILE}        ||= '/Descrip=';
  
      $self->{EQUALIZE_TIMESTAMP} ||= '$(ABSPERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';
  
      $self->{MOD_INSTALL} ||=
        $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
  install([ from_to => {split(' ', <STDIN>)}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
  CODE
  
      $self->{UMASK_NULL} = '! ';
  
      $self->SUPER::init_tools;
  
      # Use the default shell
      $self->{SHELL}    ||= 'Posix';
  
      # Redirection on VMS goes before the command, not after as on Unix.
      # $(DEV_NULL) is used once and its not worth going nuts over making
      # it work.  However, Unix's DEV_NULL is quite wrong for VMS.
      $self->{DEV_NULL}   = '';
  
      return;
  }
  
  =item init_platform (override)
  
  Add PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.
  
  MM_VMS_REVISION is for backwards compatibility before MM_VMS had a
  $VERSION.
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      $self->{MM_VMS_REVISION} = $Revision;
      $self->{MM_VMS_VERSION}  = $VERSION;
      $self->{PERL_VMS} = $self->catdir($self->{PERL_SRC}, 'VMS')
        if $self->{PERL_SRC};
  }
  
  
  =item platform_constants
  
  =cut
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      foreach my $macro (qw(PERL_VMS MM_VMS_REVISION MM_VMS_VERSION))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item init_VERSION (override)
  
  Override the *DEFINE_VERSION macros with VMS semantics.  Translate the
  MAKEMAKER filepath to VMS style.
  
  =cut
  
  sub init_VERSION {
      my $self = shift;
  
      $self->SUPER::init_VERSION;
  
      $self->{DEFINE_VERSION}    = '"$(VERSION_MACRO)=""$(VERSION)"""';
      $self->{XS_DEFINE_VERSION} = '"$(XS_VERSION_MACRO)=""$(XS_VERSION)"""';
      $self->{MAKEMAKER} = vmsify($INC{'ExtUtils/MakeMaker.pm'});
  }
  
  
  =item constants (override)
  
  Fixes up numerous file and directory macros to insure VMS syntax
  regardless of input syntax.  Also makes lists of files
  comma-separated.
  
  =cut
  
  sub constants {
      my($self) = @_;
  
      # Be kind about case for pollution
      for (@ARGV) { $_ = uc($_) if /POLLUTE/i; }
  
      # Cleanup paths for directories in MMS macros.
      foreach my $macro ( qw [
              INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB
              PERL_LIB PERL_ARCHLIB
              PERL_INC PERL_SRC ],
                          (map { 'INSTALL'.$_ } $self->installvars)
                        )
      {
          next unless defined $self->{$macro};
          next if $macro =~ /MAN/ && $self->{$macro} eq 'none';
          $self->{$macro} = $self->fixpath($self->{$macro},1);
      }
  
      # Cleanup paths for files in MMS macros.
      foreach my $macro ( qw[LIBPERL_A FIRST_MAKEFILE MAKEFILE_OLD
                             MAKE_APERL_FILE MYEXTLIB] )
      {
          next unless defined $self->{$macro};
          $self->{$macro} = $self->fixpath($self->{$macro},0);
      }
  
      # Fixup files for MMS macros
      # XXX is this list complete?
      for my $macro (qw/
                     FULLEXT VERSION_FROM
  	      /	) {
          next unless defined $self->{$macro};
          $self->{$macro} = $self->fixpath($self->{$macro},0);
      }
  
  
      for my $macro (qw/
                     OBJECT LDFROM
  	      /	) {
          next unless defined $self->{$macro};
  
          # Must expand macros before splitting on unescaped whitespace.
          $self->{$macro} = $self->eliminate_macros($self->{$macro});
          if ($self->{$macro} =~ /(?<!\^)\s/) {
              $self->{$macro} =~ s/(\\)?\n+\s+/ /g;
              $self->{$macro} = $self->wraplist(
                  map $self->fixpath($_,0), split /,?(?<!\^)\s+/, $self->{$macro}
              );
          }
          else {
              $self->{$macro} = $self->fixpath($self->{$macro},0);
          }
      }
  
      for my $macro (qw/ XS MAN1PODS MAN3PODS PM /) {
          # Where is the space coming from? --jhi
          next unless $self ne " " && defined $self->{$macro};
          my %tmp = ();
          for my $key (keys %{$self->{$macro}}) {
              $tmp{$self->fixpath($key,0)} =
                                       $self->fixpath($self->{$macro}{$key},0);
          }
          $self->{$macro} = \%tmp;
      }
  
      for my $macro (qw/ C O_FILES H /) {
          next unless defined $self->{$macro};
          my @tmp = ();
          for my $val (@{$self->{$macro}}) {
              push(@tmp,$self->fixpath($val,0));
          }
          $self->{$macro} = \@tmp;
      }
  
      # mms/k does not define a $(MAKE) macro.
      $self->{MAKE} = '$(MMS)$(MMSQUALIFIERS)';
  
      return $self->SUPER::constants;
  }
  
  
  =item special_targets
  
  Clear the default .SUFFIXES and put in our own list.
  
  =cut
  
  sub special_targets {
      my $self = shift;
  
      my $make_frag .= <<'MAKE_FRAG';
  .SUFFIXES :
  .SUFFIXES : $(OBJ_EXT) .c .cpp .cxx .xs
  
  MAKE_FRAG
  
      return $make_frag;
  }
  
  =item cflags (override)
  
  Bypass shell script and produce qualifiers for CC directly (but warn
  user if a shell script for this extension exists).  Fold multiple
  /Defines into one, since some C compilers pay attention to only one
  instance of this qualifier on the command line.
  
  =cut
  
  sub cflags {
      my($self,$libperl) = @_;
      my($quals) = $self->{CCFLAGS} || $Config{'ccflags'};
      my($definestr,$undefstr,$flagoptstr) = ('','','');
      my($incstr) = '/Include=($(PERL_INC)';
      my($name,$sys,@m);
  
      ( $name = $self->{NAME} . "_cflags" ) =~ s/:/_/g ;
      print "Unix shell script ".$Config{"$self->{'BASEEXT'}_cflags"}.
           " required to modify CC command for $self->{'BASEEXT'}\n"
      if ($Config{$name});
  
      if ($quals =~ / -[DIUOg]/) {
  	while ($quals =~ / -([Og])(\d*)\b/) {
  	    my($type,$lvl) = ($1,$2);
  	    $quals =~ s/ -$type$lvl\b\s*//;
  	    if ($type eq 'g') { $flagoptstr = '/NoOptimize'; }
  	    else { $flagoptstr = '/Optimize' . (defined($lvl) ? "=$lvl" : ''); }
  	}
  	while ($quals =~ / -([DIU])(\S+)/) {
  	    my($type,$def) = ($1,$2);
  	    $quals =~ s/ -$type$def\s*//;
  	    $def =~ s/"/""/g;
  	    if    ($type eq 'D') { $definestr .= qq["$def",]; }
  	    elsif ($type eq 'I') { $incstr .= ',' . $self->fixpath($def,1); }
  	    else                 { $undefstr  .= qq["$def",]; }
  	}
      }
      if (length $quals and $quals !~ m!/!) {
  	warn "MM_VMS: Ignoring unrecognized CCFLAGS elements \"$quals\"\n";
  	$quals = '';
      }
      $definestr .= q["PERL_POLLUTE",] if $self->{POLLUTE};
      if (length $definestr) { chop($definestr); $quals .= "/Define=($definestr)"; }
      if (length $undefstr)  { chop($undefstr);  $quals .= "/Undef=($undefstr)";   }
      # Deal with $self->{DEFINE} here since some C compilers pay attention
      # to only one /Define clause on command line, so we have to
      # conflate the ones from $Config{'ccflags'} and $self->{DEFINE}
      # ($self->{DEFINE} has already been VMSified in constants() above)
      if ($self->{DEFINE}) { $quals .= $self->{DEFINE}; }
      for my $type (qw(Def Undef)) {
  	my(@terms);
  	while ($quals =~ m:/${type}i?n?e?=([^/]+):ig) {
  		my $term = $1;
  		$term =~ s:^\((.+)\)$:$1:;
  		push @terms, $term;
  	    }
  	if ($type eq 'Def') {
  	    push @terms, qw[ $(DEFINE_VERSION) $(XS_DEFINE_VERSION) ];
  	}
  	if (@terms) {
  	    $quals =~ s:/${type}i?n?e?=[^/]+::ig;
  	    $quals .= "/${type}ine=(" . join(',',@terms) . ')';
  	}
      }
  
      $libperl or $libperl = $self->{LIBPERL_A} || "libperl.olb";
  
      # Likewise with $self->{INC} and /Include
      if ($self->{'INC'}) {
  	my(@includes) = split(/\s+/,$self->{INC});
  	foreach (@includes) {
  	    s/^-I//;
  	    $incstr .= ','.$self->fixpath($_,1);
  	}
      }
      $quals .= "$incstr)";
  #    $quals =~ s/,,/,/g; $quals =~ s/\(,/(/g;
      $self->{CCFLAGS} = $quals;
  
      $self->{PERLTYPE} ||= '';
  
      $self->{OPTIMIZE} ||= $flagoptstr || $Config{'optimize'};
      if ($self->{OPTIMIZE} !~ m!/!) {
  	if    ($self->{OPTIMIZE} =~ m!-g!) { $self->{OPTIMIZE} = '/Debug/NoOptimize' }
  	elsif ($self->{OPTIMIZE} =~ /-O(\d*)/) {
  	    $self->{OPTIMIZE} = '/Optimize' . (defined($1) ? "=$1" : '');
  	}
  	else {
  	    warn "MM_VMS: Can't parse OPTIMIZE \"$self->{OPTIMIZE}\"; using default\n" if length $self->{OPTIMIZE};
  	    $self->{OPTIMIZE} = '/Optimize';
  	}
      }
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  };
  }
  
  =item const_cccmd (override)
  
  Adds directives to point C preprocessor to the right place when
  handling #include E<lt>sys/foo.hE<gt> directives.  Also constructs CC
  command line a bit differently than MM_Unix method.
  
  =cut
  
  sub const_cccmd {
      my($self,$libperl) = @_;
      my(@m);
  
      return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
      return '' unless $self->needs_linking();
      if ($Config{'vms_cc_type'} eq 'gcc') {
          push @m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" Then Define/NoLog SYS GNU_CC_Include:[VMS]';
      }
      elsif ($Config{'vms_cc_type'} eq 'vaxc') {
          push @m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").eqs."" Then Define/NoLog SYS Sys$Library
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").nes."" Then Define/NoLog SYS VAXC$Include';
      }
      else {
          push @m,'
  .FIRST
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").eqs."" Then Define/NoLog SYS ',
  		($Config{'archname'} eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'
  	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").nes."" Then Define/NoLog SYS DECC$System_Include';
      }
  
      push(@m, "\n\nCCCMD = $Config{'cc'} \$(CCFLAGS)\$(OPTIMIZE)\n");
  
      $self->{CONST_CCCMD} = join('',@m);
  }
  
  
  =item tools_other (override)
  
  Throw in some dubious extra macros for Makefile args.
  
  Also keep around the old $(SAY) macro in case somebody's using it.
  
  =cut
  
  sub tools_other {
      my($self) = @_;
  
      # XXX Are these necessary?  Does anyone override them?  They're longer
      # than just typing the literal string.
      my $extra_tools = <<'EXTRA_TOOLS';
  
  # Just in case anyone is using the old macro.
  USEMACROS = $(MACROSTART)
  SAY = $(ECHO)
  
  EXTRA_TOOLS
  
      return $self->SUPER::tools_other . $extra_tools;
  }
  
  =item init_dist (override)
  
  VMSish defaults for some values.
  
    macro         description                     default
  
    ZIPFLAGS      flags to pass to ZIP            -Vu
  
    COMPRESS      compression command to          gzip
                  use for tarfiles
    SUFFIX        suffix to put on                -gz
                  compressed files
  
    SHAR          shar command to use             vms_share
  
    DIST_DEFAULT  default target to use to        tardist
                  create a distribution
  
    DISTVNAME     Use VERSION_SYM instead of      $(DISTNAME)-$(VERSION_SYM)
                  VERSION for the name
  
  =cut
  
  sub init_dist {
      my($self) = @_;
      $self->{ZIPFLAGS}     ||= '-Vu';
      $self->{COMPRESS}     ||= 'gzip';
      $self->{SUFFIX}       ||= '-gz';
      $self->{SHAR}         ||= 'vms_share';
      $self->{DIST_DEFAULT} ||= 'zipdist';
  
      $self->SUPER::init_dist;
  
      $self->{DISTVNAME} = "$self->{DISTNAME}-$self->{VERSION_SYM}"
        unless $self->{ARGS}{DISTVNAME};
  
      return;
  }
  
  =item c_o (override)
  
  Use VMS syntax on command line.  In particular, $(DEFINE) and
  $(PERL_INC) have been pulled into $(CCCMD).  Also use MM[SK] macros.
  
  =cut
  
  sub c_o {
      my($self) = @_;
      return '' unless $self->needs_linking();
      '
  .c$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c
  
  .cpp$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cpp
  
  .cxx$(OBJ_EXT) :
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cxx
  
  ';
  }
  
  =item xs_c (override)
  
  Use MM[SK] macros.
  
  =cut
  
  sub xs_c {
      my($self) = @_;
      return '' unless $self->needs_linking();
      '
  .xs.c :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET)
  ';
  }
  
  =item xs_o (override)
  
  Use MM[SK] macros, and VMS command line for C compiler.
  
  =cut
  
  sub xs_o {	# many makes are too dumb to use xs_c then c_o
      my($self) = @_;
      return '' unless $self->needs_linking();
      '
  .xs$(OBJ_EXT) :
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).c
  	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c
  ';
  }
  
  
  =item dlsyms (override)
  
  Create VMS linker options files specifying universal symbols for this
  extension's shareable image, and listing other shareable images or
  libraries to which it should be linked.
  
  =cut
  
  sub dlsyms {
      my($self,%attribs) = @_;
  
      return '' unless $self->needs_linking();
  
      my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
      my($vars)  = $attribs{DL_VARS}  || $self->{DL_VARS}  || [];
      my($funclist)  = $attribs{FUNCLIST}  || $self->{FUNCLIST}  || [];
      my(@m);
  
      unless ($self->{SKIPHASH}{'dynamic'}) {
  	push(@m,'
  dynamic :: $(INST_ARCHAUTODIR)$(BASEEXT).opt
  	$(NOECHO) $(NOOP)
  ');
      }
  
      push(@m,'
  static :: $(INST_ARCHAUTODIR)$(BASEEXT).opt
  	$(NOECHO) $(NOOP)
  ') unless $self->{SKIPHASH}{'static'};
  
      push @m,'
  $(INST_ARCHAUTODIR)$(BASEEXT).opt : $(BASEEXT).opt
  	$(CP) $(MMS$SOURCE) $(MMS$TARGET)
  
  $(BASEEXT).opt : Makefile.PL
  	$(PERLRUN) -e "use ExtUtils::Mksymlists;" -
  	',qq[-e "Mksymlists('NAME' => '$self->{NAME}', 'DL_FUNCS' => ],
  	neatvalue($funcs),q[, 'DL_VARS' => ],neatvalue($vars),
  	q[, 'FUNCLIST' => ],neatvalue($funclist),qq[)"\n];
  
      push @m, '	$(PERL) -e "print ""$(INST_STATIC)/Include=';
      if ($self->{OBJECT} =~ /\bBASEEXT\b/ or
          $self->{OBJECT} =~ /\b$self->{BASEEXT}\b/i) {
          push @m, ($Config{d_vms_case_sensitive_symbols}
  	           ? uc($self->{BASEEXT}) :'$(BASEEXT)');
      }
      else {  # We don't have a "main" object file, so pull 'em all in
          # Upcase module names if linker is being case-sensitive
          my($upcase) = $Config{d_vms_case_sensitive_symbols};
          my(@omods) = split ' ', $self->eliminate_macros($self->{OBJECT});
          for (@omods) {
              s/\.[^.]*$//;         # Trim off file type
              s[\$\(\w+_EXT\)][];   # even as a macro
              s/.*[:>\/\]]//;       # Trim off dir spec
              $_ = uc if $upcase;
          };
  
          my(@lines);
          my $tmp = shift @omods;
          foreach my $elt (@omods) {
              $tmp .= ",$elt";
              if (length($tmp) > 80) { push @lines, $tmp;  $tmp = ''; }
          }
          push @lines, $tmp;
          push @m, '(', join( qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""], @lines),')';
      }
      push @m, '\n$(INST_STATIC)/Library\n"";" >>$(MMS$TARGET)',"\n";
  
      if (length $self->{LDLOADLIBS}) {
          my($line) = '';
          foreach my $lib (split ' ', $self->{LDLOADLIBS}) {
              $lib =~ s%\$%\\\$%g;  # Escape '$' in VMS filespecs
              if (length($line) + length($lib) > 160) {
                  push @m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";
                  $line = $lib . '\n';
              }
              else { $line .= $lib . '\n'; }
          }
          push @m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if $line;
      }
  
      join('',@m);
  
  }
  
  =item dynamic_lib (override)
  
  Use VMS Link command.
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      return '' unless $self->needs_linking(); #might be because of a subdir
  
      return '' unless $self->has_link_code();
  
      my($otherldflags) = $attribs{OTHERLDFLAGS} || "";
      my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
      my $shr = $Config{'dbgprefix'} . 'PerlShr';
      my(@m);
      push @m,"
  
  OTHERLDFLAGS = $otherldflags
  INST_DYNAMIC_DEP = $inst_dynamic_dep
  
  ";
      push @m, '
  $(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
  	If F$TrnLNm("',$shr,'").eqs."" Then Define/NoLog/User ',"$shr Sys\$Share:$shr.$Config{'dlext'}",'
  	Link $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) $(BASEEXT).opt/Option,$(PERL_INC)perlshr_attr.opt/Option
  ';
  
      join('',@m);
  }
  
  
  =item static_lib (override)
  
  Use VMS commands to manipulate object library.
  
  =cut
  
  sub static_lib {
      my($self) = @_;
      return '' unless $self->needs_linking();
  
      return '
  $(INST_STATIC) :
  	$(NOECHO) $(NOOP)
  ' unless ($self->{OBJECT} or @{$self->{C} || []} or $self->{MYEXTLIB});
  
      my(@m);
      push @m,'
  # Rely on suffix rule for update action
  $(OBJECT) : $(INST_ARCHAUTODIR)$(DFSEP).exists
  
  $(INST_STATIC) : $(OBJECT) $(MYEXTLIB)
  ';
      # If this extension has its own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      push(@m, "\t",'$(CP) $(MYEXTLIB) $(MMS$TARGET)',"\n") if $self->{MYEXTLIB};
  
      push(@m,"\t",'If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)',"\n");
  
      # if there was a library to copy, then we can't use MMS$SOURCE_LIST,
      # 'cause it's a library and you can't stick them in other libraries.
      # In that case, we use $OBJECT instead and hope for the best
      if ($self->{MYEXTLIB}) {
        push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(OBJECT)',"\n");
      } else {
        push(@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)',"\n");
      }
  
      push @m, "\t\$(NOECHO) \$(PERL) -e 1 >\$(INST_ARCHAUTODIR)extralibs.ld\n";
      foreach my $lib (split ' ', $self->{EXTRALIBS}) {
        push(@m,"\t",'$(NOECHO) $(PERL) -e "print qq{',$lib,'\n}" >>$(INST_ARCHAUTODIR)extralibs.ld',"\n");
      }
      join('',@m);
  }
  
  
  =item extra_clean_files
  
  Clean up some OS specific files.  Plus the temp file used to shorten
  a lot of commands.  And the name mangler database.
  
  =cut
  
  sub extra_clean_files {
      return qw(
                *.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *.Opt $(BASEEXT).bso
                .MM_Tmp cxx_repository
               );
  }
  
  
  =item zipfile_target
  
  =item tarfile_target
  
  =item shdist_target
  
  Syntax for invoking shar, tar and zip differs from that for Unix.
  
  =cut
  
  sub zipfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).zip : distdir
  	$(PREOP)
  	$(ZIP) "$(ZIPFLAGS)" $(MMS$TARGET) [.$(DISTVNAME)...]*.*;
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  }
  
  sub tarfile_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  $(DISTVNAME).tar$(SUFFIX) : distdir
  	$(PREOP)
  	$(TO_UNIX)
          $(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)...]
  	$(RM_RF) $(DISTVNAME)
  	$(COMPRESS) $(DISTVNAME).tar
  	$(POSTOP)
  MAKE_FRAG
  }
  
  sub shdist_target {
      my($self) = shift;
  
      return <<'MAKE_FRAG';
  shdist : distdir
  	$(PREOP)
  	$(SHAR) [.$(DISTVNAME)...]*.*; $(DISTVNAME).share
  	$(RM_RF) $(DISTVNAME)
  	$(POSTOP)
  MAKE_FRAG
  }
  
  
  # --- Test and Installation Sections ---
  
  =item install (override)
  
  Work around DCL's 255 character limit several times,and use
  VMS-style command line quoting in a few cases.
  
  =cut
  
  sub install {
      my($self, %attribs) = @_;
      my(@m);
  
      push @m, q[
  install :: all pure_install doc_install
  	$(NOECHO) $(NOOP)
  
  install_perl :: all pure_perl_install doc_perl_install
  	$(NOECHO) $(NOOP)
  
  install_site :: all pure_site_install doc_site_install
  	$(NOECHO) $(NOOP)
  
  pure_install :: pure_$(INSTALLDIRS)_install
  	$(NOECHO) $(NOOP)
  
  doc_install :: doc_$(INSTALLDIRS)_install
          $(NOECHO) $(NOOP)
  
  pure__install : pure_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  doc__install : doc_site_install
  	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
  
  # This hack brought to you by DCL's 255-character command line limit
  pure_perl_install ::
  ];
      push @m,
  q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
  ] unless $self->{NO_PACKLIST};
  
      push @m,
  q[	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLPRIVLIB) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLARCHLIB) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLBIN) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLMAN3DIR) " >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  
  # Likewise
  pure_site_install ::
  ];
      push @m,
  q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
  ] unless $self->{NO_PACKLIST};
  
      push @m,
  q[	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLSITELIB) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLSITEARCH) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLSITEBIN) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLSITEMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLSITEMAN3DIR) " >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
  
  pure_vendor_install ::
  ];
      push @m,
  q[	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
  	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
  ] unless $self->{NO_PACKLIST};
  
      push @m,
  q[	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLVENDORLIB) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLVENDORARCH) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLVENDORBIN) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLVENDORMAN1DIR) " >>.MM_tmp
  	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLVENDORMAN3DIR) " >>.MM_tmp
  	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ];
  
      push @m, q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(NOOP)
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(NOOP)
  
  doc_vendor_install ::
  	$(NOECHO) $(NOOP)
  
  ] if $self->{NO_PERLLOCAL};
  
      push @m, q[
  # Ditto
  doc_perl_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLPRIVLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  # And again
  doc_site_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLSITELIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  doc_vendor_install ::
  	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLVENDORLIB)|" >.MM_tmp
  	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  
  ] unless $self->{NO_PERLLOCAL};
  
      push @m, q[
  uninstall :: uninstall_from_$(INSTALLDIRS)dirs
  	$(NOECHO) $(NOOP)
  
  uninstall_from_perldirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
  	$(NOECHO) $(ECHO) "Uninstall is now deprecated and makes no actual changes."
  	$(NOECHO) $(ECHO) "Please check the list above carefully for errors, and manually remove"
  	$(NOECHO) $(ECHO) "the appropriate files.  Sorry for the inconvenience."
  
  uninstall_from_sitedirs ::
  	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
  	$(NOECHO) $(ECHO) "Uninstall is now deprecated and makes no actual changes."
  	$(NOECHO) $(ECHO) "Please check the list above carefully for errors, and manually remove"
  	$(NOECHO) $(ECHO) "the appropriate files.  Sorry for the inconvenience."
  ];
  
      join('',@m);
  }
  
  =item perldepend (override)
  
  Use VMS-style syntax for files; it's cheaper to just do it directly here
  than to have the MM_Unix method call C<catfile> repeatedly.  Also, if
  we have to rebuild Config.pm, use MM[SK] to do it.
  
  =cut
  
  sub perldepend {
      my($self) = @_;
      my(@m);
  
      if ($self->{OBJECT}) {
          # Need to add an object file dependency on the perl headers.
          # this is very important for XS modules in perl.git development.
  
          push @m, $self->_perl_header_files_fragment(""); # empty separator on VMS as its in the $(PERL_INC)
      }
  
      if ($self->{PERL_SRC}) {
  	my(@macros);
  	my($mmsquals) = '$(USEMAKEFILE)[.vms]$(FIRST_MAKEFILE)';
  	push(@macros,'__AXP__=1') if $Config{'archname'} eq 'VMS_AXP';
  	push(@macros,'DECC=1')    if $Config{'vms_cc_type'} eq 'decc';
  	push(@macros,'GNUC=1')    if $Config{'vms_cc_type'} eq 'gcc';
  	push(@macros,'SOCKET=1')  if $Config{'d_has_sockets'};
  	push(@macros,qq["CC=$Config{'cc'}"])  if $Config{'cc'} =~ m!/!;
  	$mmsquals .= '$(USEMACROS)' . join(',',@macros) . '$(MACROEND)' if @macros;
  	push(@m,q[
  # Check for unpropagated config.sh changes. Should never happen.
  # We do NOT just update config.h because that is not sufficient.
  # An out of date config.h is not fatal but complains loudly!
  $(PERL_INC)config.h : $(PERL_SRC)config.sh
  	$(NOOP)
  
  $(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh
  	$(NOECHO) Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.h or genconfig.pl"
  	olddef = F$Environment("Default")
  	Set Default $(PERL_SRC)
  	$(MMS)],$mmsquals,);
  	if ($self->{PERL_ARCHLIB} =~ m|\[-| && $self->{PERL_SRC} =~ m|(\[-+)|) {
  	    my($prefix,$target) = ($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm',0));
  	    $target =~ s/\Q$prefix/[/;
  	    push(@m," $target");
  	}
  	else { push(@m,' $(MMS$TARGET)'); }
  	push(@m,q[
  	Set Default 'olddef'
  ]);
      }
  
      push(@m, join(" ", map($self->fixpath($_,0),values %{$self->{XS}}))." : \$(XSUBPPDEPS)\n")
        if %{$self->{XS}};
  
      join('',@m);
  }
  
  
  =item makeaperl (override)
  
  Undertake to build a new set of Perl images using VMS commands.  Since
  VMS does dynamic loading, it's not necessary to statically link each
  extension into the Perl image, so this isn't the normal build path.
  Consequently, it hasn't really been tested, and may well be incomplete.
  
  =cut
  
  our %olbs;  # needs to be localized
  
  sub makeaperl {
      my($self, %attribs) = @_;
      my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmpdir, $libperl) =
        @attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};
      my(@m);
      push @m, "
  # --- MakeMaker makeaperl section ---
  MAP_TARGET    = $target
  ";
      return join '', @m if $self->{PARENT};
  
      my($dir) = join ":", @{$self->{DIR}};
  
      unless ($self->{MAKEAPERL}) {
  	push @m, q{
  $(MAKE_APERL_FILE) : $(FIRST_MAKEFILE)
  	$(NOECHO) $(ECHO) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
  	$(NOECHO) $(PERLRUNINST) \
  		Makefile.PL DIR=}, $dir, q{ \
  		FIRST_MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
  		MAKEAPERL=1 NORECURS=1 };
  
  	push @m, map(q[ \\\n\t\t"$_"], @ARGV),q{
  
  $(MAP_TARGET) :: $(MAKE_APERL_FILE)
  	$(MAKE)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
  };
  	push @m, "\n";
  
  	return join '', @m;
      }
  
  
      my($linkcmd,@optlibs,@staticpkgs,$extralist,$targdir,$libperldir,%libseen);
      local($_);
  
      # The front matter of the linkcommand...
      $linkcmd = join ' ', $Config{'ld'},
  	    grep($_, @Config{qw(large split ldflags ccdlflags)});
      $linkcmd =~ s/\s+/ /g;
  
      # Which *.olb files could we make use of...
      local(%olbs);       # XXX can this be lexical?
      $olbs{$self->{INST_ARCHAUTODIR}} = "$self->{BASEEXT}\$(LIB_EXT)";
      require File::Find;
      File::Find::find(sub {
  	return unless m/\Q$self->{LIB_EXT}\E$/;
  	return if m/^libperl/;
  
  	if( exists $self->{INCLUDE_EXT} ){
  		my $found = 0;
  
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything not explicitly marked for inclusion.
  		# DynaLoader is implied.
  		foreach my $incl ((@{$self->{INCLUDE_EXT}},'DynaLoader')){
  			if( $xx eq $incl ){
  				$found++;
  				last;
  			}
  		}
  		return unless $found;
  	}
  	elsif( exists $self->{EXCLUDE_EXT} ){
  		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
  		$xx =~ s,/?$_,,;
  		$xx =~ s,/,::,g;
  
  		# Throw away anything explicitly marked for exclusion
  		foreach my $excl (@{$self->{EXCLUDE_EXT}}){
  			return if( $xx eq $excl );
  		}
  	}
  
  	$olbs{$ENV{DEFAULT}} = $_;
      }, grep( -d $_, @{$searchdirs || []}));
  
      # We trust that what has been handed in as argument will be buildable
      $static = [] unless $static;
      @olbs{@{$static}} = (1) x @{$static};
  
      $extra = [] unless $extra && ref $extra eq 'ARRAY';
      # Sort the object libraries in inverse order of
      # filespec length to try to insure that dependent extensions
      # will appear before their parents, so the linker will
      # search the parent library to resolve references.
      # (e.g. Intuit::DWIM will precede Intuit, so unresolved
      # references from [.intuit.dwim]dwim.obj can be found
      # in [.intuit]intuit.olb).
      for (sort { length($a) <=> length($b) } keys %olbs) {
  	next unless $olbs{$_} =~ /\Q$self->{LIB_EXT}\E$/;
  	my($dir) = $self->fixpath($_,1);
  	my($extralibs) = $dir . "extralibs.ld";
  	my($extopt) = $dir . $olbs{$_};
  	$extopt =~ s/$self->{LIB_EXT}$/.opt/;
  	push @optlibs, "$dir$olbs{$_}";
  	# Get external libraries this extension will need
  	if (-f $extralibs ) {
  	    my %seenthis;
  	    open my $list, "<", $extralibs or warn $!,next;
  	    while (<$list>) {
  		chomp;
  		# Include a library in the link only once, unless it's mentioned
  		# multiple times within a single extension's options file, in which
  		# case we assume the builder needed to search it again later in the
  		# link.
  		my $skip = exists($libseen{$_}) && !exists($seenthis{$_});
  		$libseen{$_}++;  $seenthis{$_}++;
  		next if $skip;
  		push @$extra,$_;
  	    }
  	}
  	# Get full name of extension for ExtUtils::Miniperl
  	if (-f $extopt) {
  	    open my $opt, '<', $extopt or die $!;
  	    while (<$opt>) {
  		next unless /(?:UNIVERSAL|VECTOR)=boot_([\w_]+)/;
  		my $pkg = $1;
  		$pkg =~ s#__*#::#g;
  		push @staticpkgs,$pkg;
  	    }
  	}
      }
      # Place all of the external libraries after all of the Perl extension
      # libraries in the final link, in order to maximize the opportunity
      # for XS code from multiple extensions to resolve symbols against the
      # same external library while only including that library once.
      push @optlibs, @$extra;
  
      $target = "Perl$Config{'exe_ext'}" unless $target;
      my $shrtarget;
      ($shrtarget,$targdir) = fileparse($target);
      $shrtarget =~ s/^([^.]*)/$1Shr/;
      $shrtarget = $targdir . $shrtarget;
      $target = "Perlshr.$Config{'dlext'}" unless $target;
      $tmpdir = "[]" unless $tmpdir;
      $tmpdir = $self->fixpath($tmpdir,1);
      if (@optlibs) { $extralist = join(' ',@optlibs); }
      else          { $extralist = ''; }
      # Let ExtUtils::Liblist find the necessary libs for us (but skip PerlShr)
      # that's what we're building here).
      push @optlibs, grep { !/PerlShr/i } split ' ', +($self->ext())[2];
      if ($libperl) {
  	unless (-f $libperl || -f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',$libperl))) {
  	    print "Warning: $libperl not found\n";
  	    undef $libperl;
  	}
      }
      unless ($libperl) {
  	if (defined $self->{PERL_SRC}) {
  	    $libperl = $self->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}");
  	} elsif (-f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}")) ) {
  	} else {
  	    print "Warning: $libperl not found
      If you're going to build a static perl binary, make sure perl is installed
      otherwise ignore this warning\n";
  	}
      }
      $libperldir = $self->fixpath((fileparse($libperl))[1],1);
  
      push @m, '
  # Fill in the target you want to produce if it\'s not perl
  MAP_TARGET    = ',$self->fixpath($target,0),'
  MAP_SHRTARGET = ',$self->fixpath($shrtarget,0),"
  MAP_LINKCMD   = $linkcmd
  MAP_PERLINC   = ", $perlinc ? map('"$_" ',@{$perlinc}) : '',"
  MAP_EXTRA     = $extralist
  MAP_LIBPERL = ",$self->fixpath($libperl,0),'
  ';
  
  
      push @m,"\n${tmpdir}Makeaperl.Opt : \$(MAP_EXTRA)\n";
      foreach (@optlibs) {
  	push @m,'	$(NOECHO) $(PERL) -e "print q{',$_,'}" >>$(MMS$TARGET)',"\n";
      }
      push @m,"\n${tmpdir}PerlShr.Opt :\n\t";
      push @m,'$(NOECHO) $(PERL) -e "print q{$(MAP_SHRTARGET)}" >$(MMS$TARGET)',"\n";
  
      push @m,'
  $(MAP_SHRTARGET) : $(MAP_LIBPERL) Makeaperl.Opt ',"${libperldir}Perlshr_Attr.Opt",'
  	$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_LIBPERL), Makeaperl.Opt/Option ',"${libperldir}Perlshr_Attr.Opt/Option",'
  $(MAP_TARGET) : $(MAP_SHRTARGET) ',"${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}PerlShr.Opt",'
  	$(MAP_LINKCMD) ',"${tmpdir}perlmain\$(OBJ_EXT)",', PerlShr.Opt/Option
  	$(NOECHO) $(ECHO) "To install the new ""$(MAP_TARGET)"" binary, say"
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
  	$(NOECHO) $(ECHO) "To remove the intermediate files, say
  	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
  ';
      push @m,"\n${tmpdir}perlmain.c : \$(FIRST_MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmpdir}Writemain.tmp\n";
      push @m, "# More from the 255-char line length limit\n";
      foreach (@staticpkgs) {
  	push @m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmpdir}Writemain.tmp\n];
      }
  
      push @m, sprintf <<'MAKE_FRAG', $tmpdir, $tmpdir;
  	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@F)" %sWritemain.tmp >$(MMS$TARGET)
  	$(NOECHO) $(RM_F) %sWritemain.tmp
  MAKE_FRAG
  
      push @m, q[
  # Still more from the 255-char line length limit
  doc_inst_perl :
  	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
  	$(NOECHO) $(ECHO) "Perl binary $(MAP_TARGET)|" >.MM_tmp
  	$(NOECHO) $(ECHO) "MAP_STATIC|$(MAP_STATIC)|" >>.MM_tmp
  	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
  	$(NOECHO) $(ECHO) -e "MAP_LIBPERL|$(MAP_LIBPERL)|" >>.MM_tmp
  	$(NOECHO) $(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q[
  	$(NOECHO) $(RM_F) .MM_tmp
  ];
  
      push @m, "
  inst_perl : pure_inst_perl doc_inst_perl
  	\$(NOECHO) \$(NOOP)
  
  pure_inst_perl : \$(MAP_TARGET)
  	$self->{CP} \$(MAP_SHRTARGET) ",$self->fixpath($Config{'installbin'},1),"
  	$self->{CP} \$(MAP_TARGET) ",$self->fixpath($Config{'installbin'},1),"
  
  clean :: map_clean
  	\$(NOECHO) \$(NOOP)
  
  map_clean :
  	\$(RM_F) ${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}perlmain.c \$(FIRST_MAKEFILE)
  	\$(RM_F) ${tmpdir}Makeaperl.Opt ${tmpdir}PerlShr.Opt \$(MAP_TARGET)
  ";
  
      join '', @m;
  }
  
  
  # --- Output postprocessing section ---
  
  =item maketext_filter (override)
  
  Insure that colons marking targets are preceded by space, in order
  to distinguish the target delimiter from a colon appearing as
  part of a filespec.
  
  =cut
  
  sub maketext_filter {
      my($self, $text) = @_;
  
      $text =~ s/^([^\s:=]+)(:+\s)/$1 $2/mg;
      return $text;
  }
  
  =item prefixify (override)
  
  prefixifying on VMS is simple.  Each should simply be:
  
      perl_root:[some.dir]
  
  which can just be converted to:
  
      volume:[your.prefix.some.dir]
  
  otherwise you get the default layout.
  
  In effect, your search prefix is ignored and $Config{vms_prefix} is
  used instead.
  
  =cut
  
  sub prefixify {
      my($self, $var, $sprefix, $rprefix, $default) = @_;
  
      # Translate $(PERLPREFIX) to a real path.
      $rprefix = $self->eliminate_macros($rprefix);
      $rprefix = vmspath($rprefix) if $rprefix;
      $sprefix = vmspath($sprefix) if $sprefix;
  
      $default = vmsify($default)
        unless $default =~ /\[.*\]/;
  
      (my $var_no_install = $var) =~ s/^install//;
      my $path = $self->{uc $var} ||
                 $ExtUtils::MM_Unix::Config_Override{lc $var} ||
                 $Config{lc $var} || $Config{lc $var_no_install};
  
      if( !$path ) {
          warn "  no Config found for $var.\n" if $Verbose >= 2;
          $path = $self->_prefixify_default($rprefix, $default);
      }
      elsif( !$self->{ARGS}{PREFIX} || !$self->file_name_is_absolute($path) ) {
          # do nothing if there's no prefix or if its relative
      }
      elsif( $sprefix eq $rprefix ) {
          warn "  no new prefix.\n" if $Verbose >= 2;
      }
      else {
  
          warn "  prefixify $var => $path\n"     if $Verbose >= 2;
          warn "    from $sprefix to $rprefix\n" if $Verbose >= 2;
  
          my($path_vol, $path_dirs) = $self->splitpath( $path );
          if( $path_vol eq $Config{vms_prefix}.':' ) {
              warn "  $Config{vms_prefix}: seen\n" if $Verbose >= 2;
  
              $path_dirs =~ s{^\[}{\[.} unless $path_dirs =~ m{^\[\.};
              $path = $self->_catprefix($rprefix, $path_dirs);
          }
          else {
              $path = $self->_prefixify_default($rprefix, $default);
          }
      }
  
      print "    now $path\n" if $Verbose >= 2;
      return $self->{uc $var} = $path;
  }
  
  
  sub _prefixify_default {
      my($self, $rprefix, $default) = @_;
  
      warn "  cannot prefix, using default.\n" if $Verbose >= 2;
  
      if( !$default ) {
          warn "No default!\n" if $Verbose >= 1;
          return;
      }
      if( !$rprefix ) {
          warn "No replacement prefix!\n" if $Verbose >= 1;
          return '';
      }
  
      return $self->_catprefix($rprefix, $default);
  }
  
  sub _catprefix {
      my($self, $rprefix, $default) = @_;
  
      my($rvol, $rdirs) = $self->splitpath($rprefix);
      if( $rvol ) {
          return $self->catpath($rvol,
                                     $self->catdir($rdirs, $default),
                                     ''
                                    )
      }
      else {
          return $self->catdir($rdirs, $default);
      }
  }
  
  
  =item cd
  
  =cut
  
  sub cd {
      my($self, $dir, @cmds) = @_;
  
      $dir = vmspath($dir);
  
      my $cmd = join "\n\t", map "$_", @cmds;
  
      # No leading tab makes it look right when embedded
      my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd;
  startdir = F$Environment("Default")
  	Set Default %s
  	%s
  	Set Default 'startdir'
  MAKE_FRAG
  
      # No trailing newline makes this easier to embed
      chomp $make_frag;
  
      return $make_frag;
  }
  
  
  =item oneliner
  
  =cut
  
  sub oneliner {
      my($self, $cmd, $switches) = @_;
      $switches = [] unless defined $switches;
  
      # Strip leading and trailing newlines
      $cmd =~ s{^\n+}{};
      $cmd =~ s{\n+$}{};
  
      $cmd = $self->quote_literal($cmd);
      $cmd = $self->escape_newlines($cmd);
  
      # Switches must be quoted else they will be lowercased.
      $switches = join ' ', map { qq{"$_"} } @$switches;
  
      return qq{\$(ABSPERLRUN) $switches -e $cmd "--"};
  }
  
  
  =item B<echo>
  
  perl trips up on "<foo>" thinking it's an input redirect.  So we use the
  native Write command instead.  Besides, its faster.
  
  =cut
  
  sub echo {
      my($self, $text, $file, $opts) = @_;
  
      # Compatibility with old options
      if( !ref $opts ) {
          my $append = $opts;
          $opts = { append => $append || 0 };
      }
      my $opencmd = $opts->{append} ? 'Open/Append' : 'Open/Write';
  
      $opts->{allow_variables} = 0 unless defined $opts->{allow_variables};
  
      my $ql_opts = { allow_variables => $opts->{allow_variables} };
  
      my @cmds = ("\$(NOECHO) $opencmd MMECHOFILE $file ");
      push @cmds, map { '$(NOECHO) Write MMECHOFILE '.$self->quote_literal($_, $ql_opts) }
                  split /\n/, $text;
      push @cmds, '$(NOECHO) Close MMECHOFILE';
      return @cmds;
  }
  
  
  =item quote_literal
  
  =cut
  
  sub quote_literal {
      my($self, $text, $opts) = @_;
      $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};
  
      # I believe this is all we should need.
      $text =~ s{"}{""}g;
  
      $text = $opts->{allow_variables}
        ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);
  
      return qq{"$text"};
  }
  
  =item escape_dollarsigns
  
  Quote, don't escape.
  
  =cut
  
  sub escape_dollarsigns {
      my($self, $text) = @_;
  
      # Quote dollar signs which are not starting a variable
      $text =~ s{\$ (?!\() }{"\$"}gx;
  
      return $text;
  }
  
  
  =item escape_all_dollarsigns
  
  Quote, don't escape.
  
  =cut
  
  sub escape_all_dollarsigns {
      my($self, $text) = @_;
  
      # Quote dollar signs
      $text =~ s{\$}{"\$\"}gx;
  
      return $text;
  }
  
  =item escape_newlines
  
  =cut
  
  sub escape_newlines {
      my($self, $text) = @_;
  
      $text =~ s{\n}{-\n}g;
  
      return $text;
  }
  
  =item max_exec_len
  
  256 characters.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      return $self->{_MAX_EXEC_LEN} ||= 256;
  }
  
  =item init_linker
  
  =cut
  
  sub init_linker {
      my $self = shift;
      $self->{EXPORT_LIST} ||= '$(BASEEXT).opt';
  
      my $shr = $Config{dbgprefix} . 'PERLSHR';
      if ($self->{PERL_SRC}) {
          $self->{PERL_ARCHIVE} ||=
            $self->catfile($self->{PERL_SRC}, "$shr.$Config{'dlext'}");
      }
      else {
          $self->{PERL_ARCHIVE} ||=
            $ENV{$shr} ? $ENV{$shr} : "Sys\$Share:$shr.$Config{'dlext'}";
      }
  
      $self->{PERL_ARCHIVE_AFTER} ||= '';
  }
  
  
  =item catdir (override)
  
  =item catfile (override)
  
  Eliminate the macros in the output to the MMS/MMK file.
  
  (File::Spec::VMS used to do this for us, but it's being removed)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      # Process the macros on VMS MMS/MMK
      my @args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @_;
  
      my $dir = $self->SUPER::catdir(@args);
  
      # Fix up the directory and force it to VMS format.
      $dir = $self->fixpath($dir, 1);
  
      return $dir;
  }
  
  sub catfile {
      my $self = shift;
  
      # Process the macros on VMS MMS/MMK
      my @args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @_;
  
      my $file = $self->SUPER::catfile(@args);
  
      $file = vmsify($file);
  
      return $file
  }
  
  
  =item eliminate_macros
  
  Expands MM[KS]/Make macros in a text string, using the contents of
  identically named elements of C<%$self>, and returns the result
  as a file specification in Unix syntax.
  
  NOTE:  This is the canonical version of the method.  The version in
  File::Spec::VMS is deprecated.
  
  =cut
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless $path;
      $self = {} unless ref $self;
  
      if ($path =~ /\s/) {
        return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
      }
  
      my($npath) = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) {
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  =item fixpath
  
     my $path = $mm->fixpath($path);
     my $path = $mm->fixpath($path, $is_dir);
  
  Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  in any directory specification, in order to avoid juxtaposing two
  VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  are all macro, so that we can tell how long the expansion is, and avoid
  overrunning DCL's command buffer when MM[KS] is running.
  
  fixpath() checks to see whether the result matches the name of a
  directory in the current default directory and returns a directory or
  file specification accordingly.  C<$is_dir> can be set to true to
  force fixpath() to consider the path to be a directory or false to force
  it to be a file.
  
  NOTE:  This is the canonical version of the method.  The version in
  File::Spec::VMS is deprecated.
  
  =cut
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ /[ \t]/) {
        return join ' ',
               map { $self->fixpath($_,$force_path) }
  	     split /[ \t]+/, $path;
      }
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) {
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
  
      return $fixedpath;
  }
  
  
  =item os_flavor
  
  VMS is VMS.
  
  =cut
  
  sub os_flavor {
      return('VMS');
  }
  
  =back
  
  
  =head1 AUTHOR
  
  Original author Charles Bailey F<bailey@newman.upenn.edu>
  
  Maintained by Michael G Schwern F<schwern@pobox.com>
  
  See L<ExtUtils::MakeMaker> for patching and contact information.
  
  
  =cut
  
  1;
  
EXTUTILS_MM_VMS

$fatpacked{"ExtUtils/MM_VOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_VOS';
  package ExtUtils::MM_VOS;
  
  use strict;
  our $VERSION = '6.92';
  
  require ExtUtils::MM_Unix;
  our @ISA = qw(ExtUtils::MM_Unix);
  
  
  =head1 NAME
  
  ExtUtils::MM_VOS - VOS specific subclass of ExtUtils::MM_Unix
  
  =head1 SYNOPSIS
  
    Don't use this module directly.
    Use ExtUtils::MM and let it choose.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Unix which contains functionality for
  VOS.
  
  Unless otherwise stated it works just like ExtUtils::MM_Unix
  
  =head2 Overridden methods
  
  =head3 extra_clean_files
  
  Cleanup VOS core files
  
  =cut
  
  sub extra_clean_files {
      return qw(*.kp);
  }
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com> with code from ExtUtils::MM_Unix
  
  =head1 SEE ALSO
  
  L<ExtUtils::MakeMaker>
  
  =cut
  
  
  1;
EXTUTILS_MM_VOS

$fatpacked{"ExtUtils/MM_Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN32';
  package ExtUtils::MM_Win32;
  
  use strict;
  
  
  =head1 NAME
  
  ExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker
  
  =head1 SYNOPSIS
  
   use ExtUtils::MM_Win32; # Done internally by ExtUtils::MakeMaker if needed
  
  =head1 DESCRIPTION
  
  See ExtUtils::MM_Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =cut
  
  use ExtUtils::MakeMaker::Config;
  use File::Basename;
  use File::Spec;
  use ExtUtils::MakeMaker qw( neatvalue );
  
  require ExtUtils::MM_Any;
  require ExtUtils::MM_Unix;
  our @ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
  our $VERSION = '6.92';
  
  $ENV{EMXSHELL} = 'sh'; # to run `commands`
  
  my ( $BORLAND, $GCC, $DLLTOOL ) = _identify_compiler_environment( \%Config );
  
  sub _identify_compiler_environment {
  	my ( $config ) = @_;
  
  	my $BORLAND = $config->{cc} =~ /^bcc/i ? 1 : 0;
  	my $GCC     = $config->{cc} =~ /\bgcc\b/i ? 1 : 0;
  	my $DLLTOOL = $config->{dlltool} || 'dlltool';
  
  	return ( $BORLAND, $GCC, $DLLTOOL );
  }
  
  
  =head2 Overridden methods
  
  =over 4
  
  =item B<dlsyms>
  
  =cut
  
  sub dlsyms {
      my($self,%attribs) = @_;
  
      my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
      my($vars)  = $attribs{DL_VARS} || $self->{DL_VARS} || [];
      my($funclist) = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
      my($imports)  = $attribs{IMPORTS} || $self->{IMPORTS} || {};
      my(@m);
  
      if (not $self->{SKIPHASH}{'dynamic'}) {
  	push(@m,"
  $self->{BASEEXT}.def: Makefile.PL
  ",
       q!	$(PERLRUN) -MExtUtils::Mksymlists \\
       -e "Mksymlists('NAME'=>\"!, $self->{NAME},
       q!\", 'DLBASE' => '!,$self->{DLBASE},
       # The above two lines quoted differently to work around
       # a bug in the 4DOS/4NT command line interpreter.  The visible
       # result of the bug was files named q('extension_name',) *with the
       # single quotes and the comma* in the extension build directories.
       q!', 'DL_FUNCS' => !,neatvalue($funcs),
       q!, 'FUNCLIST' => !,neatvalue($funclist),
       q!, 'IMPORTS' => !,neatvalue($imports),
       q!, 'DL_VARS' => !, neatvalue($vars), q!);"
  !);
      }
      join('',@m);
  }
  
  =item replace_manpage_separator
  
  Changes the path separator with .
  
  =cut
  
  sub replace_manpage_separator {
      my($self,$man) = @_;
      $man =~ s,/+,.,g;
      $man;
  }
  
  
  =item B<maybe_command>
  
  Since Windows has nothing as simple as an executable bit, we check the
  file extension.
  
  The PATHEXT env variable will be used to get a list of extensions that
  might indicate a command, otherwise .com, .exe, .bat and .cmd will be
  used by default.
  
  =cut
  
  sub maybe_command {
      my($self,$file) = @_;
      my @e = exists($ENV{'PATHEXT'})
            ? split(/;/, $ENV{PATHEXT})
  	  : qw(.com .exe .bat .cmd);
      my $e = '';
      for (@e) { $e .= "\Q$_\E|" }
      chop $e;
      # see if file ends in one of the known extensions
      if ($file =~ /($e)$/i) {
  	return $file if -e $file;
      }
      else {
  	for (@e) {
  	    return "$file$_" if -e "$file$_";
  	}
      }
      return;
  }
  
  
  =item B<init_DIRFILESEP>
  
  Using \ for Windows.
  
  =cut
  
  sub init_DIRFILESEP {
      my($self) = shift;
  
      # The ^ makes sure its not interpreted as an escape in nmake
      $self->{DIRFILESEP} = $self->is_make_type('nmake') ? '^\\' :
                            $self->is_make_type('dmake') ? '\\\\'
                                                         : '\\';
  }
  
  =item init_tools
  
  Override some of the slower, portable commands with Windows specific ones.
  
  =cut
  
  sub init_tools {
      my ($self) = @_;
  
      $self->{NOOP}     ||= 'rem';
      $self->{DEV_NULL} ||= '> NUL';
  
      $self->{FIXIN}    ||= $self->{PERL_CORE} ?
        "\$(PERLRUN) $self->{PERL_SRC}/win32/bin/pl2bat.pl" :
        'pl2bat.bat';
  
      $self->SUPER::init_tools;
  
      # Setting SHELL from $Config{sh} can break dmake.  Its ok without it.
      delete $self->{SHELL};
  
      return;
  }
  
  
  =item init_others
  
  Override the default link and compile tools.
  
  LDLOADLIBS's default is changed to $Config{libs}.
  
  Adjustments are made for Borland's quirks needing -L to come first.
  
  =cut
  
  sub init_others {
      my $self = shift;
  
      $self->{LD}     ||= 'link';
      $self->{AR}     ||= 'lib';
  
      $self->SUPER::init_others;
  
      $self->{LDLOADLIBS} ||= $Config{libs};
      # -Lfoo must come first for Borland, so we put it in LDDLFLAGS
      if ($BORLAND) {
          my $libs = $self->{LDLOADLIBS};
          my $libpath = '';
          while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /) {
              $libpath .= ' ' if length $libpath;
              $libpath .= $1;
          }
          $self->{LDLOADLIBS} = $libs;
          $self->{LDDLFLAGS} ||= $Config{lddlflags};
          $self->{LDDLFLAGS} .= " $libpath";
      }
  
      return;
  }
  
  
  =item init_platform
  
  Add MM_Win32_VERSION.
  
  =item platform_constants
  
  =cut
  
  sub init_platform {
      my($self) = shift;
  
      $self->{MM_Win32_VERSION} = $VERSION;
  
      return;
  }
  
  sub platform_constants {
      my($self) = shift;
      my $make_frag = '';
  
      foreach my $macro (qw(MM_Win32_VERSION))
      {
          next unless defined $self->{$macro};
          $make_frag .= "$macro = $self->{$macro}\n";
      }
  
      return $make_frag;
  }
  
  
  =item constants
  
  Add MAXLINELENGTH for dmake before all the constants are output.
  
  =cut
  
  sub constants {
      my $self = shift;
  
      my $make_text = $self->SUPER::constants;
      return $make_text unless $self->is_make_type('dmake');
  
      # dmake won't read any single "line" (even those with escaped newlines)
      # larger than a certain size which can be as small as 8k.  PM_TO_BLIB
      # on large modules like DateTime::TimeZone can create lines over 32k.
      # So we'll crank it up to a <ironic>WHOPPING</ironic> 64k.
      #
      # This has to come here before all the constants and not in
      # platform_constants which is after constants.
      my $size = $self->{MAXLINELENGTH} || 800000;
      my $prefix = qq{
  # Get dmake to read long commands like PM_TO_BLIB
  MAXLINELENGTH = $size
  
  };
  
      return $prefix . $make_text;
  }
  
  
  =item special_targets
  
  Add .USESHELL target for dmake.
  
  =cut
  
  sub special_targets {
      my($self) = @_;
  
      my $make_frag = $self->SUPER::special_targets;
  
      $make_frag .= <<'MAKE_FRAG' if $self->is_make_type('dmake');
  .USESHELL :
  MAKE_FRAG
  
      return $make_frag;
  }
  
  
  =item static_lib
  
  Changes how to run the linker.
  
  The rest is duplicate code from MM_Unix.  Should move the linker code
  to its own method.
  
  =cut
  
  sub static_lib {
      my($self) = @_;
      return '' unless $self->has_link_code;
  
      my(@m);
      push(@m, <<'END');
  $(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
  	$(RM_RF) $@
  END
  
      # If this extension has its own library (eg SDBM_File)
      # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
      push @m, <<'MAKE_FRAG' if $self->{MYEXTLIB};
  	$(CP) $(MYEXTLIB) $@
  MAKE_FRAG
  
      push @m,
  q{	$(AR) }.($BORLAND ? '$@ $(OBJECT:^"+")'
  			  : ($GCC ? '-ru $@ $(OBJECT)'
  			          : '-out:$@ $(OBJECT)')).q{
  	$(CHMOD) $(PERM_RWX) $@
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)\extralibs.ld
  };
  
      # Old mechanism - still available:
      push @m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};
  	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)\ext.libs
  MAKE_FRAG
  
      join('', @m);
  }
  
  
  =item dynamic_lib
  
  Complicated stuff for Win32 that I don't understand. :(
  
  =cut
  
  sub dynamic_lib {
      my($self, %attribs) = @_;
      return '' unless $self->needs_linking(); #might be because of a subdir
  
      return '' unless $self->has_link_code;
  
      my($otherldflags) = $attribs{OTHERLDFLAGS} || ($BORLAND ? 'c0d32.obj': '');
      my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
      my($ldfrom) = '$(LDFROM)';
      my(@m);
  
      push(@m,'
  # This section creates the dynamically loadable $(INST_DYNAMIC)
  # from $(OBJECT) and possibly $(MYEXTLIB).
  OTHERLDFLAGS = '.$otherldflags.'
  INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
  
  $(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
  ');
      if ($GCC) {
        push(@m,
         q{	}.$DLLTOOL.q{ --def $(EXPORT_LIST) --output-exp dll.exp
  	$(LD) -o $@ -Wl,--base-file -Wl,dll.base $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) dll.exp
  	}.$DLLTOOL.q{ --def $(EXPORT_LIST) --base-file dll.base --output-exp dll.exp
  	$(LD) -o $@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) dll.exp });
      } elsif ($BORLAND) {
        push(@m,
         q{	$(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) }.$ldfrom.q{,$@,,}
         .($self->is_make_type('dmake')
                  ? q{$(PERL_ARCHIVE:s,/,\,) $(LDLOADLIBS:s,/,\,) }
  		 .q{$(MYEXTLIB:s,/,\,),$(EXPORT_LIST:s,/,\,)}
  		: q{$(subst /,\,$(PERL_ARCHIVE)) $(subst /,\,$(LDLOADLIBS)) }
  		 .q{$(subst /,\,$(MYEXTLIB)),$(subst /,\,$(EXPORT_LIST))})
         .q{,$(RESFILES)});
      } else {	# VC
        push(@m,
         q{	$(LD) -out:$@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) }
        .q{$(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) -def:$(EXPORT_LIST)});
  
        # Embed the manifest file if it exists
        push(@m, q{
  	if exist $@.manifest mt -nologo -manifest $@.manifest -outputresource:$@;2
  	if exist $@.manifest del $@.manifest});
      }
      push @m, '
  	$(CHMOD) $(PERM_RWX) $@
  ';
  
      join('',@m);
  }
  
  =item extra_clean_files
  
  Clean out some extra dll.{base,exp} files which might be generated by
  gcc.  Otherwise, take out all *.pdb files.
  
  =cut
  
  sub extra_clean_files {
      my $self = shift;
  
      return $GCC ? (qw(dll.base dll.exp)) : ('*.pdb');
  }
  
  =item init_linker
  
  =cut
  
  sub init_linker {
      my $self = shift;
  
      $self->{PERL_ARCHIVE}       = "\$(PERL_INC)\\$Config{libperl}";
      $self->{PERL_ARCHIVE_AFTER} = '';
      $self->{EXPORT_LIST}        = '$(BASEEXT).def';
  }
  
  
  =item perl_script
  
  Checks for the perl program under several common perl extensions.
  
  =cut
  
  sub perl_script {
      my($self,$file) = @_;
      return $file if -r $file && -f _;
      return "$file.pl"  if -r "$file.pl" && -f _;
      return "$file.plx" if -r "$file.plx" && -f _;
      return "$file.bat" if -r "$file.bat" && -f _;
      return;
  }
  
  
  =item xs_o
  
  This target is stubbed out.  Not sure why.
  
  =cut
  
  sub xs_o {
      return ''
  }
  
  
  =item pasthru
  
  All we send is -nologo to nmake to prevent it from printing its damned
  banner.
  
  =cut
  
  sub pasthru {
      my($self) = shift;
      return "PASTHRU = " . ($self->is_make_type('nmake') ? "-nologo" : "");
  }
  
  
  =item arch_check (override)
  
  Normalize all arguments for consistency of comparison.
  
  =cut
  
  sub arch_check {
      my $self = shift;
  
      # Win32 is an XS module, minperl won't have it.
      # arch_check() is not critical, so just fake it.
      return 1 unless $self->can_load_xs;
      return $self->SUPER::arch_check( map { $self->_normalize_path_name($_) } @_);
  }
  
  sub _normalize_path_name {
      my $self = shift;
      my $file = shift;
  
      require Win32;
      my $short = Win32::GetShortPathName($file);
      return defined $short ? lc $short : lc $file;
  }
  
  
  =item oneliner
  
  These are based on what command.com does on Win98.  They may be wrong
  for other Windows shells, I don't know.
  
  =cut
  
  sub oneliner {
      my($self, $cmd, $switches) = @_;
      $switches = [] unless defined $switches;
  
      # Strip leading and trailing newlines
      $cmd =~ s{^\n+}{};
      $cmd =~ s{\n+$}{};
  
      $cmd = $self->quote_literal($cmd);
      $cmd = $self->escape_newlines($cmd);
  
      $switches = join ' ', @$switches;
  
      return qq{\$(ABSPERLRUN) $switches -e $cmd --};
  }
  
  
  sub quote_literal {
      my($self, $text, $opts) = @_;
      $opts->{allow_variables} = 1 unless defined $opts->{allow_variables};
  
      # See: http://www.autohotkey.net/~deleyd/parameters/parameters.htm#CPP
  
      # Apply the Microsoft C/C++ parsing rules
      $text =~ s{\\\\"}{\\\\\\\\\\"}g;  # \\" -> \\\\\"
      $text =~ s{(?<!\\)\\"}{\\\\\\"}g; # \"  -> \\\"
      $text =~ s{(?<!\\)"}{\\"}g;       # "   -> \"
      $text = qq{"$text"} if $text =~ /[ \t]/;
  
      # Apply the Command Prompt parsing rules (cmd.exe)
      my @text = split /("[^"]*")/, $text;
      # We should also escape parentheses, but it breaks one-liners containing
      # $(MACRO)s in makefiles.
      s{([<>|&^@!])}{^$1}g foreach grep { !/^"[^"]*"$/ } @text;
      $text = join('', @text);
  
      # dmake expands {{ to { and }} to }.
      if( $self->is_make_type('dmake') ) {
          $text =~ s/{/{{/g;
          $text =~ s/}/}}/g;
      }
  
      $text = $opts->{allow_variables}
        ? $self->escape_dollarsigns($text) : $self->escape_all_dollarsigns($text);
  
      return $text;
  }
  
  
  sub escape_newlines {
      my($self, $text) = @_;
  
      # Escape newlines
      $text =~ s{\n}{\\\n}g;
  
      return $text;
  }
  
  
  =item cd
  
  dmake can handle Unix style cd'ing but nmake (at least 1.5) cannot.  It
  wants:
  
      cd dir1\dir2
      command
      another_command
      cd ..\..
  
  =cut
  
  sub cd {
      my($self, $dir, @cmds) = @_;
  
      return $self->SUPER::cd($dir, @cmds) unless $self->is_make_type('nmake');
  
      my $cmd = join "\n\t", map "$_", @cmds;
  
      my $updirs = $self->catdir(map { $self->updir } $self->splitdir($dir));
  
      # No leading tab and no trailing newline makes for easier embedding.
      my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd, $updirs;
  cd %s
  	%s
  	cd %s
  MAKE_FRAG
  
      chomp $make_frag;
  
      return $make_frag;
  }
  
  
  =item max_exec_len
  
  nmake 1.50 limits command length to 2048 characters.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      return $self->{_MAX_EXEC_LEN} ||= 2 * 1024;
  }
  
  
  =item os_flavor
  
  Windows is Win32.
  
  =cut
  
  sub os_flavor {
      return('Win32');
  }
  
  
  =item cflags
  
  Defines the PERLDLL symbol if we are configured for static building since all
  code destined for the perl5xx.dll must be compiled with the PERLDLL symbol
  defined.
  
  =cut
  
  sub cflags {
      my($self,$libperl)=@_;
      return $self->{CFLAGS} if $self->{CFLAGS};
      return '' unless $self->needs_linking();
  
      my $base = $self->SUPER::cflags($libperl);
      foreach (split /\n/, $base) {
          /^(\S*)\s*=\s*(\S*)$/ and $self->{$1} = $2;
      };
      $self->{CCFLAGS} .= " -DPERLDLL" if ($self->{LINKTYPE} eq 'static');
  
      return $self->{CFLAGS} = qq{
  CCFLAGS = $self->{CCFLAGS}
  OPTIMIZE = $self->{OPTIMIZE}
  PERLTYPE = $self->{PERLTYPE}
  };
  
  }
  
  sub is_make_type {
      my($self, $type) = @_;
      return !! ($self->make =~ /\b$type(?:\.exe)?$/);
  }
  
  1;
  __END__
  
  =back
  
  =cut
  
  
EXTUTILS_MM_WIN32

$fatpacked{"ExtUtils/MM_Win95.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MM_WIN95';
  package ExtUtils::MM_Win95;
  
  use strict;
  
  our $VERSION = '6.92';
  
  require ExtUtils::MM_Win32;
  our @ISA = qw(ExtUtils::MM_Win32);
  
  use ExtUtils::MakeMaker::Config;
  
  
  =head1 NAME
  
  ExtUtils::MM_Win95 - method to customize MakeMaker for Win9X
  
  =head1 SYNOPSIS
  
    You should not be using this module directly.
  
  =head1 DESCRIPTION
  
  This is a subclass of ExtUtils::MM_Win32 containing changes necessary
  to get MakeMaker playing nice with command.com and other Win9Xisms.
  
  =head2 Overridden methods
  
  Most of these make up for limitations in the Win9x/nmake command shell.
  Mostly its lack of &&.
  
  =over 4
  
  
  =item xs_c
  
  The && problem.
  
  =cut
  
  sub xs_c {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.c:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
  	'
  }
  
  
  =item xs_cpp
  
  The && problem
  
  =cut
  
  sub xs_cpp {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs.cpp:
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.cpp
  	';
  }
  
  =item xs_o
  
  The && problem.
  
  =cut
  
  sub xs_o {
      my($self) = shift;
      return '' unless $self->needs_linking();
      '
  .xs$(OBJ_EXT):
  	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
  	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.c
  	';
  }
  
  
  =item max_exec_len
  
  Win98 chokes on things like Encode if we set the max length to nmake's max
  of 2K.  So we go for a more conservative value of 1K.
  
  =cut
  
  sub max_exec_len {
      my $self = shift;
  
      return $self->{_MAX_EXEC_LEN} ||= 1024;
  }
  
  
  =item os_flavor
  
  Win95 and Win98 and WinME are collectively Win9x and Win32
  
  =cut
  
  sub os_flavor {
      my $self = shift;
      return ($self->SUPER::os_flavor, 'Win9x');
  }
  
  
  =back
  
  
  =head1 AUTHOR
  
  Code originally inside MM_Win32.  Original author unknown.
  
  Currently maintained by Michael G Schwern C<schwern@pobox.com>.
  
  Send patches and ideas to C<makemaker@perl.org>.
  
  See https://metacpan.org/release/ExtUtils-MakeMaker.
  
  =cut
  
  
  1;
EXTUTILS_MM_WIN95

$fatpacked{"ExtUtils/MY.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MY';
  package ExtUtils::MY;
  
  use strict;
  require ExtUtils::MM;
  
  our $VERSION = '6.92';
  our @ISA = qw(ExtUtils::MM);
  
  {
      package MY;
      our @ISA = qw(ExtUtils::MY);
  }
  
  sub DESTROY {}
  
  
  =head1 NAME
  
  ExtUtils::MY - ExtUtils::MakeMaker subclass for customization
  
  =head1 SYNOPSIS
  
    # in your Makefile.PL
    sub MY::whatever {
        ...
    }
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY>
  
  ExtUtils::MY is a subclass of ExtUtils::MM.  Its provided in your
  Makefile.PL for you to add and override MakeMaker functionality.
  
  It also provides a convenient alias via the MY class.
  
  ExtUtils::MY might turn out to be a temporary solution, but MY won't
  go away.
  
  =cut
EXTUTILS_MY

$fatpacked{"ExtUtils/MakeMaker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER';
  # $Id$
  package ExtUtils::MakeMaker;
  
  use strict;
  
  BEGIN {require 5.006;}
  
  require Exporter;
  use ExtUtils::MakeMaker::Config;
  use Carp;
  use File::Path;
  
  our $Verbose = 0;       # exported
  our @Parent;            # needs to be localized
  our @Get_from_Config;   # referenced by MM_Unix
  our @MM_Sections;
  our @Overridable;
  my @Prepend_parent;
  my %Recognized_Att_Keys;
  
  our $VERSION = '6.92';
  $VERSION = eval $VERSION;  ## no critic [BuiltinFunctions::ProhibitStringyEval]
  
  # Emulate something resembling CVS $Revision$
  (our $Revision = $VERSION) =~ s{_}{};
  $Revision = int $Revision * 10000;
  
  our $Filename = __FILE__;   # referenced outside MakeMaker
  
  our @ISA = qw(Exporter);
  our @EXPORT    = qw(&WriteMakefile &writeMakefile $Verbose &prompt);
  our @EXPORT_OK = qw($VERSION &neatvalue &mkbootstrap &mksymlists
                      &WriteEmptyMakefile);
  
  # These will go away once the last of the Win32 & VMS specific code is
  # purged.
  my $Is_VMS     = $^O eq 'VMS';
  my $Is_Win32   = $^O eq 'MSWin32';
  
  full_setup();
  
  require ExtUtils::MM;  # Things like CPAN assume loading ExtUtils::MakeMaker
                         # will give them MM.
  
  require ExtUtils::MY;  # XXX pre-5.8 versions of ExtUtils::Embed expect
                         # loading ExtUtils::MakeMaker will give them MY.
                         # This will go when Embed is its own CPAN module.
  
  
  sub WriteMakefile {
      croak "WriteMakefile: Need even number of args" if @_ % 2;
  
      require ExtUtils::MY;
      my %att = @_;
  
      _convert_compat_attrs(\%att);
  
      _verify_att(\%att);
  
      my $mm = MM->new(\%att);
      $mm->flush;
  
      return $mm;
  }
  
  
  # Basic signatures of the attributes WriteMakefile takes.  Each is the
  # reference type.  Empty value indicate it takes a non-reference
  # scalar.
  my %Att_Sigs;
  my %Special_Sigs = (
   AUTHOR             => 'ARRAY',
   C                  => 'ARRAY',
   CONFIG             => 'ARRAY',
   CONFIGURE          => 'CODE',
   DIR                => 'ARRAY',
   DL_FUNCS           => 'HASH',
   DL_VARS            => 'ARRAY',
   EXCLUDE_EXT        => 'ARRAY',
   EXE_FILES          => 'ARRAY',
   FUNCLIST           => 'ARRAY',
   H                  => 'ARRAY',
   IMPORTS            => 'HASH',
   INCLUDE_EXT        => 'ARRAY',
   LIBS               => ['ARRAY',''],
   MAN1PODS           => 'HASH',
   MAN3PODS           => 'HASH',
   META_ADD           => 'HASH',
   META_MERGE         => 'HASH',
   OBJECT             => ['ARRAY', ''],
   PL_FILES           => 'HASH',
   PM                 => 'HASH',
   PMLIBDIRS          => 'ARRAY',
   PMLIBPARENTDIRS    => 'ARRAY',
   PREREQ_PM          => 'HASH',
   BUILD_REQUIRES     => 'HASH',
   CONFIGURE_REQUIRES => 'HASH',
   TEST_REQUIRES      => 'HASH',
   SKIP               => 'ARRAY',
   TYPEMAPS           => 'ARRAY',
   XS                 => 'HASH',
   VERSION            => ['version',''],
   _KEEP_AFTER_FLUSH  => '',
  
   clean      => 'HASH',
   depend     => 'HASH',
   dist       => 'HASH',
   dynamic_lib=> 'HASH',
   linkext    => 'HASH',
   macro      => 'HASH',
   postamble  => 'HASH',
   realclean  => 'HASH',
   test       => 'HASH',
   tool_autosplit => 'HASH',
  );
  
  @Att_Sigs{keys %Recognized_Att_Keys} = ('') x keys %Recognized_Att_Keys;
  @Att_Sigs{keys %Special_Sigs} = values %Special_Sigs;
  
  sub _convert_compat_attrs { #result of running several times should be same
      my($att) = @_;
      if (exists $att->{AUTHOR}) {
          if ($att->{AUTHOR}) {
              if (!ref($att->{AUTHOR})) {
                  my $t = $att->{AUTHOR};
                  $att->{AUTHOR} = [$t];
              }
          } else {
                  $att->{AUTHOR} = [];
          }
      }
  }
  
  sub _verify_att {
      my($att) = @_;
  
      while( my($key, $val) = each %$att ) {
          my $sig = $Att_Sigs{$key};
          unless( defined $sig ) {
              warn "WARNING: $key is not a known parameter.\n";
              next;
          }
  
          my @sigs   = ref $sig ? @$sig : $sig;
          my $given  = ref $val;
          unless( grep { _is_of_type($val, $_) } @sigs ) {
              my $takes = join " or ", map { _format_att($_) } @sigs;
  
              my $has = _format_att($given);
              warn "WARNING: $key takes a $takes not a $has.\n".
                   "         Please inform the author.\n";
          }
      }
  }
  
  
  # Check if a given thing is a reference or instance of $type
  sub _is_of_type {
      my($thing, $type) = @_;
  
      return 1 if ref $thing eq $type;
  
      local $SIG{__DIE__};
      return 1 if eval{ $thing->isa($type) };
  
      return 0;
  }
  
  
  sub _format_att {
      my $given = shift;
  
      return $given eq ''        ? "string/number"
           : uc $given eq $given ? "$given reference"
           :                       "$given object"
           ;
  }
  
  
  sub prompt ($;$) {  ## no critic
      my($mess, $def) = @_;
      confess("prompt function called without an argument")
          unless defined $mess;
  
      my $isa_tty = -t STDIN && (-t STDOUT || !(-f STDOUT || -c STDOUT)) ;
  
      my $dispdef = defined $def ? "[$def] " : " ";
      $def = defined $def ? $def : "";
  
      local $|=1;
      local $\;
      print "$mess $dispdef";
  
      my $ans;
      if ($ENV{PERL_MM_USE_DEFAULT} || (!$isa_tty && eof STDIN)) {
          print "$def\n";
      }
      else {
          $ans = <STDIN>;
          if( defined $ans ) {
              $ans =~ s{\015?\012$}{};
          }
          else { # user hit ctrl-D
              print "\n";
          }
      }
  
      return (!defined $ans || $ans eq '') ? $def : $ans;
  }
  
  sub eval_in_subdirs {
      my($self) = @_;
      use Cwd qw(cwd abs_path);
      my $pwd = cwd() || die "Can't figure out your cwd!";
  
      local @INC = map eval {abs_path($_) if -e} || $_, @INC;
      push @INC, '.';     # '.' has to always be at the end of @INC
  
      foreach my $dir (@{$self->{DIR}}){
          my($abs) = $self->catdir($pwd,$dir);
          eval { $self->eval_in_x($abs); };
          last if $@;
      }
      chdir $pwd;
      die $@ if $@;
  }
  
  sub eval_in_x {
      my($self,$dir) = @_;
      chdir $dir or carp("Couldn't change to directory $dir: $!");
  
      {
          package main;
          do './Makefile.PL';
      };
      if ($@) {
  #         if ($@ =~ /prerequisites/) {
  #             die "MakeMaker WARNING: $@";
  #         } else {
  #             warn "WARNING from evaluation of $dir/Makefile.PL: $@";
  #         }
          die "ERROR from evaluation of $dir/Makefile.PL: $@";
      }
  }
  
  
  # package name for the classes into which the first object will be blessed
  my $PACKNAME = 'PACK000';
  
  sub full_setup {
      $Verbose ||= 0;
  
      my @attrib_help = qw/
  
      AUTHOR ABSTRACT ABSTRACT_FROM BINARY_LOCATION
      C CAPI CCFLAGS CONFIG CONFIGURE DEFINE DIR DISTNAME DISTVNAME
      DL_FUNCS DL_VARS
      EXCLUDE_EXT EXE_FILES FIRST_MAKEFILE
      FULLPERL FULLPERLRUN FULLPERLRUNINST
      FUNCLIST H IMPORTS
  
      INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB INST_MAN1DIR INST_MAN3DIR
      INSTALLDIRS
      DESTDIR PREFIX INSTALL_BASE
      PERLPREFIX      SITEPREFIX      VENDORPREFIX
      INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
      INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
      INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN
      INSTALLMAN1DIR          INSTALLMAN3DIR
      INSTALLSITEMAN1DIR      INSTALLSITEMAN3DIR
      INSTALLVENDORMAN1DIR    INSTALLVENDORMAN3DIR
      INSTALLSCRIPT   INSTALLSITESCRIPT  INSTALLVENDORSCRIPT
      PERL_LIB        PERL_ARCHLIB
      SITELIBEXP      SITEARCHEXP
  
      INC INCLUDE_EXT LDFROM LIB LIBPERL_A LIBS LICENSE
      LINKTYPE MAKE MAKEAPERL MAKEFILE MAKEFILE_OLD MAN1PODS MAN3PODS MAP_TARGET
      META_ADD META_MERGE MIN_PERL_VERSION BUILD_REQUIRES CONFIGURE_REQUIRES
      MYEXTLIB NAME NEEDS_LINKING NOECHO NO_META NO_MYMETA NO_PACKLIST NO_PERLLOCAL
      NORECURS NO_VC OBJECT OPTIMIZE PERL_MALLOC_OK PERL PERLMAINCC PERLRUN
      PERLRUNINST PERL_CORE
      PERL_SRC PERM_DIR PERM_RW PERM_RWX MAGICXS
      PL_FILES PM PM_FILTER PMLIBDIRS PMLIBPARENTDIRS POLLUTE PPM_INSTALL_EXEC PPM_UNINSTALL_EXEC
      PPM_INSTALL_SCRIPT PPM_UNINSTALL_SCRIPT PREREQ_FATAL PREREQ_PM PREREQ_PRINT PRINT_PREREQ
      SIGN SKIP TEST_REQUIRES TYPEMAPS UNINST VERSION VERSION_FROM XS XSOPT XSPROTOARG
      XS_VERSION clean depend dist dynamic_lib linkext macro realclean
      tool_autosplit
  
      MACPERL_SRC MACPERL_LIB MACLIBS_68K MACLIBS_PPC MACLIBS_SC MACLIBS_MRC
      MACLIBS_ALL_68K MACLIBS_ALL_PPC MACLIBS_SHARED
          /;
  
      # IMPORTS is used under OS/2 and Win32
  
      # @Overridable is close to @MM_Sections but not identical.  The
      # order is important. Many subroutines declare macros. These
      # depend on each other. Let's try to collect the macros up front,
      # then pasthru, then the rules.
  
      # MM_Sections are the sections we have to call explicitly
      # in Overridable we have subroutines that are used indirectly
  
  
      @MM_Sections =
          qw(
  
   post_initialize const_config constants platform_constants
   tool_autosplit tool_xsubpp tools_other
  
   makemakerdflt
  
   dist macro depend cflags const_loadlibs const_cccmd
   post_constants
  
   pasthru
  
   special_targets
   c_o xs_c xs_o
   top_targets blibdirs linkext dlsyms dynamic_bs dynamic
   dynamic_lib static static_lib manifypods processPL
   installbin subdirs
   clean_subdirs clean realclean_subdirs realclean
   metafile signature
   dist_basics dist_core distdir dist_test dist_ci distmeta distsignature
   install force perldepend makefile staticmake test ppd
  
            ); # loses section ordering
  
      @Overridable = @MM_Sections;
      push @Overridable, qw[
  
   libscan makeaperl needs_linking
   subdir_x test_via_harness test_via_script
  
   init_VERSION init_dist init_INST init_INSTALL init_DEST init_dirscan
   init_PM init_MANPODS init_xs init_PERL init_DIRFILESEP init_linker
                           ];
  
      push @MM_Sections, qw[
  
   pm_to_blib selfdocument
  
                           ];
  
      # Postamble needs to be the last that was always the case
      push @MM_Sections, "postamble";
      push @Overridable, "postamble";
  
      # All sections are valid keys.
      @Recognized_Att_Keys{@MM_Sections} = (1) x @MM_Sections;
  
      # we will use all these variables in the Makefile
      @Get_from_Config =
          qw(
             ar cc cccdlflags ccdlflags dlext dlsrc exe_ext full_ar ld
             lddlflags ldflags libc lib_ext obj_ext osname osvers ranlib
             sitelibexp sitearchexp so
            );
  
      # 5.5.3 doesn't have any concept of vendor libs
      push @Get_from_Config, qw( vendorarchexp vendorlibexp ) if $] >= 5.006;
  
      foreach my $item (@attrib_help){
          $Recognized_Att_Keys{$item} = 1;
      }
      foreach my $item (@Get_from_Config) {
          $Recognized_Att_Keys{uc $item} = $Config{$item};
          print "Attribute '\U$item\E' => '$Config{$item}'\n"
              if ($Verbose >= 2);
      }
  
      #
      # When we eval a Makefile.PL in a subdirectory, that one will ask
      # us (the parent) for the values and will prepend "..", so that
      # all files to be installed end up below OUR ./blib
      #
      @Prepend_parent = qw(
             INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT
             MAP_TARGET INST_MAN1DIR INST_MAN3DIR PERL_SRC
             PERL FULLPERL
      );
  }
  
  sub writeMakefile {
      die <<END;
  
  The extension you are trying to build apparently is rather old and
  most probably outdated. We detect that from the fact, that a
  subroutine "writeMakefile" is called, and this subroutine is not
  supported anymore since about October 1994.
  
  Please contact the author or look into CPAN (details about CPAN can be
  found in the FAQ and at http:/www.perl.com) for a more recent version
  of the extension. If you're really desperate, you can try to change
  the subroutine name from writeMakefile to WriteMakefile and rerun
  'perl Makefile.PL', but you're most probably left alone, when you do
  so.
  
  The MakeMaker team
  
  END
  }
  
  sub new {
      my($class,$self) = @_;
      my($key);
  
      _convert_compat_attrs($self) if defined $self && $self;
  
      # Store the original args passed to WriteMakefile()
      foreach my $k (keys %$self) {
          $self->{ARGS}{$k} = $self->{$k};
      }
  
      $self = {} unless defined $self;
  
      # Temporarily bless it into MM so it can be used as an
      # object.  It will be blessed into a temp package later.
      bless $self, "MM";
  
      # Cleanup all the module requirement bits
      for my $key (qw(PREREQ_PM BUILD_REQUIRES CONFIGURE_REQUIRES TEST_REQUIRES)) {
          $self->{$key}      ||= {};
          $self->clean_versions( $key );
      }
  
  
      if ("@ARGV" =~ /\bPREREQ_PRINT\b/) {
          $self->_PREREQ_PRINT;
      }
  
      # PRINT_PREREQ is RedHatism.
      if ("@ARGV" =~ /\bPRINT_PREREQ\b/) {
          $self->_PRINT_PREREQ;
     }
  
      print "MakeMaker (v$VERSION)\n" if $Verbose;
      if (-f "MANIFEST" && ! -f "Makefile" && ! $ENV{PERL_CORE}){
          check_manifest();
      }
  
      check_hints($self);
  
      # Translate X.Y.Z to X.00Y00Z
      if( defined $self->{MIN_PERL_VERSION} ) {
          $self->{MIN_PERL_VERSION} =~ s{ ^ (\d+) \. (\d+) \. (\d+) $ }
                                        {sprintf "%d.%03d%03d", $1, $2, $3}ex;
      }
  
      my $perl_version_ok = eval {
          local $SIG{__WARN__} = sub {
              # simulate "use warnings FATAL => 'all'" for vintage perls
              die @_;
          };
          !$self->{MIN_PERL_VERSION} or $self->{MIN_PERL_VERSION} <= $]
      };
      if (!$perl_version_ok) {
          if (!defined $perl_version_ok) {
              die <<'END';
  Warning: MIN_PERL_VERSION is not in a recognized format.
  Recommended is a quoted numerical value like '5.005' or '5.008001'.
  END
          }
          elsif ($self->{PREREQ_FATAL}) {
              die sprintf <<"END", $self->{MIN_PERL_VERSION}, $];
  MakeMaker FATAL: perl version too low for this distribution.
  Required is %s. We run %s.
  END
          }
          else {
              warn sprintf
                  "Warning: Perl version %s or higher required. We run %s.\n",
                  $self->{MIN_PERL_VERSION}, $];
          }
      }
  
      my %configure_att;         # record &{$self->{CONFIGURE}} attributes
      my(%initial_att) = %$self; # record initial attributes
  
      my(%unsatisfied) = ();
      my $prereqs = $self->_all_prereqs;
      foreach my $prereq (sort keys %$prereqs) {
          my $required_version = $prereqs->{$prereq};
  
          my $pr_version = 0;
          my $installed_file;
  
          if ( $prereq eq 'perl' ) {
            if ( defined $required_version && $required_version =~ /^v?[\d_\.]+$/
                 || $required_version !~ /^v?[\d_\.]+$/ ) {
              require version;
              my $normal = eval { version->parse( $required_version ) };
              $required_version = $normal if defined $normal;
            }
            $installed_file = $prereq;
            $pr_version = $];
          }
          else {
            $installed_file = MM->_installed_file_for_module($prereq);
            $pr_version = MM->parse_version($installed_file) if $installed_file;
            $pr_version = 0 if $pr_version eq 'undef';
          }
  
          # convert X.Y_Z alpha version #s to X.YZ for easier comparisons
          $pr_version =~ s/(\d+)\.(\d+)_(\d+)/$1.$2$3/;
  
          if (!$installed_file) {
              warn sprintf "Warning: prerequisite %s %s not found.\n",
                $prereq, $required_version
                     unless $self->{PREREQ_FATAL}
                         or $ENV{PERL_CORE};
  
              $unsatisfied{$prereq} = 'not installed';
          }
          elsif ($pr_version < $required_version ){
              warn sprintf "Warning: prerequisite %s %s not found. We have %s.\n",
                $prereq, $required_version, ($pr_version || 'unknown version')
                    unless $self->{PREREQ_FATAL}
                         or $ENV{PERL_CORE};
  
              $unsatisfied{$prereq} = $required_version ? $required_version : 'unknown version' ;
          }
      }
  
      if (%unsatisfied && $self->{PREREQ_FATAL}){
          my $failedprereqs = join "\n", map {"    $_ $unsatisfied{$_}"}
                              sort { $a cmp $b } keys %unsatisfied;
          die <<"END";
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
      }
  
      if (defined $self->{CONFIGURE}) {
          if (ref $self->{CONFIGURE} eq 'CODE') {
              %configure_att = %{&{$self->{CONFIGURE}}};
              _convert_compat_attrs(\%configure_att);
              $self = { %$self, %configure_att };
          } else {
              croak "Attribute 'CONFIGURE' to WriteMakefile() not a code reference\n";
          }
      }
  
      # This is for old Makefiles written pre 5.00, will go away
      if ( Carp::longmess("") =~ /runsubdirpl/s ){
          carp("WARNING: Please rerun 'perl Makefile.PL' to regenerate your Makefiles\n");
      }
  
      my $newclass = ++$PACKNAME;
      local @Parent = @Parent;    # Protect against non-local exits
      {
          print "Blessing Object into class [$newclass]\n" if $Verbose>=2;
          mv_all_methods("MY",$newclass);
          bless $self, $newclass;
          push @Parent, $self;
          require ExtUtils::MY;
  
          no strict 'refs';   ## no critic;
          @{"$newclass\:\:ISA"} = 'MM';
      }
  
      if (defined $Parent[-2]){
          $self->{PARENT} = $Parent[-2];
          for my $key (@Prepend_parent) {
              next unless defined $self->{PARENT}{$key};
  
              # Don't stomp on WriteMakefile() args.
              next if defined $self->{ARGS}{$key} and
                      $self->{ARGS}{$key} eq $self->{$key};
  
              $self->{$key} = $self->{PARENT}{$key};
  
              unless ($Is_VMS && $key =~ /PERL$/) {
                  $self->{$key} = $self->catdir("..",$self->{$key})
                    unless $self->file_name_is_absolute($self->{$key});
              } else {
                  # PERL or FULLPERL will be a command verb or even a
                  # command with an argument instead of a full file
                  # specification under VMS.  So, don't turn the command
                  # into a filespec, but do add a level to the path of
                  # the argument if not already absolute.
                  my @cmd = split /\s+/, $self->{$key};
                  $cmd[1] = $self->catfile('[-]',$cmd[1])
                    unless (@cmd < 2) || $self->file_name_is_absolute($cmd[1]);
                  $self->{$key} = join(' ', @cmd);
              }
          }
          if ($self->{PARENT}) {
              $self->{PARENT}->{CHILDREN}->{$newclass} = $self;
              foreach my $opt (qw(POLLUTE PERL_CORE LINKTYPE LD OPTIMIZE)) {
                  if (exists $self->{PARENT}->{$opt}
                      and not exists $self->{$opt})
                      {
                          # inherit, but only if already unspecified
                          $self->{$opt} = $self->{PARENT}->{$opt};
                      }
              }
          }
          my @fm = grep /^FIRST_MAKEFILE=/, @ARGV;
          parse_args($self,@fm) if @fm;
      }
      else {
          parse_args($self, _shellwords($ENV{PERL_MM_OPT} || ''),@ARGV);
      }
  
      # RT#91540 PREREQ_FATAL not recognized on command line
      if (%unsatisfied && $self->{PREREQ_FATAL}){
          my $failedprereqs = join "\n", map {"    $_ $unsatisfied{$_}"}
                              sort { $a cmp $b } keys %unsatisfied;
          die <<"END";
  MakeMaker FATAL: prerequisites not found.
  $failedprereqs
  
  Please install these modules first and rerun 'perl Makefile.PL'.
  END
      }
  
      $self->{NAME} ||= $self->guess_name;
  
      warn "Warning: NAME must be a package name\n"
        unless $self->{NAME} =~ m!^[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*$!;
  
      ($self->{NAME_SYM} = $self->{NAME}) =~ s/\W+/_/g;
  
      $self->init_MAKE;
      $self->init_main;
      $self->init_VERSION;
      $self->init_dist;
      $self->init_INST;
      $self->init_INSTALL;
      $self->init_DEST;
      $self->init_dirscan;
      $self->init_PM;
      $self->init_MANPODS;
      $self->init_xs;
      $self->init_PERL;
      $self->init_DIRFILESEP;
      $self->init_linker;
      $self->init_ABSTRACT;
  
      $self->arch_check(
          $INC{'Config.pm'},
          $self->catfile($Config{'archlibexp'}, "Config.pm")
      );
  
      $self->init_tools();
      $self->init_others();
      $self->init_platform();
      $self->init_PERM();
      my($argv) = neatvalue(\@ARGV);
      $argv =~ s/^\[/(/;
      $argv =~ s/\]$/)/;
  
      push @{$self->{RESULT}}, <<END;
  # This Makefile is for the $self->{NAME} extension to perl.
  #
  # It was generated automatically by MakeMaker version
  # $VERSION (Revision: $Revision) from the contents of
  # Makefile.PL. Don't edit this file, edit Makefile.PL instead.
  #
  #       ANY CHANGES MADE HERE WILL BE LOST!
  #
  #   MakeMaker ARGV: $argv
  #
  END
  
      push @{$self->{RESULT}}, $self->_MakeMaker_Parameters_section(\%initial_att);
  
      if (defined $self->{CONFIGURE}) {
         push @{$self->{RESULT}}, <<END;
  
  #   MakeMaker 'CONFIGURE' Parameters:
  END
          if (scalar(keys %configure_att) > 0) {
              foreach my $key (sort keys %configure_att){
                 next if $key eq 'ARGS';
                 my($v) = neatvalue($configure_att{$key});
                 $v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;
                 $v =~ tr/\n/ /s;
                 push @{$self->{RESULT}}, "#     $key => $v";
              }
          }
          else
          {
             push @{$self->{RESULT}}, "# no values returned";
          }
          undef %configure_att;  # free memory
      }
  
      # turn the SKIP array into a SKIPHASH hash
      for my $skip (@{$self->{SKIP} || []}) {
          $self->{SKIPHASH}{$skip} = 1;
      }
      delete $self->{SKIP}; # free memory
  
      if ($self->{PARENT}) {
          for (qw/install dist dist_basics dist_core distdir dist_test dist_ci/) {
              $self->{SKIPHASH}{$_} = 1;
          }
      }
  
      # We run all the subdirectories now. They don't have much to query
      # from the parent, but the parent has to query them: if they need linking!
      unless ($self->{NORECURS}) {
          $self->eval_in_subdirs if @{$self->{DIR}};
      }
  
      foreach my $section ( @MM_Sections ){
          # Support for new foo_target() methods.
          my $method = $section;
          $method .= '_target' unless $self->can($method);
  
          print "Processing Makefile '$section' section\n" if ($Verbose >= 2);
          my($skipit) = $self->skipcheck($section);
          if ($skipit){
              push @{$self->{RESULT}}, "\n# --- MakeMaker $section section $skipit.";
          } else {
              my(%a) = %{$self->{$section} || {}};
              push @{$self->{RESULT}}, "\n# --- MakeMaker $section section:";
              push @{$self->{RESULT}}, "# " . join ", ", %a if $Verbose && %a;
              push @{$self->{RESULT}}, $self->maketext_filter(
                  $self->$method( %a )
              );
          }
      }
  
      push @{$self->{RESULT}}, "\n# End.";
  
      $self;
  }
  
  sub WriteEmptyMakefile {
      croak "WriteEmptyMakefile: Need an even number of args" if @_ % 2;
  
      my %att = @_;
      my $self = MM->new(\%att);
  
      my $new = $self->{MAKEFILE};
      my $old = $self->{MAKEFILE_OLD};
      if (-f $old) {
          _unlink($old) or warn "unlink $old: $!";
      }
      if ( -f $new ) {
          _rename($new, $old) or warn "rename $new => $old: $!"
      }
      open my $mfh, '>', $new or die "open $new for write: $!";
      print $mfh <<'EOP';
  all :
  
  clean :
  
  install :
  
  makemakerdflt :
  
  test :
  
  EOP
      close $mfh or die "close $new for write: $!";
  }
  
  
  =begin private
  
  =head3 _installed_file_for_module
  
    my $file = MM->_installed_file_for_module($module);
  
  Return the first installed .pm $file associated with the $module.  The
  one which will show up when you C<use $module>.
  
  $module is something like "strict" or "Test::More".
  
  =end private
  
  =cut
  
  sub _installed_file_for_module {
      my $class  = shift;
      my $prereq = shift;
  
      my $file = "$prereq.pm";
      $file =~ s{::}{/}g;
  
      my $path;
      for my $dir (@INC) {
          my $tmp = File::Spec->catfile($dir, $file);
          if ( -r $tmp ) {
              $path = $tmp;
              last;
          }
      }
  
      return $path;
  }
  
  
  # Extracted from MakeMaker->new so we can test it
  sub _MakeMaker_Parameters_section {
      my $self = shift;
      my $att  = shift;
  
      my @result = <<'END';
  #   MakeMaker Parameters:
  END
  
      foreach my $key (sort keys %$att){
          next if $key eq 'ARGS';
          my ($v) = neatvalue($att->{$key});
          if ($key eq 'PREREQ_PM') {
              # CPAN.pm takes prereqs from this field in 'Makefile'
              # and does not know about BUILD_REQUIRES
              $v = neatvalue({
                  %{ $att->{PREREQ_PM} || {} },
                  %{ $att->{BUILD_REQUIRES} || {} },
                  %{ $att->{TEST_REQUIRES} || {} },
              });
          } else {
              $v = neatvalue($att->{$key});
          }
  
          $v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;
          $v =~ tr/\n/ /s;
          push @result, "#     $key => $v";
      }
  
      return @result;
  }
  
  # _shellwords and _parseline borrowed from Text::ParseWords
  sub _shellwords {
      my (@lines) = @_;
      my @allwords;
  
      foreach my $line (@lines) {
        $line =~ s/^\s+//;
        my @words = _parse_line('\s+', 0, $line);
        pop @words if (@words and !defined $words[-1]);
        return() unless (@words || !length($line));
        push(@allwords, @words);
      }
      return(@allwords);
  }
  
  sub _parse_line {
      my($delimiter, $keep, $line) = @_;
      my($word, @pieces);
  
      no warnings 'uninitialized';  # we will be testing undef strings
  
      while (length($line)) {
          # This pattern is optimised to be stack conservative on older perls.
          # Do not refactor without being careful and testing it on very long strings.
          # See Perl bug #42980 for an example of a stack busting input.
          $line =~ s/^
                      (?:
                          # double quoted string
                          (")                             # $quote
                          ((?>[^\\"]*(?:\\.[^\\"]*)*))"   # $quoted
          | # --OR--
                          # singe quoted string
                          (')                             # $quote
                          ((?>[^\\']*(?:\\.[^\\']*)*))'   # $quoted
                      |   # --OR--
                          # unquoted string
              (                               # $unquoted
                              (?:\\.|[^\\"'])*?
                          )
                          # followed by
              (                               # $delim
                              \Z(?!\n)                    # EOL
                          |   # --OR--
                              (?-x:$delimiter)            # delimiter
                          |   # --OR--
                              (?!^)(?=["'])               # a quote
                          )
          )//xs or return;    # extended layout
          my ($quote, $quoted, $unquoted, $delim) = (($1 ? ($1,$2) : ($3,$4)), $5, $6);
  
  
    return() unless( defined($quote) || length($unquoted) || length($delim));
  
          if ($keep) {
        $quoted = "$quote$quoted$quote";
    }
          else {
        $unquoted =~ s/\\(.)/$1/sg;
        if (defined $quote) {
      $quoted =~ s/\\(.)/$1/sg if ($quote eq '"');
      #$quoted =~ s/\\([\\'])/$1/g if ( $PERL_SINGLE_QUOTE && $quote eq "'");
              }
    }
          $word .= substr($line, 0, 0); # leave results tainted
          $word .= defined $quote ? $quoted : $unquoted;
  
          if (length($delim)) {
              push(@pieces, $word);
              push(@pieces, $delim) if ($keep eq 'delimiters');
              undef $word;
          }
          if (!length($line)) {
              push(@pieces, $word);
    }
      }
      return(@pieces);
  }
  
  sub check_manifest {
      print "Checking if your kit is complete...\n";
      require ExtUtils::Manifest;
      # avoid warning
      $ExtUtils::Manifest::Quiet = $ExtUtils::Manifest::Quiet = 1;
      my(@missed) = ExtUtils::Manifest::manicheck();
      if (@missed) {
          print "Warning: the following files are missing in your kit:\n";
          print "\t", join "\n\t", @missed;
          print "\n";
          print "Please inform the author.\n";
      } else {
          print "Looks good\n";
      }
  }
  
  sub parse_args{
      my($self, @args) = @_;
      foreach (@args) {
          unless (m/(.*?)=(.*)/) {
              ++$Verbose if m/^verb/;
              next;
          }
          my($name, $value) = ($1, $2);
          if ($value =~ m/^~(\w+)?/) { # tilde with optional username
              $value =~ s [^~(\w*)]
                  [$1 ?
                   ((getpwnam($1))[7] || "~$1") :
                   (getpwuid($>))[7]
                   ]ex;
          }
  
          # Remember the original args passed it.  It will be useful later.
          $self->{ARGS}{uc $name} = $self->{uc $name} = $value;
      }
  
      # catch old-style 'potential_libs' and inform user how to 'upgrade'
      if (defined $self->{potential_libs}){
          my($msg)="'potential_libs' => '$self->{potential_libs}' should be";
          if ($self->{potential_libs}){
              print "$msg changed to:\n\t'LIBS' => ['$self->{potential_libs}']\n";
          } else {
              print "$msg deleted.\n";
          }
          $self->{LIBS} = [$self->{potential_libs}];
          delete $self->{potential_libs};
      }
      # catch old-style 'ARMAYBE' and inform user how to 'upgrade'
      if (defined $self->{ARMAYBE}){
          my($armaybe) = $self->{ARMAYBE};
          print "ARMAYBE => '$armaybe' should be changed to:\n",
                          "\t'dynamic_lib' => {ARMAYBE => '$armaybe'}\n";
          my(%dl) = %{$self->{dynamic_lib} || {}};
          $self->{dynamic_lib} = { %dl, ARMAYBE => $armaybe};
          delete $self->{ARMAYBE};
      }
      if (defined $self->{LDTARGET}){
          print "LDTARGET should be changed to LDFROM\n";
          $self->{LDFROM} = $self->{LDTARGET};
          delete $self->{LDTARGET};
      }
      # Turn a DIR argument on the command line into an array
      if (defined $self->{DIR} && ref \$self->{DIR} eq 'SCALAR') {
          # So they can choose from the command line, which extensions they want
          # the grep enables them to have some colons too much in case they
          # have to build a list with the shell
          $self->{DIR} = [grep $_, split ":", $self->{DIR}];
      }
      # Turn a INCLUDE_EXT argument on the command line into an array
      if (defined $self->{INCLUDE_EXT} && ref \$self->{INCLUDE_EXT} eq 'SCALAR') {
          $self->{INCLUDE_EXT} = [grep $_, split '\s+', $self->{INCLUDE_EXT}];
      }
      # Turn a EXCLUDE_EXT argument on the command line into an array
      if (defined $self->{EXCLUDE_EXT} && ref \$self->{EXCLUDE_EXT} eq 'SCALAR') {
          $self->{EXCLUDE_EXT} = [grep $_, split '\s+', $self->{EXCLUDE_EXT}];
      }
  
      foreach my $mmkey (sort keys %$self){
          next if $mmkey eq 'ARGS';
          print "  $mmkey => ", neatvalue($self->{$mmkey}), "\n" if $Verbose;
          print "'$mmkey' is not a known MakeMaker parameter name.\n"
              unless exists $Recognized_Att_Keys{$mmkey};
      }
      $| = 1 if $Verbose;
  }
  
  sub check_hints {
      my($self) = @_;
      # We allow extension-specific hints files.
  
      require File::Spec;
      my $curdir = File::Spec->curdir;
  
      my $hint_dir = File::Spec->catdir($curdir, "hints");
      return unless -d $hint_dir;
  
      # First we look for the best hintsfile we have
      my($hint)="${^O}_$Config{osvers}";
      $hint =~ s/\./_/g;
      $hint =~ s/_$//;
      return unless $hint;
  
      # Also try without trailing minor version numbers.
      while (1) {
          last if -f File::Spec->catfile($hint_dir, "$hint.pl");  # found
      } continue {
          last unless $hint =~ s/_[^_]*$//; # nothing to cut off
      }
      my $hint_file = File::Spec->catfile($hint_dir, "$hint.pl");
  
      return unless -f $hint_file;    # really there
  
      _run_hintfile($self, $hint_file);
  }
  
  sub _run_hintfile {
      our $self;
      local($self) = shift;       # make $self available to the hint file.
      my($hint_file) = shift;
  
      local($@, $!);
      warn "Processing hints file $hint_file\n";
  
      # Just in case the ./ isn't on the hint file, which File::Spec can
      # often strip off, we bung the curdir into @INC
      local @INC = (File::Spec->curdir, @INC);
      my $ret = do $hint_file;
      if( !defined $ret ) {
          my $error = $@ || $!;
          warn $error;
      }
  }
  
  sub mv_all_methods {
      my($from,$to) = @_;
  
      # Here you see the *current* list of methods that are overridable
      # from Makefile.PL via MY:: subroutines. As of VERSION 5.07 I'm
      # still trying to reduce the list to some reasonable minimum --
      # because I want to make it easier for the user. A.K.
  
      local $SIG{__WARN__} = sub {
          # can't use 'no warnings redefined', 5.6 only
          warn @_ unless $_[0] =~ /^Subroutine .* redefined/
      };
      foreach my $method (@Overridable) {
  
          # We cannot say "next" here. Nick might call MY->makeaperl
          # which isn't defined right now
  
          # Above statement was written at 4.23 time when Tk-b8 was
          # around. As Tk-b9 only builds with 5.002something and MM 5 is
          # standard, we try to enable the next line again. It was
          # commented out until MM 5.23
  
          next unless defined &{"${from}::$method"};
  
          {
              no strict 'refs';   ## no critic
              *{"${to}::$method"} = \&{"${from}::$method"};
  
              # If we delete a method, then it will be undefined and cannot
              # be called.  But as long as we have Makefile.PLs that rely on
              # %MY:: being intact, we have to fill the hole with an
              # inheriting method:
  
              {
                  package MY;
                  my $super = "SUPER::".$method;
                  *{$method} = sub {
                      shift->$super(@_);
                  };
              }
          }
      }
  
      # We have to clean out %INC also, because the current directory is
      # changed frequently and Graham Barr prefers to get his version
      # out of a History.pl file which is "required" so wouldn't get
      # loaded again in another extension requiring a History.pl
  
      # With perl5.002_01 the deletion of entries in %INC caused Tk-b11
      # to core dump in the middle of a require statement. The required
      # file was Tk/MMutil.pm.  The consequence is, we have to be
      # extremely careful when we try to give perl a reason to reload a
      # library with same name.  The workaround prefers to drop nothing
      # from %INC and teach the writers not to use such libraries.
  
  #    my $inc;
  #    foreach $inc (keys %INC) {
  #       #warn "***$inc*** deleted";
  #       delete $INC{$inc};
  #    }
  }
  
  sub skipcheck {
      my($self) = shift;
      my($section) = @_;
      if ($section eq 'dynamic') {
          print "Warning (non-fatal): Target 'dynamic' depends on targets ",
          "in skipped section 'dynamic_bs'\n"
              if $self->{SKIPHASH}{dynamic_bs} && $Verbose;
          print "Warning (non-fatal): Target 'dynamic' depends on targets ",
          "in skipped section 'dynamic_lib'\n"
              if $self->{SKIPHASH}{dynamic_lib} && $Verbose;
      }
      if ($section eq 'dynamic_lib') {
          print "Warning (non-fatal): Target '\$(INST_DYNAMIC)' depends on ",
          "targets in skipped section 'dynamic_bs'\n"
              if $self->{SKIPHASH}{dynamic_bs} && $Verbose;
      }
      if ($section eq 'static') {
          print "Warning (non-fatal): Target 'static' depends on targets ",
          "in skipped section 'static_lib'\n"
              if $self->{SKIPHASH}{static_lib} && $Verbose;
      }
      return 'skipped' if $self->{SKIPHASH}{$section};
      return '';
  }
  
  sub flush {
      my $self = shift;
  
      # This needs a bit more work for more wacky OSen
      my $type = 'Unix-style';
      if ( $self->os_flavor_is('Win32') ) {
        my $make = $self->make;
        $make = +( File::Spec->splitpath( $make ) )[-1];
        $make =~ s!\.exe$!!i;
        $type = $make . '-style';
      }
      elsif ( $Is_VMS ) {
          $type = $Config{make} . '-style';
      }
  
      my $finalname = $self->{MAKEFILE};
      print "Generating a $type $finalname\n";
      print "Writing $finalname for $self->{NAME}\n";
  
      unlink($finalname, "MakeMaker.tmp", $Is_VMS ? 'Descrip.MMS' : ());
      open(my $fh,">", "MakeMaker.tmp")
          or die "Unable to open MakeMaker.tmp: $!";
  
      for my $chunk (@{$self->{RESULT}}) {
          print $fh "$chunk\n"
              or die "Can't write to MakeMaker.tmp: $!";
      }
  
      close $fh
          or die "Can't write to MakeMaker.tmp: $!";
      _rename("MakeMaker.tmp", $finalname) or
        warn "rename MakeMaker.tmp => $finalname: $!";
      chmod 0644, $finalname unless $Is_VMS;
  
      unless ($self->{NO_MYMETA}) {
          # Write MYMETA.yml to communicate metadata up to the CPAN clients
          if ( $self->write_mymeta( $self->mymeta ) ) {
              print "Writing MYMETA.yml and MYMETA.json\n";
          }
  
      }
      my %keep = map { ($_ => 1) } qw(NEEDS_LINKING HAS_LINK_CODE);
      if ($self->{PARENT} && !$self->{_KEEP_AFTER_FLUSH}) {
          foreach (keys %$self) { # safe memory
              delete $self->{$_} unless $keep{$_};
          }
      }
  
      system("$Config::Config{eunicefix} $finalname") unless $Config::Config{eunicefix} eq ":";
  }
  
  # This is a rename for OS's where the target must be unlinked first.
  sub _rename {
      my($src, $dest) = @_;
      chmod 0666, $dest;
      unlink $dest;
      return rename $src, $dest;
  }
  
  # This is an unlink for OS's where the target must be writable first.
  sub _unlink {
      my @files = @_;
      chmod 0666, @files;
      return unlink @files;
  }
  
  
  # The following mkbootstrap() is only for installations that are calling
  # the pre-4.1 mkbootstrap() from their old Makefiles. This MakeMaker
  # writes Makefiles, that use ExtUtils::Mkbootstrap directly.
  sub mkbootstrap {
      die <<END;
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  }
  
  # Ditto for mksymlists() as of MakeMaker 5.17
  sub mksymlists {
      die <<END;
  !!! Your Makefile has been built such a long time ago, !!!
  !!! that is unlikely to work with current MakeMaker.   !!!
  !!! Please rebuild your Makefile                       !!!
  END
  }
  
  sub neatvalue {
      my($v) = @_;
      return "undef" unless defined $v;
      my($t) = ref $v;
      return "q[$v]" unless $t;
      if ($t eq 'ARRAY') {
          my(@m, @neat);
          push @m, "[";
          foreach my $elem (@$v) {
              push @neat, "q[$elem]";
          }
          push @m, join ", ", @neat;
          push @m, "]";
          return join "", @m;
      }
      return "$v" unless $t eq 'HASH';
      my(@m, $key, $val);
      while (($key,$val) = each %$v){
          last unless defined $key; # cautious programming in case (undef,undef) is true
          push(@m,"$key=>".neatvalue($val)) ;
      }
      return "{ ".join(', ',@m)." }";
  }
  
  # Look for weird version numbers, warn about them and set them to 0
  # before CPAN::Meta chokes.
  sub clean_versions {
      my($self, $key) = @_;
  
      my $reqs = $self->{$key};
      for my $module (keys %$reqs) {
          my $version = $reqs->{$module};
  
          if( !defined $version or $version !~ /^v?[\d_\.]+$/ ) {
              carp "Unparsable version '$version' for prerequisite $module";
              $reqs->{$module} = 0;
          }
      }
  }
  
  sub selfdocument {
      my($self) = @_;
      my(@m);
      if ($Verbose){
          push @m, "\n# Full list of MakeMaker attribute values:";
          foreach my $key (sort keys %$self){
              next if $key eq 'RESULT' || $key =~ /^[A-Z][a-z]/;
              my($v) = neatvalue($self->{$key});
              $v =~ s/(CODE|HASH|ARRAY|SCALAR)\([\dxa-f]+\)/$1\(...\)/;
              $v =~ tr/\n/ /s;
              push @m, "# $key => $v";
          }
      }
      join "\n", @m;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::MakeMaker - Create a module Makefile
  
  =head1 SYNOPSIS
  
    use ExtUtils::MakeMaker;
  
    WriteMakefile(
        NAME              => "Foo::Bar",
        VERSION_FROM      => "lib/Foo/Bar.pm",
    );
  
  =head1 DESCRIPTION
  
  This utility is designed to write a Makefile for an extension module
  from a Makefile.PL. It is based on the Makefile.SH model provided by
  Andy Dougherty and the perl5-porters.
  
  It splits the task of generating the Makefile into several subroutines
  that can be individually overridden.  Each subroutine returns the text
  it wishes to have written to the Makefile.
  
  As there are various Make programs with incompatible syntax, which
  use operating system shells, again with incompatible syntax, it is
  important for users of this module to know which flavour of Make
  a Makefile has been written for so they'll use the correct one and
  won't have to face the possibly bewildering errors resulting from
  using the wrong one.
  
  On POSIX systems, that program will likely be GNU Make; on Microsoft
  Windows, it will be either Microsoft NMake or DMake. Note that this
  module does not support generating Makefiles for GNU Make on Windows.
  See the section on the L</"MAKE"> parameter for details.
  
  MakeMaker is object oriented. Each directory below the current
  directory that contains a Makefile.PL is treated as a separate
  object. This makes it possible to write an unlimited number of
  Makefiles with a single invocation of WriteMakefile().
  
  =head2 How To Write A Makefile.PL
  
  See L<ExtUtils::MakeMaker::Tutorial>.
  
  The long answer is the rest of the manpage :-)
  
  =head2 Default Makefile Behaviour
  
  The generated Makefile enables the user of the extension to invoke
  
    perl Makefile.PL # optionally "perl Makefile.PL verbose"
    make
    make test        # optionally set TEST_VERBOSE=1
    make install     # See below
  
  The Makefile to be produced may be altered by adding arguments of the
  form C<KEY=VALUE>. E.g.
  
    perl Makefile.PL INSTALL_BASE=~
  
  Other interesting targets in the generated Makefile are
  
    make config     # to check if the Makefile is up-to-date
    make clean      # delete local temp files (Makefile gets renamed)
    make realclean  # delete derived files (including ./blib)
    make ci         # check in all the files in the MANIFEST file
    make dist       # see below the Distribution Support section
  
  =head2 make test
  
  MakeMaker checks for the existence of a file named F<test.pl> in the
  current directory, and if it exists it executes the script with the
  proper set of perl C<-I> options.
  
  MakeMaker also checks for any files matching glob("t/*.t"). It will
  execute all matching files in alphabetical order via the
  L<Test::Harness> module with the C<-I> switches set correctly.
  
  If you'd like to see the raw output of your tests, set the
  C<TEST_VERBOSE> variable to true.
  
    make test TEST_VERBOSE=1
  
  If you want to run particular test files, set the C<TEST_FILES> variable.
  It is possible to use globbing with this mechanism.
  
    make test TEST_FILES='t/foobar.t t/dagobah*.t'
  
  =head2 make testdb
  
  A useful variation of the above is the target C<testdb>. It runs the
  test under the Perl debugger (see L<perldebug>). If the file
  F<test.pl> exists in the current directory, it is used for the test.
  
  If you want to debug some other testfile, set the C<TEST_FILE> variable
  thusly:
  
    make testdb TEST_FILE=t/mytest.t
  
  By default the debugger is called using C<-d> option to perl. If you
  want to specify some other option, set the C<TESTDB_SW> variable:
  
    make testdb TESTDB_SW=-Dx
  
  =head2 make install
  
  make alone puts all relevant files into directories that are named by
  the macros INST_LIB, INST_ARCHLIB, INST_SCRIPT, INST_MAN1DIR and
  INST_MAN3DIR.  All these default to something below ./blib if you are
  I<not> building below the perl source directory. If you I<are>
  building below the perl source, INST_LIB and INST_ARCHLIB default to
  ../../lib, and INST_SCRIPT is not defined.
  
  The I<install> target of the generated Makefile copies the files found
  below each of the INST_* directories to their INSTALL*
  counterparts. Which counterparts are chosen depends on the setting of
  INSTALLDIRS according to the following table:
  
                                   INSTALLDIRS set to
                             perl        site          vendor
  
                   PERLPREFIX      SITEPREFIX          VENDORPREFIX
    INST_ARCHLIB   INSTALLARCHLIB  INSTALLSITEARCH     INSTALLVENDORARCH
    INST_LIB       INSTALLPRIVLIB  INSTALLSITELIB      INSTALLVENDORLIB
    INST_BIN       INSTALLBIN      INSTALLSITEBIN      INSTALLVENDORBIN
    INST_SCRIPT    INSTALLSCRIPT   INSTALLSITESCRIPT   INSTALLVENDORSCRIPT
    INST_MAN1DIR   INSTALLMAN1DIR  INSTALLSITEMAN1DIR  INSTALLVENDORMAN1DIR
    INST_MAN3DIR   INSTALLMAN3DIR  INSTALLSITEMAN3DIR  INSTALLVENDORMAN3DIR
  
  The INSTALL... macros in turn default to their %Config
  ($Config{installprivlib}, $Config{installarchlib}, etc.) counterparts.
  
  You can check the values of these variables on your system with
  
      perl '-V:install.*'
  
  And to check the sequence in which the library directories are
  searched by perl, run
  
      perl -le 'print join $/, @INC'
  
  Sometimes older versions of the module you're installing live in other
  directories in @INC.  Because Perl loads the first version of a module it
  finds, not the newest, you might accidentally get one of these older
  versions even after installing a brand new version.  To delete I<all other
  versions of the module you're installing> (not simply older ones) set the
  C<UNINST> variable.
  
      make install UNINST=1
  
  
  =head2 INSTALL_BASE
  
  INSTALL_BASE can be passed into Makefile.PL to change where your
  module will be installed.  INSTALL_BASE is more like what everyone
  else calls "prefix" than PREFIX is.
  
  To have everything installed in your home directory, do the following.
  
      # Unix users, INSTALL_BASE=~ works fine
      perl Makefile.PL INSTALL_BASE=/path/to/your/home/dir
  
  Like PREFIX, it sets several INSTALL* attributes at once.  Unlike
  PREFIX it is easy to predict where the module will end up.  The
  installation pattern looks like this:
  
      INSTALLARCHLIB     INSTALL_BASE/lib/perl5/$Config{archname}
      INSTALLPRIVLIB     INSTALL_BASE/lib/perl5
      INSTALLBIN         INSTALL_BASE/bin
      INSTALLSCRIPT      INSTALL_BASE/bin
      INSTALLMAN1DIR     INSTALL_BASE/man/man1
      INSTALLMAN3DIR     INSTALL_BASE/man/man3
  
  INSTALL_BASE in MakeMaker and C<--install_base> in Module::Build (as
  of 0.28) install to the same location.  If you want MakeMaker and
  Module::Build to install to the same location simply set INSTALL_BASE
  and C<--install_base> to the same location.
  
  INSTALL_BASE was added in 6.31.
  
  
  =head2 PREFIX and LIB attribute
  
  PREFIX and LIB can be used to set several INSTALL* attributes in one
  go.  Here's an example for installing into your home directory.
  
      # Unix users, PREFIX=~ works fine
      perl Makefile.PL PREFIX=/path/to/your/home/dir
  
  This will install all files in the module under your home directory,
  with man pages and libraries going into an appropriate place (usually
  ~/man and ~/lib).  How the exact location is determined is complicated
  and depends on how your Perl was configured.  INSTALL_BASE works more
  like what other build systems call "prefix" than PREFIX and we
  recommend you use that instead.
  
  Another way to specify many INSTALL directories with a single
  parameter is LIB.
  
      perl Makefile.PL LIB=~/lib
  
  This will install the module's architecture-independent files into
  ~/lib, the architecture-dependent files into ~/lib/$archname.
  
  Note, that in both cases the tilde expansion is done by MakeMaker, not
  by perl by default, nor by make.
  
  Conflicts between parameters LIB, PREFIX and the various INSTALL*
  arguments are resolved so that:
  
  =over 4
  
  =item *
  
  setting LIB overrides any setting of INSTALLPRIVLIB, INSTALLARCHLIB,
  INSTALLSITELIB, INSTALLSITEARCH (and they are not affected by PREFIX);
  
  =item *
  
  without LIB, setting PREFIX replaces the initial C<$Config{prefix}>
  part of those INSTALL* arguments, even if the latter are explicitly
  set (but are set to still start with C<$Config{prefix}>).
  
  =back
  
  If the user has superuser privileges, and is not working on AFS or
  relatives, then the defaults for INSTALLPRIVLIB, INSTALLARCHLIB,
  INSTALLSCRIPT, etc. will be appropriate, and this incantation will be
  the best:
  
      perl Makefile.PL;
      make;
      make test
      make install
  
  make install by default writes some documentation of what has been
  done into the file C<$(INSTALLARCHLIB)/perllocal.pod>. This feature
  can be bypassed by calling make pure_install.
  
  =head2 AFS users
  
  will have to specify the installation directories as these most
  probably have changed since perl itself has been installed. They will
  have to do this by calling
  
      perl Makefile.PL INSTALLSITELIB=/afs/here/today \
          INSTALLSCRIPT=/afs/there/now INSTALLMAN3DIR=/afs/for/manpages
      make
  
  Be careful to repeat this procedure every time you recompile an
  extension, unless you are sure the AFS installation directories are
  still valid.
  
  =head2 Static Linking of a new Perl Binary
  
  An extension that is built with the above steps is ready to use on
  systems supporting dynamic loading. On systems that do not support
  dynamic loading, any newly created extension has to be linked together
  with the available resources. MakeMaker supports the linking process
  by creating appropriate targets in the Makefile whenever an extension
  is built. You can invoke the corresponding section of the makefile with
  
      make perl
  
  That produces a new perl binary in the current directory with all
  extensions linked in that can be found in INST_ARCHLIB, SITELIBEXP,
  and PERL_ARCHLIB. To do that, MakeMaker writes a new Makefile, on
  UNIX, this is called F<Makefile.aperl> (may be system dependent). If you
  want to force the creation of a new perl, it is recommended that you
  delete this F<Makefile.aperl>, so the directories are searched through
  for linkable libraries again.
  
  The binary can be installed into the directory where perl normally
  resides on your machine with
  
      make inst_perl
  
  To produce a perl binary with a different name than C<perl>, either say
  
      perl Makefile.PL MAP_TARGET=myperl
      make myperl
      make inst_perl
  
  or say
  
      perl Makefile.PL
      make myperl MAP_TARGET=myperl
      make inst_perl MAP_TARGET=myperl
  
  In any case you will be prompted with the correct invocation of the
  C<inst_perl> target that installs the new binary into INSTALLBIN.
  
  make inst_perl by default writes some documentation of what has been
  done into the file C<$(INSTALLARCHLIB)/perllocal.pod>. This
  can be bypassed by calling make pure_inst_perl.
  
  Warning: the inst_perl: target will most probably overwrite your
  existing perl binary. Use with care!
  
  Sometimes you might want to build a statically linked perl although
  your system supports dynamic loading. In this case you may explicitly
  set the linktype with the invocation of the Makefile.PL or make:
  
      perl Makefile.PL LINKTYPE=static    # recommended
  
  or
  
      make LINKTYPE=static                # works on most systems
  
  =head2 Determination of Perl Library and Installation Locations
  
  MakeMaker needs to know, or to guess, where certain things are
  located.  Especially INST_LIB and INST_ARCHLIB (where to put the files
  during the make(1) run), PERL_LIB and PERL_ARCHLIB (where to read
  existing modules from), and PERL_INC (header files and C<libperl*.*>).
  
  Extensions may be built either using the contents of the perl source
  directory tree or from the installed perl library. The recommended way
  is to build extensions after you have run 'make install' on perl
  itself. You can do that in any directory on your hard disk that is not
  below the perl source tree. The support for extensions below the ext
  directory of the perl distribution is only good for the standard
  extensions that come with perl.
  
  If an extension is being built below the C<ext/> directory of the perl
  source then MakeMaker will set PERL_SRC automatically (e.g.,
  C<../..>).  If PERL_SRC is defined and the extension is recognized as
  a standard extension, then other variables default to the following:
  
    PERL_INC     = PERL_SRC
    PERL_LIB     = PERL_SRC/lib
    PERL_ARCHLIB = PERL_SRC/lib
    INST_LIB     = PERL_LIB
    INST_ARCHLIB = PERL_ARCHLIB
  
  If an extension is being built away from the perl source then MakeMaker
  will leave PERL_SRC undefined and default to using the installed copy
  of the perl library. The other variables default to the following:
  
    PERL_INC     = $archlibexp/CORE
    PERL_LIB     = $privlibexp
    PERL_ARCHLIB = $archlibexp
    INST_LIB     = ./blib/lib
    INST_ARCHLIB = ./blib/arch
  
  If perl has not yet been installed then PERL_SRC can be defined on the
  command line as shown in the previous section.
  
  
  =head2 Which architecture dependent directory?
  
  If you don't want to keep the defaults for the INSTALL* macros,
  MakeMaker helps you to minimize the typing needed: the usual
  relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined
  by Configure at perl compilation time. MakeMaker supports the user who
  sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not,
  then MakeMaker defaults the latter to be the same subdirectory of
  INSTALLPRIVLIB as Configure decided for the counterparts in %Config,
  otherwise it defaults to INSTALLPRIVLIB. The same relationship holds
  for INSTALLSITELIB and INSTALLSITEARCH.
  
  MakeMaker gives you much more freedom than needed to configure
  internal variables and get different results. It is worth mentioning
  that make(1) also lets you configure most of the variables that are
  used in the Makefile. But in the majority of situations this will not
  be necessary, and should only be done if the author of a package
  recommends it (or you know what you're doing).
  
  =head2 Using Attributes and Parameters
  
  The following attributes may be specified as arguments to WriteMakefile()
  or as NAME=VALUE pairs on the command line. Attributes that became
  available with later versions of MakeMaker are indicated.
  
  In order to maintain portability of attributes with older versions of
  MakeMaker you may want to use L<App::EUMM::Upgrade> with your C<Makefile.PL>.
  
  =over 2
  
  =item ABSTRACT
  
  One line description of the module. Will be included in PPD file.
  
  =item ABSTRACT_FROM
  
  Name of the file that contains the package description. MakeMaker looks
  for a line in the POD matching /^($package\s-\s)(.*)/. This is typically
  the first line in the "=head1 NAME" section. $2 becomes the abstract.
  
  =item AUTHOR
  
  Array of strings containing name (and email address) of package author(s).
  Is used in CPAN Meta files (META.yml or META.json) and PPD
  (Perl Package Description) files for PPM (Perl Package Manager).
  
  =item BINARY_LOCATION
  
  Used when creating PPD files for binary packages.  It can be set to a
  full or relative path or URL to the binary archive for a particular
  architecture.  For example:
  
          perl Makefile.PL BINARY_LOCATION=x86/Agent.tar.gz
  
  builds a PPD package that references a binary of the C<Agent> package,
  located in the C<x86> directory relative to the PPD itself.
  
  =item BUILD_REQUIRES
  
  Available in version 6.5503 and above.
  
  A hash of modules that are needed to build your module but not run it.
  
  This will go into the C<build_requires> field of your F<META.yml> and the C<build> of the C<prereqs> field of your F<META.json>.
  
  Defaults to C<<< { "ExtUtils::MakeMaker" => 0 } >>> if this attribute is not specified.
  
  The format is the same as PREREQ_PM.
  
  =item C
  
  Ref to array of *.c file names. Initialised from a directory scan
  and the values portion of the XS attribute hash. This is not
  currently used by MakeMaker but may be handy in Makefile.PLs.
  
  =item CCFLAGS
  
  String that will be included in the compiler call command line between
  the arguments INC and OPTIMIZE.
  
  =item CONFIG
  
  Arrayref. E.g. [qw(archname manext)] defines ARCHNAME & MANEXT from
  config.sh. MakeMaker will add to CONFIG the following values anyway:
  ar
  cc
  cccdlflags
  ccdlflags
  dlext
  dlsrc
  ld
  lddlflags
  ldflags
  libc
  lib_ext
  obj_ext
  ranlib
  sitelibexp
  sitearchexp
  so
  
  =item CONFIGURE
  
  CODE reference. The subroutine should return a hash reference. The
  hash may contain further attributes, e.g. {LIBS =E<gt> ...}, that have to
  be determined by some evaluation method.
  
  =item CONFIGURE_REQUIRES
  
  Available in version 6.52 and above.
  
  A hash of modules that are required to run Makefile.PL itself, but not
  to run your distribution.
  
  This will go into the C<configure_requires> field of your F<META.yml> and the C<configure> of the C<prereqs> field of your F<META.json>.
  
  Defaults to C<<< { "ExtUtils::MakeMaker" => 0 } >>> if this attribute is not specified.
  
  The format is the same as PREREQ_PM.
  
  =item DEFINE
  
  Something like C<"-DHAVE_UNISTD_H">
  
  =item DESTDIR
  
  This is the root directory into which the code will be installed.  It
  I<prepends itself to the normal prefix>.  For example, if your code
  would normally go into F</usr/local/lib/perl> you could set DESTDIR=~/tmp/
  and installation would go into F<~/tmp/usr/local/lib/perl>.
  
  This is primarily of use for people who repackage Perl modules.
  
  NOTE: Due to the nature of make, it is important that you put the trailing
  slash on your DESTDIR.  F<~/tmp/> not F<~/tmp>.
  
  =item DIR
  
  Ref to array of subdirectories containing Makefile.PLs e.g. ['sdbm']
  in ext/SDBM_File
  
  =item DISTNAME
  
  A safe filename for the package.
  
  Defaults to NAME below but with :: replaced with -.
  
  For example, Foo::Bar becomes Foo-Bar.
  
  =item DISTVNAME
  
  Your name for distributing the package with the version number
  included.  This is used by 'make dist' to name the resulting archive
  file.
  
  Defaults to DISTNAME-VERSION.
  
  For example, version 1.04 of Foo::Bar becomes Foo-Bar-1.04.
  
  On some OS's where . has special meaning VERSION_SYM may be used in
  place of VERSION.
  
  =item DLEXT
  
  Specifies the extension of the module's loadable object. For example:
  
    DLEXT => 'unusual_ext', # Default value is $Config{so}
  
  NOTE: When using this option to alter the extension of a module's
  loadable object, it is also necessary that the module's pm file
  specifies the same change:
  
    local $DynaLoader::dl_dlext = 'unusual_ext';
  
  =item DL_FUNCS
  
  Hashref of symbol names for routines to be made available as universal
  symbols.  Each key/value pair consists of the package name and an
  array of routine names in that package.  Used only under AIX, OS/2,
  VMS and Win32 at present.  The routine names supplied will be expanded
  in the same way as XSUB names are expanded by the XS() macro.
  Defaults to
  
    {"$(NAME)" => ["boot_$(NAME)" ] }
  
  e.g.
  
    {"RPC" => [qw( boot_rpcb rpcb_gettime getnetconfigent )],
     "NetconfigPtr" => [ 'DESTROY'] }
  
  Please see the L<ExtUtils::Mksymlists> documentation for more information
  about the DL_FUNCS, DL_VARS and FUNCLIST attributes.
  
  =item DL_VARS
  
  Array of symbol names for variables to be made available as universal symbols.
  Used only under AIX, OS/2, VMS and Win32 at present.  Defaults to [].
  (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])
  
  =item EXCLUDE_EXT
  
  Array of extension names to exclude when doing a static build.  This
  is ignored if INCLUDE_EXT is present.  Consult INCLUDE_EXT for more
  details.  (e.g.  [ qw( Socket POSIX ) ] )
  
  This attribute may be most useful when specified as a string on the
  command line:  perl Makefile.PL EXCLUDE_EXT='Socket Safe'
  
  =item EXE_FILES
  
  Ref to array of executable files. The files will be copied to the
  INST_SCRIPT directory. Make realclean will delete them from there
  again.
  
  If your executables start with something like #!perl or
  #!/usr/bin/perl MakeMaker will change this to the path of the perl
  'Makefile.PL' was invoked with so the programs will be sure to run
  properly even if perl is not in /usr/bin/perl.
  
  =item FIRST_MAKEFILE
  
  The name of the Makefile to be produced.  This is used for the second
  Makefile that will be produced for the MAP_TARGET.
  
  Defaults to 'Makefile' or 'Descrip.MMS' on VMS.
  
  (Note: we couldn't use MAKEFILE because dmake uses this for something
  else).
  
  =item FULLPERL
  
  Perl binary able to run this extension, load XS modules, etc...
  
  =item FULLPERLRUN
  
  Like PERLRUN, except it uses FULLPERL.
  
  =item FULLPERLRUNINST
  
  Like PERLRUNINST, except it uses FULLPERL.
  
  =item FUNCLIST
  
  This provides an alternate means to specify function names to be
  exported from the extension.  Its value is a reference to an
  array of function names to be exported by the extension.  These
  names are passed through unaltered to the linker options file.
  
  =item H
  
  Ref to array of *.h file names. Similar to C.
  
  =item IMPORTS
  
  This attribute is used to specify names to be imported into the
  extension. Takes a hash ref.
  
  It is only used on OS/2 and Win32.
  
  =item INC
  
  Include file dirs eg: C<"-I/usr/5include -I/path/to/inc">
  
  =item INCLUDE_EXT
  
  Array of extension names to be included when doing a static build.
  MakeMaker will normally build with all of the installed extensions when
  doing a static build, and that is usually the desired behavior.  If
  INCLUDE_EXT is present then MakeMaker will build only with those extensions
  which are explicitly mentioned. (e.g.  [ qw( Socket POSIX ) ])
  
  It is not necessary to mention DynaLoader or the current extension when
  filling in INCLUDE_EXT.  If the INCLUDE_EXT is mentioned but is empty then
  only DynaLoader and the current extension will be included in the build.
  
  This attribute may be most useful when specified as a string on the
  command line:  perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'
  
  =item INSTALLARCHLIB
  
  Used by 'make install', which copies files from INST_ARCHLIB to this
  directory if INSTALLDIRS is set to perl.
  
  =item INSTALLBIN
  
  Directory to install binary files (e.g. tkperl) into if
  INSTALLDIRS=perl.
  
  =item INSTALLDIRS
  
  Determines which of the sets of installation directories to choose:
  perl, site or vendor.  Defaults to site.
  
  =item INSTALLMAN1DIR
  
  =item INSTALLMAN3DIR
  
  These directories get the man pages at 'make install' time if
  INSTALLDIRS=perl.  Defaults to $Config{installman*dir}.
  
  If set to 'none', no man pages will be installed.
  
  =item INSTALLPRIVLIB
  
  Used by 'make install', which copies files from INST_LIB to this
  directory if INSTALLDIRS is set to perl.
  
  Defaults to $Config{installprivlib}.
  
  =item INSTALLSCRIPT
  
  Used by 'make install' which copies files from INST_SCRIPT to this
  directory if INSTALLDIRS=perl.
  
  =item INSTALLSITEARCH
  
  Used by 'make install', which copies files from INST_ARCHLIB to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLSITEBIN
  
  Used by 'make install', which copies files from INST_BIN to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLSITELIB
  
  Used by 'make install', which copies files from INST_LIB to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLSITEMAN1DIR
  
  =item INSTALLSITEMAN3DIR
  
  These directories get the man pages at 'make install' time if
  INSTALLDIRS=site (default).  Defaults to
  $(SITEPREFIX)/man/man$(MAN*EXT).
  
  If set to 'none', no man pages will be installed.
  
  =item INSTALLSITESCRIPT
  
  Used by 'make install' which copies files from INST_SCRIPT to this
  directory if INSTALLDIRS is set to site (default).
  
  =item INSTALLVENDORARCH
  
  Used by 'make install', which copies files from INST_ARCHLIB to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INSTALLVENDORBIN
  
  Used by 'make install', which copies files from INST_BIN to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INSTALLVENDORLIB
  
  Used by 'make install', which copies files from INST_LIB to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INSTALLVENDORMAN1DIR
  
  =item INSTALLVENDORMAN3DIR
  
  These directories get the man pages at 'make install' time if
  INSTALLDIRS=vendor.  Defaults to $(VENDORPREFIX)/man/man$(MAN*EXT).
  
  If set to 'none', no man pages will be installed.
  
  =item INSTALLVENDORSCRIPT
  
  Used by 'make install' which copies files from INST_SCRIPT to this
  directory if INSTALLDIRS is set to vendor.
  
  =item INST_ARCHLIB
  
  Same as INST_LIB for architecture dependent files.
  
  =item INST_BIN
  
  Directory to put real binary files during 'make'. These will be copied
  to INSTALLBIN during 'make install'
  
  =item INST_LIB
  
  Directory where we put library files of this extension while building
  it.
  
  =item INST_MAN1DIR
  
  Directory to hold the man pages at 'make' time
  
  =item INST_MAN3DIR
  
  Directory to hold the man pages at 'make' time
  
  =item INST_SCRIPT
  
  Directory where executable files should be installed during
  'make'. Defaults to "./blib/script", just to have a dummy location during
  testing. make install will copy the files in INST_SCRIPT to
  INSTALLSCRIPT.
  
  =item LD
  
  Program to be used to link libraries for dynamic loading.
  
  Defaults to $Config{ld}.
  
  =item LDDLFLAGS
  
  Any special flags that might need to be passed to ld to create a
  shared library suitable for dynamic loading.  It is up to the makefile
  to use it.  (See L<Config/lddlflags>)
  
  Defaults to $Config{lddlflags}.
  
  =item LDFROM
  
  Defaults to "$(OBJECT)" and is used in the ld command to specify
  what files to link/load from (also see dynamic_lib below for how to
  specify ld flags)
  
  =item LIB
  
  LIB should only be set at C<perl Makefile.PL> time but is allowed as a
  MakeMaker argument. It has the effect of setting both INSTALLPRIVLIB
  and INSTALLSITELIB to that value regardless any explicit setting of
  those arguments (or of PREFIX).  INSTALLARCHLIB and INSTALLSITEARCH
  are set to the corresponding architecture subdirectory.
  
  =item LIBPERL_A
  
  The filename of the perllibrary that will be used together with this
  extension. Defaults to libperl.a.
  
  =item LIBS
  
  An anonymous array of alternative library
  specifications to be searched for (in order) until
  at least one library is found. E.g.
  
    'LIBS' => ["-lgdbm", "-ldbm -lfoo", "-L/path -ldbm.nfs"]
  
  Mind, that any element of the array
  contains a complete set of arguments for the ld
  command. So do not specify
  
    'LIBS' => ["-ltcl", "-ltk", "-lX11"]
  
  See ODBM_File/Makefile.PL for an example, where an array is needed. If
  you specify a scalar as in
  
    'LIBS' => "-ltcl -ltk -lX11"
  
  MakeMaker will turn it into an array with one element.
  
  =item LICENSE
  
  Available in version 6.31 and above.
  
  The licensing terms of your distribution.  Generally it's "perl_5" for the
  same license as Perl itself.
  
  See L<CPAN::Meta::Spec> for the list of options.
  
  Defaults to "unknown".
  
  =item LINKTYPE
  
  'static' or 'dynamic' (default unless usedl=undef in
  config.sh). Should only be used to force static linking (also see
  linkext below).
  
  =item MAGICXS
  
  When this is set to C<1>, C<OBJECT> will be automagically derived from C<XS>.
  
  =item MAKE
  
  Variant of make you intend to run the generated Makefile with.  This
  parameter lets Makefile.PL know what make quirks to account for when
  generating the Makefile.
  
  MakeMaker also honors the MAKE environment variable.  This parameter
  takes precedence.
  
  Currently the only significant values are 'dmake' and 'nmake' for Windows
  users, instructing MakeMaker to generate a Makefile in the flavour of
  DMake ("Dennis Vadura's Make") or Microsoft NMake respectively.
  
  Defaults to $Config{make}, which may go looking for a Make program
  in your environment.
  
  How are you supposed to know what flavour of Make a Makefile has
  been generated for if you didn't specify a value explicitly? Search
  the generated Makefile for the definition of the MAKE variable,
  which is used to recursively invoke the Make utility. That will tell
  you what Make you're supposed to invoke the Makefile with.
  
  =item MAKEAPERL
  
  Boolean which tells MakeMaker that it should include the rules to
  make a perl. This is handled automatically as a switch by
  MakeMaker. The user normally does not need it.
  
  =item MAKEFILE_OLD
  
  When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be
  backed up at this location.
  
  Defaults to $(FIRST_MAKEFILE).old or $(FIRST_MAKEFILE)_old on VMS.
  
  =item MAN1PODS
  
  Hashref of pod-containing files. MakeMaker will default this to all
  EXE_FILES files that include POD directives. The files listed
  here will be converted to man pages and installed as was requested
  at Configure time.
  
  This hash should map POD files (or scripts containing POD) to the
  man file names under the C<blib/man1/> directory, as in the following
  example:
  
    MAN1PODS            => {
      'doc/command.pod'    => 'blib/man1/command.1',
      'scripts/script.pl'  => 'blib/man1/script.1',
    }
  
  =item MAN3PODS
  
  Hashref that assigns to *.pm and *.pod files the files into which the
  manpages are to be written. MakeMaker parses all *.pod and *.pm files
  for POD directives. Files that contain POD will be the default keys of
  the MAN3PODS hashref. These will then be converted to man pages during
  C<make> and will be installed during C<make install>.
  
  Example similar to MAN1PODS.
  
  =item MAP_TARGET
  
  If it is intended that a new perl binary be produced, this variable
  may hold a name for that binary. Defaults to perl
  
  =item META_ADD
  
  =item META_MERGE
  
  Available in version 6.46 and above.
  
  A hashref of items to add to the CPAN Meta file (F<META.yml> or
  F<META.json>).
  
  They differ in how they behave if they have the same key as the
  default metadata.  META_ADD will override the default value with its
  own.  META_MERGE will merge its value with the default.
  
  Unless you want to override the defaults, prefer META_MERGE so as to
  get the advantage of any future defaults.
  
  By default CPAN Meta specification C<1.4> is used. In order to use
  CPAN Meta specification C<2.0>, indicate with C<meta-spec> the version
  you want to use.
  
    META_MERGE        => {
  
      "meta-spec" => { version => 2 },
  
      resources => {
  
        repository => {
            type => 'git',
            url => 'git://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker.git',
            web => 'https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker',
        },
  
      },
  
    },
  
  =item MIN_PERL_VERSION
  
  Available in version 6.48 and above.
  
  The minimum required version of Perl for this distribution.
  
  Either the 5.006001 or the 5.6.1 format is acceptable.
  
  =item MYEXTLIB
  
  If the extension links to a library that it builds, set this to the
  name of the library (see SDBM_File)
  
  =item NAME
  
  The package representing the distribution. For example, C<Test::More>
  or C<ExtUtils::MakeMaker>. It will be used to derive information about
  the distribution such as the L<DISTNAME>, installation locations
  within the Perl library and where XS files will be looked for by
  default (see L<XS>).
  
  C<NAME> I<must> be a valid Perl package name and it I<must> have an
  associated C<.pm> file. For example, C<Foo::Bar> is a valid C<NAME>
  and there must exist F<Foo/Bar.pm>.  Any XS code should be in
  F<Bar.xs> unless stated otherwise.
  
  Your distribution B<must> have a C<NAME>.
  
  =item NEEDS_LINKING
  
  MakeMaker will figure out if an extension contains linkable code
  anywhere down the directory tree, and will set this variable
  accordingly, but you can speed it up a very little bit if you define
  this boolean variable yourself.
  
  =item NOECHO
  
  Command so make does not print the literal commands it's running.
  
  By setting it to an empty string you can generate a Makefile that
  prints all commands. Mainly used in debugging MakeMaker itself.
  
  Defaults to C<@>.
  
  =item NORECURS
  
  Boolean.  Attribute to inhibit descending into subdirectories.
  
  =item NO_META
  
  When true, suppresses the generation and addition to the MANIFEST of
  the META.yml and META.json module meta-data files during 'make distdir'.
  
  Defaults to false.
  
  =item NO_MYMETA
  
  When true, suppresses the generation of MYMETA.yml and MYMETA.json module
  meta-data files during 'perl Makefile.PL'.
  
  Defaults to false.
  
  =item NO_PACKLIST
  
  When true, suppresses the writing of C<packlist> files for installs.
  
  Defaults to false.
  
  =item NO_PERLLOCAL
  
  When true, suppresses the appending of installations to C<perllocal>.
  
  Defaults to false.
  
  =item NO_VC
  
  In general, any generated Makefile checks for the current version of
  MakeMaker and the version the Makefile was built under. If NO_VC is
  set, the version check is neglected. Do not write this into your
  Makefile.PL, use it interactively instead.
  
  =item OBJECT
  
  List of object files, defaults to '$(BASEEXT)$(OBJ_EXT)', but can be a long
  string or an array containing all object files, e.g. "tkpBind.o
  tkpButton.o tkpCanvas.o" or ["tkpBind.o", "tkpButton.o", "tkpCanvas.o"]
  
  (Where BASEEXT is the last component of NAME, and OBJ_EXT is $Config{obj_ext}.)
  
  =item OPTIMIZE
  
  Defaults to C<-O>. Set it to C<-g> to turn debugging on. The flag is
  passed to subdirectory makes.
  
  =item PERL
  
  Perl binary for tasks that can be done by miniperl.
  
  =item PERL_CORE
  
  Set only when MakeMaker is building the extensions of the Perl core
  distribution.
  
  =item PERLMAINCC
  
  The call to the program that is able to compile perlmain.c. Defaults
  to $(CC).
  
  =item PERL_ARCHLIB
  
  Same as for PERL_LIB, but for architecture dependent files.
  
  Used only when MakeMaker is building the extensions of the Perl core
  distribution (because normally $(PERL_ARCHLIB) is automatically in @INC,
  and adding it would get in the way of PERL5LIB).
  
  =item PERL_LIB
  
  Directory containing the Perl library to use.
  
  Used only when MakeMaker is building the extensions of the Perl core
  distribution (because normally $(PERL_LIB) is automatically in @INC,
  and adding it would get in the way of PERL5LIB).
  
  =item PERL_MALLOC_OK
  
  defaults to 0.  Should be set to TRUE if the extension can work with
  the memory allocation routines substituted by the Perl malloc() subsystem.
  This should be applicable to most extensions with exceptions of those
  
  =over 4
  
  =item *
  
  with bugs in memory allocations which are caught by Perl's malloc();
  
  =item *
  
  which interact with the memory allocator in other ways than via
  malloc(), realloc(), free(), calloc(), sbrk() and brk();
  
  =item *
  
  which rely on special alignment which is not provided by Perl's malloc().
  
  =back
  
  B<NOTE.>  Neglecting to set this flag in I<any one> of the loaded extension
  nullifies many advantages of Perl's malloc(), such as better usage of
  system resources, error detection, memory usage reporting, catchable failure
  of memory allocations, etc.
  
  =item PERLPREFIX
  
  Directory under which core modules are to be installed.
  
  Defaults to $Config{installprefixexp}, falling back to
  $Config{installprefix}, $Config{prefixexp} or $Config{prefix} should
  $Config{installprefixexp} not exist.
  
  Overridden by PREFIX.
  
  =item PERLRUN
  
  Use this instead of $(PERL) when you wish to run perl.  It will set up
  extra necessary flags for you.
  
  =item PERLRUNINST
  
  Use this instead of $(PERL) when you wish to run perl to work with
  modules.  It will add things like -I$(INST_ARCH) and other necessary
  flags so perl can see the modules you're about to install.
  
  =item PERL_SRC
  
  Directory containing the Perl source code (use of this should be
  avoided, it may be undefined)
  
  =item PERM_DIR
  
  Desired permission for directories. Defaults to C<755>.
  
  =item PERM_RW
  
  Desired permission for read/writable files. Defaults to C<644>.
  
  =item PERM_RWX
  
  Desired permission for executable files. Defaults to C<755>.
  
  =item PL_FILES
  
  MakeMaker can run programs to generate files for you at build time.
  By default any file named *.PL (except Makefile.PL and Build.PL) in
  the top level directory will be assumed to be a Perl program and run
  passing its own basename in as an argument.  For example...
  
      perl foo.PL foo
  
  This behavior can be overridden by supplying your own set of files to
  search.  PL_FILES accepts a hash ref, the key being the file to run
  and the value is passed in as the first argument when the PL file is run.
  
      PL_FILES => {'bin/foobar.PL' => 'bin/foobar'}
  
  Would run bin/foobar.PL like this:
  
      perl bin/foobar.PL bin/foobar
  
  If multiple files from one program are desired an array ref can be used.
  
      PL_FILES => {'bin/foobar.PL' => [qw(bin/foobar1 bin/foobar2)]}
  
  In this case the program will be run multiple times using each target file.
  
      perl bin/foobar.PL bin/foobar1
      perl bin/foobar.PL bin/foobar2
  
  PL files are normally run B<after> pm_to_blib and include INST_LIB and
  INST_ARCH in their C<@INC>, so the just built modules can be
  accessed... unless the PL file is making a module (or anything else in
  PM) in which case it is run B<before> pm_to_blib and does not include
  INST_LIB and INST_ARCH in its C<@INC>.  This apparently odd behavior
  is there for backwards compatibility (and it's somewhat DWIM).
  
  
  =item PM
  
  Hashref of .pm files and *.pl files to be installed.  e.g.
  
    {'name_of_file.pm' => '$(INST_LIB)/install_as.pm'}
  
  By default this will include *.pm and *.pl and the files found in
  the PMLIBDIRS directories.  Defining PM in the
  Makefile.PL will override PMLIBDIRS.
  
  =item PMLIBDIRS
  
  Ref to array of subdirectories containing library files.  Defaults to
  [ 'lib', $(BASEEXT) ]. The directories will be scanned and I<any> files
  they contain will be installed in the corresponding location in the
  library.  A libscan() method can be used to alter the behaviour.
  Defining PM in the Makefile.PL will override PMLIBDIRS.
  
  (Where BASEEXT is the last component of NAME.)
  
  =item PM_FILTER
  
  A filter program, in the traditional Unix sense (input from stdin, output
  to stdout) that is passed on each .pm file during the build (in the
  pm_to_blib() phase).  It is empty by default, meaning no filtering is done.
  
  Great care is necessary when defining the command if quoting needs to be
  done.  For instance, you would need to say:
  
    {'PM_FILTER' => 'grep -v \\"^\\#\\"'}
  
  to remove all the leading comments on the fly during the build.  The
  extra \\ are necessary, unfortunately, because this variable is interpolated
  within the context of a Perl program built on the command line, and double
  quotes are what is used with the -e switch to build that command line.  The
  # is escaped for the Makefile, since what is going to be generated will then
  be:
  
    PM_FILTER = grep -v \"^\#\"
  
  Without the \\ before the #, we'd have the start of a Makefile comment,
  and the macro would be incorrectly defined.
  
  =item POLLUTE
  
  Release 5.005 grandfathered old global symbol names by providing preprocessor
  macros for extension source compatibility.  As of release 5.6, these
  preprocessor definitions are not available by default.  The POLLUTE flag
  specifies that the old names should still be defined:
  
    perl Makefile.PL POLLUTE=1
  
  Please inform the module author if this is necessary to successfully install
  a module under 5.6 or later.
  
  =item PPM_INSTALL_EXEC
  
  Name of the executable used to run C<PPM_INSTALL_SCRIPT> below. (e.g. perl)
  
  =item PPM_INSTALL_SCRIPT
  
  Name of the script that gets executed by the Perl Package Manager after
  the installation of a package.
  
  =item PPM_UNINSTALL_EXEC
  
  Name of the executable used to run C<PPM_UNINSTALL_SCRIPT> below. (e.g. perl)
  
  =item PPM_UNINSTALL_SCRIPT
  
  Name of the script that gets executed by the Perl Package Manager before
  the removal of a package.
  
  =item PREFIX
  
  This overrides all the default install locations.  Man pages,
  libraries, scripts, etc...  MakeMaker will try to make an educated
  guess about where to place things under the new PREFIX based on your
  Config defaults.  Failing that, it will fall back to a structure
  which should be sensible for your platform.
  
  If you specify LIB or any INSTALL* variables they will not be affected
  by the PREFIX.
  
  =item PREREQ_FATAL
  
  Bool. If this parameter is true, failing to have the required modules
  (or the right versions thereof) will be fatal. C<perl Makefile.PL>
  will C<die> instead of simply informing the user of the missing dependencies.
  
  It is I<extremely> rare to have to use C<PREREQ_FATAL>. Its use by module
  authors is I<strongly discouraged> and should never be used lightly.
  
  For dependencies that are required in order to run C<Makefile.PL>,
  see C<CONFIGURE_REQUIRES>.
  
  Module installation tools have ways of resolving unmet dependencies but
  to do that they need a F<Makefile>.  Using C<PREREQ_FATAL> breaks this.
  That's bad.
  
  Assuming you have good test coverage, your tests should fail with
  missing dependencies informing the user more strongly that something
  is wrong.  You can write a F<t/00compile.t> test which will simply
  check that your code compiles and stop "make test" prematurely if it
  doesn't.  See L<Test::More/BAIL_OUT> for more details.
  
  
  =item PREREQ_PM
  
  A hash of modules that are needed to run your module.  The keys are
  the module names ie. Test::More, and the minimum version is the
  value. If the required version number is 0 any version will do.
  
  This will go into the C<requires> field of your F<META.yml> and the C<runtime> of the C<prereqs> field of your F<META.json>.
  
      PREREQ_PM => {
          # Require Test::More at least 0.47
          "Test::More" => "0.47",
  
          # Require any version of Acme::Buffy
          "Acme::Buffy" => 0,
      }
  
  =item PREREQ_PRINT
  
  Bool.  If this parameter is true, the prerequisites will be printed to
  stdout and MakeMaker will exit.  The output format is an evalable hash
  ref.
  
    $PREREQ_PM = {
                   'A::B' => Vers1,
                   'C::D' => Vers2,
                   ...
                 };
  
  If a distribution defines a minimal required perl version, this is
  added to the output as an additional line of the form:
  
    $MIN_PERL_VERSION = '5.008001';
  
  If BUILD_REQUIRES is not empty, it will be dumped as $BUILD_REQUIRES hashref.
  
  =item PRINT_PREREQ
  
  RedHatism for C<PREREQ_PRINT>.  The output format is different, though:
  
      perl(A::B)>=Vers1 perl(C::D)>=Vers2 ...
  
  A minimal required perl version, if present, will look like this:
  
      perl(perl)>=5.008001
  
  =item SITEPREFIX
  
  Like PERLPREFIX, but only for the site install locations.
  
  Defaults to $Config{siteprefixexp}.  Perls prior to 5.6.0 didn't have
  an explicit siteprefix in the Config.  In those cases
  $Config{installprefix} will be used.
  
  Overridable by PREFIX
  
  =item SIGN
  
  When true, perform the generation and addition to the MANIFEST of the
  SIGNATURE file in the distdir during 'make distdir', via 'cpansign
  -s'.
  
  Note that you need to install the Module::Signature module to
  perform this operation.
  
  Defaults to false.
  
  =item SKIP
  
  Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the
  Makefile. Caution! Do not use the SKIP attribute for the negligible
  speedup. It may seriously damage the resulting Makefile. Only use it
  if you really need it.
  
  =item TEST_REQUIRES
  
  Available in version 6.64 and above.
  
  A hash of modules that are needed to test your module but not run or
  build it.
  
  This will go into the C<build_requires> field of your F<META.yml> and the C<test> of the C<prereqs> field of your F<META.json>.
  
  The format is the same as PREREQ_PM.
  
  =item TYPEMAPS
  
  Ref to array of typemap file names.  Use this when the typemaps are
  in some directory other than the current directory or when they are
  not named B<typemap>.  The last typemap in the list takes
  precedence.  A typemap in the current directory has highest
  precedence, even if it isn't listed in TYPEMAPS.  The default system
  typemap has lowest precedence.
  
  =item VENDORPREFIX
  
  Like PERLPREFIX, but only for the vendor install locations.
  
  Defaults to $Config{vendorprefixexp}.
  
  Overridable by PREFIX
  
  =item VERBINST
  
  If true, make install will be verbose
  
  =item VERSION
  
  Your version number for distributing the package.  This defaults to
  0.1.
  
  =item VERSION_FROM
  
  Instead of specifying the VERSION in the Makefile.PL you can let
  MakeMaker parse a file to determine the version number. The parsing
  routine requires that the file named by VERSION_FROM contains one
  single line to compute the version number. The first line in the file
  that contains something like a $VERSION assignment or C<package Name
  VERSION> will be used. The following lines will be parsed o.k.:
  
      # Good
      package Foo::Bar 1.23;                      # 1.23
      $VERSION   = '1.00';                        # 1.00
      *VERSION   = \'1.01';                       # 1.01
      ($VERSION) = q$Revision$ =~ /(\d+)/g;       # The digits in $Revision$
      $FOO::VERSION = '1.10';                     # 1.10
      *FOO::VERSION = \'1.11';                    # 1.11
  
  but these will fail:
  
      # Bad
      my $VERSION         = '1.01';
      local $VERSION      = '1.02';
      local $FOO::VERSION = '1.30';
  
  (Putting C<my> or C<local> on the preceding line will work o.k.)
  
  "Version strings" are incompatible and should not be used.
  
      # Bad
      $VERSION = 1.2.3;
      $VERSION = v1.2.3;
  
  L<version> objects are fine.  As of MakeMaker 6.35 version.pm will be
  automatically loaded, but you must declare the dependency on version.pm.
  For compatibility with older MakeMaker you should load on the same line
  as $VERSION is declared.
  
      # All on one line
      use version; our $VERSION = qv(1.2.3);
  
  The file named in VERSION_FROM is not added as a dependency to
  Makefile. This is not really correct, but it would be a major pain
  during development to have to rewrite the Makefile for any smallish
  change in that file. If you want to make sure that the Makefile
  contains the correct VERSION macro after any change of the file, you
  would have to do something like
  
      depend => { Makefile => '$(VERSION_FROM)' }
  
  See attribute C<depend> below.
  
  =item VERSION_SYM
  
  A sanitized VERSION with . replaced by _.  For places where . has
  special meaning (some filesystems, RCS labels, etc...)
  
  =item XS
  
  Hashref of .xs files. MakeMaker will default this.  e.g.
  
    {'name_of_file.xs' => 'name_of_file.c'}
  
  The .c files will automatically be included in the list of files
  deleted by a make clean.
  
  =item XSOPT
  
  String of options to pass to xsubpp.  This might include C<-C++> or
  C<-extern>.  Do not include typemaps here; the TYPEMAP parameter exists for
  that purpose.
  
  =item XSPROTOARG
  
  May be set to C<-protoypes>, C<-noprototypes> or the empty string.  The
  empty string is equivalent to the xsubpp default, or C<-noprototypes>.
  See the xsubpp documentation for details.  MakeMaker
  defaults to the empty string.
  
  =item XS_VERSION
  
  Your version number for the .xs file of this package.  This defaults
  to the value of the VERSION attribute.
  
  =back
  
  =head2 Additional lowercase attributes
  
  can be used to pass parameters to the methods which implement that
  part of the Makefile.  Parameters are specified as a hash ref but are
  passed to the method as a hash.
  
  =over 2
  
  =item clean
  
    {FILES => "*.xyz foo"}
  
  =item depend
  
    {ANY_TARGET => ANY_DEPENDENCY, ...}
  
  (ANY_TARGET must not be given a double-colon rule by MakeMaker.)
  
  =item dist
  
    {TARFLAGS => 'cvfF', COMPRESS => 'gzip', SUFFIX => '.gz',
    SHAR => 'shar -m', DIST_CP => 'ln', ZIP => '/bin/zip',
    ZIPFLAGS => '-rl', DIST_DEFAULT => 'private tardist' }
  
  If you specify COMPRESS, then SUFFIX should also be altered, as it is
  needed to tell make the target file of the compression. Setting
  DIST_CP to ln can be useful, if you need to preserve the timestamps on
  your files. DIST_CP can take the values 'cp', which copies the file,
  'ln', which links the file, and 'best' which copies symbolic links and
  links the rest. Default is 'best'.
  
  =item dynamic_lib
  
    {ARMAYBE => 'ar', OTHERLDFLAGS => '...', INST_DYNAMIC_DEP => '...'}
  
  =item linkext
  
    {LINKTYPE => 'static', 'dynamic' or ''}
  
  NB: Extensions that have nothing but *.pm files had to say
  
    {LINKTYPE => ''}
  
  with Pre-5.0 MakeMakers. Since version 5.00 of MakeMaker such a line
  can be deleted safely. MakeMaker recognizes when there's nothing to
  be linked.
  
  =item macro
  
    {ANY_MACRO => ANY_VALUE, ...}
  
  =item postamble
  
  Anything put here will be passed to MY::postamble() if you have one.
  
  =item realclean
  
    {FILES => '$(INST_ARCHAUTODIR)/*.xyz'}
  
  =item test
  
  Specify the targets for testing.
  
    {TESTS => 't/*.t'}
  
  C<RECURSIVE_TEST_FILES> can be used to include all directories
  recursively under C<t> that contain C<.t> files. It will be ignored if
  you provide your own C<TESTS> attribute, defaults to false.
  
    {RECURSIVE_TEST_FILES=>1}
  
  =item tool_autosplit
  
    {MAXLEN => 8}
  
  =back
  
  =head2 Overriding MakeMaker Methods
  
  If you cannot achieve the desired Makefile behaviour by specifying
  attributes you may define private subroutines in the Makefile.PL.
  Each subroutine returns the text it wishes to have written to
  the Makefile. To override a section of the Makefile you can
  either say:
  
          sub MY::c_o { "new literal text" }
  
  or you can edit the default by saying something like:
  
          package MY; # so that "SUPER" works right
          sub c_o {
              my $inherited = shift->SUPER::c_o(@_);
              $inherited =~ s/old text/new text/;
              $inherited;
          }
  
  If you are running experiments with embedding perl as a library into
  other applications, you might find MakeMaker is not sufficient. You'd
  better have a look at ExtUtils::Embed which is a collection of utilities
  for embedding.
  
  If you still need a different solution, try to develop another
  subroutine that fits your needs and submit the diffs to
  C<makemaker@perl.org>
  
  For a complete description of all MakeMaker methods see
  L<ExtUtils::MM_Unix>.
  
  Here is a simple example of how to add a new target to the generated
  Makefile:
  
      sub MY::postamble {
          return <<'MAKE_FRAG';
      $(MYEXTLIB): sdbm/Makefile
              cd sdbm && $(MAKE) all
  
      MAKE_FRAG
      }
  
  =head2 The End Of Cargo Cult Programming
  
  WriteMakefile() now does some basic sanity checks on its parameters to
  protect against typos and malformatted values.  This means some things
  which happened to work in the past will now throw warnings and
  possibly produce internal errors.
  
  Some of the most common mistakes:
  
  =over 2
  
  =item C<< MAN3PODS => ' ' >>
  
  This is commonly used to suppress the creation of man pages.  MAN3PODS
  takes a hash ref not a string, but the above worked by accident in old
  versions of MakeMaker.
  
  The correct code is C<< MAN3PODS => { } >>.
  
  =back
  
  
  =head2 Hintsfile support
  
  MakeMaker.pm uses the architecture-specific information from
  Config.pm. In addition it evaluates architecture specific hints files
  in a C<hints/> directory. The hints files are expected to be named
  like their counterparts in C<PERL_SRC/hints>, but with an C<.pl> file
  name extension (eg. C<next_3_2.pl>). They are simply C<eval>ed by
  MakeMaker within the WriteMakefile() subroutine, and can be used to
  execute commands as well as to include special variables. The rules
  which hintsfile is chosen are the same as in Configure.
  
  The hintsfile is eval()ed immediately after the arguments given to
  WriteMakefile are stuffed into a hash reference $self but before this
  reference becomes blessed. So if you want to do the equivalent to
  override or create an attribute you would say something like
  
      $self->{LIBS} = ['-ldbm -lucb -lc'];
  
  =head2 Distribution Support
  
  For authors of extensions MakeMaker provides several Makefile
  targets. Most of the support comes from the ExtUtils::Manifest module,
  where additional documentation can be found.
  
  =over 4
  
  =item    make distcheck
  
  reports which files are below the build directory but not in the
  MANIFEST file and vice versa. (See ExtUtils::Manifest::fullcheck() for
  details)
  
  =item    make skipcheck
  
  reports which files are skipped due to the entries in the
  C<MANIFEST.SKIP> file (See ExtUtils::Manifest::skipcheck() for
  details)
  
  =item    make distclean
  
  does a realclean first and then the distcheck. Note that this is not
  needed to build a new distribution as long as you are sure that the
  MANIFEST file is ok.
  
  =item    make veryclean
  
  does a realclean first and then removes backup files such as C<*~>,
  C<*.bak>, C<*.old> and C<*.orig>
  
  =item    make manifest
  
  rewrites the MANIFEST file, adding all remaining files found (See
  ExtUtils::Manifest::mkmanifest() for details)
  
  =item    make distdir
  
  Copies all the files that are in the MANIFEST file to a newly created
  directory with the name C<$(DISTNAME)-$(VERSION)>. If that directory
  exists, it will be removed first.
  
  Additionally, it will create META.yml and META.json module meta-data file
  in the distdir and add this to the distdir's MANIFEST.  You can shut this
  behavior off with the NO_META flag.
  
  =item   make disttest
  
  Makes a distdir first, and runs a C<perl Makefile.PL>, a make, and
  a make test in that directory.
  
  =item    make tardist
  
  First does a distdir. Then a command $(PREOP) which defaults to a null
  command, followed by $(TO_UNIX), which defaults to a null command under
  UNIX, and will convert files in distribution directory to UNIX format
  otherwise. Next it runs C<tar> on that directory into a tarfile and
  deletes the directory. Finishes with a command $(POSTOP) which
  defaults to a null command.
  
  =item    make dist
  
  Defaults to $(DIST_DEFAULT) which in turn defaults to tardist.
  
  =item    make uutardist
  
  Runs a tardist first and uuencodes the tarfile.
  
  =item    make shdist
  
  First does a distdir. Then a command $(PREOP) which defaults to a null
  command. Next it runs C<shar> on that directory into a sharfile and
  deletes the intermediate directory again. Finishes with a command
  $(POSTOP) which defaults to a null command.  Note: For shdist to work
  properly a C<shar> program that can handle directories is mandatory.
  
  =item    make zipdist
  
  First does a distdir. Then a command $(PREOP) which defaults to a null
  command. Runs C<$(ZIP) $(ZIPFLAGS)> on that directory into a
  zipfile. Then deletes that directory. Finishes with a command
  $(POSTOP) which defaults to a null command.
  
  =item    make ci
  
  Does a $(CI) and a $(RCS_LABEL) on all files in the MANIFEST file.
  
  =back
  
  Customization of the dist targets can be done by specifying a hash
  reference to the dist attribute of the WriteMakefile call. The
  following parameters are recognized:
  
      CI           ('ci -u')
      COMPRESS     ('gzip --best')
      POSTOP       ('@ :')
      PREOP        ('@ :')
      TO_UNIX      (depends on the system)
      RCS_LABEL    ('rcs -q -Nv$(VERSION_SYM):')
      SHAR         ('shar')
      SUFFIX       ('.gz')
      TAR          ('tar')
      TARFLAGS     ('cvf')
      ZIP          ('zip')
      ZIPFLAGS     ('-r')
  
  An example:
  
      WriteMakefile(
          ...other options...
          dist => {
              COMPRESS => "bzip2",
              SUFFIX   => ".bz2"
          }
      );
  
  
  =head2 Module Meta-Data (META and MYMETA)
  
  Long plaguing users of MakeMaker based modules has been the problem of
  getting basic information about the module out of the sources
  I<without> running the F<Makefile.PL> and doing a bunch of messy
  heuristics on the resulting F<Makefile>.  Over the years, it has become
  standard to keep this information in one or more CPAN Meta files
  distributed with each distribution.
  
  The original format of CPAN Meta files was L<YAML> and the corresponding
  file was called F<META.yml>.  In 2010, version 2 of the L<CPAN::Meta::Spec>
  was released, which mandates JSON format for the metadata in order to
  overcome certain compatibility issues between YAML serializers and to
  avoid breaking older clients unable to handle a new version of the spec.
  The L<CPAN::Meta> library is now standard for accessing old and new-style
  Meta files.
  
  If L<CPAN::Meta> is installed, MakeMaker will automatically generate
  F<META.json> and F<META.yml> files for you and add them to your F<MANIFEST> as
  part of the 'distdir' target (and thus the 'dist' target).  This is intended to
  seamlessly and rapidly populate CPAN with module meta-data.  If you wish to
  shut this feature off, set the C<NO_META> C<WriteMakefile()> flag to true.
  
  At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees
  to use the CPAN Meta format to communicate post-configuration requirements
  between toolchain components.  These files, F<MYMETA.json> and F<MYMETA.yml>,
  are generated when F<Makefile.PL> generates a F<Makefile> (if L<CPAN::Meta>
  is installed).  Clients like L<CPAN> or L<CPANPLUS> will read this
  files to see what prerequisites must be fulfilled before building or testing
  the distribution.  If you with to shut this feature off, set the C<NO_MYMETA>
  C<WriteMakeFile()> flag to true.
  
  =head2 Disabling an extension
  
  If some events detected in F<Makefile.PL> imply that there is no way
  to create the Module, but this is a normal state of things, then you
  can create a F<Makefile> which does nothing, but succeeds on all the
  "usual" build targets.  To do so, use
  
      use ExtUtils::MakeMaker qw(WriteEmptyMakefile);
      WriteEmptyMakefile();
  
  instead of WriteMakefile().
  
  This may be useful if other modules expect this module to be I<built>
  OK, as opposed to I<work> OK (say, this system-dependent module builds
  in a subdirectory of some other distribution, or is listed as a
  dependency in a CPAN::Bundle, but the functionality is supported by
  different means on the current architecture).
  
  =head2 Other Handy Functions
  
  =over 4
  
  =item prompt
  
      my $value = prompt($message);
      my $value = prompt($message, $default);
  
  The C<prompt()> function provides an easy way to request user input
  used to write a makefile.  It displays the $message as a prompt for
  input.  If a $default is provided it will be used as a default.  The
  function returns the $value selected by the user.
  
  If C<prompt()> detects that it is not running interactively and there
  is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable
  is set to true, the $default will be used without prompting.  This
  prevents automated processes from blocking on user input.
  
  If no $default is provided an empty string will be used instead.
  
  =back
  
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item PERL_MM_OPT
  
  Command line options used by C<MakeMaker-E<gt>new()>, and thus by
  C<WriteMakefile()>.  The string is split as the shell would, and the result
  is processed before any actual command line arguments are processed.
  
    PERL_MM_OPT='CCFLAGS="-Wl,-rpath -Wl,/foo/bar/lib" LIBS="-lwibble -lwobble"'
  
  =item PERL_MM_USE_DEFAULT
  
  If set to a true value then MakeMaker's prompt function will
  always return the default without waiting for user input.
  
  =item PERL_CORE
  
  Same as the PERL_CORE parameter.  The parameter overrides this.
  
  =back
  
  =head1 SEE ALSO
  
  L<Module::Build> is a pure-Perl alternative to MakeMaker which does
  not rely on make or any other external utility.  It is easier to
  extend to suit your needs.
  
  L<Module::Install> is a wrapper around MakeMaker which adds features
  not normally available.
  
  L<ExtUtils::ModuleMaker> and L<Module::Starter> are both modules to
  help you setup your distribution.
  
  L<CPAN::Meta> and L<CPAN::Meta::Spec> explain CPAN Meta files in detail.
  
  =head1 AUTHORS
  
  Andy Dougherty C<doughera@lafayette.edu>, Andreas KE<ouml>nig
  C<andreas.koenig@mind.de>, Tim Bunce C<timb@cpan.org>.  VMS
  support by Charles Bailey C<bailey@newman.upenn.edu>.  OS/2 support
  by Ilya Zakharevich C<ilya@math.ohio-state.edu>.
  
  Currently maintained by Michael G Schwern C<schwern@pobox.com>
  
  Send patches and ideas to C<makemaker@perl.org>.
  
  Send bug reports via http://rt.cpan.org/.  Please send your
  generated Makefile along with your report.
  
  For more up-to-date information, see L<https://metacpan.org/release/ExtUtils-MakeMaker>.
  
  Repository available at L<https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker>.
  
  =head1 LICENSE
  
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  
  =cut
EXTUTILS_MAKEMAKER

$fatpacked{"ExtUtils/MakeMaker/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_CONFIG';
  package ExtUtils::MakeMaker::Config;
  
  use strict;
  
  our $VERSION = '6.92';
  
  use Config ();
  
  # Give us an overridable config.
  our %Config = %Config::Config;
  
  sub import {
      my $caller = caller;
  
      no strict 'refs';   ## no critic
      *{$caller.'::Config'} = \%Config;
  }
  
  1;
  
  
  =head1 NAME
  
  ExtUtils::MakeMaker::Config - Wrapper around Config.pm
  
  
  =head1 SYNOPSIS
  
    use ExtUtils::MakeMaker::Config;
    print $Config{installbin};  # or whatever
  
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY>
  
  A very thin wrapper around Config.pm so MakeMaker is easier to test.
  
  =cut
EXTUTILS_MAKEMAKER_CONFIG

$fatpacked{"ExtUtils/Mkbootstrap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKBOOTSTRAP';
  package ExtUtils::Mkbootstrap;
  
  # There's just too much Dynaloader incest here to turn on strict vars.
  use strict 'refs';
  
  our $VERSION = '6.92';
  
  require Exporter;
  our @ISA = ('Exporter');
  our @EXPORT = ('&Mkbootstrap');
  
  use Config;
  
  our $Verbose = 0;
  
  
  sub Mkbootstrap {
      my($baseext, @bsloadlibs)=@_;
      @bsloadlibs = grep($_, @bsloadlibs); # strip empty libs
  
      print "	bsloadlibs=@bsloadlibs\n" if $Verbose;
  
      # We need DynaLoader here because we and/or the *_BS file may
      # call dl_findfile(). We don't say `use' here because when
      # first building perl extensions the DynaLoader will not have
      # been built when MakeMaker gets first used.
      require DynaLoader;
  
      rename "$baseext.bs", "$baseext.bso"
        if -s "$baseext.bs";
  
      if (-f "${baseext}_BS"){
  	$_ = "${baseext}_BS";
  	package DynaLoader; # execute code as if in DynaLoader
  	local($osname, $dlsrc) = (); # avoid warnings
  	($osname, $dlsrc) = @Config::Config{qw(osname dlsrc)};
  	$bscode = "";
  	unshift @INC, ".";
  	require $_;
  	shift @INC;
      }
  
      if ($Config{'dlsrc'} =~ /^dl_dld/){
  	package DynaLoader;
  	push(@dl_resolve_using, dl_findfile('-lc'));
      }
  
      my(@all) = (@bsloadlibs, @DynaLoader::dl_resolve_using);
      my($method) = '';
      if (@all){
  	open my $bs, ">", "$baseext.bs"
  		or die "Unable to open $baseext.bs: $!";
  	print "Writing $baseext.bs\n";
  	print "	containing: @all" if $Verbose;
  	print $bs "# $baseext DynaLoader bootstrap file for $^O architecture.\n";
  	print $bs "# Do not edit this file, changes will be lost.\n";
  	print $bs "# This file was automatically generated by the\n";
  	print $bs "# Mkbootstrap routine in ExtUtils::Mkbootstrap (v$VERSION).\n";
  	print $bs "\@DynaLoader::dl_resolve_using = ";
  	# If @all contains names in the form -lxxx or -Lxxx then it's asking for
  	# runtime library location so we automatically add a call to dl_findfile()
  	if (" @all" =~ m/ -[lLR]/){
  	    print $bs "  dl_findfile(qw(\n  @all\n  ));\n";
  	}else{
  	    print $bs "  qw(@all);\n";
  	}
  	# write extra code if *_BS says so
  	print $bs $DynaLoader::bscode if $DynaLoader::bscode;
  	print $bs "\n1;\n";
  	close $bs;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::Mkbootstrap - make a bootstrap file for use by DynaLoader
  
  =head1 SYNOPSIS
  
  C<Mkbootstrap>
  
  =head1 DESCRIPTION
  
  Mkbootstrap typically gets called from an extension Makefile.
  
  There is no C<*.bs> file supplied with the extension. Instead, there may
  be a C<*_BS> file which has code for the special cases, like posix for
  berkeley db on the NeXT.
  
  This file will get parsed, and produce a maybe empty
  C<@DynaLoader::dl_resolve_using> array for the current architecture.
  That will be extended by $BSLOADLIBS, which was computed by
  ExtUtils::Liblist::ext(). If this array still is empty, we do nothing,
  else we write a .bs file with an C<@DynaLoader::dl_resolve_using>
  array.
  
  The C<*_BS> file can put some code into the generated C<*.bs> file by
  placing it in C<$bscode>. This is a handy 'escape' mechanism that may
  prove useful in complex situations.
  
  If @DynaLoader::dl_resolve_using contains C<-L*> or C<-l*> entries then
  Mkbootstrap will automatically add a dl_findfile() call to the
  generated C<*.bs> file.
  
  =cut
EXTUTILS_MKBOOTSTRAP

$fatpacked{"ExtUtils/Mksymlists.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MKSYMLISTS';
  package ExtUtils::Mksymlists;
  
  use 5.006;
  use strict qw[ subs refs ];
  # no strict 'vars';  # until filehandles are exempted
  
  use Carp;
  use Exporter;
  use Config;
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(&Mksymlists);
  our $VERSION = '6.92';
  
  sub Mksymlists {
      my(%spec) = @_;
      my($osname) = $^O;
  
      croak("Insufficient information specified to Mksymlists")
          unless ( $spec{NAME} or
                   ($spec{FILE} and ($spec{DL_FUNCS} or $spec{FUNCLIST})) );
  
      $spec{DL_VARS} = [] unless $spec{DL_VARS};
      ($spec{FILE} = $spec{NAME}) =~ s/.*::// unless $spec{FILE};
      $spec{FUNCLIST} = [] unless $spec{FUNCLIST};
      $spec{DL_FUNCS} = { $spec{NAME} => [] }
          unless ( ($spec{DL_FUNCS} and keys %{$spec{DL_FUNCS}}) or
                   @{$spec{FUNCLIST}});
      if (defined $spec{DL_FUNCS}) {
          foreach my $package (sort keys %{$spec{DL_FUNCS}}) {
              my($packprefix,$bootseen);
              ($packprefix = $package) =~ s/\W/_/g;
              foreach my $sym (@{$spec{DL_FUNCS}->{$package}}) {
                  if ($sym =~ /^boot_/) {
                      push(@{$spec{FUNCLIST}},$sym);
                      $bootseen++;
                  }
                  else {
                      push(@{$spec{FUNCLIST}},"XS_${packprefix}_$sym");
                  }
              }
              push(@{$spec{FUNCLIST}},"boot_$packprefix") unless $bootseen;
          }
      }
  
  #    We'll need this if we ever add any OS which uses mod2fname
  #    not as pseudo-builtin.
  #    require DynaLoader;
      if (defined &DynaLoader::mod2fname and not $spec{DLBASE}) {
          $spec{DLBASE} = DynaLoader::mod2fname([ split(/::/,$spec{NAME}) ]);
      }
  
      if    ($osname eq 'aix') { _write_aix(\%spec); }
      elsif ($osname eq 'MacOS'){ _write_aix(\%spec) }
      elsif ($osname eq 'VMS') { _write_vms(\%spec) }
      elsif ($osname eq 'os2') { _write_os2(\%spec) }
      elsif ($osname eq 'MSWin32') { _write_win32(\%spec) }
      else {
          croak("Don't know how to create linker option file for $osname\n");
      }
  }
  
  
  sub _write_aix {
      my($data) = @_;
  
      rename "$data->{FILE}.exp", "$data->{FILE}.exp_old";
  
      open( my $exp, ">", "$data->{FILE}.exp")
          or croak("Can't create $data->{FILE}.exp: $!\n");
      print $exp join("\n",@{$data->{DL_VARS}}, "\n") if @{$data->{DL_VARS}};
      print $exp join("\n",@{$data->{FUNCLIST}}, "\n") if @{$data->{FUNCLIST}};
      close $exp;
  }
  
  
  sub _write_os2 {
      my($data) = @_;
      require Config;
      my $threaded = ($Config::Config{archname} =~ /-thread/ ? " threaded" : "");
  
      if (not $data->{DLBASE}) {
          ($data->{DLBASE} = $data->{NAME}) =~ s/.*:://;
          $data->{DLBASE} = substr($data->{DLBASE},0,7) . '_';
      }
      my $distname = $data->{DISTNAME} || $data->{NAME};
      $distname = "Distribution $distname";
      my $patchlevel = " pl$Config{perl_patchlevel}" || '';
      my $comment = sprintf "Perl (v%s%s%s) module %s",
        $Config::Config{version}, $threaded, $patchlevel, $data->{NAME};
      chomp $comment;
      if ($data->{INSTALLDIRS} and $data->{INSTALLDIRS} eq 'perl') {
          $distname = 'perl5-porters@perl.org';
          $comment = "Core $comment";
      }
      $comment = "$comment (Perl-config: $Config{config_args})";
      $comment = substr($comment, 0, 200) . "...)" if length $comment > 203;
      rename "$data->{FILE}.def", "$data->{FILE}_def.old";
  
      open(my $def, ">", "$data->{FILE}.def")
          or croak("Can't create $data->{FILE}.def: $!\n");
      print $def "LIBRARY '$data->{DLBASE}' INITINSTANCE TERMINSTANCE\n";
      print $def "DESCRIPTION '\@#$distname:$data->{VERSION}#\@ $comment'\n";
      print $def "CODE LOADONCALL\n";
      print $def "DATA LOADONCALL NONSHARED MULTIPLE\n";
      print $def "EXPORTS\n  ";
      print $def join("\n  ",@{$data->{DL_VARS}}, "\n") if @{$data->{DL_VARS}};
      print $def join("\n  ",@{$data->{FUNCLIST}}, "\n") if @{$data->{FUNCLIST}};
      _print_imports($def, $data);
      close $def;
  }
  
  sub _print_imports {
      my ($def, $data)= @_;
      my $imports= $data->{IMPORTS}
          or return;
      if ( keys %$imports ) {
          print $def "IMPORTS\n";
          foreach my $name (sort keys %$imports) {
              print $def "  $name=$imports->{$name}\n";
          }
      }
  }
  
  sub _write_win32 {
      my($data) = @_;
  
      require Config;
      if (not $data->{DLBASE}) {
          ($data->{DLBASE} = $data->{NAME}) =~ s/.*:://;
          $data->{DLBASE} = substr($data->{DLBASE},0,7) . '_';
      }
      rename "$data->{FILE}.def", "$data->{FILE}_def.old";
  
      open( my $def, ">", "$data->{FILE}.def" )
          or croak("Can't create $data->{FILE}.def: $!\n");
      # put library name in quotes (it could be a keyword, like 'Alias')
      if ($Config::Config{'cc'} !~ /^gcc/i) {
          print $def "LIBRARY \"$data->{DLBASE}\"\n";
      }
      print $def "EXPORTS\n  ";
      my @syms;
      # Export public symbols both with and without underscores to
      # ensure compatibility between DLLs from different compilers
      # NOTE: DynaLoader itself only uses the names without underscores,
      # so this is only to cover the case when the extension DLL may be
      # linked to directly from C. GSAR 97-07-10
      if ($Config::Config{'cc'} =~ /^bcc/i) {
          for (@{$data->{DL_VARS}}, @{$data->{FUNCLIST}}) {
              push @syms, "_$_", "$_ = _$_";
          }
      }
      else {
          for (@{$data->{DL_VARS}}, @{$data->{FUNCLIST}}) {
              push @syms, "$_", "_$_ = $_";
          }
      }
      print $def join("\n  ",@syms, "\n") if @syms;
      _print_imports($def, $data);
      close $def;
  }
  
  
  sub _write_vms {
      my($data) = @_;
  
      require Config; # a reminder for once we do $^O
      require ExtUtils::XSSymSet;
  
      my($isvax) = $Config::Config{'archname'} =~ /VAX/i;
      my($set) = new ExtUtils::XSSymSet;
  
      rename "$data->{FILE}.opt", "$data->{FILE}.opt_old";
  
      open(my $opt,">", "$data->{FILE}.opt")
          or croak("Can't create $data->{FILE}.opt: $!\n");
  
      # Options file declaring universal symbols
      # Used when linking shareable image for dynamic extension,
      # or when linking PerlShr into which we've added this package
      # as a static extension
      # We don't do anything to preserve order, so we won't relax
      # the GSMATCH criteria for a dynamic extension
  
      print $opt "case_sensitive=yes\n"
          if $Config::Config{d_vms_case_sensitive_symbols};
  
      foreach my $sym (@{$data->{FUNCLIST}}) {
          my $safe = $set->addsym($sym);
          if ($isvax) { print $opt "UNIVERSAL=$safe\n" }
          else        { print $opt "SYMBOL_VECTOR=($safe=PROCEDURE)\n"; }
      }
  
      foreach my $sym (@{$data->{DL_VARS}}) {
          my $safe = $set->addsym($sym);
          print $opt "PSECT_ATTR=${sym},PIC,OVR,RD,NOEXE,WRT,NOSHR\n";
          if ($isvax) { print $opt "UNIVERSAL=$safe\n" }
          else        { print $opt "SYMBOL_VECTOR=($safe=DATA)\n"; }
      }
  
      close $opt;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  ExtUtils::Mksymlists - write linker options files for dynamic extension
  
  =head1 SYNOPSIS
  
      use ExtUtils::Mksymlists;
      Mksymlists(  NAME     => $name ,
                   DL_VARS  => [ $var1, $var2, $var3 ],
                   DL_FUNCS => { $pkg1 => [ $func1, $func2 ],
                                 $pkg2 => [ $func3 ] );
  
  =head1 DESCRIPTION
  
  C<ExtUtils::Mksymlists> produces files used by the linker under some OSs
  during the creation of shared libraries for dynamic extensions.  It is
  normally called from a MakeMaker-generated Makefile when the extension
  is built.  The linker option file is generated by calling the function
  C<Mksymlists>, which is exported by default from C<ExtUtils::Mksymlists>.
  It takes one argument, a list of key-value pairs, in which the following
  keys are recognized:
  
  =over 4
  
  =item DLBASE
  
  This item specifies the name by which the linker knows the
  extension, which may be different from the name of the
  extension itself (for instance, some linkers add an '_' to the
  name of the extension).  If it is not specified, it is derived
  from the NAME attribute.  It is presently used only by OS2 and Win32.
  
  =item DL_FUNCS
  
  This is identical to the DL_FUNCS attribute available via MakeMaker,
  from which it is usually taken.  Its value is a reference to an
  associative array, in which each key is the name of a package, and
  each value is an a reference to an array of function names which
  should be exported by the extension.  For instance, one might say
  C<DL_FUNCS =E<gt> { Homer::Iliad =E<gt> [ qw(trojans greeks) ],
  Homer::Odyssey =E<gt> [ qw(travellers family suitors) ] }>.  The
  function names should be identical to those in the XSUB code;
  C<Mksymlists> will alter the names written to the linker option
  file to match the changes made by F<xsubpp>.  In addition, if
  none of the functions in a list begin with the string B<boot_>,
  C<Mksymlists> will add a bootstrap function for that package,
  just as xsubpp does.  (If a B<boot_E<lt>pkgE<gt>> function is
  present in the list, it is passed through unchanged.)  If
  DL_FUNCS is not specified, it defaults to the bootstrap
  function for the extension specified in NAME.
  
  =item DL_VARS
  
  This is identical to the DL_VARS attribute available via MakeMaker,
  and, like DL_FUNCS, it is usually specified via MakeMaker.  Its
  value is a reference to an array of variable names which should
  be exported by the extension.
  
  =item FILE
  
  This key can be used to specify the name of the linker option file
  (minus the OS-specific extension), if for some reason you do not
  want to use the default value, which is the last word of the NAME
  attribute (I<e.g.> for C<Tk::Canvas>, FILE defaults to C<Canvas>).
  
  =item FUNCLIST
  
  This provides an alternate means to specify function names to be
  exported from the extension.  Its value is a reference to an
  array of function names to be exported by the extension.  These
  names are passed through unaltered to the linker options file.
  Specifying a value for the FUNCLIST attribute suppresses automatic
  generation of the bootstrap function for the package. To still create
  the bootstrap name you have to specify the package name in the
  DL_FUNCS hash:
  
      Mksymlists(  NAME     => $name ,
  		 FUNCLIST => [ $func1, $func2 ],
                   DL_FUNCS => { $pkg => [] } );
  
  
  =item IMPORTS
  
  This attribute is used to specify names to be imported into the
  extension. It is currently only used by OS/2 and Win32.
  
  =item NAME
  
  This gives the name of the extension (I<e.g.> C<Tk::Canvas>) for which
  the linker option file will be produced.
  
  =back
  
  When calling C<Mksymlists>, one should always specify the NAME
  attribute.  In most cases, this is all that's necessary.  In
  the case of unusual extensions, however, the other attributes
  can be used to provide additional information to the linker.
  
  =head1 AUTHOR
  
  Charles Bailey I<E<lt>bailey@newman.upenn.eduE<gt>>
  
  =head1 REVISION
  
  Last revised 14-Feb-1996, for Perl 5.002.
EXTUTILS_MKSYMLISTS

$fatpacked{"ExtUtils/testlib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_TESTLIB';
  package ExtUtils::testlib;
  
  use strict;
  use warnings;
  
  our $VERSION = '6.92';
  
  use Cwd;
  use File::Spec;
  
  # So the tests can chdir around and not break @INC.
  # We use getcwd() because otherwise rel2abs will blow up under taint
  # mode pre-5.8.  We detaint is so @INC won't be tainted.  This is
  # no worse, and probably better, than just shoving an untainted,
  # relative "blib/lib" onto @INC.
  my $cwd;
  BEGIN {
      ($cwd) = getcwd() =~ /(.*)/;
  }
  use lib map { File::Spec->rel2abs($_, $cwd) } qw(blib/arch blib/lib);
  1;
  __END__
  
  =head1 NAME
  
  ExtUtils::testlib - add blib/* directories to @INC
  
  =head1 SYNOPSIS
  
    use ExtUtils::testlib;
  
  =head1 DESCRIPTION
  
  After an extension has been built and before it is installed it may be
  desirable to test it bypassing C<make test>. By adding
  
      use ExtUtils::testlib;
  
  to a test program the intermediate directories used by C<make> are
  added to @INC.
  
EXTUTILS_TESTLIB

$fatpacked{"File/Copy/Recursive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_COPY_RECURSIVE';
  package File::Copy::Recursive;
  
  use strict;
  BEGIN {
      # Keep older versions of Perl from trying to use lexical warnings
      $INC{'warnings.pm'} = "fake warnings entry for < 5.6 perl ($])" if $] < 5.006;
  }
  use warnings;
  
  use Carp;
  use File::Copy; 
  use File::Spec; #not really needed because File::Copy already gets it, but for good measure :)
  
  use vars qw( 
      @ISA      @EXPORT_OK $VERSION  $MaxDepth $KeepMode $CPRFComp $CopyLink 
      $PFSCheck $RemvBase $NoFtlPth  $ForcePth $CopyLoop $RMTrgFil $RMTrgDir 
      $CondCopy $BdTrgWrn $SkipFlop  $DirPerms
  );
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(fcopy rcopy dircopy fmove rmove dirmove pathmk pathrm pathempty pathrmdir);
  $VERSION = '0.38';
  
  $MaxDepth = 0;
  $KeepMode = 1;
  $CPRFComp = 0; 
  $CopyLink = eval { local $SIG{'__DIE__'};symlink '',''; 1 } || 0;
  $PFSCheck = 1;
  $RemvBase = 0;
  $NoFtlPth = 0;
  $ForcePth = 0;
  $CopyLoop = 0;
  $RMTrgFil = 0;
  $RMTrgDir = 0;
  $CondCopy = {};
  $BdTrgWrn = 0;
  $SkipFlop = 0;
  $DirPerms = 0777; 
  
  my $samecheck = sub {
     return 1 if $^O eq 'MSWin32'; # need better way to check for this on winders...
     return if @_ != 2 || !defined $_[0] || !defined $_[1];
     return if $_[0] eq $_[1];
  
     my $one = '';
     if($PFSCheck) {
        $one    = join( '-', ( stat $_[0] )[0,1] ) || '';
        my $two = join( '-', ( stat $_[1] )[0,1] ) || '';
        if ( $one eq $two && $one ) {
            carp "$_[0] and $_[1] are identical";
            return;
        }
     }
  
     if(-d $_[0] && !$CopyLoop) {
        $one    = join( '-', ( stat $_[0] )[0,1] ) if !$one;
        my $abs = File::Spec->rel2abs($_[1]);
        my @pth = File::Spec->splitdir( $abs );
        while(@pth) {
           my $cur = File::Spec->catdir(@pth);
           last if !$cur; # probably not necessary, but nice to have just in case :)
           my $two = join( '-', ( stat $cur )[0,1] ) || '';
           if ( $one eq $two && $one ) {
               # $! = 62; # Too many levels of symbolic links
               carp "Caught Deep Recursion Condition: $_[0] contains $_[1]";
               return;
           }
        
           pop @pth;
        }
     }
  
     return 1;
  };
  
  my $glob = sub {
      my ($do, $src_glob, @args) = @_;
      
      local $CPRFComp = 1;
      
      my @rt;
      for my $path ( glob($src_glob) ) {
          my @call = [$do->($path, @args)] or return;
          push @rt, \@call;
      }
      
      return @rt;
  };
  
  my $move = sub {
     my $fl = shift;
     my @x;
     if($fl) {
        @x = fcopy(@_) or return;
     } else {
        @x = dircopy(@_) or return;
     }
     if(@x) {
        if($fl) {
           unlink $_[0] or return;
        } else {
           pathrmdir($_[0]) or return;
        }
        if($RemvBase) {
           my ($volm, $path) = File::Spec->splitpath($_[0]);
           pathrm(File::Spec->catpath($volm,$path,''), $ForcePth, $NoFtlPth) or return;
        }
     }
    return wantarray ? @x : $x[0];
  };
  
  my $ok_todo_asper_condcopy = sub {
      my $org = shift;
      my $copy = 1;
      if(exists $CondCopy->{$org}) {
          if($CondCopy->{$org}{'md5'}) {
  
          }
          if($copy) {
  
          }
      }
      return $copy;
  };
  
  sub fcopy { 
     $samecheck->(@_) or return;
     if($RMTrgFil && (-d $_[1] || -e $_[1]) ) {
        my $trg = $_[1];
        if( -d $trg ) {
          my @trgx = File::Spec->splitpath( $_[0] );
          $trg = File::Spec->catfile( $_[1], $trgx[ $#trgx ] );
        }
        $samecheck->($_[0], $trg) or return;
        if(-e $trg) {
           if($RMTrgFil == 1) {
              unlink $trg or carp "\$RMTrgFil failed: $!";
           } else {
              unlink $trg or return;
           }
        }
     }
     my ($volm, $path) = File::Spec->splitpath($_[1]);
     if($path && !-d $path) {
        pathmk(File::Spec->catpath($volm,$path,''), $NoFtlPth);
     }
     if( -l $_[0] && $CopyLink ) {
        carp "Copying a symlink ($_[0]) whose target does not exist" 
            if !-e readlink($_[0]) && $BdTrgWrn;
        symlink readlink(shift()), shift() or return;
     } else {  
        copy(@_) or return;
  
        my @base_file = File::Spec->splitpath($_[0]);
        my $mode_trg = -d $_[1] ? File::Spec->catfile($_[1], $base_file[ $#base_file ]) : $_[1];
  
        chmod scalar((stat($_[0]))[2]), $mode_trg if $KeepMode;
     }
     return wantarray ? (1,0,0) : 1; # use 0's incase they do math on them and in case rcopy() is called in list context = no uninit val warnings
  }
  
  sub rcopy { 
      if (-l $_[0] && $CopyLink) {
          goto &fcopy;    
      }
      
      goto &dircopy if -d $_[0] || substr( $_[0], ( 1 * -1), 1) eq '*';
      goto &fcopy;
  }
  
  sub rcopy_glob {
      $glob->(\&rcopy, @_);
  }
  
  sub dircopy {
     if($RMTrgDir && -d $_[1]) {
        if($RMTrgDir == 1) {
           pathrmdir($_[1]) or carp "\$RMTrgDir failed: $!";
        } else {
           pathrmdir($_[1]) or return;
        }
     }
     my $globstar = 0;
     my $_zero = $_[0];
     my $_one = $_[1];
     if ( substr( $_zero, ( 1 * -1 ), 1 ) eq '*') {
         $globstar = 1;
         $_zero = substr( $_zero, 0, ( length( $_zero ) - 1 ) );
     }
  
     $samecheck->(  $_zero, $_[1] ) or return;
     if ( !-d $_zero || ( -e $_[1] && !-d $_[1] ) ) {
         $! = 20; 
         return;
     } 
  
     if(!-d $_[1]) {
        pathmk($_[1], $NoFtlPth) or return;
     } else {
        if($CPRFComp && !$globstar) {
           my @parts = File::Spec->splitdir($_zero);
           while($parts[ $#parts ] eq '') { pop @parts; }
           $_one = File::Spec->catdir($_[1], $parts[$#parts]);
        }
     }
     my $baseend = $_one;
     my $level   = 0;
     my $filen   = 0;
     my $dirn    = 0;
  
     my $recurs; #must be my()ed before sub {} since it calls itself
     $recurs =  sub {
        my ($str,$end,$buf) = @_;
        $filen++ if $end eq $baseend; 
        $dirn++ if $end eq $baseend;
        
        $DirPerms = oct($DirPerms) if substr($DirPerms,0,1) eq '0';
        mkdir($end,$DirPerms) or return if !-d $end;
        chmod scalar((stat($str))[2]), $end if $KeepMode;
        if($MaxDepth && $MaxDepth =~ m/^\d+$/ && $level >= $MaxDepth) {
           return ($filen,$dirn,$level) if wantarray;
           return $filen;
        }
        $level++;
  
        
        my @files;
        if ( $] < 5.006 ) {
            opendir(STR_DH, $str) or return;
            @files = grep( $_ ne '.' && $_ ne '..', readdir(STR_DH));
            closedir STR_DH;
        }
        else {
            opendir(my $str_dh, $str) or return;
            @files = grep( $_ ne '.' && $_ ne '..', readdir($str_dh));
            closedir $str_dh;
        }
  
        for my $file (@files) {
            my ($file_ut) = $file =~ m{ (.*) }xms;
            my $org = File::Spec->catfile($str, $file_ut);
            my $new = File::Spec->catfile($end, $file_ut);
            if( -l $org && $CopyLink ) {
                carp "Copying a symlink ($org) whose target does not exist" 
                    if !-e readlink($org) && $BdTrgWrn;
                symlink readlink($org), $new or return;
            } 
            elsif(-d $org) {
                $recurs->($org,$new,$buf) if defined $buf;
                $recurs->($org,$new) if !defined $buf;
                $filen++;
                $dirn++;
            } 
            else {
                if($ok_todo_asper_condcopy->($org)) {
                    if($SkipFlop) {
                        fcopy($org,$new,$buf) or next if defined $buf;
                        fcopy($org,$new) or next if !defined $buf;                      
                    }
                    else {
                        fcopy($org,$new,$buf) or return if defined $buf;
                        fcopy($org,$new) or return if !defined $buf;
                    }
                    chmod scalar((stat($org))[2]), $new if $KeepMode;
                    $filen++;
                }
            }
        }
        1;
     };
  
     $recurs->($_zero, $_one, $_[2]) or return;
     return wantarray ? ($filen,$dirn,$level) : $filen;
  }
  
  sub fmove { $move->(1, @_) } 
  
  sub rmove { 
      if (-l $_[0] && $CopyLink) {
          goto &fmove;    
      }
      
      goto &dirmove if -d $_[0] || substr( $_[0], ( 1 * -1), 1) eq '*';
      goto &fmove;
  }
  
  sub rmove_glob {
      $glob->(\&rmove, @_);
  }
  
  sub dirmove { $move->(0, @_) }
  
  sub pathmk {
     my @parts = File::Spec->splitdir( shift() );
     my $nofatal = shift;
     my $pth = $parts[0];
     my $zer = 0;
     if(!$pth) {
        $pth = File::Spec->catdir($parts[0],$parts[1]);
        $zer = 1;
     }
     for($zer..$#parts) {
        $DirPerms = oct($DirPerms) if substr($DirPerms,0,1) eq '0';
        mkdir($pth,$DirPerms) or return if !-d $pth && !$nofatal;
        mkdir($pth,$DirPerms) if !-d $pth && $nofatal;
        $pth = File::Spec->catdir($pth, $parts[$_ + 1]) unless $_ == $#parts;
     }
     1;
  } 
  
  sub pathempty {
     my $pth = shift; 
  
     return 2 if !-d $pth;
  
     my @names;
     my $pth_dh;
     if ( $] < 5.006 ) {
         opendir(PTH_DH, $pth) or return;
         @names = grep !/^\.+$/, readdir(PTH_DH);
     }
     else {
         opendir($pth_dh, $pth) or return;
         @names = grep !/^\.+$/, readdir($pth_dh);       
     }
     
     for my $name (@names) {
        my ($name_ut) = $name =~ m{ (.*) }xms;
        my $flpth     = File::Spec->catdir($pth, $name_ut);
  
        if( -l $flpth ) {
  	      unlink $flpth or return; 
        }
        elsif(-d $flpth) {
            pathrmdir($flpth) or return;
        } 
        else {
            unlink $flpth or return;
        }
     }
  
     if ( $] < 5.006 ) {
         closedir PTH_DH;
     }
     else {
         closedir $pth_dh;
     }
     
     1;
  }
  
  sub pathrm {
     my $path = shift;
     return 2 if !-d $path;
     my @pth = File::Spec->splitdir( $path );
     my $force = shift;
  
     while(@pth) { 
        my $cur = File::Spec->catdir(@pth);
        last if !$cur; # necessary ??? 
        if(!shift()) {
           pathempty($cur) or return if $force;
           rmdir $cur or return;
        } 
        else {
           pathempty($cur) if $force;
           rmdir $cur;
        }
        pop @pth;
     }
     1;
  }
  
  sub pathrmdir {
      my $dir = shift;
      if( -e $dir ) {
          return if !-d $dir;
      }
      else {
          return 2;
      }
  
      pathempty($dir) or return;
      
      rmdir $dir or return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Copy::Recursive - Perl extension for recursively copying files and directories
  
  =head1 SYNOPSIS
  
    use File::Copy::Recursive qw(fcopy rcopy dircopy fmove rmove dirmove);
  
    fcopy($orig,$new[,$buf]) or die $!;
    rcopy($orig,$new[,$buf]) or die $!;
    dircopy($orig,$new[,$buf]) or die $!;
  
    fmove($orig,$new[,$buf]) or die $!;
    rmove($orig,$new[,$buf]) or die $!;
    dirmove($orig,$new[,$buf]) or die $!;
    
    rcopy_glob("orig/stuff-*", $trg [, $buf]) or die $!;
    rmove_glob("orig/stuff-*", $trg [,$buf]) or die $!;
  
  =head1 DESCRIPTION
  
  This module copies and moves directories recursively (or single files, well... singley) to an optional depth and attempts to preserve each file or directory's mode.
  
  =head1 EXPORT
  
  None by default. But you can export all the functions as in the example above and the path* functions if you wish.
  
  =head2 fcopy()
  
  This function uses File::Copy's copy() function to copy a file but not a directory. Any directories are recursively created if need be.
  One difference to File::Copy::copy() is that fcopy attempts to preserve the mode (see Preserving Mode below)
  The optional $buf in the synopsis if the same as File::Copy::copy()'s 3rd argument
  returns the same as File::Copy::copy() in scalar context and 1,0,0 in list context to accomidate rcopy()'s list context on regular files. (See below for more info)
  
  =head2 dircopy()
  
  This function recursively traverses the $orig directory's structure and recursively copies it to the $new directory.
  $new is created if necessary (multiple non existant directories is ok (IE foo/bar/baz). The script logically and portably creates all of them if necessary).
  It attempts to preserve the mode (see Preserving Mode below) and 
  by default it copies all the way down into the directory, (see Managing Depth) below.
  If a directory is not specified it croaks just like fcopy croaks if its not a file that is specified.
  
  returns true or false, for true in scalar context it returns the number of files and directories copied,
  In list context it returns the number of files and directories, number of directories only, depth level traversed.
  
    my $num_of_files_and_dirs = dircopy($orig,$new);
    my($num_of_files_and_dirs,$num_of_dirs,$depth_traversed) = dircopy($orig,$new);
    
  Normally it stops and return's if a copy fails, to continue on regardless set $File::Copy::Recursive::SkipFlop to true.
  
      local $File::Copy::Recursive::SkipFlop = 1;
  
  That way it will copy everythgingit can ina directory and won't stop because of permissions, etc...
  
  =head2 rcopy()
  
  This function will allow you to specify a file *or* directory. It calls fcopy() if its a file and dircopy() if its a directory.
  If you call rcopy() (or fcopy() for that matter) on a file in list context, the values will be 1,0,0 since no directories and no depth are used. 
  This is important becasue if its a directory in list context and there is only the initial directory the return value is 1,1,1.
  
  =head2 rcopy_glob()
  
  This function lets you specify a pattern suitable for perl's glob() as the first argument. Subsequently each path returned by perl's glob() gets rcopy()ied.
  
  It returns and array whose items are array refs that contain the return value of each rcopy() call.
  
  It forces behavior as if $File::Copy::Recursive::CPRFComp is true.
  
  =head2 fmove()
  
  Copies the file then removes the original. You can manage the path the original file is in according to $RemvBase.
  
  =head2 dirmove()
  
  Uses dircopy() to copy the directory then removes the original. You can manage the path the original directory is in according to $RemvBase.
  
  =head2 rmove()
  
  Like rcopy() but calls fmove() or dirmove() instead.
  
  =head2 rmove_glob()
  
  Like rcopy_glob() but calls rmove() instead of rcopy()
  
  =head3 $RemvBase
  
  Default is false. When set to true the *move() functions will not only attempt to remove the original file or directory but will remove the given path it is in.
  
  So if you:
  
     rmove('foo/bar/baz', '/etc/');
     # "baz" is removed from foo/bar after it is successfully copied to /etc/
     
     local $File::Copy::Recursive::Remvbase = 1;
     rmove('foo/bar/baz','/etc/');
     # if baz is successfully copied to /etc/ :
     # first "baz" is removed from foo/bar
     # then "foo/bar is removed via pathrm()
  
  =head4 $ForcePth
  
  Default is false. When set to true it calls pathempty() before any directories are removed to empty the directory so it can be rmdir()'ed when $RemvBase is in effect.
  
  =head2 Creating and Removing Paths
  
  =head3 $NoFtlPth
  
  Default is false. If set to true  rmdir(), mkdir(), and pathempty() calls in pathrm() and pathmk() do not return() on failure.
  
  If its set to true they just silently go about their business regardless. This isn't a good idea but its there if you want it.
  
  =head3 $DirPerms
  
  Mode to pass to any mkdir() calls. Defaults to 0777 as per umask()'s POD. Explicitly having this allows older perls to be able to use FCR and might add a bit of flexibility for you.
  
  Any value you set it to should be suitable for oct()
  
  =head3 Path functions
  
  These functions exist soley because they were necessary for the move and copy functions to have the features they do and not because they are of themselves the purpose of this module. That being said, here is how they work so you can understand how the copy and move funtions work and use them by themselves if you wish.
  
  =head4 pathrm()
  
  Removes a given path recursively. It removes the *entire* path so be carefull!!!
  
  Returns 2 if the given path is not a directory.
  
    File::Copy::Recursive::pathrm('foo/bar/baz') or die $!;
    # foo no longer exists
  
  Same as:
  
    rmdir 'foo/bar/baz' or die $!;
    rmdir 'foo/bar' or die $!;
    rmdir 'foo' or die $!;
  
  An optional second argument makes it call pathempty() before any rmdir()'s when set to true.
  
    File::Copy::Recursive::pathrm('foo/bar/baz', 1) or die $!;
    # foo no longer exists
  
  Same as:PFSCheck
  
    File::Copy::Recursive::pathempty('foo/bar/baz') or die $!;
    rmdir 'foo/bar/baz' or die $!;
    File::Copy::Recursive::pathempty('foo/bar/') or die $!;
    rmdir 'foo/bar' or die $!;
    File::Copy::Recursive::pathempty('foo/') or die $!;
    rmdir 'foo' or die $!;
  
  An optional third argument acts like $File::Copy::Recursive::NoFtlPth, again probably not a good idea.
  
  =head4 pathempty()
  
  Recursively removes the given directory's contents so it is empty. returns 2 if argument is not a directory, 1 on successfully emptying the directory.
  
     File::Copy::Recursive::pathempty($pth) or die $!;
     # $pth is now an empty directory
  
  =head4 pathmk()
  
  Creates a given path recursively. Creates foo/bar/baz even if foo does not exist.
  
     File::Copy::Recursive::pathmk('foo/bar/baz') or die $!;
  
  An optional second argument if true acts just like $File::Copy::Recursive::NoFtlPth, which means you'd never get your die() if something went wrong. Again, probably a *bad* idea.
  
  =head4 pathrmdir()
  
  Same as rmdir() but it calls pathempty() first to recursively empty it first since rmdir can not remove a directory with contents.
  Just removes the top directory the path given instead of the entire path like pathrm(). Return 2 if given argument does not exist (IE its already gone). Return false if it exists but is not a directory.
  
  =head2 Preserving Mode
  
  By default a quiet attempt is made to change the new file or directory to the mode of the old one.
  To turn this behavior off set
    $File::Copy::Recursive::KeepMode
  to false;
  
  =head2 Managing Depth
  
  You can set the maximum depth a directory structure is recursed by setting:
    $File::Copy::Recursive::MaxDepth 
  to a whole number greater than 0.
  
  =head2 SymLinks
  
  If your system supports symlinks then symlinks will be copied as symlinks instead of as the target file.
  Perl's symlink() is used instead of File::Copy's copy()
  You can customize this behavior by setting $File::Copy::Recursive::CopyLink to a true or false value.
  It is already set to true or false dending on your system's support of symlinks so you can check it with an if statement to see how it will behave:
  
      if($File::Copy::Recursive::CopyLink) {
          print "Symlinks will be preserved\n";
      } else {
          print "Symlinks will not be preserved because your system does not support it\n";
      }
  
  If symlinks are being copied you can set $File::Copy::Recursive::BdTrgWrn to true to make it carp when it copies a link whose target does not exist. Its false by default.
  
      local $File::Copy::Recursive::BdTrgWrn  = 1;
  
  =head2 Removing existing target file or directory before copying.
  
  This can be done by setting $File::Copy::Recursive::RMTrgFil or $File::Copy::Recursive::RMTrgDir for file or directory behavior respectively.
  
  0 = off (This is the default)
  
  1 = carp() $! if removal fails
  
  2 = return if removal fails
  
      local $File::Copy::Recursive::RMTrgFil = 1;
      fcopy($orig, $target) or die $!;
      # if it fails it does warn() and keeps going
  
      local $File::Copy::Recursive::RMTrgDir = 2;
      dircopy($orig, $target) or die $!;
      # if it fails it does your "or die"
  
  This should be unnecessary most of the time but its there if you need it :)
  
  =head2 Turning off stat() check
  
  By default the files or directories are checked to see if they are the same (IE linked, or two paths (absolute/relative or different relative paths) to the same file) by comparing the file's stat() info. 
  It's a very efficient check that croaks if they are and shouldn't be turned off but if you must for some weird reason just set $File::Copy::Recursive::PFSCheck to a false value. ("PFS" stands for "Physical File System")
  
  =head2 Emulating cp -rf dir1/ dir2/
  
  By default dircopy($dir1,$dir2) will put $dir1's contents right into $dir2 whether $dir2 exists or not.
  
  You can make dircopy() emulate cp -rf by setting $File::Copy::Recursive::CPRFComp to true.
  
  NOTE: This only emulates -f in the sense that it does not prompt. It does not remove the target file or directory if it exists.
  If you need to do that then use the variables $RMTrgFil and $RMTrgDir described in "Removing existing target file or directory before copying" above.
  
  That means that if $dir2 exists it puts the contents into $dir2/$dir1 instead of $dir2 just like cp -rf.
  If $dir2 does not exist then the contents go into $dir2 like normal (also like cp -rf)
  
  So assuming 'foo/file':
  
      dircopy('foo', 'bar') or die $!;
      # if bar does not exist the result is bar/file
      # if bar does exist the result is bar/file
  
      $File::Copy::Recursive::CPRFComp = 1;
      dircopy('foo', 'bar') or die $!;
      # if bar does not exist the result is bar/file
      # if bar does exist the result is bar/foo/file
  
  You can also specify a star for cp -rf glob type behavior:
  
      dircopy('foo/*', 'bar') or die $!;
      # if bar does not exist the result is bar/file
      # if bar does exist the result is bar/file
  
      $File::Copy::Recursive::CPRFComp = 1;
      dircopy('foo/*', 'bar') or die $!;
      # if bar does not exist the result is bar/file
      # if bar does exist the result is bar/file
  
  NOTE: The '*' is only like cp -rf foo/* and *DOES NOT EXPAND PARTIAL DIRECTORY NAMES LIKE YOUR SHELL DOES* (IE not like cp -rf fo* to copy foo/*)
  
  =head2 Allowing Copy Loops
  
  If you want to allow:
  
    cp -rf . foo/
  
  type behavior set $File::Copy::Recursive::CopyLoop to true.
  
  This is false by default so that a check is done to see if the source directory will contain the target directory and croaks to avoid this problem.
  
  If you ever find a situation where $CopyLoop = 1 is desirable let me know (IE its a bad bad idea but is there if you want it)
  
  (Note: On Windows this was necessary since it uses stat() to detemine samedness and stat() is essencially useless for this on Windows. 
  The test is now simply skipped on Windows but I'd rather have an actual reliable check if anyone in Microsoft land would care to share)
  
  =head1 SEE ALSO
  
  L<File::Copy> L<File::Spec>
  
  =head1 TO DO
  
  I am currently working on and reviewing some other modules to use in the new interface so we can lose the horrid globals as well as some other undesirable traits and also more easily make available some long standing requests.
  
  Tests will be easier to do with the new interface and hence the testing focus will shift to the new interface and aim to be comprehensive.
  
  The old interface will work, it just won't be brought in until it is used, so it will add no overhead for users of the new interface.
  
  I'll add this after the latest verision has been out for a while with no new features or issues found :)
  
  =head1 AUTHOR
  
  Daniel Muey, L<http://drmuey.com/cpan_contact.pl>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2004 by Daniel Muey
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
FILE_COPY_RECURSIVE

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;
  use warnings;
  package File::pushd;
  # ABSTRACT: change directory temporarily for a limited scope
  our $VERSION = '1.005'; # VERSION
  
  our @EXPORT  = qw( pushd tempd );
  our @ISA     = qw( Exporter );
  
  use Exporter;
  use Carp;
  use Cwd         qw( getcwd abs_path );
  use File::Path  qw( rmtree );
  use File::Temp  qw();
  use File::Spec;
  
  use overload
      q{""} => sub { File::Spec->canonpath( $_[0]->{_pushd} ) },
      fallback => 1;
  
  #--------------------------------------------------------------------------#
  # pushd()
  #--------------------------------------------------------------------------#
  
  sub pushd {
      my ($target_dir, $options) = @_;
      $options->{untaint_pattern} ||= qr{^([-+@\w./]+)$};
  
      $target_dir = "." unless defined $target_dir;
      croak "Can't locate directory $target_dir" unless -d $target_dir;
  
      my $tainted_orig = getcwd;
      my $orig;
      if ( $tainted_orig =~ $options->{untaint_pattern} ) {
        $orig = $1;
      }
      else {
        $orig = $tainted_orig;
      }
  
      my $tainted_dest;
      eval { $tainted_dest   = $target_dir ? abs_path( $target_dir ) : $orig };
      croak "Can't locate absolute path for $target_dir: $@" if $@;
  
      my $dest;
      if ( $tainted_dest =~ $options->{untaint_pattern} ) {
        $dest = $1;
      }
      else {
        $dest = $tainted_dest;
      }
  
      if ($dest ne $orig) {
          chdir $dest or croak "Can't chdir to $dest\: $!";
      }
  
      my $self = bless {
          _pushd => $dest,
          _original => $orig
      }, __PACKAGE__;
  
      return $self;
  }
  
  #--------------------------------------------------------------------------#
  # tempd()
  #--------------------------------------------------------------------------#
  
  sub tempd {
      my ($options) = @_;
      my $dir;
      eval { $dir = pushd( File::Temp::tempdir( CLEANUP => 0 ), $options ) };
      croak $@ if $@;
      $dir->{_tempd} = 1;
      return $dir;
  }
  
  #--------------------------------------------------------------------------#
  # preserve()
  #--------------------------------------------------------------------------#
  
  sub preserve {
      my $self = shift;
      return 1 if ! $self->{"_tempd"};
      if ( @_ == 0 ) {
          return $self->{_preserve} = 1;
      }
      else {
          return $self->{_preserve} = $_[0] ? 1 : 0;
      }
  }
  
  #--------------------------------------------------------------------------#
  # DESTROY()
  # Revert to original directory as object is destroyed and cleanup
  # if necessary
  #--------------------------------------------------------------------------#
  
  sub DESTROY {
      my ($self) = @_;
      my $orig = $self->{_original};
      chdir $orig if $orig; # should always be so, but just in case...
      if ( $self->{_tempd} &&
          !$self->{_preserve} ) {
          # don't destroy existing $@ if there is no error.
          my $err = do {
              local $@;
              eval { rmtree( $self->{_pushd} ) };
              $@;
          };
          carp $err if $err;
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::pushd - change directory temporarily for a limited scope
  
  =head1 VERSION
  
  version 1.005
  
  =head1 SYNOPSIS
  
    use File::pushd;
   
    chdir $ENV{HOME};
   
    # change directory again for a limited scope
    {
        my $dir = pushd( '/tmp' );
        # working directory changed to /tmp
    }
    # working directory has reverted to $ENV{HOME}
   
    # tempd() is equivalent to pushd( File::Temp::tempdir )
    {
        my $dir = tempd();
    }
   
    # object stringifies naturally as an absolute path
    {
       my $dir = pushd( '/tmp' );
       my $filename = File::Spec->catfile( $dir, "somefile.txt" );
       # gives /tmp/somefile.txt
    }
  
  =head1 DESCRIPTION
  
  File::pushd does a temporary C<<< chdir >>> that is easily and automatically
  reverted, similar to C<<< pushd >>> in some Unix command shells.  It works by
  creating an object that caches the original working directory.  When the object
  is destroyed, the destructor calls C<<< chdir >>> to revert to the original working
  directory.  By storing the object in a lexical variable with a limited scope,
  this happens automatically at the end of the scope.
  
  This is very handy when working with temporary directories for tasks like
  testing; a function is provided to streamline getting a temporary
  directory from L<File::Temp>.
  
  For convenience, the object stringifies as the canonical form of the absolute
  pathname of the directory entered.
  
  =head1 USAGE
  
    use File::pushd;
  
  Using File::pushd automatically imports the C<<< pushd >>> and C<<< tempd >>> functions.
  
  =head2 pushd
  
    {
        my $dir = pushd( $target_directory );
    }
  
  Caches the current working directory, calls C<<< chdir >>> to change to the target
  directory, and returns a File::pushd object.  When the object is
  destroyed, the working directory reverts to the original directory.
  
  The provided target directory can be a relative or absolute path. If
  called with no arguments, it uses the current directory as its target and
  returns to the current directory when the object is destroyed.
  
  If the target directory does not exist or if the directory change fails
  for some reason, C<<< pushd >>> will die with an error message.
  
  Can be given a hashref as an optional second argument.  The only supported
  option is C<<< untaint_pattern >>>, which is used to untaint file paths involved.
  It defaults to C<<< qr{^([-+@\w./]+)$} >>>, which is reasonably restrictive (e.g.
  it does not even allow spaces in the path).  Change this to suit your
  circumstances and security needs if running under taint mode. B<Note>: you
  must include the parentheses in the pattern to capture the untainted
  portion of the path.
  
  =head2 tempd
  
    {
        my $dir = tempd();
    }
  
  This function is like C<<< pushd >>> but automatically creates and calls C<<< chdir >>> to
  a temporary directory created by L<File::Temp>. Unlike normal L<File::Temp>
  cleanup which happens at the end of the program, this temporary directory is
  removed when the object is destroyed. (But also see C<<< preserve >>>.)  A warning
  will be issued if the directory cannot be removed.
  
  As with C<<< pushd >>>, C<<< tempd >>> will die if C<<< chdir >>> fails.
  
  It may be given a single options hash that will be passed internally
  to CE<lt>pushdE<gt>.
  
  =head2 preserve
  
    {
        my $dir = tempd();
        $dir->preserve;      # mark to preserve at end of scope
        $dir->preserve(0);   # mark to delete at end of scope
    }
  
  Controls whether a temporary directory will be cleaned up when the object is
  destroyed.  With no arguments, C<<< preserve >>> sets the directory to be preserved.
  With an argument, the directory will be preserved if the argument is true, or
  marked for cleanup if the argument is false.  Only C<<< tempd >>> objects may be
  marked for cleanup.  (Target directories to C<<< pushd >>> are always preserved.)
  C<<< preserve >>> returns true if the directory will be preserved, and false
  otherwise.
  
  =head1 SEE ALSO
  
  =over
  
  =item *
  
  L<File::chdir>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/file-pushd/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/file-pushd>
  
    git clone git://github.com/dagolden/file-pushd.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTOR
  
  Diab Jerius <djerius@cfa.harvard.edu>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David A Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
FILE_PUSHD

$fatpacked{"Import/Into.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IMPORT_INTO';
  package Import::Into;
  
  use strict;
  use warnings FATAL => 'all';
  
  our $VERSION = '1.002001'; # 1.2.1
  
  sub _prelude {
    my $target = shift;
    my ($package, $file, $line, $level)
      = ref $target         ? @{$target}{qw(package filename line)}
      : $target =~ /[^0-9]/ ? ($target)
                            : (undef, undef, undef, $target);
    if (defined $level) {
      my ($p, $fn, $ln) = caller($level + 2);
      $package ||= $p;
      $file    ||= $fn;
      $line    ||= $ln;
    }
    qq{package $package;\n}
      . ($file ? "#line $line \"$file\"\n" : '')
  }
  
  sub _make_action {
    my ($action, $target) = @_;
    my $version = ref $target && $target->{version};
    my $ver_check = $version ? '$_[0]->VERSION($version);' : '';
    eval _prelude($target).qq{sub { $ver_check shift->$action(\@_) }}
      or die "Failed to build action sub to ${action} for ${target}: $@";
  }
  
  sub import::into {
    my ($class, $target, @args) = @_;
    _make_action(import => $target)->($class, @args);
  }
  
  sub unimport::out_of {
    my ($class, $target, @args) = @_;
    _make_action(unimport => $target)->($class, @args);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Import::Into - import packages into other packages
  
  =head1 SYNOPSIS
  
    package My::MultiExporter;
  
    use Import::Into;
  
    use Thing1 ();
    use Thing2 ();
  
    # simple
    sub import {
      Thing1->import::into(scalar caller);
    }
  
    # multiple
    sub import {
      my $target = caller;
      Thing1->import::into($target);
      Thing2->import::into($target, qw(import arguments));
    }
  
    # by level
    sub import {
      Thing1->import::into(1);
    }
  
    # with exporter
    use base qw(Exporter);
    sub import {
      shift->export_to_level(1);
      Thing1->import::into(1);
    }
  
    # no My::MultiExporter == no Thing1
    sub unimport {
      Thing1->unimport::out_of(scalar caller);
    }
  
  People wanting to re-export your module should also be using L<Import::Into>.
  Any exporter or pragma will work seamlessly.
  
  Note: You do B<not> need to make any changes to Thing1 to be able to call
  C<import::into> on it. This is a global method, and is callable on any
  package (and in fact on any object as well, although it's rarer that you'd
  want to do that).
  
  =head1 DESCRIPTION
  
  Writing exporters is a pain. Some use L<Exporter>, some use L<Sub::Exporter>,
  some use L<Moose::Exporter>, some use L<Exporter::Declare> ... and some things
  are pragmas.
  
  Exporting on someone else's behalf is harder.  The exporters don't provide a
  consistent API for this, and pragmas need to have their import method called
  directly, since they effect the current unit of compilation.
  
  C<Import::Into> provides global methods to make this painless.
  
  =head1 METHODS
  
  =head2 $package->import::into( $target, @arguments );
  
  A global method, callable on any package.  Imports the given package into
  C<$target>.  C<@arguments> are passed along to the package's import method.
  
  C<$target> can be an package name to export to, an integer for the
  caller level to export to, or a hashref with the following options:
  
  =over 4
  
  =item package
  
  The target package to export to.
  
  =item filename
  
  The apparent filename to export to.  Some exporting modules, such as
  L<autodie> or L<strictures>, care about the filename they are being imported
  to.
  
  =item line
  
  The apparent line number to export to.  To be combined with the C<filename>
  option.
  
  =item level
  
  The caller level to export to.  This will automatically populate the
  C<package>, C<filename>, and C<line> options, making it the easiest most
  constent option.
  
  =item version
  
  A version number to check for the module.  The equivalent of specifying the
  version number on a C<use> line.
  
  =back
  
  =head2 $package->unimport::out_of( $target, @arguments );
  
  Equivalent to C<import::into>, but dispatches to C<$package>'s C<unimport>
  method instead of C<import>.
  
  =head1 WHY USE THIS MODULE
  
  The APIs for exporting modules aren't consistent.  L<Exporter> subclasses
  provide export_to_level, but if they overrode their import method all bets
  are off.  L<Sub::Exporter> provides an into parameter but figuring out
  something used it isn't trivial. Pragmas need to have their C<import> method
  called directly since they affect the current unit of compilation.
  
  It's ... annoying.
  
  However, there is an approach that actually works for all of these types.
  
    eval "package $target; use $thing;"
  
  will work for anything checking caller, which is everything except pragmas.
  But it doesn't work for pragmas - pragmas need:
  
    $thing->import;
  
  because they're designed to affect the code currently being compiled - so
  within an eval, that's the scope of the eval itself, not the module that
  just C<use>d you - so
  
    sub import {
      eval "use strict;"
    }
  
  doesn't do what you wanted, but
  
    sub import {
      strict->import;
    }
  
  will apply L<strict> to the calling file correctly.
  
  Of course, now you have two new problems - first, that you still need to
  know if something's a pragma, and second that you can't use either of
  these approaches alone on something like L<Moose> or L<Moo> that's both
  an exporter and a pragma.
  
  So, a solution for that is:
  
    my $sub = eval "package $target; sub { shift->import(\@_) }";
    $sub->($thing, @import_args);
  
  which means that import is called from the right place for pragmas to take
  effect, and from the right package for caller checking to work - and so
  behaves correctly for all types of exporter, for pragmas, and for hybrids.
  
  Additionally, some import routines check the filename they are being imported
  to.  This can be dealt with by generating a L<#line directive|perlsyn/Plain
  Old Comments (Not!)> in the eval, which will change what C<caller> reports for
  the filename when called in the importer. The filename and line number to use
  in the directive then need to be fetched using C<caller>:
  
    my ($target, $file, $line) = caller(1);
    my $sub = eval qq{
      package $target;
    #line $line "$file"
      sub { shift->import(\@_) }
    };
    $sub->($thing, @import_args);
  
  And you need to switch between these implementations depending on if you are
  targetting a specific package, or something in your call stack.
  
  Remembering all this, however, is excessively irritating. So I wrote a module
  so I didn't have to anymore. Loading L<Import::Into> creates a global method
  C<import::into> which you can call on any package to import it into another
  package. So now you can simply write:
  
    use Import::Into;
  
    $thing->import::into($target, @import_args);
  
  This works because of how perl resolves method calls - a call to a simple
  method name is resolved against the package of the class or object, so
  
    $thing->method_name(@args);
  
  is roughly equivalent to:
  
    my $code_ref = $thing->can('method_name');
    $code_ref->($thing, @args);
  
  while if a C<::> is found, the lookup is made relative to the package name
  (i.e. everything before the last C<::>) so
  
    $thing->Package::Name::method_name(@args);
  
  is roughly equivalent to:
  
    my $code_ref = Package::Name->can('method_name');
    $code_ref->($thing, @args);
  
  So since L<Import::Into> defines a method C<into> in package C<import>
  the syntax reliably calls that.
  
  For more craziness of this order, have a look at the article I wrote at
  L<http://shadow.cat/blog/matt-s-trout/madness-with-methods> which covers
  coderef abuse and the C<${\...}> syntax.
  
  Final note: You do still need to ensure that you already loaded C<$thing> - if
  you're receiving this from a parameter, I recommend using L<Module::Runtime>:
  
    use Import::Into;
    use Module::Runtime qw(use_module);
  
    use_module($thing)->import::into($target, @import_args);
  
  And that's it.
  
  =head1 ACKNOWLEDGEMENTS
  
  Thanks to Getty for asking "how can I get C<< use strict; use warnings; >>
  turned on for all consumers of my code?" and then "why is this not a
  module?!".
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Import::Into L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
IMPORT_INTO

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;
  
  
  use strict;
  use Carp ();
  use base qw(Exporter);
  @JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);
  
  BEGIN {
      $JSON::VERSION = '2.90';
      $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);
      $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };
  }
  
  my $Module_XS  = 'JSON::XS';
  my $Module_PP  = 'JSON::PP';
  my $Module_bp  = 'JSON::backportPP'; # included in JSON distribution
  my $PP_Version = '2.27203';
  my $XS_Version = '2.34';
  
  
  # XS and PP common methods
  
  my @PublicMethods = qw/
      ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref 
      allow_blessed convert_blessed filter_json_object filter_json_single_key_object 
      shrink max_depth max_size encode decode decode_prefix allow_unknown
  /;
  
  my @Properties = qw/
      ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref
      allow_blessed convert_blessed shrink max_depth max_size allow_unknown
  /;
  
  my @XSOnlyMethods = qw/allow_tags/; # Currently nothing
  
  my @PPOnlyMethods = qw/
      indent_length sort_by
      allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed
  /; # JSON::PP specific
  
  
  # used in _load_xs and _load_pp ($INSTALL_ONLY is not used currently)
  my $_INSTALL_DONT_DIE  = 1; # When _load_xs fails to load XS, don't die.
  my $_INSTALL_ONLY      = 2; # Don't call _set_methods()
  my $_ALLOW_UNSUPPORTED = 0;
  my $_UNIV_CONV_BLESSED = 0;
  my $_USSING_bpPP       = 0;
  
  
  # Check the environment variable to decide worker module. 
  
  unless ($JSON::Backend) {
      $JSON::DEBUG and  Carp::carp("Check used worker module...");
  
      my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;
  
      if ($backend eq '1' or $backend =~ /JSON::XS\s*,\s*JSON::PP/) {
          _load_xs($_INSTALL_DONT_DIE) or _load_pp();
      }
      elsif ($backend eq '0' or $backend eq 'JSON::PP') {
          _load_pp();
      }
      elsif ($backend eq '2' or $backend eq 'JSON::XS') {
          _load_xs();
      }
      elsif ($backend eq 'JSON::backportPP') {
          $_USSING_bpPP = 1;
          _load_pp();
      }
      else {
          Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid.";
      }
  }
  
  
  sub import {
      my $pkg = shift;
      my @what_to_export;
      my $no_export;
  
      for my $tag (@_) {
          if ($tag eq '-support_by_pp') {
              if (!$_ALLOW_UNSUPPORTED++) {
                  JSON::Backend::XS
                      ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend eq $Module_XS);
              }
              next;
          }
          elsif ($tag eq '-no_export') {
              $no_export++, next;
          }
          elsif ( $tag eq '-convert_blessed_universally' ) {
              eval q|
                  require B;
                  *UNIVERSAL::TO_JSON = sub {
                      my $b_obj = B::svref_2object( $_[0] );
                      return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                              : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                              : undef
                              ;
                  }
              | if ( !$_UNIV_CONV_BLESSED++ );
              next;
          }
          push @what_to_export, $tag;
      }
  
      return if ($no_export);
  
      __PACKAGE__->export_to_level(1, $pkg, @what_to_export);
  }
  
  
  # OBSOLETED
  
  sub jsonToObj {
      my $alternative = 'from_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'decode';
      }
      Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";
      return JSON::from_json(@_);
  };
  
  sub objToJson {
      my $alternative = 'to_json';
      if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
          shift @_; $alternative = 'encode';
      }
      Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";
      JSON::to_json(@_);
  };
  
  
  # INTERFACES
  
  sub to_json ($@) {
      if (
          ref($_[0]) eq 'JSON'
          or (@_ > 2 and $_[0] eq 'JSON')
      ) {
          Carp::croak "to_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      $json->encode($_[0]);
  }
  
  
  sub from_json ($@) {
      if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {
          Carp::croak "from_json should not be called as a method.";
      }
      my $json = JSON->new;
  
      if (@_ == 2 and ref $_[1] eq 'HASH') {
          my $opt  = $_[1];
          for my $method (keys %$opt) {
              $json->$method( $opt->{$method} );
          }
      }
  
      return $json->decode( $_[0] );
  }
  
  
  
  sub true  { $JSON::true  }
  
  sub false { $JSON::false }
  
  sub null  { undef; }
  
  
  sub require_xs_version { $XS_Version; }
  
  sub backend {
      my $proto = shift;
      $JSON::Backend;
  }
  
  #*module = *backend;
  
  
  sub is_xs {
      return $_[0]->backend eq $Module_XS;
  }
  
  
  sub is_pp {
      return not $_[0]->is_xs;
  }
  
  
  sub pureperl_only_methods { @PPOnlyMethods; }
  
  
  sub property {
      my ($self, $name, $value) = @_;
  
      if (@_ == 1) {
          my %props;
          for $name (@Properties) {
              my $method = 'get_' . $name;
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  $props{$name} = $value == 1 ? 0 : $value;
                  next;
              }
              $props{$name} = $self->$method();
          }
          return \%props;
      }
      elsif (@_ > 3) {
          Carp::croak('property() can take only the option within 2 arguments.');
      }
      elsif (@_ == 2) {
          if ( my $method = $self->can('get_' . $name) ) {
              if ($name eq 'max_size') {
                  my $value = $self->$method();
                  return $value == 1 ? 0 : $value;
              }
              $self->$method();
          }
      }
      else {
          $self->$name($value);
      }
  
  }
  
  
  
  # INTERNAL
  
  sub _load_xs {
      my $opt = shift;
  
      $JSON::DEBUG and Carp::carp "Load $Module_XS.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($Module_PP);
  
      eval qq|
          use $Module_XS $XS_Version ();
      |;
  
      if ($@) {
          if (defined $opt and $opt & $_INSTALL_DONT_DIE) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_XS...($@)";
              return 0;
          }
          Carp::croak $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_XS );
          my $data = join("", <DATA>); # this code is from Jcode 2.xx.
          close(DATA);
          eval $data;
          JSON::Backend::XS->init;
      }
  
      return 1;
  };
  
  
  sub _load_pp {
      my $opt = shift;
      my $backend = $_USSING_bpPP ? $Module_bp : $Module_PP;
  
      $JSON::DEBUG and Carp::carp "Load $backend.";
  
      # if called after install module, overload is disable.... why?
      JSON::Boolean::_overrride_overload($Module_XS);
      JSON::Boolean::_overrride_overload($backend);
  
      if ( $_USSING_bpPP ) {
          eval qq| require $backend |;
      }
      else {
          eval qq| use $backend $PP_Version () |;
      }
  
      if ($@) {
          if ( $backend eq $Module_PP ) {
              $JSON::DEBUG and Carp::carp "Can't load $Module_PP ($@), so try to load $Module_bp";
              $_USSING_bpPP++;
              $backend = $Module_bp;
              JSON::Boolean::_overrride_overload($backend);
              local $^W; # if PP installed but invalid version, backportPP redefines methods.
              eval qq| require $Module_bp |;
          }
          Carp::croak $@ if $@;
      }
  
      unless (defined $opt and $opt & $_INSTALL_ONLY) {
          _set_module( $JSON::Backend = $Module_PP ); # even if backportPP, set $Backend with 'JSON::PP'
          JSON::Backend::PP->init;
      }
  };
  
  
  sub _set_module {
      return if defined $JSON::true;
  
      my $module = shift;
  
      local $^W;
      no strict qw(refs);
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::ISA, $module;
      if ( JSON->is_xs and JSON->backend->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      for my $method ($module eq $Module_XS ? @PPOnlyMethods : @XSOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  
  
  #
  # JSON Boolean
  #
  
  package JSON::Boolean;
  
  my %Installed;
  
  sub _overrride_overload {
      return; # this function is currently disable.
      return if ($Installed{ $_[0] }++);
  
      my $boolean = $_[0] . '::Boolean';
  
      eval sprintf(q|
          package %s;
          use overload (
              '""' => sub { ${$_[0]} == 1 ? 'true' : 'false' },
              'eq' => sub {
                  my ($obj, $op) = ref ($_[0]) ? ($_[0], $_[1]) : ($_[1], $_[0]);
                  if ($op eq 'true' or $op eq 'false') {
                      return "$obj" eq 'true' ? 'true' eq $op : 'false' eq $op;
                  }
                  else {
                      return $obj ? 1 == $op : 0 == $op;
                  }
              },
          );
      |, $boolean);
  
      if ($@) { Carp::croak $@; }
  
      if ( exists $INC{'JSON/XS.pm'} and $boolean eq 'JSON::XS::Boolean' ) {
          local $^W;
          my $true  = do { bless \(my $dummy = 1), $boolean };
          my $false = do { bless \(my $dummy = 0), $boolean };
          *JSON::XS::true  = sub () { $true };
          *JSON::XS::false = sub () { $false };
      }
      elsif ( exists $INC{'JSON/PP.pm'} and $boolean eq 'JSON::PP::Boolean' ) {
          local $^W;
          my $true  = do { bless \(my $dummy = 1), $boolean };
          my $false = do { bless \(my $dummy = 0), $boolean };
          *JSON::PP::true  = sub { $true };
          *JSON::PP::false = sub { $false };
      }
  
      return 1;
  }
  
  
  #
  # Helper classes for Backend Module (PP)
  #
  
  package JSON::Backend::PP;
  
  sub init {
      local $^W;
      no strict qw(refs); # this routine may be called after JSON::Backend::XS init was called.
      *{"JSON::decode_json"} = \&{"JSON::PP::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::PP::encode_json"};
      *{"JSON::PP::is_xs"}  = sub { 0 };
      *{"JSON::PP::is_pp"}  = sub { 1 };
      return 1;
  }
  
  #
  # To save memory, the below lines are read only when XS backend is used.
  #
  
  package JSON;
  
  1;
  __DATA__
  
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  use constant INDENT_LENGTH_FLAG => 15 << 12;
  
  use constant UNSUPPORTED_ENCODE_FLAG => {
      ESCAPE_SLASH      => 0x00000010,
      ALLOW_BIGNUM      => 0x00000020,
      AS_NONBLESSED     => 0x00000040,
      EXPANDED          => 0x10000000, # for developer's
  };
  
  use constant UNSUPPORTED_DECODE_FLAG => {
      LOOSE             => 0x00000001,
      ALLOW_BIGNUM      => 0x00000002,
      ALLOW_BAREKEY     => 0x00000004,
      ALLOW_SINGLEQUOTE => 0x00000008,
      EXPANDED          => 0x20000000, # for developer's
  };
  
  
  sub init {
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"JSON::XS::decode_json"};
      *{"JSON::encode_json"} = \&{"JSON::XS::encode_json"};
      *{"JSON::XS::is_xs"}  = sub { 1 };
      *{"JSON::XS::is_pp"}  = sub { 0 };
      return 1;
  }
  
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      local $^W;
      no strict qw(refs);
  
      my $JSON_XS_encode_orignal     = \&JSON::XS::encode;
      my $JSON_XS_decode_orignal     = \&JSON::XS::decode;
      my $JSON_XS_incr_parse_orignal = \&JSON::XS::incr_parse;
  
      *JSON::XS::decode     = \&JSON::Backend::XS::Supportable::_decode;
      *JSON::XS::encode     = \&JSON::Backend::XS::Supportable::_encode;
      *JSON::XS::incr_parse = \&JSON::Backend::XS::Supportable::_incr_parse;
  
      *{JSON::XS::_original_decode}     = $JSON_XS_decode_orignal;
      *{JSON::XS::_original_encode}     = $JSON_XS_encode_orignal;
      *{JSON::XS::_original_incr_parse} = $JSON_XS_incr_parse_orignal;
  
      push @JSON::Backend::XS::Supportable::ISA, 'JSON';
  
      my $pkg = 'JSON::Backend::XS::Supportable';
  
      *{JSON::new} = sub {
          my $proto = JSON::XS->new; $$proto = 0;
          bless  $proto, $pkg;
      };
  
  
      for my $method (@methods) {
          my $flag = uc($method);
          my $type |= (UNSUPPORTED_ENCODE_FLAG->{$flag} || 0);
             $type |= (UNSUPPORTED_DECODE_FLAG->{$flag} || 0);
  
          next unless($type);
  
          $pkg->_make_unsupported_method($method => $type);
      }
  
  #    push @{"JSON::XS::Boolean::ISA"}, qw(JSON::PP::Boolean);
  #    push @{"JSON::PP::Boolean::ISA"}, qw(JSON::Boolean);
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  
      return 1;
  }
  
  
  
  
  #
  # Helper classes for XS
  #
  
  package JSON::Backend::XS::Supportable;
  
  $Carp::Internal{'JSON::Backend::XS::Supportable'} = 1;
  
  sub _make_unsupported_method {
      my ($pkg, $method, $type) = @_;
  
      local $^W;
      no strict qw(refs);
  
      *{"$pkg\::$method"} = sub {
          local $^W;
          if (defined $_[1] ? $_[1] : 1) {
              ${$_[0]} |= $type;
          }
          else {
              ${$_[0]} &= ~$type;
          }
          $_[0];
      };
  
      *{"$pkg\::get_$method"} = sub {
          ${$_[0]} & $type ? 1 : '';
      };
  
  }
  
  
  sub _set_for_pp {
      JSON::_load_pp( $_INSTALL_ONLY );
  
      my $type  = shift;
      my $pp    = JSON::PP->new;
      my $prop = $_[0]->property;
  
      for my $name (keys %$prop) {
          $pp->$name( $prop->{$name} ? $prop->{$name} : 0 );
      }
  
      my $unsupported = $type eq 'encode' ? JSON::Backend::XS::UNSUPPORTED_ENCODE_FLAG
                                          : JSON::Backend::XS::UNSUPPORTED_DECODE_FLAG;
      my $flags       = ${$_[0]} || 0;
  
      for my $name (keys %$unsupported) {
          next if ($name eq 'EXPANDED'); # for developer's
          my $enable = ($flags & $unsupported->{$name}) ? 1 : 0;
          my $method = lc $name;
          $pp->$method($enable);
      }
  
      $pp->indent_length( $_[0]->get_indent_length );
  
      return $pp;
  }
  
  sub _encode { # using with PP encode
      if (${$_[0]}) {
          _set_for_pp('encode' => @_)->encode($_[1]);
      }
      else {
          $_[0]->_original_encode( $_[1] );
      }
  }
  
  
  sub _decode { # if unsupported-flag is set, use PP
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->decode($_[1]);
      }
      else {
          $_[0]->_original_decode( $_[1] );
      }
  }
  
  
  sub decode_prefix { # if unsupported-flag is set, use PP
      _set_for_pp('decode' => @_)->decode_prefix($_[1]);
  }
  
  
  sub _incr_parse {
      if (${$_[0]}) {
          _set_for_pp('decode' => @_)->incr_parse($_[1]);
      }
      else {
          $_[0]->_original_incr_parse( $_[1] );
      }
  }
  
  
  sub get_indent_length {
      ${$_[0]} << 4 >> 16;
  }
  
  
  sub indent_length {
      my $length = $_[1];
  
      if (!defined $length or $length > 15 or $length < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          local $^W;
          $length <<= 12;
          ${$_[0]} &= ~ JSON::Backend::XS::INDENT_LENGTH_FLAG;
          ${$_[0]} |= $length;
          *JSON::XS::encode = \&JSON::Backend::XS::Supportable::_encode;
      }
  
      $_[0];
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # If you want to use PP only support features, call with '-support_by_pp'
   # When XS unsupported feature is enable, using PP (de|en)code instead of XS ones.
   
   use JSON -support_by_pp;
   
   # option-acceptable interfaces (expect/generate UNICODE by default)
   
   $json_text   = to_json( $perl_scalar, { ascii => 1, pretty => 1 } );
   $perl_scalar = from_json( $json_text, { utf8  => 1 } );
   
   # Between (en|de)code_json and (to|from)_json, if you want to write
   # a code which communicates to an outer world (encoded in UTF-8),
   # recommend to use (en|de)code_json.
   
  =head1 VERSION
  
      2.90
  
  This version is compatible with JSON::XS B<2.34> and later.
  (Not yet compatble to JSON::XS B<3.0x>.)
  
  
  =head1 NOTE
  
  JSON::PP was earlier included in the C<JSON> distribution, but
  has since Perl 5.14 been a core module. For this reason,
  L<JSON::PP> was removed from the JSON distribution and can now
  be found also in the Perl5 repository at
  
  =over
  
  =item * L<http://perl5.git.perl.org/perl.git>
  
  =back
  
  (The newest JSON::PP version still exists in CPAN.)
  
  Instead, the C<JSON> distribution will include JSON::backportPP
  for backwards computability. JSON.pm should thus work as it did
  before.
  
  =head1 DESCRIPTION
  
   *************************** CAUTION **************************************
   *                                                                        *
   * INCOMPATIBLE CHANGE (JSON::XS version 2.90)                            *
   *                                                                        *
   * JSON.pm had patched JSON::XS::Boolean and JSON::PP::Boolean internally *
   * on loading time for making these modules inherit JSON::Boolean.        *
   * But since JSON::XS v3.0 it use Types::Serialiser as boolean class.     *
   * Then now JSON.pm breaks boolean classe overload features and           *
   * -support_by_pp if JSON::XS v3.0 or later is installed.                 *
   *                                                                        *
   * JSON::true and JSON::false returned JSON::Boolean objects.             *
   * For workaround, they return JSON::PP::Boolean objects in this version. *
   *                                                                        *
   *     isa_ok(JSON::true, 'JSON::PP::Boolean');                           *
   *                                                                        *
   * And it discards a feature:                                             *
   *                                                                        *
   *     ok(JSON::true eq 'true');                                          *
   *                                                                        *
   * In other word, JSON::PP::Boolean overload numeric only.                *
   *                                                                        *
   *     ok( JSON::true == 1 );                                             *
   *                                                                        *
   **************************************************************************
  
   ************************** CAUTION ********************************
   * This is 'JSON module version 2' and there are many differences  *
   * to version 1.xx                                                 *
   * Please check your applications using old version.              *
   *   See to 'INCOMPATIBLE CHANGES TO OLD VERSION'                  *
   *******************************************************************
  
  JSON (JavaScript Object Notation) is a simple data format.
  See to L<http://www.json.org/> and C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>).
  
  This module converts Perl data structures to JSON and vice versa using either
  L<JSON::XS> or L<JSON::PP>.
  
  JSON::XS is the fastest and most proper JSON module on CPAN which must be
  compiled and installed in your environment.
  JSON::PP is a pure-Perl module which is bundled in this distribution and
  has a strong compatibility to JSON::XS.
  
  This module try to use JSON::XS by default and fail to it, use JSON::PP instead.
  So its features completely depend on JSON::XS or JSON::PP.
  
  See to L<BACKEND MODULE DECISION>.
  
  To distinguish the module name 'JSON' and the format type JSON,
  the former is quoted by CE<lt>E<gt> (its results vary with your using media),
  and the latter is left just as it is.
  
  Module name : C<JSON>
  
  Format type : JSON
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module (i.e. backend modules) knows how to handle Unicode, documents
  how and when it does so, and even documents what "correct" means.
  
  Even though there are limitations, this feature is available since Perl version 5.6.
  
  JSON::XS requires Perl 5.8.2 (but works correctly in 5.8.8 or later), so in older versions
  C<JSON> should call JSON::PP as the backend which can be used since Perl 5.005.
  
  With Perl 5.8.x JSON::PP works, but from 5.8.0 to 5.8.2, because of a Perl side problem,
  JSON::PP works slower in the versions. And in 5.005, the Unicode handling is not available.
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> for more information.
  
  See also to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>
  and L<JSON::XS/ENCODING/CODESET_FLAG_NOTES>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  L</MAPPING> section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security
  feature).
  
  See to L<JSON::XS/FEATURES> and L<JSON::PP/FEATURES>.
  
  =item * fast
  
  This module returns a JSON::XS object itself if available.
  Compared to other JSON modules and other serialisers such as Storable,
  JSON::XS usually compares favorably in terms of speed, too.
  
  If not available, C<JSON> returns a JSON::PP object instead of JSON::XS and
  it is very slow as pure-Perl.
  
  =item * simple to use
  
  This module has both a simple functional interface as well as an
  object oriented interface interface.
  
  =item * reasonably versatile output formats
  
  You can choose between the most compact guaranteed-single-line format possible
  (nice for simple line-based protocols), a pure-ASCII format (for when your transport
  is not 8-bit clean, still supports the whole Unicode range), or a pretty-printed
  format (for when you want to read that stuff). Or you can combine those features
  in whatever way you like.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  C<to_json> and C<from_json> are additional functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar)
  
  Converts the given Perl data structure to a json string.
  
  This function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Takes a hash reference as the second.
  
     $json_text = to_json($perl_scalar, $flag_hashref)
  
  So,
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
  
  equivalent to:
  
     $json_text = JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<encode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text)
  
  The opposite of C<to_json>: expects a json string and tries
  to parse it, returning the resulting reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->decode($json_text)
  
  Takes a hash reference as the second.
  
      $perl_scalar = from_json($json_text, $flag_hashref)
  
  So,
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
  
  equivalent to:
  
      $perl_scalar = JSON->new->utf8(1)->decode($json_text)
  
  If you want to write a modern perl code which communicates to outer world,
  you should use C<decode_json> (supposed that JSON data are encoded in UTF-8).
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::Boolean object.
  
  =head2 JSON::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl version is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<from_json>.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
    # or
    $perl_scalar = from_json( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable or C<to_json>.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # or 
    $unicode_json_text = to_json( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  =head2 new
  
      $json = JSON->new
  
  Returns a new C<JSON> object inherited from either JSON::XS or JSON::PP
  that can be used to de/encode JSON strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
  This feature depends on the used Perl version and environment.
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::XS->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::XS->new->decode (decode "UTF-32LE", $jsontext);
  
  See to L<JSON::PP/UNICODE HANDLING ON PERLS> if the backend is PP.
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  The indent space length is three and JSON::XS cannot change the indent
  space length.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, identifying them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  The indent space length is three.
  With JSON::PP, you can also access C<indent_length> to change indent space length.
  
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =over
  
  =item convert_blessed_universally mode
  
  If use C<JSON> with C<-convert_blessed_universally>, the C<UNIVERSAL::TO_JSON>
  subroutine is defined as the below code:
  
     *UNIVERSAL::TO_JSON = sub {
         my $b_obj = B::svref_2object( $_[0] );
         return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                 : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                 : undef
                 ;
     }
  
  This will cause that C<encode> method converts simple blessed objects into
  JSON objects as non-blessed object.
  
     JSON -convert_blessed_universally;
     $json->allow_blessed->convert_blessed->encode( $blessed_object )
  
  This feature is experimental and may be removed in the future.
  
  =back
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  With JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible. This can save
  memory when your JSON texts are either very very long or you have many
  short strings. It will also try to downgrade any strings to octet-form
  if possible: perl stores strings internally either in an encoding called
  UTF-X or in octet-form. The latter cannot store everything but uses less
  space in general (and some buggy Perl or C code might even rely on that
  internal representation being used).
  
  With JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>. See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE> and L<JSON::PP/METHODS>.
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  Note that nesting is implemented by recursion in C. The default value has
  been chosen to be as large as typical operating systems allow without
  crashing. (JSON::XS)
  
  With JSON::PP as the backend, when a large value (100 or more) was set and
  it de/encodes a deep nested object/text, it may raise a warning
  'Deep recursion on subroutine' at the perl runtime phase.
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS>, below, for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 property
  
      $boolean = $json->property($property_name)
  
  Returns a boolean value about above some properties.
  
  The available properties are C<ascii>, C<latin1>, C<utf8>,
  C<indent>,C<space_before>, C<space_after>, C<relaxed>, C<canonical>,
  C<allow_nonref>, C<allow_unknown>, C<allow_blessed>, C<convert_blessed>,
  C<shrink>, C<max_depth> and C<max_size>.
  
     $boolean = $json->property('utf8');
      => 0
     $json->utf8;
     $boolean = $json->property('utf8');
      => 1
  
  Sets the property with a given boolean value.
  
      $json = $json->property($property_name => $boolean);
  
  With no argument, it returns all the above properties as a hash reference.
  
      $flag_hashref = $json->property();
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  The backend module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthesis
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP SUPPORT METHODS
  
  The below methods are JSON::PP own methods, so when C<JSON> works
  with JSON::PP (i.e. the created object is a JSON::PP object), available.
  See to L<JSON::PP/JSON::PP OWN METHODS> in detail.
  
  If you use C<JSON> with additional C<-support_by_pp>, some methods
  are available even with JSON::XS. See to L<USE PP FEATURES EVEN THOUGH XS BACKEND>.
  
     BEING { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
     # functional interfaces too.
     print to_json(["/"], {escape_slash => 1});
     print from_json('["foo"]', {utf8 => 1});
  
  If you do not want to all functions but C<-support_by_pp>,
  use C<-no_export>.
  
     use JSON -support_by_pp, -no_export;
     # functional interfaces are not exported.
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  any JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<MAPPING> about the conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But by default
  JSON backend modules encode strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  With JSON::XS, The indent space length is 3 and cannot be changed.
  With JSON::PP, it sets the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  with 'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  See to L<JSON::PP/JSON::PP OWN METHODS>.
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the least significant bit.
  
  If the backend is JSON::PP and C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::null> returns C<undef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same data structure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  In future, the ordered object feature will be added to JSON::PP using C<tie> mechanism.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  With C<convert_blessed_universally> mode,  C<encode> converts blessed
  hash references or blessed array references (contains other blessed references)
  into JSON members and arrays.
  
     use JSON -convert_blessed_universally;
     JSON->new->allow_blessed->convert_blessed->encode( $blessed_object );
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  If the backend is JSON::PP and C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 JSON and ECMAscript
  
  See to L<JSON::XS/JSON and ECMAscript>.
  
  =head1 JSON and YAML
  
  JSON is not a subset of YAML.
  See to L<JSON::XS/JSON and YAML>.
  
  
  =head1 BACKEND MODULE DECISION
  
  When you use C<JSON>, C<JSON> tries to C<use> JSON::XS. If this call failed, it will
  C<uses> JSON::PP. The required JSON::XS version is I<2.2> or later.
  
  The C<JSON> constructor method returns an object inherited from the backend module,
  and JSON::XS object is a blessed scalar reference while JSON::PP is a blessed hash
  reference.
  
  So, your program should not depend on the backend module, especially
  returned objects should not be modified.
  
   my $json = JSON->new; # XS or PP?
   $json->{stash} = 'this is xs object'; # this code may raise an error!
  
  To check the backend module, there are some methods - C<backend>, C<is_pp> and C<is_xs>.
  
    JSON->backend; # 'JSON::XS' or 'JSON::PP'
    
    JSON->backend->is_pp: # 0 or 1
    
    JSON->backend->is_xs: # 1 or 0
    
    $json->is_xs; # 1 or 0
    
    $json->is_pp; # 0 or 1
  
  
  If you set an environment variable C<PERL_JSON_BACKEND>, the calling action will be changed.
  
  =over
  
  =item PERL_JSON_BACKEND = 0 or PERL_JSON_BACKEND = 'JSON::PP'
  
  Always use JSON::PP
  
  =item PERL_JSON_BACKEND == 1 or PERL_JSON_BACKEND = 'JSON::XS,JSON::PP'
  
  (The default) Use compiled JSON::XS if it is properly compiled & installed,
  otherwise use JSON::PP.
  
  =item PERL_JSON_BACKEND == 2 or PERL_JSON_BACKEND = 'JSON::XS'
  
  Always use compiled JSON::XS, die if it isn't properly compiled & installed.
  
  =item PERL_JSON_BACKEND = 'JSON::backportPP'
  
  Always use JSON::backportPP.
  JSON::backportPP is JSON::PP back port module.
  C<JSON> includes JSON::backportPP instead of JSON::PP.
  
  =back
  
  These ideas come from L<DBI::PurePerl> mechanism.
  
  example:
  
   BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::PP' }
   use JSON; # always uses JSON::PP
  
  In future, it may be able to specify another module.
  
  =head1 USE PP FEATURES EVEN THOUGH XS BACKEND
  
  Many methods are available with either JSON::XS or JSON::PP and
  when the backend module is JSON::XS, if any JSON::PP specific (i.e. JSON::XS unsupported)
  method is called, it will C<warn> and be noop.
  
  But If you C<use> C<JSON> passing the optional string C<-support_by_pp>,
  it makes a part of those unsupported methods available.
  This feature is achieved by using JSON::PP in C<de/encode>.
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 2 } # with JSON::XS
     use JSON -support_by_pp;
     my $json = JSON->new;
     $json->allow_nonref->escape_slash->encode("/");
  
  At this time, the returned object is a C<JSON::Backend::XS::Supportable>
  object (re-blessed XS object), and  by checking JSON::XS unsupported flags
  in de/encoding, can support some unsupported methods - C<loose>, C<allow_bignum>,
  C<allow_barekey>, C<allow_singlequote>, C<escape_slash> and C<indent_length>.
  
  When any unsupported methods are not enable, C<XS de/encode> will be
  used as is. The switch is achieved by changing the symbolic tables.
  
  C<-support_by_pp> is effective only when the backend module is JSON::XS
  and it makes the de/encoding speed down a bit.
  
  See to L<JSON::PP SUPPORT METHODS>.
  
  =head1 INCOMPATIBLE CHANGES TO OLD VERSION
  
  There are big incompatibility between new version (2.00) and old (1.xx).
  If you use old C<JSON> 1.xx in your code, please check it.
  
  See to L<Transition ways from 1.xx to 2.xx.>
  
  =over
  
  =item jsonToObj and objToJson are obsoleted.
  
  Non Perl-style name C<jsonToObj> and C<objToJson> are obsoleted
  (but not yet deleted from the source).
  If you use these functions in your code, please replace them
  with C<from_json> and C<to_json>.
  
  
  =item Global variables are no longer available.
  
  C<JSON> class variables - C<$JSON::AUTOCONVERT>, C<$JSON::BareKey>, etc...
  - are not available any longer.
  Instead, various features can be used through object methods.
  
  
  =item Package JSON::Converter and JSON::Parser are deleted.
  
  Now C<JSON> bundles with JSON::PP which can handle JSON more properly than them.
  
  =item Package JSON::NotString is deleted.
  
  There was C<JSON::NotString> class which represents JSON value C<true>, C<false>, C<null>
  and numbers. It was deleted and replaced by C<JSON::Boolean>.
  
  C<JSON::Boolean> represents C<true> and C<false>.
  
  C<JSON::Boolean> does not represent C<null>.
  
  C<JSON::null> returns C<undef>.
  
  C<JSON> makes L<JSON::XS::Boolean> and L<JSON::PP::Boolean> is-a relation
  to L<JSON::Boolean>.
  
  =item function JSON::Number is obsoleted.
  
  C<JSON::Number> is now needless because JSON::XS and JSON::PP have
  round-trip integrity.
  
  =item JSONRPC modules are deleted.
  
  Perl implementation of JSON-RPC protocol - C<JSONRPC >, C<JSONRPC::Transport::HTTP>
  and C<Apache::JSONRPC > are deleted in this distribution.
  Instead of them, there is L<JSON::RPC> which supports JSON-RPC protocol version 1.1.
  
  =back
  
  =head2 Transition ways from 1.xx to 2.xx.
  
  You should set C<suport_by_pp> mode firstly, because
  it is always successful for the below codes even with JSON::XS.
  
      use JSON -support_by_pp;
  
  =over
  
  =item Exported jsonToObj (simple)
  
    from_json($json_text);
  
  =item Exported objToJson (simple)
  
    to_json($perl_scalar);
  
  =item Exported jsonToObj (advanced)
  
    $flags = {allow_barekey => 1, allow_singlequote => 1};
    from_json($json_text, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    $JSON::QuotApos = 1;
    jsonToObj($json_text);
  
  =item Exported objToJson (advanced)
  
    $flags = {allow_blessed => 1, allow_barekey => 1};
    to_json($perl_scalar, $flags);
  
  equivalent to:
  
    $JSON::BareKey = 1;
    objToJson($perl_scalar);
  
  =item jsonToObj as object method
  
    $json->decode($json_text);
  
  =item objToJson as object method
  
    $json->encode($perl_scalar);
  
  =item new method with parameters
  
  The C<new> method in 2.x takes any parameters no longer.
  You can set parameters instead;
  
     $json = JSON->new->pretty;
  
  =item $JSON::Pretty, $JSON::Indent, $JSON::Delimiter
  
  If C<indent> is enable, that means C<$JSON::Pretty> flag set. And
  C<$JSON::Delimiter> was substituted by C<space_before> and C<space_after>.
  In conclusion:
  
     $json->indent->space_before->space_after;
  
  Equivalent to:
  
    $json->pretty;
  
  To change indent length, use C<indent_length>.
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->pretty->indent_length(2)->encode($perl_scalar);
  
  =item $JSON::BareKey
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_barekey->decode($json_text)
  
  =item $JSON::ConvBlessed
  
  use C<-convert_blessed_universally>. See to L<convert_blessed>.
  
  =item $JSON::QuotApos
  
  (Only with JSON::PP, if C<-support_by_pp> is not used.)
  
    $json->allow_singlequote->decode($json_text)
  
  =item $JSON::SingleQuote
  
  Disable. C<JSON> does not make such a invalid JSON string any longer.
  
  =item $JSON::KeySort
  
    $json->canonical->encode($perl_scalar)
  
  This is the ascii sort.
  
  If you want to use with your own sort routine, check the C<sort_by> method.
  
  (Only with JSON::PP, even if C<-support_by_pp> is used currently.)
  
    $json->sort_by($sort_routine_ref)->encode($perl_scalar)
   
    $json->sort_by(sub { $JSON::PP::a <=> $JSON::PP::b })->encode($perl_scalar)
  
  Can't access C<$a> and C<$b> but C<$JSON::PP::a> and C<$JSON::PP::b>.
  
  =item $JSON::SkipInvalid
  
    $json->allow_unknown
  
  =item $JSON::AUTOCONVERT
  
  Needless. C<JSON> backend modules have the round-trip integrity.
  
  =item $JSON::UTF8
  
  Needless because C<JSON> (JSON::XS/JSON::PP) sets
  the UTF8 flag on properly.
  
      # With UTF8-flagged strings
  
      $json->allow_nonref;
      $str = chr(1000); # UTF8-flagged
  
      $json_text  = $json->utf8(0)->encode($str);
      utf8::is_utf8($json_text);
      # true
      $json_text  = $json->utf8(1)->encode($str);
      utf8::is_utf8($json_text);
      # false
  
      $str = '"' . chr(1000) . '"'; # UTF8-flagged
  
      $perl_scalar  = $json->utf8(0)->decode($str);
      utf8::is_utf8($perl_scalar);
      # true
      $perl_scalar  = $json->utf8(1)->decode($str);
      # died because of 'Wide character in subroutine'
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =item $JSON::UnMapping
  
  Disable. See to L<MAPPING>.
  
  =item $JSON::SelfConvert
  
  This option was deleted.
  Instead of it, if a given blessed object has the C<TO_JSON> method,
  C<TO_JSON> will be executed with C<convert_blessed>.
  
    $json->convert_blessed->encode($blessed_hashref_or_arrayref)
    # if need, call allow_blessed
  
  Note that it was C<toJson> in old version, but now not C<toJson> but C<TO_JSON>.
  
  =back
  
  =head1 TODO
  
  =over
  
  =item example programs
  
  =back
  
  =head1 THREADS
  
  No test with JSON::PP. If with JSON::XS, See to L<JSON::XS/THREADS>.
  
  
  =head1 BUGS
  
  Please report bugs relevant to C<JSON> to E<lt>makamaka[at]cpan.orgE<gt>.
  
  
  =head1 SEE ALSO
  
  Most of the document is copied and modified from JSON::XS doc.
  
  L<JSON::XS>, L<JSON::PP>
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP';
  package JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  use base qw(Exporter);
  use overload ();
  
  use Carp ();
  use B ();
  #use Devel::Peek;
  
  $JSON::PP::VERSION = '2.27203';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enable?
      # Helper module sets @JSON::PP::_properties.
      if ($] < 5.008 ) {
          my $helper = $] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $flag_name = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my %encode_allow_method
       = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                            allow_blessed convert_blessed indent indent_length allow_bignum
                            as_nonblessed
                          /;
  my %decode_allow_method
       = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                            allow_barekey max_size relaxed/;
  
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent      => 0,
          FLAGS       => 0,
          fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ > 1) {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $idx = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($idx->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
                  return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
  
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  ) unless ($allow_blessed);
  
                  return 'null';
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, string_to_json( $self, $k )
                            .  $del
                            . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, $self->object_to_json($v) || $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
      }
  
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $b_obj = B::svref_2object(\$value);  # for round trip problem
          my $flags = $b_obj->FLAGS;
  
          return $value # as is 
              if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
          my $type = ref($value);
  
          if(!$type){
              return string_to_json($self, $value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          elsif ($type) {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
               if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                   return 'null';
               }
               else {
                   if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                   }
                   else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                   }
               }
  
          }
          else {
              return $self->{fallback}->($value)
                   if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
              return 'null';
          }
  
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # 1chracter
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest nubmer of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bigint;   # using Math::BigInt
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      # $opt flag
      # 0x00000001 .... decode_prefix
      # 0x10000000 .... incr_parse
  
      sub PP_decode_json {
          my ($self, $opt); # $opt is an effective flag during this decode_json.
  
          ($self, $text, $opt) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $idx = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
              = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
          }
          else {
              utf8::upgrade( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          # Currently no effect
          # should use regexp
          my @octets = unpack('C4', $text);
          $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                      : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                      : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                      : ( $octets[2]                ) ? 'UTF-16LE'
                      : (!$octets[2]                ) ? 'UTF-32LE'
                      : 'unknown';
  
          white(); # remove head white space
  
          my $valid_start = defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
  
          if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          if ( $ch ) {
              return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
              decode_error("garbage after JSON object");
          }
  
          ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my ($i, $s, $t, $u);
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          if ( $utf8 ) {
                              unless( $ch = is_valid_utf8($ch) ) {
                                  $at -= 1;
                                  decode_error("malformed UTF-8 character in JSON string");
                              }
                              else {
                                  $at += $utf8_len - 1;
                              }
                          }
                          else {
                              utf8::encode( $ch );
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch le ' '){
                  next_chr();
              }
              elsif($ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at--;
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
  
          # According to RFC4627, hex or oct digts are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              my $hex  = $peek =~ /[xX]/; # 0 or 1
  
              if($hex){
                  decode_error("malformed number (leading zero must not be followed by another digit)");
                  ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
              }
              else{ # oct
                  ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                  if (defined $n and length $n > 1) {
                      decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
              }
  
              if(defined $n and length($n)){
                  if (!$hex and length($n) == 1) {
                     decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
                  $at += length($n) + $hex;
                  next_chr;
                  return $hex ? hex($n) : oct($n);
              }
          }
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($v !~ /[.eE]/ and length $v > $max_intsize) {
              if ($allow_bigint) { # from Adam Sussman
                  require Math::BigInt;
                  return Math::BigInt->new($v);
              }
              else {
                  return "$v";
              }
          }
          elsif ($allow_bigint) {
              require Math::BigFloat;
              return Math::BigFloat->new($v);
          }
  
          return 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = $] >= 5.008           ? 'U*'
                     : $] <  5.006           ? 'C*'
                     : utf8::is_utf8( $str ) ? 'U*' # 5.6
                     : 'C*'
                     ;
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( $] >= 5.008 ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
      }
  
      if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
          package JSON::PP;
          require subs;
          subs->import('join');
          eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |;
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Sclar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamely copied and modified from JSON::XS code.
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  package JSON::PP::Boolean;
  
  use overload (
     "0+"     => sub { ${$_[0]} },
     "++"     => sub { $_[0] = ${$_[0]} + 1 },
     "--"     => sub { $_[0] = ${$_[0]} - 1 },
     fallback => 1,
  );
  
  
  ###############################
  
  package JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  $JSON::PP::IncrParser::VERSION = '1.01';
  
  my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_parsing => 0,
          incr_p       => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
  
      my $max_size = $coder->get_max_size;
  
      if ( defined wantarray ) {
  
          $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
  
          if ( wantarray ) {
              my @ret;
  
              $self->{incr_parsing} = 1;
  
              do {
                  push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
  
                  unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                  }
  
              } until ( length $self->{incr_text} >= $self->{incr_p} );
  
              $self->{incr_parsing} = 0;
  
              return @ret;
          }
          else { # in scalar context
              $self->{incr_parsing} = 1;
              my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
              $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
              return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
          }
  
      }
  
  }
  
  
  sub _incr_parse {
      my ( $self, $coder, $text, $skip ) = @_;
      my $p = $self->{incr_p};
      my $restore = $p;
  
      my @obj;
      my $len = length $text;
  
      if ( $self->{incr_mode} == INCR_M_WS ) {
          while ( $len > $p ) {
              my $s = substr( $text, $p, 1 );
              $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
              $self->{incr_mode} = INCR_M_JSON;
              last;
         }
      }
  
      while ( $len > $p ) {
          my $s = substr( $text, $p++, 1 );
  
          if ( $s eq '"' ) {
              if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                  next;
              }
  
              if ( $self->{incr_mode} != INCR_M_STR  ) {
                  $self->{incr_mode} = INCR_M_STR;
              }
              else {
                  $self->{incr_mode} = INCR_M_JSON;
                  unless ( $self->{incr_nest} ) {
                      last;
                  }
              }
          }
  
          if ( $self->{incr_mode} == INCR_M_JSON ) {
  
              if ( $s eq '[' or $s eq '{' ) {
                  if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                      Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                  }
              }
              elsif ( $s eq ']' or $s eq '}' ) {
                  last if ( --$self->{incr_nest} <= 0 );
              }
              elsif ( $s eq '#' ) {
                  while ( $len > $p ) {
                      last if substr( $text, $p++, 1 ) eq "\n";
                  }
              }
  
          }
  
      }
  
      $self->{incr_p} = $p;
  
      return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
      return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
  
      return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
  
      local $Carp::CarpLevel = 2;
  
      $self->{incr_p} = $restore;
      $self->{incr_c} = $p;
  
      my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
  
      $self->{incr_text} = substr( $self->{incr_text}, $p );
      $self->{incr_p} = 0;
  
      return $obj || '';
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
      $self->{incr_p} = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_p}       = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
      $self->{incr_parsing} = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.27202
  
  L<JSON::XS> 2.27 (~2.30) compatible.
  
  =head1 NOTE
  
  JSON::PP had been inculded in JSON distribution (CPAN module).
  It was a perl core module in Perl 5.14.
  
  =head1 DESCRIPTION
  
  This module is L<JSON::XS> compatible pure Perl module.
  (Perl 5.8 or later is recommended)
  
  JSON::XS is the fastest and most proper JSON module on CPAN.
  It is written by Marc Lehmann in C, so must be compiled and
  installed in the used environment.
  
  JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
  
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module knows how to handle Unicode (depending on Perl version).
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and L<UNICODE HANDLING ON PERLS>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types supported
  by JSON and Perl, the deserialised data structure is identical on the Perl
  level. (e.g. the string "2.0" doesn't suddenly become "2" just because
  it looks like a number). There I<are> minor exceptions to this, read the
  MAPPING section below to learn about those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a security feature).
  But when some options are set, loose chcking features are available.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::PP::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl vresion is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON::PP->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 METHODS
  
  Basically, check to L<JSON> or L<JSON::XS>.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Rturns a new JSON::PP object that can be used to de/encode JSON
  strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
  
  In Perl 5.005, there is no character having high value (more than 255).
  See to L<UNICODE HANDLING ON PERLS>.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  See to L<UNICODE HANDLING ON PERLS>.
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  (In Perl 5.005, any character outside the range 0..255 does not exist.
  See to L<UNICODE HANDLING ON PERLS>.)
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> flags in one call to generate the most readable
  (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  If you want your own sorting routine, you can give a code referece
  or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  In JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible.
  It will also try to downgrade any strings to octet-form if possible.
  
  In JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>.
  See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  When a large value (100 or more) was set and it de/encodes a deep nested object/text,
  it may raise a warning 'Deep recursion on subroutin' at the perl runtime phase.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthese
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the errornous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want ot repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP OWN METHODS
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<JSON::XS/MAPPING> aboout the normal conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But default
  JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  JSON::XS indent space length is 3 and cannot be changed.
  JSON::PP set the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used
  in encoding JSON objects.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  =head1 INTERNAL
  
  For developers.
  
  =over
  
  =item PP_encode_box
  
  Returns
  
          {
              depth        => $depth,
              indent_count => $indent_count,
          }
  
  
  =item PP_decode_box
  
  Returns
  
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
  
  =back
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON::PP>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded toa JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the leats significant bit.
  
  When C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check wether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::PP::true . "\n";
      => true
     print JSON::PP::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::PP::null> returns C<unddef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same datastructure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false, JSON::PP::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::PP::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choise is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  When C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 UNICODE HANDLING ON PERLS
  
  If you do not know about Unicode on Perl well,
  please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =head2 Perl 5.8 and later
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
  
      $json->allow_nonref->encode(chr hex 3042);
      $json->allow_nonref->encode(chr hex 12345);
  
  Reuturns C<"\u3042"> and C<"\ud808\udf45"> respectively.
  
      $json->allow_nonref->decode('"\u3042"');
      $json->allow_nonref->decode('"\ud808\udf45"');
  
  Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
  
  Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
  so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
  
  
  =head2 Perl 5.6
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work.
  
  =head2 Perl 5.005
  
  Perl 5.005 is a byte sementics world -- all strings are sequences of bytes.
  That means the unicode handling is not available.
  
  In encoding,
  
      $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
      $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
  
  Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
  as C<$value % 256>, so the above codes are equivalent to :
  
      $json->allow_nonref->encode(chr 66);
      $json->allow_nonref->encode(chr 69);
  
  In decoding,
  
      $json->decode('"\u00e3\u0081\u0082"');
  
  The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
  japanese character (C<HIRAGANA LETTER A>).
  And if it is represented in Unicode code point, C<U+3042>.
  
  Next, 
  
      $json->decode('"\u3042"');
  
  We ordinary expect the returned value is a Unicode character C<U+3042>.
  But here is 5.005 world. This is C<0xE3 0x81 0x82>.
  
      $json->decode('"\ud808\udf45"');
  
  This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
  
  
  =head1 TODO
  
  =over
  
  =item speed
  
  =item memory saving
  
  =back
  
  
  =head1 SEE ALSO
  
  Most of the document are copied and modified from JSON::XS doc.
  
  L<JSON::XS>
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_PP

$fatpacked{"JSON/PP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_BOOLEAN';
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable and similar modules. See
  L<JSON::PP> for more info about this class.
  
  =cut
  
  use JSON::PP ();
  use strict;
  
  1;
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_PP_BOOLEAN

$fatpacked{"JSON/PP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_PP_COMPAT5006';
  package JSON::PP::Compat5006;
  
  use 5.006;
  use strict;
  
  BEGIN {
      if ( $] >= 5.008 ) {
          require Carp;
          die( "JSON::PP::Compat5006 is for Perl 5.6" );
      }
  }
  
  my @properties;
  
  $JSON::PP::Compat5006::VERSION = '1.09';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          my $len =  length $_[0]; # char length
          {
              use bytes; #  byte length;
              return $len != length $_[0]; # if !=, UTF8-flagged on.
          }
      }
  
  
      sub utf8::upgrade {
          ; # noop;
      }
  
  
      sub utf8::downgrade ($;$) {
          return 1 unless ( utf8::is_utf8( $_[0] ) );
  
          if ( _is_valid_utf8( $_[0] ) ) {
              my $downgrade;
              for my $c ( unpack( "U*", $_[0] ) ) {
                  if ( $c < 256 ) {
                      $downgrade .= pack("C", $c);
                  }
                  else {
                      $downgrade .= pack("U", $c);
                  }
              }
              $_[0] = $downgrade;
              return 1;
          }
          else {
              Carp::croak("Wide character in subroutine entry") unless ( $_[1] );
              0;
          }
      }
  
  
      sub utf8::encode ($) { # UTF8 flag off
          if ( utf8::is_utf8( $_[0] ) ) {
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
          else {
              $_[0] = pack( "U*", unpack( "C*", $_[0] ) );
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
      }
  
  
      sub utf8::decode ($) { # UTF8 flag on
          if ( _is_valid_utf8( $_[0] ) ) {
              utf8::downgrade( $_[0] );
              $_[0] = pack( "U*", unpack( "U*", $_[0] ) );
          }
      }
  
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&JSON::PP::_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&JSON::PP::_decode_unicode;
  
      unless ( defined &B::SVp_NOK ) { # missing in B module.
          eval q{ sub B::SVp_NOK () { 0x02000000; } };
      }
  
  }
  
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _unpack_emu { # for Perl 5.6 unpack warnings
      return   !utf8::is_utf8($_[0]) ? unpack('C*', $_[0]) 
             : _is_valid_utf8($_[0]) ? unpack('U*', $_[0])
             : unpack('C*', $_[0]);
  }
  
  
  sub _is_valid_utf8 {
      my $str = $_[0];
      my $is_utf8;
  
      while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg)
      {
          if (defined $1) {
              $is_utf8 = 1 if (!defined $is_utf8);
          }
          else {
              $is_utf8 = 0 if (!defined $is_utf8);
              if ($is_utf8) { # eventually, not utf8
                  return;
              }
          }
      }
  
      return $is_utf8;
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP::Compat5006 - Helper module in using JSON::PP in Perl 5.6
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2010 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_PP_COMPAT5006

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package # This is JSON::backportPP
      JSON::PP;
  
  # JSON-2.0
  
  use 5.005;
  use strict;
  use base qw(Exporter);
  use overload ();
  
  use Carp ();
  use B ();
  #use Devel::Peek;
  
  use vars qw($VERSION);
  $VERSION = '2.27204';
  
  @JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
  
  # instead of hash-access, i tried index-access for speed.
  # but this method is not faster than what i expected. so it will be changed.
  
  use constant P_ASCII                => 0;
  use constant P_LATIN1               => 1;
  use constant P_UTF8                 => 2;
  use constant P_INDENT               => 3;
  use constant P_CANONICAL            => 4;
  use constant P_SPACE_BEFORE         => 5;
  use constant P_SPACE_AFTER          => 6;
  use constant P_ALLOW_NONREF         => 7;
  use constant P_SHRINK               => 8;
  use constant P_ALLOW_BLESSED        => 9;
  use constant P_CONVERT_BLESSED      => 10;
  use constant P_RELAXED              => 11;
  
  use constant P_LOOSE                => 12;
  use constant P_ALLOW_BIGNUM         => 13;
  use constant P_ALLOW_BAREKEY        => 14;
  use constant P_ALLOW_SINGLEQUOTE    => 15;
  use constant P_ESCAPE_SLASH         => 16;
  use constant P_AS_NONBLESSED        => 17;
  
  use constant P_ALLOW_UNKNOWN        => 18;
  
  use constant OLD_PERL => $] < 5.008 ? 1 : 0;
  
  BEGIN {
      my @xs_compati_bit_properties = qw(
              latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
              allow_blessed convert_blessed relaxed allow_unknown
      );
      my @pp_bit_properties = qw(
              allow_singlequote allow_bignum loose
              allow_barekey escape_slash as_nonblessed
      );
  
      # Perl version check, Unicode handling is enable?
      # Helper module sets @JSON::PP::_properties.
      if ($] < 5.008 ) {
          my $helper = $] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';
          eval qq| require $helper |;
          if ($@) { Carp::croak $@; }
      }
  
      for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
          my $flag_name = 'P_' . uc($name);
  
          eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$flag_name] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$flag_name] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
              }
          /;
      }
  
  }
  
  
  
  # Functions
  
  my %encode_allow_method
       = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                            allow_blessed convert_blessed indent indent_length allow_bignum
                            as_nonblessed
                          /;
  my %decode_allow_method
       = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                            allow_barekey max_size relaxed/;
  
  
  my $JSON; # cache
  
  sub encode_json ($) { # encode
      ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
  }
  
  
  sub decode_json { # decode
      ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
  }
  
  # Obsoleted
  
  sub to_json($) {
     Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
  }
  
  
  sub from_json($) {
     Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
  }
  
  
  # Methods
  
  sub new {
      my $class = shift;
      my $self  = {
          max_depth   => 512,
          max_size    => 0,
          indent      => 0,
          FLAGS       => 0,
          fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
          indent_length => 3,
      };
  
      bless $self, $class;
  }
  
  
  sub encode {
      return $_[0]->PP_encode_json($_[1]);
  }
  
  
  sub decode {
      return $_[0]->PP_decode_json($_[1], 0x00000000);
  }
  
  
  sub decode_prefix {
      return $_[0]->PP_decode_json($_[1], 0x00000001);
  }
  
  
  # accessor
  
  
  # pretty printing
  
  sub pretty {
      my ($self, $v) = @_;
      my $enable = defined $v ? $v : 1;
  
      if ($enable) { # indent_length(3) for JSON::XS compatibility
          $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
      }
      else {
          $self->indent(0)->space_before(0)->space_after(0);
      }
  
      $self;
  }
  
  # etc
  
  sub max_depth {
      my $max  = defined $_[1] ? $_[1] : 0x80000000;
      $_[0]->{max_depth} = $max;
      $_[0];
  }
  
  
  sub get_max_depth { $_[0]->{max_depth}; }
  
  
  sub max_size {
      my $max  = defined $_[1] ? $_[1] : 0;
      $_[0]->{max_size} = $max;
      $_[0];
  }
  
  
  sub get_max_size { $_[0]->{max_size}; }
  
  
  sub filter_json_object {
      $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub filter_json_single_key_object {
      if (@_ > 1) {
          $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
      }
      $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
      $_[0];
  }
  
  sub indent_length {
      if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
          Carp::carp "The acceptable range of indent_length() is 0 to 15.";
      }
      else {
          $_[0]->{indent_length} = $_[1];
      }
      $_[0];
  }
  
  sub get_indent_length {
      $_[0]->{indent_length};
  }
  
  sub sort_by {
      $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
      $_[0];
  }
  
  sub allow_bigint {
      Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
  }
  
  ###############################
  
  ###
  ### Perl => JSON
  ###
  
  
  { # Convert
  
      my $max_depth;
      my $indent;
      my $ascii;
      my $latin1;
      my $utf8;
      my $space_before;
      my $space_after;
      my $canonical;
      my $allow_blessed;
      my $convert_blessed;
  
      my $indent_length;
      my $escape_slash;
      my $bignum;
      my $as_nonblessed;
  
      my $depth;
      my $indent_count;
      my $keysort;
  
  
      sub PP_encode_json {
          my $self = shift;
          my $obj  = shift;
  
          $indent_count = 0;
          $depth        = 0;
  
          my $idx = $self->{PROPS};
  
          ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
              $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
           = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                      P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
  
          ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
  
          $keysort = $canonical ? sub { $a cmp $b } : undef;
  
          if ($self->{sort_by}) {
              $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                       : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                       : sub { $a cmp $b };
          }
  
          encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
               if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
  
          my $str  = $self->object_to_json($obj);
  
          $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible
  
          unless ($ascii or $latin1 or $utf8) {
              utf8::upgrade($str);
          }
  
          if ($idx->[ P_SHRINK ]) {
              utf8::downgrade($str, 1);
          }
  
          return $str;
      }
  
  
      sub object_to_json {
          my ($self, $obj) = @_;
          my $type = ref($obj);
  
          if($type eq 'HASH'){
              return $self->hash_to_json($obj);
          }
          elsif($type eq 'ARRAY'){
              return $self->array_to_json($obj);
          }
          elsif ($type) { # blessed object?
              if (blessed($obj)) {
  
                  return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
  
                  if ( $convert_blessed and $obj->can('TO_JSON') ) {
                      my $result = $obj->TO_JSON();
                      if ( defined $result and ref( $result ) ) {
                          if ( refaddr( $obj ) eq refaddr( $result ) ) {
                              encode_error( sprintf(
                                  "%s::TO_JSON method returned same object as was passed instead of a new one",
                                  ref $obj
                              ) );
                          }
                      }
  
                      return $self->object_to_json( $result );
                  }
  
                  return "$obj" if ( $bignum and _is_bignum($obj) );
                  return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.
  
                  encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                      . "nor convert_blessed settings are enabled", $obj)
                  ) unless ($allow_blessed);
  
                  return 'null';
              }
              else {
                  return $self->value_to_json($obj);
              }
          }
          else{
              return $self->value_to_json($obj);
          }
      }
  
  
      sub hash_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
          my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
  
          for my $k ( _sort( $obj ) ) {
              if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
              push @res, string_to_json( $self, $k )
                            .  $del
                            . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
      }
  
  
      sub array_to_json {
          my ($self, $obj) = @_;
          my @res;
  
          encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                           if (++$depth > $max_depth);
  
          my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
  
          for my $v (@$obj){
              push @res, $self->object_to_json($v) || $self->value_to_json($v);
          }
  
          --$depth;
          $self->_down_indent() if ($indent);
  
          return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
      }
  
  
      sub value_to_json {
          my ($self, $value) = @_;
  
          return 'null' if(!defined $value);
  
          my $b_obj = B::svref_2object(\$value);  # for round trip problem
          my $flags = $b_obj->FLAGS;
  
          return $value # as is 
              if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?
  
          my $type = ref($value);
  
          if(!$type){
              return string_to_json($self, $value);
          }
          elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
              return $$value == 1 ? 'true' : 'false';
          }
          elsif ($type) {
              if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                  return $self->value_to_json("$value");
              }
  
              if ($type eq 'SCALAR' and defined $$value) {
                  return   $$value eq '1' ? 'true'
                         : $$value eq '0' ? 'false'
                         : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                         : encode_error("cannot encode reference to scalar");
              }
  
               if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                   return 'null';
               }
               else {
                   if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                      encode_error("cannot encode reference to scalar");
                   }
                   else {
                      encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                   }
               }
  
          }
          else {
              return $self->{fallback}->($value)
                   if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
              return 'null';
          }
  
      }
  
  
      my %esc = (
          "\n" => '\n',
          "\r" => '\r',
          "\t" => '\t',
          "\f" => '\f',
          "\b" => '\b',
          "\"" => '\"',
          "\\" => '\\\\',
          "\'" => '\\\'',
      );
  
  
      sub string_to_json {
          my ($self, $arg) = @_;
  
          $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
          $arg =~ s/\//\\\//g if ($escape_slash);
          $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
  
          if ($ascii) {
              $arg = JSON_PP_encode_ascii($arg);
          }
  
          if ($latin1) {
              $arg = JSON_PP_encode_latin1($arg);
          }
  
          if ($utf8) {
              utf8::encode($arg);
          }
  
          return '"' . $arg . '"';
      }
  
  
      sub blessed_to_json {
          my $reftype = reftype($_[1]) || '';
          if ($reftype eq 'HASH') {
              return $_[0]->hash_to_json($_[1]);
          }
          elsif ($reftype eq 'ARRAY') {
              return $_[0]->array_to_json($_[1]);
          }
          else {
              return 'null';
          }
      }
  
  
      sub encode_error {
          my $error  = shift;
          Carp::croak "$error";
      }
  
  
      sub _sort {
          defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
      }
  
  
      sub _up_indent {
          my $self  = shift;
          my $space = ' ' x $indent_length;
  
          my ($pre,$post) = ('','');
  
          $post = "\n" . $space x $indent_count;
  
          $indent_count++;
  
          $pre = "\n" . $space x $indent_count;
  
          return ($pre,$post);
      }
  
  
      sub _down_indent { $indent_count--; }
  
  
      sub PP_encode_box {
          {
              depth        => $depth,
              indent_count => $indent_count,
          };
      }
  
  } # Convert
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
          } unpack('U*', $_[0])
      );
  }
  
  
  sub _encode_surrogates { # from perlunicode
      my $uni = $_[0] - 0x10000;
      return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
  }
  
  
  sub _is_bignum {
      $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
  }
  
  
  
  #
  # JSON => Perl
  #
  
  my $max_intsize;
  
  BEGIN {
      my $checkint = 1111;
      for my $d (5..64) {
          $checkint .= 1;
          my $int   = eval qq| $checkint |;
          if ($int =~ /[eE]/) {
              $max_intsize = $d - 1;
              last;
          }
      }
  }
  
  { # PARSE 
  
      my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
          b    => "\x8",
          t    => "\x9",
          n    => "\xA",
          f    => "\xC",
          r    => "\xD",
          '\\' => '\\',
          '"'  => '"',
          '/'  => '/',
      );
  
      my $text; # json data
      my $at;   # offset
      my $ch;   # 1chracter
      my $len;  # text length (changed according to UTF8 or NON UTF8)
      # INTERNAL
      my $depth;          # nest counter
      my $encoding;       # json text encoding
      my $is_valid_utf8;  # temp variable
      my $utf8_len;       # utf8 byte length
      # FLAGS
      my $utf8;           # must be utf8
      my $max_depth;      # max nest number of objects and arrays
      my $max_size;
      my $relaxed;
      my $cb_object;
      my $cb_sk_object;
  
      my $F_HOOK;
  
      my $allow_bigint;   # using Math::BigInt
      my $singlequote;    # loosely quoting
      my $loose;          # 
      my $allow_barekey;  # bareKey
  
      # $opt flag
      # 0x00000001 .... decode_prefix
      # 0x10000000 .... incr_parse
  
      sub PP_decode_json {
          my ($self, $opt); # $opt is an effective flag during this decode_json.
  
          ($self, $text, $opt) = @_;
  
          ($at, $ch, $depth) = (0, '', 0);
  
          if ( !defined $text or ref $text ) {
              decode_error("malformed JSON string, neither array, object, number, string or atom");
          }
  
          my $idx = $self->{PROPS};
  
          ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
              = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
  
          if ( $utf8 ) {
              utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
          }
          else {
              utf8::upgrade( $text );
          }
  
          $len = length $text;
  
          ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
               = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
  
          if ($max_size > 1) {
              use bytes;
              my $bytes = length $text;
              decode_error(
                  sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                      , $bytes, $max_size), 1
              ) if ($bytes > $max_size);
          }
  
          # Currently no effect
          # should use regexp
          my @octets = unpack('C4', $text);
          $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                      : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                      : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                      : ( $octets[2]                ) ? 'UTF-16LE'
                      : (!$octets[2]                ) ? 'UTF-32LE'
                      : 'unknown';
  
          white(); # remove head white space
  
          my $valid_start = defined $ch; # Is there a first character for JSON structure?
  
          my $result = value();
  
          return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse
  
          decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
  
          if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                  decode_error(
                  'JSON text must be an object or array (but found number, string, true, false or null,'
                         . ' use allow_nonref to allow this)', 1);
          }
  
          Carp::croak('something wrong.') if $len < $at; # we won't arrive here.
  
          my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length
  
          white(); # remove tail white space
  
          if ( $ch ) {
              return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
              decode_error("garbage after JSON object");
          }
  
          ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
      }
  
  
      sub next_chr {
          return $ch = undef if($at >= $len);
          $ch = substr($text, $at++, 1);
      }
  
  
      sub value {
          white();
          return          if(!defined $ch);
          return object() if($ch eq '{');
          return array()  if($ch eq '[');
          return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
          return number() if($ch =~ /[0-9]/ or $ch eq '-');
          return word();
      }
  
      sub string {
          my ($i, $s, $t, $u);
          my $utf16;
          my $is_utf8;
  
          ($is_valid_utf8, $utf8_len) = ('', 0);
  
          $s = ''; # basically UTF8 flag on
  
          if($ch eq '"' or ($singlequote and $ch eq "'")){
              my $boundChar = $ch;
  
              OUTER: while( defined(next_chr()) ){
  
                  if($ch eq $boundChar){
                      next_chr();
  
                      if ($utf16) {
                          decode_error("missing low surrogate character in surrogate pair");
                      }
  
                      utf8::decode($s) if($is_utf8);
  
                      return $s;
                  }
                  elsif($ch eq '\\'){
                      next_chr();
                      if(exists $escapes{$ch}){
                          $s .= $escapes{$ch};
                      }
                      elsif($ch eq 'u'){ # UNICODE handling
                          my $u = '';
  
                          for(1..4){
                              $ch = next_chr();
                              last OUTER if($ch !~ /[0-9a-fA-F]/);
                              $u .= $ch;
                          }
  
                          # U+D800 - U+DBFF
                          if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                              $utf16 = $u;
                          }
                          # U+DC00 - U+DFFF
                          elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                              unless (defined $utf16) {
                                  decode_error("missing high surrogate character in surrogate pair");
                              }
                              $is_utf8 = 1;
                              $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                              $utf16 = undef;
                          }
                          else {
                              if (defined $utf16) {
                                  decode_error("surrogate pair expected");
                              }
  
                              if ( ( my $hex = hex( $u ) ) > 127 ) {
                                  $is_utf8 = 1;
                                  $s .= JSON_PP_decode_unicode($u) || next;
                              }
                              else {
                                  $s .= chr $hex;
                              }
                          }
  
                      }
                      else{
                          unless ($loose) {
                              $at -= 2;
                              decode_error('illegal backslash escape sequence in string');
                          }
                          $s .= $ch;
                      }
                  }
                  else{
  
                      if ( ord $ch  > 127 ) {
                          if ( $utf8 ) {
                              unless( $ch = is_valid_utf8($ch) ) {
                                  $at -= 1;
                                  decode_error("malformed UTF-8 character in JSON string");
                              }
                              else {
                                  $at += $utf8_len - 1;
                              }
                          }
                          else {
                              utf8::encode( $ch );
                          }
  
                          $is_utf8 = 1;
                      }
  
                      if (!$loose) {
                          if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                              $at--;
                              decode_error('invalid character encountered while parsing JSON string');
                          }
                      }
  
                      $s .= $ch;
                  }
              }
          }
  
          decode_error("unexpected end of string while parsing JSON string");
      }
  
  
      sub white {
          while( defined $ch  ){
              if($ch le ' '){
                  next_chr();
              }
              elsif($ch eq '/'){
                  next_chr();
                  if(defined $ch and $ch eq '/'){
                      1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                  }
                  elsif(defined $ch and $ch eq '*'){
                      next_chr();
                      while(1){
                          if(defined $ch){
                              if($ch eq '*'){
                                  if(defined(next_chr()) and $ch eq '/'){
                                      next_chr();
                                      last;
                                  }
                              }
                              else{
                                  next_chr();
                              }
                          }
                          else{
                              decode_error("Unterminated comment");
                          }
                      }
                      next;
                  }
                  else{
                      $at--;
                      decode_error("malformed JSON string, neither array, object, number, string or atom");
                  }
              }
              else{
                  if ($relaxed and $ch eq '#') { # correctly?
                      pos($text) = $at;
                      $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                      $at = pos($text);
                      next_chr;
                      next;
                  }
  
                  last;
              }
          }
      }
  
  
      sub array {
          my $a  = $_[0] || []; # you can use this code to use another array ref object.
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                      if (++$depth > $max_depth);
  
          next_chr();
          white();
  
          if(defined $ch and $ch eq ']'){
              --$depth;
              next_chr();
              return $a;
          }
          else {
              while(defined($ch)){
                  push @$a, value();
  
                  white();
  
                  if (!defined $ch) {
                      last;
                  }
  
                  if($ch eq ']'){
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq ']') {
                      --$depth;
                      next_chr();
                      return $a;
                  }
  
              }
          }
  
          decode_error(", or ] expected while parsing array");
      }
  
  
      sub object {
          my $o = $_[0] || {}; # you can use this code to use another hash ref object.
          my $k;
  
          decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                  if (++$depth > $max_depth);
          next_chr();
          white();
  
          if(defined $ch and $ch eq '}'){
              --$depth;
              next_chr();
              if ($F_HOOK) {
                  return _json_object_hook($o);
              }
              return $o;
          }
          else {
              while (defined $ch) {
                  $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                  white();
  
                  if(!defined $ch or $ch ne ':'){
                      $at--;
                      decode_error("':' expected");
                  }
  
                  next_chr();
                  $o->{$k} = value();
                  white();
  
                  last if (!defined $ch);
  
                  if($ch eq '}'){
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
                  if($ch ne ','){
                      last;
                  }
  
                  next_chr();
                  white();
  
                  if ($relaxed and $ch eq '}') {
                      --$depth;
                      next_chr();
                      if ($F_HOOK) {
                          return _json_object_hook($o);
                      }
                      return $o;
                  }
  
              }
  
          }
  
          $at--;
          decode_error(", or } expected while parsing object/hash");
      }
  
  
      sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
          my $key;
          while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
              $key .= $ch;
              next_chr();
          }
          return $key;
      }
  
  
      sub word {
          my $word =  substr($text,$at-1,4);
  
          if($word eq 'true'){
              $at += 3;
              next_chr;
              return $JSON::PP::true;
          }
          elsif($word eq 'null'){
              $at += 3;
              next_chr;
              return undef;
          }
          elsif($word eq 'fals'){
              $at += 3;
              if(substr($text,$at,1) eq 'e'){
                  $at++;
                  next_chr;
                  return $JSON::PP::false;
              }
          }
  
          $at--; # for decode_error report
  
          decode_error("'null' expected")  if ($word =~ /^n/);
          decode_error("'true' expected")  if ($word =~ /^t/);
          decode_error("'false' expected") if ($word =~ /^f/);
          decode_error("malformed JSON string, neither array, object, number, string or atom");
      }
  
  
      sub number {
          my $n    = '';
          my $v;
  
          # According to RFC4627, hex or oct digits are invalid.
          if($ch eq '0'){
              my $peek = substr($text,$at,1);
              my $hex  = $peek =~ /[xX]/; # 0 or 1
  
              if($hex){
                  decode_error("malformed number (leading zero must not be followed by another digit)");
                  ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
              }
              else{ # oct
                  ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                  if (defined $n and length $n > 1) {
                      decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
              }
  
              if(defined $n and length($n)){
                  if (!$hex and length($n) == 1) {
                     decode_error("malformed number (leading zero must not be followed by another digit)");
                  }
                  $at += length($n) + $hex;
                  next_chr;
                  return $hex ? hex($n) : oct($n);
              }
          }
  
          if($ch eq '-'){
              $n = '-';
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after initial minus)");
              }
          }
  
          while(defined $ch and $ch =~ /\d/){
              $n .= $ch;
              next_chr;
          }
  
          if(defined $ch and $ch eq '.'){
              $n .= '.';
  
              next_chr;
              if (!defined $ch or $ch !~ /\d/) {
                  decode_error("malformed number (no digits after decimal point)");
              }
              else {
                  $n .= $ch;
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
          }
  
          if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
              $n .= $ch;
              next_chr;
  
              if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                  $n .= $ch;
                  next_chr;
                  if (!defined $ch or $ch =~ /\D/) {
                      decode_error("malformed number (no digits after exp sign)");
                  }
                  $n .= $ch;
              }
              elsif(defined($ch) and $ch =~ /\d/){
                  $n .= $ch;
              }
              else {
                  decode_error("malformed number (no digits after exp sign)");
              }
  
              while(defined(next_chr) and $ch =~ /\d/){
                  $n .= $ch;
              }
  
          }
  
          $v .= $n;
  
          if ($v !~ /[.eE]/ and length $v > $max_intsize) {
              if ($allow_bigint) { # from Adam Sussman
                  require Math::BigInt;
                  return Math::BigInt->new($v);
              }
              else {
                  return "$v";
              }
          }
          elsif ($allow_bigint) {
              require Math::BigFloat;
              return Math::BigFloat->new($v);
          }
  
          return 0+$v;
      }
  
  
      sub is_valid_utf8 {
  
          $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                    : $_[0] =~ /[\xC2-\xDF]/  ? 2
                    : $_[0] =~ /[\xE0-\xEF]/  ? 3
                    : $_[0] =~ /[\xF0-\xF4]/  ? 4
                    : 0
                    ;
  
          return unless $utf8_len;
  
          my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
  
          return ( $is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x )  ? $is_valid_utf8 : '';
      }
  
  
      sub decode_error {
          my $error  = shift;
          my $no_rep = shift;
          my $str    = defined $text ? substr($text, $at) : '';
          my $mess   = '';
          my $type   = $] >= 5.008           ? 'U*'
                     : $] <  5.006           ? 'C*'
                     : utf8::is_utf8( $str ) ? 'U*' # 5.6
                     : 'C*'
                     ;
  
          for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
              $mess .=  $c == 0x07 ? '\a'
                      : $c == 0x09 ? '\t'
                      : $c == 0x0a ? '\n'
                      : $c == 0x0d ? '\r'
                      : $c == 0x0c ? '\f'
                      : $c <  0x20 ? sprintf('\x{%x}', $c)
                      : $c == 0x5c ? '\\\\'
                      : $c <  0x80 ? chr($c)
                      : sprintf('\x{%x}', $c)
                      ;
              if ( length $mess >= 20 ) {
                  $mess .= '...';
                  last;
              }
          }
  
          unless ( length $mess ) {
              $mess = '(end of string)';
          }
  
          Carp::croak (
              $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
          );
  
      }
  
  
      sub _json_object_hook {
          my $o    = $_[0];
          my @ks = keys %{$o};
  
          if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
              my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
              if (@val == 1) {
                  return $val[0];
              }
          }
  
          my @val = $cb_object->($o) if ($cb_object);
          if (@val == 0 or @val > 1) {
              return $o;
          }
          else {
              return $val[0];
          }
      }
  
  
      sub PP_decode_box {
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
      }
  
  } # PARSE
  
  
  sub _decode_surrogates { # from perlunicode
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
      my $un  = pack('U*', $uni);
      utf8::encode( $un );
      return $un;
  }
  
  
  sub _decode_unicode {
      my $un = pack('U', hex shift);
      utf8::encode( $un );
      return $un;
  }
  
  #
  # Setup for various Perl versions (the code from JSON::PP58)
  #
  
  BEGIN {
  
      unless ( defined &utf8::is_utf8 ) {
         require Encode;
         *utf8::is_utf8 = *Encode::is_utf8;
      }
  
      if ( $] >= 5.008 ) {
          *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
          *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
          *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
          *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
      }
  
      if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
          package # hide from PAUSE
            JSON::PP;
          require subs;
          subs->import('join');
          eval q|
              sub join {
                  return '' if (@_ < 2);
                  my $j   = shift;
                  my $str = shift;
                  for (@_) { $str .= $j . $_; }
                  return $str;
              }
          |;
      }
  
  
      sub JSON::PP::incr_parse {
          local $Carp::CarpLevel = 1;
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
      }
  
  
      sub JSON::PP::incr_skip {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
      }
  
  
      sub JSON::PP::incr_reset {
          ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
      }
  
      eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                  Carp::croak("incr_text can not be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ( $] >= 5.006 );
  
  } # Setup for various Perl versions (the code from JSON::PP58)
  
  
  ###############################
  # Utilities
  #
  
  BEGIN {
      eval 'require Scalar::Util';
      unless($@){
          *JSON::PP::blessed = \&Scalar::Util::blessed;
          *JSON::PP::reftype = \&Scalar::Util::reftype;
          *JSON::PP::refaddr = \&Scalar::Util::refaddr;
      }
      else{ # This code is from Scalar::Util.
          # warn $@;
          eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
          *JSON::PP::blessed = sub {
              local($@, $SIG{__DIE__}, $SIG{__WARN__});
              ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
          };
          my %tmap = qw(
              B::NULL   SCALAR
              B::HV     HASH
              B::AV     ARRAY
              B::CV     CODE
              B::IO     IO
              B::GV     GLOB
              B::REGEXP REGEXP
          );
          *JSON::PP::reftype = sub {
              my $r = shift;
  
              return undef unless length(ref($r));
  
              my $t = ref(B::svref_2object($r));
  
              return
                  exists $tmap{$t} ? $tmap{$t}
                : length(ref($$r)) ? 'REF'
                :                    'SCALAR';
          };
          *JSON::PP::refaddr = sub {
            return undef unless length(ref($_[0]));
  
            my $addr;
            if(defined(my $pkg = blessed($_[0]))) {
              $addr .= bless $_[0], 'Scalar::Util::Fake';
              bless $_[0], $pkg;
            }
            else {
              $addr .= $_[0]
            }
  
            $addr =~ /0x(\w+)/;
            local $^W;
            #no warnings 'portable';
            hex($1);
          }
      }
  }
  
  
  # shamelessly copied and modified from JSON::XS code.
  
  unless ( $INC{'JSON/PP.pm'} ) {
      eval q|
          package
              JSON::PP::Boolean;
  
          use overload (
              "0+"     => sub { ${$_[0]} },
              "++"     => sub { $_[0] = ${$_[0]} + 1 },
              "--"     => sub { $_[0] = ${$_[0]} - 1 },
              fallback => 1,
          );
      |;
  }
  
  $JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
  $JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
  
  sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
  
  sub true  { $JSON::PP::true  }
  sub false { $JSON::PP::false }
  sub null  { undef; }
  
  ###############################
  
  ###############################
  
  package # hide from PAUSE
    JSON::PP::IncrParser;
  
  use strict;
  
  use constant INCR_M_WS   => 0; # initial whitespace skipping
  use constant INCR_M_STR  => 1; # inside string
  use constant INCR_M_BS   => 2; # inside backslash
  use constant INCR_M_JSON => 3; # outside anything, count nesting
  use constant INCR_M_C0   => 4;
  use constant INCR_M_C1   => 5;
  
  use vars qw($VERSION);
  $VERSION = '1.01';
  
  my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
  
  sub new {
      my ( $class ) = @_;
  
      bless {
          incr_nest    => 0,
          incr_text    => undef,
          incr_parsing => 0,
          incr_p       => 0,
      }, $class;
  }
  
  
  sub incr_parse {
      my ( $self, $coder, $text ) = @_;
  
      $self->{incr_text} = '' unless ( defined $self->{incr_text} );
  
      if ( defined $text ) {
          if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
              utf8::upgrade( $self->{incr_text} ) ;
              utf8::decode( $self->{incr_text} ) ;
          }
          $self->{incr_text} .= $text;
      }
  
  
      my $max_size = $coder->get_max_size;
  
      if ( defined wantarray ) {
  
          $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
  
          if ( wantarray ) {
              my @ret;
  
              $self->{incr_parsing} = 1;
  
              do {
                  push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
  
                  unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                      $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                  }
  
              } until ( length $self->{incr_text} >= $self->{incr_p} );
  
              $self->{incr_parsing} = 0;
  
              return @ret;
          }
          else { # in scalar context
              $self->{incr_parsing} = 1;
              my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
              $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
              return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
          }
  
      }
  
  }
  
  
  sub _incr_parse {
      my ( $self, $coder, $text, $skip ) = @_;
      my $p = $self->{incr_p};
      my $restore = $p;
  
      my @obj;
      my $len = length $text;
  
      if ( $self->{incr_mode} == INCR_M_WS ) {
          while ( $len > $p ) {
              my $s = substr( $text, $p, 1 );
              $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
              $self->{incr_mode} = INCR_M_JSON;
              last;
         }
      }
  
      while ( $len > $p ) {
          my $s = substr( $text, $p++, 1 );
  
          if ( $s eq '"' ) {
              if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                  next;
              }
  
              if ( $self->{incr_mode} != INCR_M_STR  ) {
                  $self->{incr_mode} = INCR_M_STR;
              }
              else {
                  $self->{incr_mode} = INCR_M_JSON;
                  unless ( $self->{incr_nest} ) {
                      last;
                  }
              }
          }
  
          if ( $self->{incr_mode} == INCR_M_JSON ) {
  
              if ( $s eq '[' or $s eq '{' ) {
                  if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                      Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                  }
              }
              elsif ( $s eq ']' or $s eq '}' ) {
                  last if ( --$self->{incr_nest} <= 0 );
              }
              elsif ( $s eq '#' ) {
                  while ( $len > $p ) {
                      last if substr( $text, $p++, 1 ) eq "\n";
                  }
              }
  
          }
  
      }
  
      $self->{incr_p} = $p;
  
      return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
      return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
  
      return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
  
      local $Carp::CarpLevel = 2;
  
      $self->{incr_p} = $restore;
      $self->{incr_c} = $p;
  
      my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
  
      $self->{incr_text} = substr( $self->{incr_text}, $p );
      $self->{incr_p} = 0;
  
      return $obj || '';
  }
  
  
  sub incr_text {
      if ( $_[0]->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
      $_[0]->{incr_text};
  }
  
  
  sub incr_skip {
      my $self  = shift;
      $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
      $self->{incr_p} = 0;
  }
  
  
  sub incr_reset {
      my $self = shift;
      $self->{incr_text}    = undef;
      $self->{incr_p}       = 0;
      $self->{incr_mode}    = 0;
      $self->{incr_nest}    = 0;
      $self->{incr_parsing} = 0;
  }
  
  ###############################
  
  
  1;
  __END__
  =pod
  
  =head1 NAME
  
  JSON::PP - JSON::XS compatible pure-Perl module.
  
  =head1 SYNOPSIS
  
   use JSON::PP;
  
   # exported functions, they croak on error
   # and expect/generate UTF-8
  
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
  
   # OO-interface
  
   $coder = JSON::PP->new->ascii->pretty->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
   
   # Note that JSON version 2.0 and above will automatically use
   # JSON::XS or JSON::PP, so you should be able to just:
   
   use JSON;
  
  
  =head1 VERSION
  
      2.27200
  
  L<JSON::XS> 2.27 (~2.30) compatible.
  
  =head1 DESCRIPTION
  
  This module is L<JSON::XS> compatible pure Perl module.
  (Perl 5.8 or later is recommended)
  
  JSON::XS is the fastest and most proper JSON module on CPAN.
  It is written by Marc Lehmann in C, so must be compiled and
  installed in the used environment.
  
  JSON::PP is a pure-Perl module and has compatibility to JSON::XS.
  
  
  =head2 FEATURES
  
  =over
  
  =item * correct unicode handling
  
  This module knows how to handle Unicode (depending on Perl version).
  
  See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and
  L<UNICODE HANDLING ON PERLS>.
  
  
  =item * round-trip integrity
  
  When you serialise a perl data structure using only data types
  supported by JSON and Perl, the deserialised data structure is
  identical on the Perl level. (e.g. the string "2.0" doesn't suddenly
  become "2" just because it looks like a number). There I<are> minor
  exceptions to this, read the MAPPING section below to learn about
  those.
  
  
  =item * strict checking of JSON correctness
  
  There is no guessing, no generating of illegal JSON texts by default,
  and only JSON is accepted as input by default (the latter is a
  security feature). But when some options are set, loose checking
  features are available.
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string.
  
  This function call is functionally identical to:
  
      $json_text = JSON::PP->new->utf8->encode($perl_scalar)
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON::PP->new->utf8->decode($json_text)
  
  =head2 JSON::PP::is_bool
  
      $is_boolean = JSON::PP::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::PP::true or
  JSON::PP::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  =head2 JSON::PP::true
  
  Returns JSON true value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::false
  
  Returns JSON false value which is blessed object.
  It C<isa> JSON::PP::Boolean object.
  
  =head2 JSON::PP::null
  
  Returns C<undef>.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  
  =head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER
  
  This section supposes that your perl version is 5.8 or later.
  
  If you know a JSON text from an outer world - a network, a file content, and so on,
  is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
  with C<utf8> enable. And the decoded result will contain UNICODE characters.
  
    # from network
    my $json        = JSON::PP->new->utf8;
    my $json_text   = CGI->new->param( 'json_data' );
    my $perl_scalar = $json->decode( $json_text );
    
    # from file content
    local $/;
    open( my $fh, '<', 'json.data' );
    $json_text   = <$fh>;
    $perl_scalar = decode_json( $json_text );
  
  If an outer data is not encoded in UTF-8, firstly you should C<decode> it.
  
    use Encode;
    local $/;
    open( my $fh, '<', 'json.data' );
    my $encoding = 'cp932';
    my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
    
    # or you can write the below code.
    #
    # open( my $fh, "<:encoding($encoding)", 'json.data' );
    # $unicode_json_text = <$fh>;
  
  In this case, C<$unicode_json_text> is of course UNICODE string.
  So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  
    $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );
  
  Or C<encode 'utf8'> and C<decode_json>:
  
    $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
    # this way is not efficient.
  
  And now, you want to convert your C<$perl_scalar> into JSON data and
  send it to an outer world - a network or a file content, and so on.
  
  Your data usually contains UNICODE strings and you want the converted data to be encoded
  in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.
  
    print encode_json( $perl_scalar ); # to a network? file? or display?
    # or
    print $json->utf8->encode( $perl_scalar );
  
  If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
  for some reason, then its characters are regarded as B<latin1> for perl
  (because it does not concern with your $encoding).
  You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
  Instead of them, you use C<JSON> module object with C<utf8> disable.
  Note that the resulted text is a UNICODE string but no problem to print it.
  
    # $perl_scalar contains $encoding encoded string values
    $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
    # $unicode_json_text consists of characters less than 0x100
    print $unicode_json_text;
  
  Or C<decode $encoding> all string values and C<encode_json>:
  
    $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
    # ... do it to each string values, then encode_json
    $json_text = encode_json( $perl_scalar );
  
  This method is a proper way but probably not efficient.
  
  See to L<Encode>, L<perluniintro>.
  
  
  =head1 METHODS
  
  Basically, check to L<JSON> or L<JSON::XS>.
  
  =head2 new
  
      $json = JSON::PP->new
  
  Returns a new JSON::PP object that can be used to de/encode JSON
  strings.
  
  All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the JSON object again and thus calls can
  be chained:
  
     my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If $enable is true (or missing), then the encode method will not generate characters outside
  the code range 0..127. Any Unicode characters outside that range will be escaped using either
  a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
  (See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).
  
  In Perl 5.005, there is no character having high value (more than 255).
  See to L<UNICODE HANDLING ON PERLS>.
  
  If $enable is false, then the encode method will not escape Unicode characters unless
  required by the JSON syntax or other flags. This results in a faster and more compact format.
  
    JSON::PP->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If $enable is true (or missing), then the encode method will encode the resulting JSON
  text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.
  
  If $enable is false, then the encode method will not escape Unicode characters
  unless required by the JSON syntax or other flags.
  
    JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  See to L<UNICODE HANDLING ON PERLS>.
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If $enable is true (or missing), then the encode method will encode the JSON result
  into UTF-8, as required by many protocols, while the decode method expects to be handled
  an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
  characters outside the range 0..255, they are thus useful for bytewise/binary I/O.
  
  (In Perl 5.005, any character outside the range 0..255 does not exist.
  See to L<UNICODE HANDLING ON PERLS>.)
  
  In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
  encoding families, as described in RFC4627.
  
  If $enable is false, then the encode method will return the JSON string as a (non-encoded)
  Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
  (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);
  
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> flags in one call to generate the most readable
  (or most compact) form possible.
  
  Equivalent to:
  
     $json->indent->space_before->space_after
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  The default indent space length is three.
  You can use C<indent_length> to change the length.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  If you want your own sorting routine, you can give a code reference
  or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
     JSON::PP->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If $enable is true (or missing), then "encode" will *not* throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON "null" value.
  Note that blessed objects are not included here and are handled
  separately by c<allow_nonref>.
  
  If $enable is false (the default), then "encode" will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect "decode" in any way, and it is
  recommended to leave it off unless you know your communications
  partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference. Instead, the value of the
  B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
  disabled or no C<TO_JSON> method found) or a representation of the
  object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
  encoded. Has no effect on C<decode>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context
  and the resulting scalar will be encoded instead of the object. If no
  C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
  to do.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with the C<to_json>
  function or method.
  
  This setting does not yet influence C<decode> in any way.
  
  If C<$enable> is false, then the C<allow_blessed> setting will decide what
  to do when a blessed object is found.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument passed to the coderef
  is a reference to the newly-created hash. If the code references returns
  a single scalar (which need not be a reference), this value
  (i.e. a copy of that scalar to avoid aliasing) is inserted into the
  deserialised data structure. If it returns an empty list
  (NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
  hash will be inserted. This setting can slow down decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON::PP->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON::PP
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 shrink
  
      $json = $json->shrink([$enable])
      
      $enabled = $json->get_shrink
  
  In JSON::XS, this flag resizes strings generated by either
  C<encode> or C<decode> to their minimum size possible.
  It will also try to downgrade any strings to octet-form if possible.
  
  In JSON::PP, it is noop about resizing strings but tries
  C<utf8::downgrade> to the returned string by C<encode>.
  See to L<utf8>.
  
  See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.
  
  When a large value (100 or more) was set and it de/encodes a deep nested object/text,
  it may raise a warning 'Deep recursion on subroutine' at the perl runtime phase.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  See L<JSON::XS/SECURITY CONSIDERATIONS> for more info on why this is useful.
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl data structure (a simple scalar or a reference
  to a hash or array) to its JSON representation. Simple scalars will be
  converted into JSON string or number sequences, while references to arrays
  become JSON arrays and references to hashes become JSON objects. Undefined
  Perl values (e.g. C<undef>) become JSON C<null> values.
  References to the integers C<0> and C<1> are converted into C<true> and C<false>.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  JSON numbers and strings become simple Perl scalars. JSON arrays become
  Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
  C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
  C<null> becomes C<undef>.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([], 3)
  
  =head1 INCREMENTAL PARSING
  
  Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.
  
  In some cases, there is the need for incremental parsing of JSON texts.
  This module does allow you to parse a JSON stream incrementally.
  It does so by accumulating text until it has a full JSON object, which
  it then can decode. This process is similar to using C<decode_prefix>
  to see if a full JSON object is available, but is much more efficient
  (and can be implemented with a minimum of method calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect parenthesis
  mismatches. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators between the JSON
  objects or arrays, instead they must be concatenated back-to-back. If
  an error occurs, an exception will be raised as in the scalar context
  case. Note that in this case, any previously-parsed JSON texts will be
  lost.
  
  Example: Parse some JSON arrays/objects in a given string and return them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
      $json->incr_text =~ s/\s*,\s*//;
  
  In Perl 5.005, C<lvalue> attribute is not available.
  You must write codes like the below:
  
      $string = $json->incr_text;
      $string =~ s/\s*,\s*//;
      $json->incr_text( $string );
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove the
  parsed text from the input buffer. This is useful after C<incr_parse>
  died, in which case the input buffer and incremental parser state is left
  unchanged, to skip the text parsed so far and to reset the parse state.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  See to L<JSON::XS/INCREMENTAL PARSING> for examples.
  
  
  =head1 JSON::PP OWN METHODS
  
  =head2 allow_singlequote
  
      $json = $json->allow_singlequote([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  JSON strings quoted by single quotations that are invalid JSON
  format.
  
      $json->allow_singlequote->decode({"foo":'bar'});
      $json->allow_singlequote->decode({'foo':"bar"});
      $json->allow_singlequote->decode({'foo':'bar'});
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
  
  =head2 allow_barekey
  
      $json = $json->allow_barekey([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will accept
  bare keys of JSON object that are invalid JSON format.
  
  As same as the C<relaxed> option, this option may be used to parse
  application-specific files written by humans.
  
      $json->allow_barekey->decode('{foo:"bar"}');
  
  =head2 allow_bignum
  
      $json = $json->allow_bignum([$enable])
  
  If C<$enable> is true (or missing), then C<decode> will convert
  the big integer Perl cannot handle as integer into a L<Math::BigInt>
  object and convert a floating number (any) into a L<Math::BigFloat>.
  
  On the contrary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers with C<allow_blessed> enable.
  
     $json->allow_nonref->allow_blessed->allow_bignum;
     $bigfloat = $json->decode('2.000000000000000000000000001');
     print $json->encode($bigfloat);
     # => 2.000000000000000000000000001
  
  See to L<JSON::XS/MAPPING> about the normal conversion of JSON number.
  
  =head2 loose
  
      $json = $json->loose([$enable])
  
  The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
  and the module doesn't allow to C<decode> to these (except for \x2f).
  If C<$enable> is true (or missing), then C<decode>  will accept these
  unescaped strings.
  
      $json->loose->decode(qq|["abc
                                     def"]|);
  
  See L<JSON::XS/SSECURITY CONSIDERATIONS>.
  
  =head2 escape_slash
  
      $json = $json->escape_slash([$enable])
  
  According to JSON Grammar, I<slash> (U+002F) is escaped. But default
  JSON::PP (as same as JSON::XS) encodes strings without escaping slash.
  
  If C<$enable> is true (or missing), then C<encode> will escape slashes.
  
  =head2 indent_length
  
      $json = $json->indent_length($length)
  
  JSON::XS indent space length is 3 and cannot be changed.
  JSON::PP set the indent space length with the given $length.
  The default is 3. The acceptable range is 0 to 15.
  
  =head2 sort_by
  
      $json = $json->sort_by($function_name)
      $json = $json->sort_by($subroutine_ref)
  
  If $function_name or $subroutine_ref are set, its sort routine are used
  in encoding JSON objects.
  
     $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     $js = $pc->sort_by('own_sort')->encode($obj);
     # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);
  
     sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }
  
  As the sorting routine runs in the JSON::PP scope, the given
  subroutine name and the special variables C<$a>, C<$b> will begin
  'JSON::PP::'.
  
  If $integer is set, then the effect is same as C<canonical> on.
  
  =head1 INTERNAL
  
  For developers.
  
  =over
  
  =item PP_encode_box
  
  Returns
  
          {
              depth        => $depth,
              indent_count => $indent_count,
          }
  
  
  =item PP_decode_box
  
  Returns
  
          {
              text    => $text,
              at      => $at,
              ch      => $ch,
              len     => $len,
              depth   => $depth,
              encoding      => $encoding,
              is_valid_utf8 => $is_valid_utf8,
          };
  
  =back
  
  =head1 MAPPING
  
  This section is copied from JSON::XS and modified to C<JSON::PP>.
  JSON::XS and JSON::PP mapping mechanisms are almost equivalent.
  
  See to L<JSON::XS/MAPPING>.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, C<JSON> will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, C<JSON> only guarantees precision up to but not including
  the least significant bit.
  
  When C<allow_bignum> is enable, the big integers 
  and the numeric can be optionally converted into L<Math::BigInt> and
  L<Math::BigFloat> objects.
  
  =item true, false
  
  These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
     print JSON::PP::true . "\n";
      => true
     print JSON::PP::true + 1;
      => 1
  
     ok(JSON::true eq  '1');
     ok(JSON::true == 1);
  
  C<JSON> will install these missing overloading features to the backend modules.
  
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  C<JSON::PP::null> returns C<undef>.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent ordering
  in hash keys (or JSON objects), they will usually be encoded in a
  pseudo-random order that can change between runs of the same program but
  stays generally the same within a single run of a program. C<JSON>
  optionally sort the hash keys (determined by the I<canonical> flag), so
  the same data structure will serialise to the same JSON text (given same
  settings and version of JSON::XS), but this incurs a runtime overhead
  and is only rarely useful, e.g. when you want to compare some JSON text
  against another for equality.
  
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     to_json [\0,JSON::PP::true]      # yields [false,true]
  
  =item JSON::PP::true, JSON::PP::false, JSON::PP::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  JSON::PP::null returns C<undef>.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON. See the
  C<allow_blessed> and C<convert_blessed> methods on various options on
  how to deal with this: basically, you can choose between throwing an
  exception, encoding the reference as if it weren't blessed, or provide
  your own serialiser method.
  
  See to L<convert_blessed>.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways.
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =item Big Number
  
  When C<allow_bignum> is enable, 
  C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
  objects into JSON numbers.
  
  
  =back
  
  =head1 UNICODE HANDLING ON PERLS
  
  If you do not know about Unicode on Perl well,
  please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.
  
  =head2 Perl 5.8 and later
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work properly.
  
      $json->allow_nonref->encode(chr hex 3042);
      $json->allow_nonref->encode(chr hex 12345);
  
  Returns C<"\u3042"> and C<"\ud808\udf45"> respectively.
  
      $json->allow_nonref->decode('"\u3042"');
      $json->allow_nonref->decode('"\ud808\udf45"');
  
  Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.
  
  Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
  so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.
  
  
  =head2 Perl 5.6
  
  Perl can handle Unicode and the JSON::PP de/encode methods also work.
  
  =head2 Perl 5.005
  
  Perl 5.005 is a byte semantics world -- all strings are sequences of bytes.
  That means the unicode handling is not available.
  
  In encoding,
  
      $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
      $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.
  
  Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
  as C<$value % 256>, so the above codes are equivalent to :
  
      $json->allow_nonref->encode(chr 66);
      $json->allow_nonref->encode(chr 69);
  
  In decoding,
  
      $json->decode('"\u00e3\u0081\u0082"');
  
  The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
  japanese character (C<HIRAGANA LETTER A>).
  And if it is represented in Unicode code point, C<U+3042>.
  
  Next, 
  
      $json->decode('"\u3042"');
  
  We ordinary expect the returned value is a Unicode character C<U+3042>.
  But here is 5.005 world. This is C<0xE3 0x81 0x82>.
  
      $json->decode('"\ud808\udf45"');
  
  This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.
  
  
  =head1 TODO
  
  =over
  
  =item speed
  
  =item memory saving
  
  =back
  
  
  =head1 SEE ALSO
  
  Most of the document are copied and modified from JSON::XS doc.
  
  L<JSON::XS>
  
  RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  =head1 NAME
  
  JSON::PP::Boolean - dummy module providing JSON::PP::Boolean
  
  =head1 SYNOPSIS
  
   # do not "use" yourself
  
  =head1 DESCRIPTION
  
  This module exists only to provide overload resolution for Storable
  and similar modules. See L<JSON::PP> for more info about this class.
  
  =cut
  
  use JSON::backportPP ();
  use strict;
  
  1;
  
  =head1 AUTHOR
  
  This idea is from L<JSON::XS::Boolean> written by
  Marc Lehmann <schmorp[at]schmorp.de>
  
  =cut
  
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package # This is JSON::backportPP
      JSON::backportPP5005;
  
  use 5.005;
  use strict;
  
  my @properties;
  
  $JSON::PP5005::VERSION = '1.10';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          0; # It is considered that UTF8 flag off for Perl 5.005.
      }
  
      sub utf8::upgrade {
      }
  
      sub utf8::downgrade {
          1; # must always return true.
      }
  
      sub utf8::encode  {
      }
  
      sub utf8::decode {
      }
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
  
      # missing in B module.
      sub B::SVp_IOK () { 0x01000000; }
      sub B::SVp_NOK () { 0x02000000; }
      sub B::SVp_POK () { 0x04000000; }
  
      $INC{'bytes.pm'} = 1; # dummy
  }
  
  
  
  sub _encode_ascii {
      join('', map { $_ <= 127 ? chr($_) : sprintf('\u%04x', $_) } unpack('C*', $_[0]) );
  }
  
  
  sub _encode_latin1 {
      join('', map { chr($_) } unpack('C*', $_[0]) );
  }
  
  
  sub _decode_surrogates { # from http://homepage1.nifty.com/nomenclator/unicode/ucs_utf.htm
      my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00); # from perlunicode
      my $bit = unpack('B32', pack('N', $uni));
  
      if ( $bit =~ /^00000000000(...)(......)(......)(......)$/ ) {
          my ($w, $x, $y, $z) = ($1, $2, $3, $4);
          return pack('B*', sprintf('11110%s10%s10%s10%s', $w, $x, $y, $z));
      }
      else {
          Carp::croak("Invalid surrogate pair");
      }
  }
  
  
  sub _decode_unicode {
      my ($u) = @_;
      my ($utf8bit);
  
      if ( $u =~ /^00([89a-f][0-9a-f])$/i ) { # 0x80-0xff
           return pack( 'H2', $1 );
      }
  
      my $bit = unpack("B*", pack("H*", $u));
  
      if ( $bit =~ /^00000(.....)(......)$/ ) {
          $utf8bit = sprintf('110%s10%s', $1, $2);
      }
      elsif ( $bit =~ /^(....)(......)(......)$/ ) {
          $utf8bit = sprintf('1110%s10%s10%s', $1, $2, $3);
      }
      else {
          Carp::croak("Invalid escaped unicode");
      }
  
      return pack('B*', $utf8bit);
  }
  
  
  sub JSON::PP::incr_text {
      $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
      if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
          Carp::croak("incr_text can not be called when the incremental parser already started parsing");
      }
  
      $_[0]->{_incr_parser}->{incr_text} = $_[1] if ( @_ > 1 );
      $_[0]->{_incr_parser}->{incr_text};
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP5005 - Helper module in using JSON::PP in Perl 5.005
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package # This is JSON::backportPP
      JSON::backportPP56;
  
  use 5.006;
  use strict;
  
  my @properties;
  
  $JSON::PP56::VERSION = '1.08';
  
  BEGIN {
  
      sub utf8::is_utf8 {
          my $len =  length $_[0]; # char length
          {
              use bytes; #  byte length;
              return $len != length $_[0]; # if !=, UTF8-flagged on.
          }
      }
  
  
      sub utf8::upgrade {
          ; # noop;
      }
  
  
      sub utf8::downgrade ($;$) {
          return 1 unless ( utf8::is_utf8( $_[0] ) );
  
          if ( _is_valid_utf8( $_[0] ) ) {
              my $downgrade;
              for my $c ( unpack( "U*", $_[0] ) ) {
                  if ( $c < 256 ) {
                      $downgrade .= pack("C", $c);
                  }
                  else {
                      $downgrade .= pack("U", $c);
                  }
              }
              $_[0] = $downgrade;
              return 1;
          }
          else {
              Carp::croak("Wide character in subroutine entry") unless ( $_[1] );
              0;
          }
      }
  
  
      sub utf8::encode ($) { # UTF8 flag off
          if ( utf8::is_utf8( $_[0] ) ) {
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
          else {
              $_[0] = pack( "U*", unpack( "C*", $_[0] ) );
              $_[0] = pack( "C*", unpack( "C*", $_[0] ) );
          }
      }
  
  
      sub utf8::decode ($) { # UTF8 flag on
          if ( _is_valid_utf8( $_[0] ) ) {
              utf8::downgrade( $_[0] );
              $_[0] = pack( "U*", unpack( "U*", $_[0] ) );
          }
      }
  
  
      *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
      *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
      *JSON::PP::JSON_PP_decode_surrogates = \&JSON::PP::_decode_surrogates;
      *JSON::PP::JSON_PP_decode_unicode    = \&JSON::PP::_decode_unicode;
  
      unless ( defined &B::SVp_NOK ) { # missing in B module.
          eval q{ sub B::SVp_NOK () { 0x02000000; } };
      }
  
  }
  
  
  
  sub _encode_ascii {
      join('',
          map {
              $_ <= 127 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _encode_latin1 {
      join('',
          map {
              $_ <= 255 ?
                  chr($_) :
              $_ <= 65535 ?
                  sprintf('\u%04x', $_) : sprintf('\u%x\u%x', JSON::PP::_encode_surrogates($_));
          } _unpack_emu($_[0])
      );
  }
  
  
  sub _unpack_emu { # for Perl 5.6 unpack warnings
      return   !utf8::is_utf8($_[0]) ? unpack('C*', $_[0]) 
             : _is_valid_utf8($_[0]) ? unpack('U*', $_[0])
             : unpack('C*', $_[0]);
  }
  
  
  sub _is_valid_utf8 {
      my $str = $_[0];
      my $is_utf8;
  
      while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg)
      {
          if (defined $1) {
              $is_utf8 = 1 if (!defined $is_utf8);
          }
          else {
              $is_utf8 = 0 if (!defined $is_utf8);
              if ($is_utf8) { # eventually, not utf8
                  return;
              }
          }
      }
  
      return $is_utf8;
  }
  
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  JSON::PP56 - Helper module in using JSON::PP in Perl 5.6
  
  =head1 DESCRIPTION
  
  JSON::PP calls internally.
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2007-2012 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"Method/Generate/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use strictures 1;
  use Moo::_Utils;
  use base qw(Moo::Object);
  use Sub::Quote;
  use B 'perlstring';
  use Scalar::Util 'blessed';
  use overload ();
  use Module::Runtime qw(use_module);
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
    our $CAN_HAZ_XS_PRED =
      $CAN_HAZ_XS &&
      (eval { Class::XSAccessor->VERSION('1.17') })
    ;
  }
  
  sub _SIGDIE
  {
    our ($CurrentAttribute, $OrigSigDie);
    my $sigdie = $OrigSigDie && $OrigSigDie != \&_SIGDIE
      ? $OrigSigDie
      : sub { die $_[0] };
  
    return $sigdie->(@_) if ref($_[0]);
  
    my $attr_desc = _attr_desc(@$CurrentAttribute{qw(name init_arg)});
    $sigdie->("$CurrentAttribute->{step} for $attr_desc failed: $_[0]");
  }
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    die "You cannot overwrite a locally defined method ($method) with @{[ $type || 'an accessor' ]}";
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      die "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ /\A[A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)*\z/;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
  
    for my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (!defined $spec->{default} || ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name", 'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      for my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${reader}")}{CODE};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${accessor}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${writer}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${pred}")}{CODE};
      if (our $CAN_HAZ_XS && our $CAN_HAZ_XS_PRED) {
        $methods{$pred} = $self->_generate_xs(
          exists_predicates => $into, $pred, $name, $spec
        );
      } else {
        $methods{$pred} =
          quote_sub "${into}::${pred}" =>
            '    '.$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
          ;
      }
    }
    if (my $pred = $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $spec->{builder_sub} );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${cl}")}{CODE};
      $methods{$cl} =
        quote_sub "${into}::${cl}" =>
          $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], use_module('Moo::Role')->methods_provided_by(use_module($hspec))
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && *{_getglob("${into}::${proxy}")}{CODE};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
  
  
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" => $self->_generate_asserter($name, $spec),
          delete $self->{captures}
        ;
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and ($spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\perlstring $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\perlstring $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa}
      ? "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n");
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
        : perlstring $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->_generate_simple_get(@args);
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $value_store = '$_[0]';
      my $code;
      if ($coerce) {
        $value_store = '$value';
        $code = "do { my (\$self, \$value) = \@_;\n"
          ."        \$value = "
          .$self->_generate_coerce($name, $value_store, $coerce).";\n";
      }
      else {
        $code = "do { my \$self = shift;\n";
      }
      if ($isa_check) {
        $code .=
          "        ".$self->_generate_isa_check($name, $value_store, $isa_check).";\n";
      }
      my $simple = $self->_generate_simple_set('$self', $name, $spec, $value_store);
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', $value_store, $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        $value_store;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return perlstring($name) if !defined($init_arg) or $init_arg eq $name;
    return perlstring($name).' (constructor argument: '.perlstring($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce)
    );
  }
  
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_die_prefix {
    my ($self, $name, $prefix, $arg, $inside) = @_;
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'
    .'    init_arg => '.(defined $arg ? B::perlstring($arg) : 'undef') . ",\n"
    .'    name     => '.B::perlstring($name).",\n"
    .'    step     => '.B::perlstring($prefix).",\n"
    ."  };\n"
    .'  local $Method::Generate::Accessor::OrigSigDie = $SIG{__DIE__};'."\n"
    .'  local $SIG{__DIE__} = \&Method::Generate::Accessor::_SIGDIE;'."\n"
    .$inside
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_}.$self->_sanitize_name($name);
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify(
          $code, $values, Sub::Quote::capture_unroll($cap_name, $captures, 6), $local
        );
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_}.$self->_sanitize_name($name);
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub _sanitize_name {
    my ($self, $name) = @_;
    $name =~ s/([_\W])/sprintf('_%x', ord($1))/ge;
    $name;
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $name, $spec
                        );
      my $get_value =
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ($spec->{coerce}) {
        $get_value = $self->_generate_coerce(
          $name, $get_value,
          $spec->{coerce}, $init_arg
        )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}, $init_arg
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name, $spec),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $source,
              $spec->{coerce}, $init_arg
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}, $init_arg
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name, $spec),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      #Internals::SetReadWrite($foo);
      #Scalar::Util::weaken ($foo);
      #Internals::SetReadOnly($foo);
      #
      # but requires XS and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : $weak_simple;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
  
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  unless (".$self->_generate_simple_has('$_[0]', $name, $spec).") {\n"
     .qq!    die "Attempted to access '${name}' but it is not set";\n!
     ."  }\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using perlstring
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
    my $invalid = "Invalid $setting '" . overload::StrVal($value)
      . "' for $into not a coderef";
    $invalid .= " $appended" if $appended;
  
    unless (ref $value and (ref $value eq 'CODE' or blessed($value))) {
      die "$invalid or code-convertible object";
    }
  
    unless (eval { \&$value }) {
      die "$invalid and could not be converted to a coderef: $@";
    }
  
    1;
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B 'perlstring';
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @builds;
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use strictures 1;
  use Sub::Quote;
  use base qw(Moo::Object);
  use Sub::Defer;
  use B 'perlstring';
  use Moo::_Utils qw(_getstash);
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    my $specs = $self->{attribute_specs}||={};
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        die "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        foreach my $key (keys %$old_spec) {
          if (!exists $new_spec->{$key}) {
            $new_spec->{$key} = $old_spec->{$key}
              unless $key eq 'handles';
          }
          elsif ($key eq 'moosify') {
            $new_spec->{$key} = [
              map { ref $_ eq 'ARRAY' ? @$_ : $_ }
                ($old_spec->{$key}, $new_spec->{$key})
            ];
          }
        }
      }
      if (exists $new_spec->{init_arg} && !defined $new_spec->{init_arg}
          && $new_spec->{required}) {
        die "${name} attribute can't be required with init_arg => undef";
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub buildall_generator {
    require Method::Generate::BuildAll;
    Method::Generate::BuildAll->new;
  }
  
  sub _build_construction_string {
    my ($self) = @_;
    my $builder = $self->{construction_builder};
    $builder ? $self->$builder
      : 'bless('
      .$self->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    my $package = $self->{package};
    defer_sub "${package}::new" => sub {
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      $body .= $self->buildall_generator->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.perlstring($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg_key = perlstring($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $test{$_},
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my %s = %{$spec->{$_}}; # ignore required if default or builder set
          $s{required} and not($s{builder} or $s{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, qw('
      .join(' ',@required_init).')) {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  use Moo;
  Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    construction_builder => { is => 'lazy' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'ro' },
  );
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B qw(perlstring);
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL(Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'METHOD_INLINER';
  package Method::Inliner;
  
  use strictures 1;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
  	$fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;
  use strict;
  use warnings;
  use Cwd;
  use Carp ();
  use Module::CPANfile::Environment;
  use Module::CPANfile::Result;
  
  our $VERSION = '1.0002';
  
  sub new {
      my($class, $file) = @_;
      bless {}, $class;
  }
  
  sub load {
      my($proto, $file) = @_;
  
      my $self = ref $proto ? $proto : $proto->new;
      $self->parse($file || Cwd::abs_path('cpanfile'));
      $self;
  }
  
  sub save {
      my($self, $path) = @_;
  
      open my $out, ">", $path or die "$path: $!";
      print {$out} $self->to_string;
  }
  
  sub parse {
      my($self, $file) = @_;
  
      my $code = do {
          open my $fh, "<", $file or die "$file: $!";
          join '', <$fh>;
      };
  
      my $env = Module::CPANfile::Environment->new($file);
      $self->{result} = $env->parse($code) or die $@;
  }
  
  sub from_prereqs {
      my($proto, $prereqs) = @_;
  
      my $self = $proto->new;
      $self->{result} = Module::CPANfile::Result->from_prereqs($prereqs);
  
      $self;
  }
  
  sub features {
      my $self = shift;
      map $self->feature($_), keys %{$self->{result}{features}};
  }
  
  sub feature {
      my($self, $identifier) = @_;
  
      my $data = $self->{result}{features}{$identifier}
        or Carp::croak("Unknown feature '$identifier'");
  
      require CPAN::Meta::Feature;
      CPAN::Meta::Feature->new($data->{identifier}, {
          description => $data->{description},
          prereqs => $data->{spec},
      });
  }
  
  sub prereq { shift->prereqs }
  
  sub prereqs {
      my $self = shift;
      require CPAN::Meta::Prereqs;
      CPAN::Meta::Prereqs->new($self->prereq_specs);
  }
  
  sub effective_prereqs {
      my($self, $features) = @_;
      $self->prereqs_with(@{$features || []});
  }
  
  sub prereqs_with {
      my($self, @feature_identifiers) = @_;
  
      my $prereqs = $self->prereqs;
      my @others = map { $self->feature($_)->prereqs } @feature_identifiers;
  
      $prereqs->with_merged_prereqs(\@others);
  }
  
  sub prereq_specs {
      my $self = shift;
      $self->{result}{spec};
  }
  
  sub merge_meta {
      my($self, $file, $version) = @_;
  
      require CPAN::Meta;
  
      $version ||= $file =~ /\.yml$/ ? '1.4' : '2';
  
      my $prereq = $self->prereqs;
  
      my $meta = CPAN::Meta->load_file($file);
      my $prereqs_hash = $prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;
      my $struct = { %{$meta->as_struct}, prereqs => $prereqs_hash };
  
      CPAN::Meta->new($struct)->save($file, { version => $version });
  }
  
  sub _dump {
      my $str = shift;
      require Data::Dumper;
      chomp(my $value = Data::Dumper->new([$str])->Terse(1)->Dump);
      $value;
  }
  
  sub to_string {
      my($self, $include_empty) = @_;
  
      my $prereqs = $self->{result}{spec};
  
      my $code = '';
      $code .= $self->_dump_prereqs($self->{result}{spec}, $include_empty);
  
      for my $feature (values %{$self->{result}{features}}) {
          $code .= sprintf "feature %s, %s => sub {\n", _dump($feature->{identifier}), _dump($feature->{description});
          $code .= $self->_dump_prereqs($feature->{spec}, $include_empty, 4);
          $code .= "}\n\n";
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  sub _dump_prereqs {
      my($self, $prereqs, $include_empty, $base_indent) = @_;
  
      my $code = '';
      for my $phase (qw(runtime configure build test develop)) {
          my $indent = $phase eq 'runtime' ? '' : '    ';
          $indent = (' ' x ($base_indent || 0)) . $indent;
  
          my($phase_code, $requirements);
          $phase_code .= "on $phase => sub {\n" unless $phase eq 'runtime';
  
          for my $type (qw(requires recommends suggests conflicts)) {
              for my $mod (sort keys %{$prereqs->{$phase}{$type}}) {
                  my $ver = $prereqs->{$phase}{$type}{$mod};
                  $phase_code .= $ver eq '0'
                               ? "${indent}$type '$mod';\n"
                               : "${indent}$type '$mod', '$ver';\n";
                  $requirements++;
              }
          }
  
          $phase_code .= "\n" unless $requirements;
          $phase_code .= "};\n" unless $phase eq 'runtime';
  
          $code .= $phase_code . "\n" if $requirements or $include_empty;
      }
  
      $code =~ s/\n+$/\n/s;
      $code;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Module::CPANfile - Parse cpanfile
  
  =head1 SYNOPSIS
  
    use Module::CPANfile;
  
    my $file = Module::CPANfile->load("cpanfile");
    my $prereqs = $file->prereqs; # CPAN::Meta::Prereqs object
  
    my @features = $file->features; # CPAN::Meta::Feature objects
    my $merged_prereqs = $file->prereqs_with(@identifiers); # CPAN::Meta::Prereqs
  
    $file->merge_meta('MYMETA.json');
  
  =head1 DESCRIPTION
  
  Module::CPANfile is a tool to handle L<cpanfile> format to load application
  specific dependencies, not just for CPAN distributions.
  
  =head1 METHODS
  
  =over 4
  
  =item load
  
    $file = Module::CPANfile->load;
    $file = Module::CPANfile->load('cpanfile');
  
  Load and parse a cpanfile. By default it tries to load C<cpanfile> in
  the current directory, unless you pass the path to its argument.
  
  =item from_prereqs
  
    $file = Module::CPANfile->from_prereqs({
      runtime => { requires => { DBI => '1.000' } },
    });
  
  Creates a new Module::CPANfile object from prereqs hash you can get
  via L<CPAN::Meta>'s C<prereqs>, or L<CPAN::Meta::Prereqs>'
  C<as_string_hash>.
  
    # read MYMETA, then feed the prereqs to create Module::CPANfile
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
  
    # load cpanfile, then recreate it with round-trip
    my $file = Module::CPANfile->load('cpanfile');
    $file = Module::CPANfile->from_prereqs($file->prereq_specs);
                                      # or $file->prereqs->as_string_hash
  
  =item prereqs
  
  Returns L<CPAN::Meta::Prereqs> object out of the parsed cpanfile.
  
  =item prereq_specs
  
  Returns a hash reference that should be passed to C<< CPAN::Meta::Prereqs->new >>.
  
  =item features
  
  Returns a list of features available in the cpanfile as L<CPAN::Meta::Feature>.
  
  =item prereqs_with(@identifiers), effective_prereqs(\@identifiers)
  
  Returns L<CPAN::Meta::Prereqs> object, with merged prereqs for
  features identified with the C<@identifiers>.
  
  =item to_string($include_empty)
  
    $file->to_string;
    $file->to_string(1);
  
  Returns a canonical string (code) representation for cpanfile. Useful
  if you want to convert L<CPAN::Meta::Prereqs> to a new cpanfile.
  
    # read MYMETA's prereqs and print cpanfile representation of it
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    print $file->to_sring;
  
  By default, it omits the phase where there're no modules
  registered. If you pass the argument of a true value, it will print
  them as well.
  
  =item save
  
    $file->save('cpanfile');
  
  Saves the currently loaded prereqs as a new C<cpanfile> by calling
  C<to_string>. Beware B<this method will overwrite the existing
  cpanfile without any warning or backup>. Taking a backup or giving
  warnings to users is a caller's responsibility.
  
    # Read MYMETA.json and creates a new cpanfile
    my $meta = CPAN::Meta->load_file('MYMETA.json');
    my $file = Module::CPANfile->from_prereqs($meta->prereqs);
    $file->save('cpanfile');
  
  =item merge_meta
  
    $file->merge_meta('META.yml');
    $file->merge_meta('MYMETA.json', '2.0');
  
  Merge the effective prereqs with Meta specification loaded from the
  given META file, using CPAN::Meta. You can specify the META spec
  version in the second argument, which defaults to 1.4 in case the
  given file is YAML, and 2 if it is JSON.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<cpanfile>, L<CPAN::Meta>, L<CPAN::Meta::Spec>
  
  =cut
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;
  use strict;
  use warnings;
  use Module::CPANfile::Result;
  use Carp ();
  
  my @bindings = qw(
      on requires recommends suggests conflicts
      feature
      osname
      configure_requires build_requires test_requires author_requires
  );
  
  my $file_id = 1;
  
  sub new {
      my($class, $file) = @_;
      bless {
          file => $file,
      }, $class;
  }
  
  sub bind {
      my $class = shift;
      my $pkg = caller;
  
      my $result = Module::CPANfile::Result->new;
      for my $binding (@bindings) {
          no strict 'refs';
          *{"$pkg\::$binding"} = sub { $result->$binding(@_) };
      }
  
      return $result;
  }
  
  sub parse {
      my($self, $code) = @_;
  
      my($res, $err);
  
      {
          local $@;
          $file_id++;
          $res = eval <<EVAL;
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  my \$_result;
  BEGIN { \$_result = Module::CPANfile::Environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  
  \$_result;
  EVAL
          $err = $@;
      }
  
      if ($err) { die "Parsing $self->{file} failed: $err" };
  
      return $res;
  }
  
  1;
  
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Result.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_RESULT';
  package Module::CPANfile::Result;
  use strict;
  
  sub from_prereqs {
      my($class, $spec) = @_;
      bless {
          phase => 'runtime',
          spec => $spec,
      }, $class;
  }
  
  sub new {
      bless {
          phase => 'runtime', # default phase
          features => {},
          feature => undef,
          spec  => {},
      }, shift;
  }
  
  sub on {
      my($self, $phase, $code) = @_;
      local $self->{phase} = $phase;
      $code->()
  }
  
  sub feature {
      my($self, $identifier, $description, $code) = @_;
  
      # shortcut: feature identifier => sub { ... }
      if (@_ == 3 && ref($description) eq 'CODE') {
          $code = $description;
          $description = $identifier;
      }
  
      unless (ref $description eq '' && ref $code eq 'CODE') {
          Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }");
      }
  
      local $self->{feature} = $self->{features}{$identifier}
        = { identifier => $identifier, description => $description, spec => {} };
      $code->();
  }
  
  sub osname { die "TODO" }
  
  sub requires {
      my($self, $module, $requirement) = @_;
      ($self->{feature} ? $self->{feature}{spec} : $self->{spec})
        ->{$self->{phase}}{requires}{$module} = $requirement || 0;
  }
  
  sub recommends {
      my($self, $module, $requirement) = @_;
      ($self->{feature} ? $self->{feature}{spec} : $self->{spec})
        ->{$self->{phase}}{recommends}{$module} = $requirement || 0;
  }
  
  sub suggests {
      my($self, $module, $requirement) = @_;
      ($self->{feature} ? $self->{feature}{spec} : $self->{spec})
        ->{$self->{phase}}{suggests}{$module} = $requirement || 0;
  }
  
  sub conflicts {
      my($self, $module, $requirement) = @_;
      ($self->{feature} ? $self->{feature}{spec} : $self->{spec})
        ->{$self->{phase}}{conflicts}{$module} = $requirement || 0;
  }
  
  # Module::Install compatible shortcuts
  
  sub configure_requires {
      my($self, @args) = @_;
      $self->on(configure => sub { $self->requires(@args) });
  }
  
  sub build_requires {
      my($self, @args) = @_;
      $self->on(build => sub { $self->requires(@args) });
  }
  
  sub test_requires {
      my($self, @args) = @_;
      $self->on(test => sub { $self->requires(@args) });
  }
  
  sub author_requires {
      my($self, @args) = @_;
      $self->on(develop => sub { $self->requires(@args) });
  }
  
  1;
MODULE_CPANFILE_RESULT

$fatpacked{"Module/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_READER';
  package Module::Reader;
  BEGIN { require 5.006 }
  use strict;
  use warnings;
  
  our $VERSION = '0.002001';
  $VERSION = eval $VERSION;
  
  use base 'Exporter';
  our @EXPORT_OK = qw(module_content module_handle);
  our %EXPORT_TAGS = (all => [@EXPORT_OK]);
  
  use File::Spec;
  use Scalar::Util qw(blessed reftype openhandle);
  use Carp;
  use constant _OPEN_STRING => $] >= 5.008;
  BEGIN {
      require IO::String
          if !_OPEN_STRING;
  }
  
  sub module_content {
      my $module = _get_module(@_);
      if (ref $module) {
          local $/;
          return scalar <$module>;
      }
      else {
          return $module;
      }
  }
  
  sub module_handle {
      my $module = _get_module(@_);
      if (ref $module) {
          return $module;
      }
      elsif (_OPEN_STRING) {
          open my $fh, '<', \$module;
          return $fh;
      }
      else {
          return IO::String->new($module);
      }
  }
  
  sub _get_module {
      my ($package, @inc) = @_;
      (my $module = "$package.pm") =~ s{::}{/}g;
      my $opts = ref $_[-1] && ref $_[-1] eq 'HASH' && pop @inc || {};
      if (!@inc) {
          @inc = @INC;
      }
      if (my $found = $opts->{found}) {
          if (my $full_module = $found->{$module}) {
              if (ref $full_module) {
                  @inc = $full_module;
              }
              elsif (-f $full_module) {
                  open my $fh, '<', $full_module
                      or die "Couldn't open ${full_module} for ${module}: $!";
                  return $fh;
              }
          }
      }
      for my $inc (@inc) {
          if (!ref $inc) {
              my $full_module = File::Spec->catfile($inc, $module);
              next unless -f $full_module;
              open my $fh, '<', $full_module
                  or die "Couldn't open ${full_module} for ${module}: $!";
              return $fh;
          }
  
          my @cb = ref $inc eq 'ARRAY'  ? $inc->[0]->($inc, $module)
                 : blessed $inc         ? $inc->INC($module)
                                        : $inc->($inc, $module);
  
          next
              unless ref $cb[0];
          my $fh;
          if (reftype $cb[0] eq 'GLOB' && openhandle $cb[0]) {
              $fh = shift @cb;
          }
  
          if (ref $cb[0] eq 'CODE') {
              my $cb = shift @cb;
              # require docs are wrong, perl sends 0 as the first param
              my @params = (0, @cb ? $cb[0] : ());
  
              my $module = '';
              while (1) {
                  local $_ = $fh ? <$fh> : '';
                  $_ = ''
                      if !defined;
                  last if !$cb->(@params);
                  $module .= $_;
              }
              return $module;
          }
          elsif ($fh) {
              return $fh;
          }
      }
      croak "Can't find module $module";
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Module::Reader - Read the source of a module like perl does
  
  =head1 SYNOPSIS
  
      use Module::Reader qw(:all);
      my $io = module_handle('My::Module');
      my $content = module_content('My::Module');
      
      my $io = module_handle('My::Module', @search_dirs);
      
      my $io = module_handle('My::Module', @search_dirs, { found => \%INC });
  
  =head1 DESCRIPTION
  
  Reads the content of perl modules the same way perl does.  This
  includes reading modules available only by L<@INC hooks|perlfunc/require>, or filtered
  through them.
  
  =head1 EXPORTS
  
  =head2 module_handle( $module_name, @search_dirs, \%options )
  
  Returns an IO handle to the given module.  Searches the directories
  specified, or L<@INC|perlvar/@INC> if none are.
  
  =head3 Options
  
  =over 4
  
  =item found
  
  A reference to a hash like L<%INC|perlvar/%INC> with module file names (in the
  style 'F<My/Module.pm>') as keys and full file paths as values.
  Modules listed in this will be used in preference to searching
  through directories.
  
  =back
  
  =head2 module_content( $module_name, @search_dirs, \%options )
  
  Returns the content of the given module.  Accepts the same options as C<module_handle>.
  
  =head1 AUTHOR
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head2 CONTRIBUTORS
  
  None yet.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2013 the Module::Reader L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
MODULE_READER

$fatpacked{"Module/Runtime.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same syntax
  that is used for barewords in Perl source.  In principle this syntax
  can vary between versions of Perl, and this module applies the syntax of
  the Perl on which it is running.  In practice the usable syntax hasn't
  changed yet.  There's some intent for Unicode module names to be supported
  in the future, but this hasn't yet amounted to any consistent facility.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.19.8.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.014";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = CORE::require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(CORE::require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and later improved in version
  2.20, and on both occasions this function changed to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	my $fn = module_notional_filename($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		($@ !~ /\ACan't locate \Q$fn\E .+ at \Q@{[__FILE__]}\E line/s ||
  		 $@ =~ /^Compilation\ failed\ in\ require
  			 \ at\ \Q@{[__FILE__]}\E\ line/xm);
  	$name->VERSION($version) if @_ >= 2;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 BUGS
  
  On Perl versions 5.7.2 to 5.8.8, if C<require> is overridden by the
  C<CORE::GLOBAL> mechanism, it is likely to break the heuristics used by
  L</use_package_optimistically>, making it signal an error for a missing
  module rather than assume that it was already loaded.  From Perl 5.8.9
  onwards, and on 5.7.1 and earlier, this module can avoid being confused
  by such an override.  On the affected versions, a C<require> override
  might be installed by L<Lexical::SealRequireHints>, if something requires
  its bugfix but for some reason its XS implementation isn't available.
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012, 2014
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO';
  package Moo;
  
  use strictures 1;
  use Moo::_Utils;
  use B 'perlstring';
  use Sub::Defer ();
  use Import::Into;
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    _set_loaded(caller);
    strictures->import::into(1);
    if ($Role::Tiny::INFO{$target} and $Role::Tiny::INFO{$target}{is_role}) {
      die "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        # Note that when multiple attributes specified, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    my $stash = _getstash($target);
    my @not_methods = map { *$_{CODE}||() } grep !ref($_), values %$stash;
    @{$MAKERS{$target}{not_methods}={}}{@not_methods} = @not_methods;
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{"Role/Tiny.pm"} && $Role::Tiny::INFO{$superclass}) {
        require Carp;
        Carp::croak("Can't extend role '$superclass'");
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    no warnings 'once'; # piss off. -- mst
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              if (my $defer_target =
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target, $select_super) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
      require Sub::Defer;
      my ($moo_constructor, $con);
  
      if ($select_super && $MAKERS{$select_super}) {
        $moo_constructor = 1;
        $con = $MAKERS{$select_super}{constructor};
      } else {
        my $t_new = $target->can('new');
        if ($t_new) {
          if ($t_new == Moo::Object->can('new')) {
            $moo_constructor = 1;
          } elsif (my $defer_target = (Sub::Defer::defer_info($t_new)||[])->[0]) {
            my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
            if ($MAKERS{$pkg}) {
              $moo_constructor = 1;
              $con = $MAKERS{$pkg}{constructor};
            }
          }
        } else {
          $moo_constructor = 1; # no other constructor, make a Moo one
        }
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(
          package => $target,
          accessor_generator => $class->_accessor_maker_for($target),
          $moo_constructor ? (
            $con ? (construction_string => $con->construction_string) : ()
          ) : (
            construction_builder => sub {
              '$class->'.$target.'::SUPER::new('
                .($target->can('FOREIGNBUILDARGS') ?
                  '$class->FOREIGNBUILDARGS(@_)' : '@_')
                .')'
            },
          ),
          subconstructor_handler => (
            '      if ($Moo::MAKERS{$class}) {'."\n"
            .'        '.$class.'->_constructor_maker_for($class,'.perlstring($target).');'."\n"
            .'        return $class->new(@_)'.";\n"
            .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
            .'        return $meta->new_object($class->BUILDARGS(@_));'."\n"
            .'      }'."\n"
          ),
        )
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  sub _concrete_methods_of {
    my ($me, $role) = @_;
    my $makers = $MAKERS{$role};
    # grab role symbol table
    my $stash = _getstash($role);
    # reverse so our keys become the values (captured coderefs) in case
    # they got copied or re-used since
    my $not_methods = { reverse %{$makers->{not_methods}||{}} };
    +{
      # grab all code entries that aren't in the not_methods list
      map {
        my $code = *{$stash->{$_}}{CODE};
        ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
      } grep !ref($stash->{$_}), keys %$stash
    };
  }
  
  1;
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
   use namespace::clean;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
   );
  
   has pounds => (
     is  => 'rw',
     isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  And elsewhere:
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  This module is an extremely light-weight subset of L<Moose> optimised for
  rapid startup and "pay only for what you use".
  
  It also avoids depending on any XS modules to allow simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite -- two
  thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead of provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  However, sometimes you're writing a command line script or a CGI script
  where fast startup is essential, or code designed to be deployed as a single
  file via L<App::FatPacker>, or you're writing a CPAN module and you want it
  to be usable by people with those constraints.
  
  I've tried several times to use L<Mouse> but it's 3x the size of Moo and
  takes longer to load than most of my Moo based CGI scripts take to run.
  
  If you don't want L<Moose>, you don't want "less metaprotocol" like L<Mouse>,
  you want "as little as possible" -- which means "no metaprotocol", which is
  what Moo provides.
  
  Better still, if you install and load L<Moose>, we set up metaclasses for your
  L<Moo> classes and L<Moo::Role> roles, so you can use them in L<Moose> code
  without ever noticing that some of your codebase is using L<Moo>.
  
  Hence, Moo exists as its name -- Minimal Object Orientation -- with a pledge
  to make it smooth to upgrade to L<Moose> when you need more than minimal
  features.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without anybody ever noticing you aren't using
  L<Moose> everywhere.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  classes and roles, so that C<< isa => 'MyClass' >> and C<< isa => 'MyRole' >>
  work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  So will extending a L<Mouse> class or consuming a L<Mouse::Role> - but note
  that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you want types to be upgraded to the L<Moose> types, use
  L<MooX::Types::MooseLike> and install the L<MooseX::Types> library to
  match the L<MooX::Types::MooseLike> library you're using - L<Moo> will
  load the L<MooseX::Types> library and use that type for the newly created
  metaclass.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  currently global and turns the mechanism off entirely so don't put this
  in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it
  will be used to generate simple accessors, readers, and writers for
  a speed boost.  Simple accessors are those without lazy defaults,
  type checks/coercions, or triggers.  Readers and writers generated
  by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   sub BUILDARGS {
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return { @args };
   };
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as C<BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares base class. Multiple superclasses can be passed for multiple
  inheritance (but please use roles instead).  The class will be loaded, however
  no errors will be triggered if it can't be found and there are already subs in
  the class.
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
  
  or
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles have conflicting methods.  The
  roles will be loaded using the same mechansim as C<extends> uses.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
   package Foo;
   use Moo;
   has 'attr' => (
     is => 'ro'
   );
  
   package Bar;
   use Moo;
   extends 'Foo';
   has '+attr' => (
     default => sub { "blah" },
   );
  
  Using the C<+> notation, it's possible to override an attribute.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * is
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> generates an accessor that dies if you attempt to write to it - i.e.
  a getter only - by defaulting C<reader> to the name of the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> generates a reader like C<ro>, but also sets C<writer> to
  C<_set_${attribute_name}> for attributes that are designed to be written
  from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> generates a normal getter/setter by defaulting C<accessor> to the
  name of the attribute.
  
  =item * isa
  
  Takes a coderef which is meant to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   isa => sub {
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  Note that the return value is ignored, only whether the sub lives or
  dies matters.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<MooseX::Types> style named types, look at
  L<MooX::Types::MooseLike>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item * coerce
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] % 2 ? $_[0] : $_[0] + 1
   },
  
  Note that L<Moo> will always fire your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * handles
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a role (L<Moo::Role>) that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. Coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<default>
  
  Takes a coderef which will get called with $self as its only argument
  to populate an attribute if no value is supplied to the constructor - or
  if the attribute is lazy, when the attribute is first retrieved if no
  value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item * C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or <_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on instantiation.
  
  =item * C<reader>
  
  The value of this attribute will be the name of the method to get the value of
  the attribute.  If you like Java style methods, you might set this to
  C<get_foo>
  
  =item * C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item * C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened; use this when circular references are possible, which will cause
  leaks.
  
  =item * C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item * C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Sub::Quote;
  
    use Moo;
    use namespace::clean;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo> will not clean up imported subroutines for you; you will have
  to do that manually. The recommended way to do this is to declare your
  imports first, then C<use Moo>, then C<use namespace::clean>.
  Anything imported before L<namespace::clean> will be scrubbed.
  Anything imported or declared after will be still be available.
  
   package Record;
  
   use Digest::MD5 qw(md5_hex);
  
   use Moo;
   use namespace::clean;
  
   has name => (is => 'ro', required => 1);
   has id => (is => 'lazy');
   sub _build_id {
     my ($self) = @_;
     return md5_hex($self->name);
   }
  
   1;
  
  If you were to import C<md5_hex> after L<namespace::clean> you would
  be able to call C<< ->md5_hex() >> on your C<Record> instances (and it
  probably wouldn't do what you expect!).
  
  L<Moo::Role>s behave slightly differently.  Since their methods are
  composed into the consuming class, they can do a little more for you
  automatically.  As long as you declare your imports before calling
  C<use Moo::Role>, those imports and the ones L<Moo::Role> itself
  provides will not be composed into consuming classes, so there's usually
  no need to use L<namespace::clean>.
  
  B<On L<namespace::autoclean>:> If you're coming to Moo from the Moose
  world, you may be accustomed to using L<namespace::autoclean> in all
  your packages. This is not recommended for L<Moo> packages, because
  L<namespace::autoclean> will inflate your class to a full L<Moose>
  class.  It'll work, but you will lose the benefits of L<Moo>.  Instead
  you are recommended to just use L<namespace::clean>.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, just make a library of coderefs, or better yet, functions
  that return quoted subs. L<MooX::Types::MooseLike> provides a similar API
  to L<MooseX::Types::Moose> so that you can write
  
    has days_to_live => (is => 'ro', isa => Int);
  
  and have it work with both; it is hoped that providing only subrefs as an
  API will encourage the use of other type systems as well, since it's
  probably the weakest part of Moose design-wise.
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you wanted
  L<Moose> - Moo succeeds at being small because it explicitly does not
  provide a metaprotocol. However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  C<BUILDARGS> is not triggered if your class does not have any attributes.
  Without attributes, C<BUILDARGS> return value would be ignored, so we just
  skip calling the method instead.
  
  Handling of warnings: when you C<use Moo> we enable FATAL warnings, and some
  several extra pragmas when used in development: L<indirect>,
  L<multidimensional>, and L<bareword::filehandles>.  See the L<strictures>
  documentation for the details on this.
  
  A similar invocation for L<Moose> would be:
  
    use Moose;
    use warnings FATAL => "all";
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
      package MyClass;
      use Moo;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
      package MyClass;
  
      use Moose;
      use MooseX::NonMoose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
      __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#moose@irc.perl.org">(click for instant chatroom login)</a>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#web-simple@irc.perl.org">(click for instant chatroom login)</a>
  
  Bugtracker: L<https://rt.cpan.org/Public/Dist/Display.html?Name=Moo>
  
  Git repository: L<git://github.com/moose/Moo.git>
  
  Git browser: L<https://github.com/moose/Moo>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  bluefeet - Aran Deltac (cpan:BLUEFEET) <bluefeet@gmail.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2011 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/Conflicts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_CONFLICTS';
  package # hide from PAUSE
      Moo::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Moo',
      -conflicts => {
          # enter conflicting downstream deps here, with the version indicating
          # the last *broken* version that *does not work*.
          'HTML::Restrict' => '2.1.5',
      },
  
      # these dists' ::Conflicts modules (if they exist) are also checked for
      # more incompatibilities -- should include all runtime prereqs here.
      -also => [ qw(
          Carp
          Class::Method::Modifiers
          strictures
          Module::Runtime
          Role::Tiny
          Devel::GlobalDestruction
      ) ],
  ;
  
  1;
MOO_CONFLICTS

$fatpacked{"Moo/HandleMoose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  
  use strictures 1;
  use Moo::_Utils;
  use B qw(perlstring);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', do { no warnings 'once'; keys %Moo::MAKERS };
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    for my $spec (values %$attr_specs) {
      if (my $inflators = delete $spec->{moosify}) {
        $_->($spec) for @$inflators;
      }
    }
  
    my %methods
      = %{($am_role ? 'Role::Tiny' : 'Moo')->_concrete_methods_of($name)};
  
    # if stuff gets added afterwards, _maybe_reset_handlemoose should
    # trigger the recreation of the metaclass but we need to ensure the
    # Role::Tiny cache is cleared so we don't confuse Moo itself.
    if (my $info = $Role::Tiny::INFO{$name}) {
      delete $info->{methods};
    }
  
    # needed to ensure the method body is stable and get things named
    Sub::Defer::undefer_sub($_) for grep defined, values %methods;
    my @attrs;
    {
      # This local is completely not required for roles but harmless
      local @{_getstash($name)}{keys %methods};
      my %seen_name;
      foreach my $name (@$attr_order) {
        $seen_name{$name} = 1;
        my %spec = %{$attr_specs->{$name}};
        my %spec_map = (
          map { $_->name => $_->init_arg||$_->name }
          (
            (grep { $_->has_init_arg }
               $meta->attribute_metaclass->meta->get_all_attributes),
            grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
            map {
              my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                           ->meta;
              map $meta->get_attribute($_), $meta->get_attribute_list
            }  @{$spec{traits}||[]}
          )
        );
        # have to hard code this because Moose's role meta-model is lacking
        $spec_map{traits} ||= 'traits';
  
        $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
        my $coerce = $spec{coerce};
        if (my $isa = $spec{isa}) {
          my $tc = $spec{isa} = do {
            if (my $mapped = $TYPE_MAP{$isa}) {
              my $type = $mapped->();
              Scalar::Util::blessed($type) && $type->isa("Moose::Meta::TypeConstraint")
                or die "error inflating attribute '$name' for package '$_[0]': \$TYPE_MAP{$isa} did not return a valid type constraint'";
              $coerce ? $type->create_child_type(name => $type->name) : $type;
            } else {
              Moose::Meta::TypeConstraint->new(
                constraint => sub { eval { &$isa; 1 } }
              );
            }
          };
          if ($coerce) {
            $tc->coercion(Moose::Meta::TypeCoercion->new)
               ->_compiled_type_coercion($coerce);
            $spec{coerce} = 1;
          }
        } elsif ($coerce) {
          my $attr = perlstring($name);
          my $tc = Moose::Meta::TypeConstraint->new(
                     constraint => sub { die "This is not going to work" },
                     inlined => sub {
                        'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                     },
                   );
          $tc->coercion(Moose::Meta::TypeCoercion->new)
             ->_compiled_type_coercion($coerce);
          $spec{isa} = $tc;
          $spec{coerce} = 1;
        }
        %spec =
          map { $spec_map{$_} => $spec{$_} }
          grep { exists $spec_map{$_} }
          keys %spec;
        push @attrs, $meta->add_attribute($name => %spec);
      }
      foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
        foreach my $attr ($mouse->get_all_attributes) {
          my %spec = %{$attr};
          delete @spec{qw(
            associated_class associated_methods __METACLASS__
            provides curries
          )};
          my $name = delete $spec{name};
          next if $seen_name{$name}++;
          push @attrs, $meta->add_attribute($name => %spec);
        }
      }
    }
    for my $meth_name (keys %methods) {
      my $meth_code = $methods{$meth_name};
      $meta->add_method($meth_name, $meth_code) if $meth_code;
    }
  
    if ($am_role) {
      my $info = $Moo::Role::INFO{$name};
      $meta->add_required_methods(@{$info->{requires}});
      foreach my $modifier (@{$info->{modifiers}}) {
        my ($type, @args) = @$modifier;
        my $code = pop @args;
        $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
      }
    } else {
      foreach my $attr (@attrs) {
        foreach my $method (@{$attr->associated_methods}) {
          $method->{body} = $name->can($method->name);
        }
      }
      bless(
        $meta->find_method_by_name('new'),
        'Moo::HandleMoose::FakeConstructor',
      );
      # a combination of Moo and Moose may bypass a Moo constructor but still
      # use a Moo DEMOLISHALL.  We need to make sure this is loaded before
      # global destruction.
      require Method::Generate::DemolishAll;
    }
    $meta->add_role(Class::MOP::class_of($_))
      for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
        do { no warnings 'once'; keys %{$Role::Tiny::APPLIED_TO{$name}} };
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->$meth(@_)
  }
  sub can {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->can(@_)
  }
  sub isa {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/HandleMoose/_TypeMap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_HANDLEMOOSE__TYPEMAP';
  package Moo::HandleMoose::_TypeMap;
  use strictures 1;
  
  package
    Moo::HandleMoose;
  our %TYPE_MAP;
  
  package Moo::HandleMoose::_TypeMap;
  
  use Scalar::Util ();
  
  our %WEAK_TYPES;
  
  sub _str_to_ref {
    my $in = shift;
    return $in
      if ref $in;
  
    if ($in =~ /(?:^|=)[A-Z]+\(0x([0-9a-zA-Z]+)\)$/) {
      my $id = do { no warnings 'portable'; hex "$1" };
      require B;
      my $sv = bless \$id, 'B::SV';
      my $ref = eval { $sv->object_2svref };
      if (!defined $ref) {
        die <<'END_ERROR';
  Moo initialization encountered types defined in a parent thread - ensure that
  Moo is require()d before any further thread spawns following a type definition.
  END_ERROR
      }
      return $ref;
    }
    return $in;
  }
  
  sub TIEHASH  { bless {}, $_[0] }
  
  sub STORE {
    my ($self, $key, $value) = @_;
    my $type = _str_to_ref($key);
    $WEAK_TYPES{$type} = $type;
    Scalar::Util::weaken($WEAK_TYPES{$type})
      if ref $type;
    $self->{$key} = $value;
  }
  
  sub FETCH    { $_[0]->{$_[1]} }
  sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
  sub NEXTKEY  { each %{$_[0]} }
  sub EXISTS   { exists $_[0]->{$_[1]} }
  sub DELETE   { delete $_[0]->{$_[1]} }
  sub CLEAR    { %{$_[0]} = () }
  sub SCALAR   { scalar %{$_[0]} }
  
  sub CLONE {
    my @types = map {
      defined $WEAK_TYPES{$_} ? ($WEAK_TYPES{$_} => $TYPE_MAP{$_}) : ()
    } keys %TYPE_MAP;
    %WEAK_TYPES = ();
    %TYPE_MAP = @types;
  }
  
  sub DESTROY {
    my %types = %{$_[0]};
    untie %TYPE_MAP;
    %TYPE_MAP = %types;
  }
  
  my @types = %TYPE_MAP;
  tie %TYPE_MAP, __PACKAGE__;
  %TYPE_MAP = @types;
  
  1;
MOO_HANDLEMOOSE__TYPEMAP

$fatpacked{"Moo/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_OBJECT';
  package Moo::Object;
  
  use strictures 1;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    $NO_BUILD{$class} and
      return bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class)
      : do {
          my $proto = ref($_[0]) eq 'HASH' ? $_[0] : { @_ };
          bless({ %$proto }, $class)->BUILDALL($proto);
        };
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    require Role::Tiny;
    { no warnings 'redefine'; *does = \&Role::Tiny::does_role }
    goto &Role::Tiny::does_role;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_ROLE';
  package Moo::Role;
  
  use strictures 1;
  use Moo::_Utils;
  use Role::Tiny ();
  use base qw(Role::Tiny);
  use Import::Into;
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  
  BEGIN { *INFO = \%Role::Tiny::INFO }
  
  our %INFO;
  our %APPLY_DEFAULTS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my ($me) = @_;
    _set_loaded(caller);
    strictures->import::into(1);
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      die "Cannot import Moo::Role into a Moo class";
    }
    $INFO{$target} ||= {};
    # get symbol table reference
    my $stash = _getstash($target);
    _install_tracked $target => has => sub {
      my $name_proto = shift;
      my @name_proto = ref $name_proto eq 'ARRAY' ? @$name_proto : $name_proto;
      if (@_ % 2 != 0) {
        require Carp;
        Carp::croak("Invalid options for " . join(', ', map "'$_'", @name_proto)
          . " attribute(s): even number of arguments expected, got " . scalar @_)
      }
      my %spec = @_;
      foreach my $name (@name_proto) {
        my $spec_ref = @name_proto > 1 ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    return if $INFO{$target}{is_role}; # already exported into this package
    $INFO{$target}{is_role} = 1;
    *{_getglob("${target}::meta")} = $me->can('meta');
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later) with a map to the coderefs in case of copying or re-use
    my @not_methods = ('', map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $Role::Tiny::APPLIED_TO{$target} = { $target => undef };
  
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub methods_provided_by {
    my ($self, $role) = @_;
    $self->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $INFO{$role};
    return $self->SUPER::methods_provided_by($role);
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    _load_module($role);
    my $meta;
    if (!$INFO{$role}
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      my $is_mouse = $meta->isa('Mouse::Meta::Role');
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep $role->can($_),
          grep !($is_mouse && $_ eq 'meta'),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $Role::Tiny::APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
  
            $spec->{isa} = sub {
              &$check or die "Type constraint failed for $_[0]"
            };
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      require Class::Method::Modifiers if @$mods;
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      $me->_inhale_if_moose($role);
      die "${role} is not a Moo::Role" unless $INFO{$role};
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    $me->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $INFO{$role};
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
        $me->_inhale_if_moose($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      *{_getglob("${new_name}::ISA")} = [ $superclass ];
      $me->apply_roles_to_package($new_name, @roles);
      _set_loaded($new_name, (caller)[1]);
      return $new_name;
    }
  
    require Sub::Quote;
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Role::Tiny" unless $INFO{$role};
    }
  
    $Moo::MAKERS{$new_name} = {is_class => 1};
  
    $me->_handle_constructor($new_name, $_) for @roles;
  
    _set_loaded($new_name, (caller)[1]);
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
    _set_loaded(ref $new, (caller)[1]);
  
    my $apply_defaults = $APPLY_DEFAULTS{ref $new} ||= do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for(ref $new)
          and my $m = Moo->_accessor_maker_for(ref $new)) {
        require Sub::Quote;
  
        my $specs = $con_gen->all_attribute_specs;
  
        my $assign = '';
        my %captures;
        foreach my $name ( keys %attrs ) {
          my $spec = $specs->{$name};
          if ($m->has_eager_default($name, $spec)) {
            my ($has, $has_cap)
              = $m->generate_simple_has('$_[0]', $name, $spec);
            my ($code, $pop_cap)
              = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
            $assign .= $code;
            @captures{keys %$has_cap, keys %$pop_cap}
              = (values %$has_cap, values %$pop_cap);
          }
        }
        Sub::Quote::quote_sub($assign, \%captures);
      }
      else {
        sub {};
      }
    };
    $new->$apply_defaults;
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $Role::Tiny::COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    if ($INFO{$to}) {
      push @{$INFO{$to}{attributes}||=[]}, @$attr_info;
    } else {
      # only fiddle with the constructor if the target is a Moo class
      if ($INC{"Moo.pm"}
          and my $con = Moo->_constructor_maker_for($to)) {
        # shallow copy of the specs since the constructor will assign an index
        $con->register_attribute_specs(map ref() ? { %$_ } : $_, @$attr_info);
      }
    }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  And elsewhere:
  
   package Some::Class;
  
   use Moo;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 CLEANING UP IMPORTS
  
  L<Moo::Role> cleans up its own imported methods and any imports
  declared before the C<use Moo::Role> statement automatically.
  Anything imported after C<use Moo::Role> will be composed into
  consuming packages.  A package that consumes this role:
  
   package My::Role::ID;
  
   use Digest::MD5 qw(md5_hex);
   use Moo::Role;
   use Digest::SHA qw(sha1_hex);
  
   requires 'name';
  
   sub as_md5  { my ($self) = @_; return md5_hex($self->name);  }
   sub as_sha1 { my ($self) = @_; return sha1_hex($self->name); }
  
   1;
  
  ..will now have a C<< $self->sha1_hex() >> method available to it
  that probably does not do what you expect.  On the other hand, a call
  to C<< $self->md5_hex() >> will die with the helpful error message:
  C<Can't locate object method "md5_hex">.
  
  See L<Moo/"CLEANING UP IMPORTS"> for more details.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__UTILS';
  package Moo::_Utils;
  
  no warnings 'once'; # guard against -w
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use constant lt_5_8_3 => ( $] < 5.008003 or $ENV{MOO_TEST_PRE_583} ) ? 1 : 0;
  use constant can_haz_subname => eval { require Sub::Name };
  
  use strictures 1;
  use Module::Runtime qw(use_package_optimistically module_notional_filename);
  
  use Devel::GlobalDestruction ();
  use base qw(Exporter);
  use Moo::_mro;
  use Config;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa _getstash _install_coderef _name_coderef
      _unimport_coderefs _in_global_destruction _set_loaded
  );
  
  sub _in_global_destruction ();
  *_in_global_destruction = \&Devel::GlobalDestruction::in_global_destruction;
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      require Sub::Defer;
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  sub _load_module {
    my $module = $_[0];
    my $file = module_notional_filename($module);
    use_package_optimistically($module);
    return 1
      if $INC{$file};
    my $error = $@ || "Can't locate $file";
  
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($module)||{};
    return 1 if grep +(!ref($_) and *$_{CODE}), values %$stash;
    return 1
      if $INC{"Moose.pm"} && Class::MOP::class_of($module)
      or Mouse::Util->can('find_meta') && Mouse::Util::find_meta($module);
    die $error;
  }
  
  sub _maybe_load_module {
    return $MAYBE_LOADED{$_[0]} if exists $MAYBE_LOADED{$_[0]};
    (my $proto = $_[0]) =~ s/::/\//g;
    local $@;
    if (eval { require "${proto}.pm"; 1 }) {
      $MAYBE_LOADED{$_[0]} = 1;
    } else {
      if (exists $INC{"${proto}.pm"}) {
        warn "$_[0] exists but failed to load with error: $@";
      }
      $MAYBE_LOADED{$_[0]} = 0;
    }
    return $MAYBE_LOADED{$_[0]};
  }
  
  sub _set_loaded {
    $INC{Module::Runtime::module_notional_filename($_[0])} ||= $_[1];
  }
  
  sub _get_linear_isa {
    return mro::get_linear_isa($_[0]);
  }
  
  sub _install_coderef {
    no warnings 'redefine';
    *{_getglob($_[0])} = _name_coderef(@_);
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    can_haz_subname ? Sub::Name::subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  if ($Config{useithreads}) {
    require Moo::HandleMoose::_TypeMap;
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO__MRO';
  package Moo::_mro;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/sification.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOO_SIFICATION';
  package Moo::sification;
  
  use strictures 1;
  use Moo::_Utils ();
  
  sub unimport { our $disarmed = 1 }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disarmed or Moo::_Utils::_in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  if ($INC{"Moose.pm"}) {
    require Moo::HandleMoose;
    Moo::HandleMoose->import;
  } else {
    $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
  }
  
  1;
MOO_SIFICATION

$fatpacked{"Parse/CPAN/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_CPAN_META';
  use 5.008001;
  use strict;
  package Parse::CPAN::Meta;
  # ABSTRACT: Parse META.yml and META.json CPAN metadata files
  our $VERSION = '1.4414'; # VERSION
  
  use Exporter;
  use Carp 'croak';
  
  our @ISA = qw/Exporter/;
  our @EXPORT_OK = qw/Load LoadFile/;
  
  sub load_file {
    my ($class, $filename) = @_;
  
    my $meta = _slurp($filename);
  
    if ($filename =~ /\.ya?ml$/) {
      return $class->load_yaml_string($meta);
    }
    elsif ($filename =~ /\.json$/) {
      return $class->load_json_string($meta);
    }
    else {
      $class->load_string($meta); # try to detect yaml/json
    }
  }
  
  sub load_string {
    my ($class, $string) = @_;
    if ( $string =~ /^---/ ) { # looks like YAML
      return $class->load_yaml_string($string);
    }
    elsif ( $string =~ /^\s*\{/ ) { # looks like JSON
      return $class->load_json_string($string);
    }
    else { # maybe doc-marker-free YAML
      return $class->load_yaml_string($string);
    }
  }
  
  sub load_yaml_string {
    my ($class, $string) = @_;
    my $backend = $class->yaml_backend();
    my $data = eval { no strict 'refs'; &{"$backend\::Load"}($string) };
    croak $@ if $@;
    return $data || {}; # in case document was valid but empty
  }
  
  sub load_json_string {
    my ($class, $string) = @_;
    my $data = eval { $class->json_backend()->new->decode($string) };
    croak $@ if $@;
    return $data || {};
  }
  
  sub yaml_backend {
    if (! defined $ENV{PERL_YAML_BACKEND} ) {
      _can_load( 'CPAN::Meta::YAML', 0.011 )
        or croak "CPAN::Meta::YAML 0.011 is not available\n";
      return "CPAN::Meta::YAML";
    }
    else {
      my $backend = $ENV{PERL_YAML_BACKEND};
      _can_load( $backend )
        or croak "Could not load PERL_YAML_BACKEND '$backend'\n";
      $backend->can("Load")
        or croak "PERL_YAML_BACKEND '$backend' does not implement Load()\n";
      return $backend;
    }
  }
  
  sub json_backend {
    if (! $ENV{PERL_JSON_BACKEND} or $ENV{PERL_JSON_BACKEND} eq 'JSON::PP') {
      _can_load( 'JSON::PP' => 2.27103 )
        or croak "JSON::PP 2.27103 is not available\n";
      return 'JSON::PP';
    }
    else {
      _can_load( 'JSON' => 2.5 )
        or croak  "JSON 2.5 is required for " .
                  "\$ENV{PERL_JSON_BACKEND} = '$ENV{PERL_JSON_BACKEND}'\n";
      return "JSON";
    }
  }
  
  sub _slurp {
    require Encode;
    open my $fh, "<:raw", "$_[0]" ## no critic
      or die "can't open $_[0] for reading: $!";
    my $content = do { local $/; <$fh> };
    $content = Encode::decode('UTF-8', $content, Encode::PERLQQ());
    return $content;
  }
    
  sub _can_load {
    my ($module, $version) = @_;
    (my $file = $module) =~ s{::}{/}g;
    $file .= ".pm";
    return 1 if $INC{$file};
    return 0 if exists $INC{$file}; # prior load failed
    eval { require $file; 1 }
      or return 0;
    if ( defined $version ) {
      eval { $module->VERSION($version); 1 }
        or return 0;
    }
    return 1;
  }
  
  # Kept for backwards compatibility only
  # Create an object from a file
  sub LoadFile ($) {
    return Load(_slurp(shift));
  }
  
  # Parse a document from a string.
  sub Load ($) {
    require CPAN::Meta::YAML;
    my $object = eval { CPAN::Meta::YAML::Load(shift) };
    croak $@ if $@;
    return $object;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Parse::CPAN::Meta - Parse META.yml and META.json CPAN metadata files
  
  =head1 VERSION
  
  version 1.4414
  
  =head1 SYNOPSIS
  
      #############################################
      # In your file
      
      ---
      name: My-Distribution
      version: 1.23
      resources:
        homepage: "http://example.com/dist/My-Distribution"
      
      
      #############################################
      # In your program
      
      use Parse::CPAN::Meta;
      
      my $distmeta = Parse::CPAN::Meta->load_file('META.yml');
      
      # Reading properties
      my $name     = $distmeta->{name};
      my $version  = $distmeta->{version};
      my $homepage = $distmeta->{resources}{homepage};
  
  =head1 DESCRIPTION
  
  B<Parse::CPAN::Meta> is a parser for F<META.json> and F<META.yml> files, using
  L<JSON::PP> and/or L<CPAN::Meta::YAML>.
  
  B<Parse::CPAN::Meta> provides three methods: C<load_file>, C<load_json_string>,
  and C<load_yaml_string>.  These will read and deserialize CPAN metafiles, and
  are described below in detail.
  
  B<Parse::CPAN::Meta> provides a legacy API of only two functions,
  based on the YAML functions of the same name. Wherever possible,
  identical calling semantics are used.  These may only be used with YAML sources.
  
  All error reporting is done with exceptions (die'ing).
  
  Note that META files are expected to be in UTF-8 encoding, only.  When
  converted string data, it must first be decoded from UTF-8.
  
  =begin Pod::Coverage
  
  
  
  
  =end Pod::Coverage
  
  =head1 METHODS
  
  =head2 load_file
  
    my $metadata_structure = Parse::CPAN::Meta->load_file('META.json');
  
    my $metadata_structure = Parse::CPAN::Meta->load_file('META.yml');
  
  This method will read the named file and deserialize it to a data structure,
  determining whether it should be JSON or YAML based on the filename.
  The file will be read using the ":utf8" IO layer.
  
  =head2 load_yaml_string
  
    my $metadata_structure = Parse::CPAN::Meta->load_yaml_string($yaml_string);
  
  This method deserializes the given string of YAML and returns the first
  document in it.  (CPAN metadata files should always have only one document.)
  If the source was UTF-8 encoded, the string must be decoded before calling
  C<load_yaml_string>.
  
  =head2 load_json_string
  
    my $metadata_structure = Parse::CPAN::Meta->load_json_string($json_string);
  
  This method deserializes the given string of JSON and the result.  
  If the source was UTF-8 encoded, the string must be decoded before calling
  C<load_json_string>.
  
  =head2 load_string
  
    my $metadata_structure = Parse::CPAN::Meta->load_string($some_string);
  
  If you don't know whether a string contains YAML or JSON data, this method
  will use some heuristics and guess.  If it can't tell, it assumes YAML.
  
  =head2 yaml_backend
  
    my $backend = Parse::CPAN::Meta->yaml_backend;
  
  Returns the module name of the YAML serializer. See L</ENVIRONMENT>
  for details.
  
  =head2 json_backend
  
    my $backend = Parse::CPAN::Meta->json_backend;
  
  Returns the module name of the JSON serializer.  This will either
  be L<JSON::PP> or L<JSON>.  Even if C<PERL_JSON_BACKEND> is set,
  this will return L<JSON> as further delegation is handled by
  the L<JSON> module.  See L</ENVIRONMENT> for details.
  
  =head1 FUNCTIONS
  
  For maintenance clarity, no functions are exported by default.  These functions
  are available for backwards compatibility only and are best avoided in favor of
  C<load_file>.
  
  =head2 Load
  
    my @yaml = Parse::CPAN::Meta::Load( $string );
  
  Parses a string containing a valid YAML stream into a list of Perl data
  structures.
  
  =head2 LoadFile
  
    my @yaml = Parse::CPAN::Meta::LoadFile( 'META.yml' );
  
  Reads the YAML stream from a file instead of a string.
  
  =head1 ENVIRONMENT
  
  =head2 PERL_JSON_BACKEND
  
  By default, L<JSON::PP> will be used for deserializing JSON data. If the
  C<PERL_JSON_BACKEND> environment variable exists, is true and is not
  "JSON::PP", then the L<JSON> module (version 2.5 or greater) will be loaded and
  used to interpret C<PERL_JSON_BACKEND>.  If L<JSON> is not installed or is too
  old, an exception will be thrown.
  
  =head2 PERL_YAML_BACKEND
  
  By default, L<CPAN::Meta::YAML> will be used for deserializing YAML data. If
  the C<PERL_YAML_BACKEND> environment variable is defined, then it is interpreted
  as a module to use for deserialization.  The given module must be installed,
  must load correctly and must implement the C<Load()> function or an exception
  will be thrown.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<http://rt.cpan.org/Public/Dist/Display.html?Name=Parse-CPAN-Meta>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta>
  
    git clone https://github.com/Perl-Toolchain-Gang/Parse-CPAN-Meta.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Adam Kennedy <adamk@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Joshua ben Jore <jjore@cpan.org>
  
  =item *
  
  Neil Bowers <neil@bowers.com>
  
  =item *
  
  Ricardo Signes <rjbs@cpan.org>
  
  =item *
  
  Steffen Mueller <smueller@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Adam Kennedy and Contributors.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PARSE_CPAN_META

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  our $VERSION = '0.052'; # VERSION
  
  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 3.40 ();
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_BSD   => ( scalar $^O =~ /bsd$/ ),
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  my $HAS_UU; # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      eval { require Unicode::UTF8; Unicode::UTF8->VERSION(0.58); 1 };
  }
  
  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};
  
  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;
  
  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?$}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }
  
  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT$/ ) : ( $_[0] eq '/' );
  }
  
  # flock doesn't work on NFS on BSD.  Since program authors often can't control
  # or detect that, we warn once instead of being fatal if we can detect it and
  # people who need it strict can fatalize the 'flock' category
  
  #<<< No perltidy
  { package flock; use if Path::Tiny::IS_BSD(), 'warnings::register' }
  #>>>
  
  my $WARNED_BSD_NFS = 0;
  
  sub _throw {
      my ( $self, $function, $file ) = @_;
      if (   IS_BSD()
          && $function =~ /^flock/
          && $! =~ /operation not supported/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_BSD_NFS ) {
              warnings::warn( flock => "No flock for NFS on BSD: continuing in unsafe mode" );
              $WARNED_BSD_NFS++;
          }
      }
      else {
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ), $! );
      }
      return;
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  
  sub path {
      my $path = shift;
      Carp::croak("path() requires a defined, positive-length argument")
        unless defined $path && length $path;
  
      # stringify initial path
      $path = "$path";
  
      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|$)};
          $path .= "/" if $path =~ m{^$UNC_VOL$};
      }
  
      # concatenate more arguments (stringifies any objects, too)
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }
  
      # canonicalize paths
      my $cpath = $path = File::Spec->canonpath($path); # ugh, but probably worth it
      $path =~ tr[\\][/] if IS_WIN32();                 # unix convention enforced
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL$}; # canonpath strips it
  
      # hack to make splitpath give us a basename; root paths must always have
      # a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?$}{/};
      }
      else {
          $path =~ s{/$}{};
      }
  
      # do any tilde expansions
      if ( $path =~ m{^(~[^/]*).*} ) {
          my ($homedir) = glob($1); # glob without list context == heisenbug!
          $path =~ s{^(~[^/]*)}{$homedir};
      }
  
      # and we're finally done
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  
  sub new { shift; path(@_) }
  
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  
  sub tempfile {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
  
      # File::Temp->newdir demands leading template
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
      return ( \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  
  sub absolute {
      my ( $self, $base ) = @_;
  
      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }
  
      # relative path on any OS
      require Cwd;
      return path( ( defined($base) ? $base : Cwd::getcwd() ), $_[0]->[PATH] );
  }
  
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, ">>", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw('close');
  }
  
  sub append_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &append }
  
  sub append_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          append( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &append;
      }
  }
  
  
  sub basename {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[FILE];
      return $self->[FILE];
  }
  
  
  sub canonpath { $_[0]->[CANON] }
  
  
  sub child {
      my ( $self, @parts ) = @_;
      return path( $self->[PATH], @parts );
  }
  
  
  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');
  
      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }
  
      return map { path( $self->[PATH], $_ ) } @children;
  }
  
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  }
  
  
  sub digest {
      my ( $self, $alg, @args ) = @_;
      $alg = 'SHA-256' unless defined $alg;
      require Digest;
      return Digest->new( $alg, @args )->add( $self->slurp_raw )->hexdigest;
  }
  
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -f $_[0]->[PATH] }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked/ );
      my ( $opentype, $binmode ) = @args;
  
      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;
  
      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;
  
      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");
  
              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }
  
              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }
  
              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX
              $opentype = "+<";
              $lock     = Fcntl::LOCK_EX();
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }
  
      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }
  
      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;
  
      return $fh;
  }
  
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  
  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }
  
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( @result, $counter );
          while ( my $line = <$fh> ) {
              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})$// if $chomp;
              push @result, $line;
              last if ++$counter == $args->{count};
          }
          return @result;
      }
      elsif ($chomp) {
          return map { s/(?:\x{0d}?\x{0a}|\x{0d})$//; $_ } <$fh>; ## no critic
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() )
          && $args->{chomp}
          && !$args->{count} )
      {
          return split /(?:\x{0d}?\x{0a}|\x{0d})/, slurp_utf8($self); ## no critic
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err} = \$err unless defined $args->{err};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst )
        || $self->_throw( 'rename', $self->[PATH] . "' -> '$dst'" );
  }
  
  
  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw:encoding(UTF-8)" );
      };
  }
  
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.$)} ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/$}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  
  sub realpath {
      my $self = shift;
      require Cwd;
      my $realpath = eval {
          local $SIG{__WARN__} = sub { }; # (sigh) pure-perl CWD can carp
          Cwd::realpath( $self->[PATH] );
      };
      $self->_throw("resolving realpath") unless defined $realpath and length $realpath;
      return path($realpath);
  }
  
  
  # Easy to get wrong, so wash it through File::Spec (sigh)
  sub relative { path( File::Spec->abs2rel( $_[0]->[PATH], $_[1] ) ) }
  
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink $self->[PATH] || $self->_throw('unlink');
  }
  
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err}  = \$err unless defined $args->{err};
      $args->{safe} = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $temp = path( $self->[PATH] . $$ . int( rand( 2**31 ) ) );
      my $fh = $temp->filehandle( { locked => 1 }, ">", $binmode );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      close $fh or $self->_throw( 'close', $temp->[PATH] );
  
      # spewing need to follow the link
      # and replace the destination instead
      my $resolved_path = $self->[PATH];
      $resolved_path = readlink $resolved_path while -l $resolved_path;
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          spew( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }
  
  
  sub stringify { $_[0]->[PATH] }
  
  
  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = path(shift);
  
      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }
  
      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }
  
      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|$)};
      }
  }
  
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      $epoch = defined($epoch) ? $epoch : time();
      utime $epoch, $epoch, $self->[PATH]
        or $self->_throw("utime ($epoch)");
      return $self;
  }
  
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  package Path::Tiny::Error;
  
  our @CARP_NOT = qw/Path::Tiny/;
  
  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );
  
  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.052
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    $head = $file->lines( {count => 1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module attempts to provide a small, fast utility for working with
  file paths.  It is friendlier to use than L<File::Spec> and provides
  easy access to functions from several other core file handling modules.
  
  It doesn't attempt to be as full-featured as L<IO::All> or L<Path::Class>,
  nor does it try to work for anything except Unix-like and Win32 platforms.
  Even then, it might break if you try something particularly obscure or
  tortuous.  (Quick!  What does this mean: C<< ///../../..//./././a//b/.././c/././ >>?
  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform).
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode without CRLF translation.  Installing L<Unicode::UTF8> 0.58 or later
  will speed up several of them and is highly recommended.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  Unless an argument is given, the current directory is used as the
  absolute base path.  The argument must be absolute or you won't get an absolute
  result.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  On Windows, an absolute path without a volume component will have it added
  based on the current drive.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<binmode()> on the handle used for writing.
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  append will be done instead on the data encoded with C<Unicode::UTF8>.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename; # bar.txt
  
  Returns the file portion or last directory portion of a path.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  =head2 children
  
      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt$/ );
  
  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.
  
  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:
  
      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies a file using L<File::Copy>'s C<copy> function.
  
  =head2 digest
  
      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  
  Returns a hexadecimal digest for a file.  Any arguments are passed to the
  constructor for L<Digest> to select an algorithm.  If no arguments are given,
  the default is SHA-256.
  
  =head2 dirname
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory name portion of the path.  This is roughly
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually has the trailing slash. If that's not desired, stringify directories
  or call C<parent> on files.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }
      if ( path("/tmp")->is_file ) { ... }
      if ( path("/tmp")->is_dir ) { ... }
  
  Just like C<-e>, C<-f> or C<-d>.  This means the file or directory actually has to
  exist on the filesystem.  Until then, it's just a path.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", "<<", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked with C<LOCK_SH>.  When using
  C<locked>, ">" or "+>" modes will delay truncation until after the lock is
  acquired.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  =head2 is_rootdir
  
      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }
  
  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  
  This works even on C<MSWin32> with drives and UNC volumes:
  
      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.
  
  The default is the same as:
  
      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.  If C<binmode>
  is provided, it will be set on the handle prior to reading.  If C<count> is
  provided, up to that many lines will be returned. If C<chomp> is set, any
  end-of-line character sequences (C<CR>, C<CRLF>, or C<LF>) will be removed
  from the lines returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of
  C<:raw:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Just like C<rename>.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  
      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  
  See L</filehandle> for more on locking.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  If the path can't be resolved (e.g. if it includes directories that don't exist),
  an exception will be thrown:
  
      $real = path("doesnt_exist/foo")->realpath; # dies
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a relative path name.
  Given the trickiness of this, it's a thin wrapper around
  C<< File::Spec->abs2rel() >>.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  B<Note: as of 0.012, remove only works on files>.
  
  This is just like C<unlink>, except if the path does not exist, it returns
  false rather than throwing an exception.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference may be
  used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  slurp will be done instead and the result decoded with C<Unicode::UTF8>.
  This is just as strict and is roughly an order of magnitude faster than
  using C<:encoding(UTF-8)>.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>.
  If L<Unicode::UTF8> 0.58+ is installed, a raw spew will be done instead on
  the data encoded with C<Unicode::UTF8>.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  =head2 subsumes
  
      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false
  
  Returns true if the first path is a prefix of the second path at a directory
  boundary.
  
  This B<does not> resolve parent directory entries (C<..>) or symlinks:
  
      path("foo/bar")->subsumes("foo/bar/../baz"); # true
  
  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:
  
      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with spew:
  
      path("foo.txt")->touch->spew( $content );
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  
  Returns the volume portion of the path.  This is equivalent
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_BSD IS_WIN32
  
  =head1 EXCEPTION HANDLING
  
  Failures will be thrown as exceptions in the class C<Path::Tiny::Error>.
  
  The object will be a hash reference with the following fields:
  
  =over 4
  
  =item *
  
  C<op> — a description of the operation, usually function call and any extra info
  
  =item *
  
  C<file> — the file or directory relating to the error
  
  =item *
  
  C<err> — hold C<$!> at the time the error was thrown
  
  =item *
  
  C<msg> — a string combining the above data and a Carp-like short stack trace
  
  =back
  
  Exception objects will stringify as the C<msg> field.
  
  =head1 CAVEATS
  
  =head2 File locking
  
  If flock is not supported on a platform, it will not be used, even if
  locking is requested.
  
  See additional caveats below.
  
  =head3 NFS and BSD
  
  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  Path::Tiny has some heuristics to detect this
  and will warn once and let you continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:
  
      use warnings FATAL => 'flock';
  
  =head3 AIX and locking
  
  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  Consider L<PerlIO::utf8_strict> for a faster L<PerlIO> layer alternative to
  C<:encoding(UTF-8)>, though it does not appear to be as fast as the
  C<Unicode::UTF8> approach.
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  =over 4
  
  =item *
  
  L<File::Fu>
  
  =item *
  
  L<IO::All>
  
  =item *
  
  L<Path::Class>
  
  =back
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  =over 4
  
  =item *
  
  L<Path::Iterator::Rule>
  
  =item *
  
  L<File::Next>
  
  =back
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Path-Tiny>
  
    git clone https://github.com/dagolden/Path-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  Gabor Szabo <szabgab@cpan.org>
  
  =item *
  
  Gabriel Andrade <gabiruh@gmail.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Geraud Continsouzas <geraud@scsi.nc>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Martin Kjeldsen <mk@bluepipe.dk>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =item *
  
  Toby Inkster <tobyink@cpan.org>
  
  =item *
  
  김도형 - Keedi Kim <keedi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Sub/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_DEFER';
  package Sub::Defer;
  
  use strictures 1;
  use base qw(Exporter);
  use Moo::_Utils;
  use Scalar::Util qw(weaken);
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(defer_sub undefer_sub undefer_all);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    return ${$undeferred_ref}
      if ${$undeferred_ref};
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    weaken($DEFERRED{$made} = $DEFERRED{$deferred});
  
    return $made;
  }
  
  sub undefer_all {
    undefer_sub($_) for keys %DEFERRED;
    return;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    $DEFERRED{$deferred||''};
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_info;
    my $deferred = sub {
      $undeferred ||= undefer_sub($deferred_info->[3]);
      goto &$undeferred;
    };
    $deferred_info = [ $target, $maker, \$undeferred, $deferred ];
    weaken($DEFERRED{$deferred} = $deferred_info);
    _install_coderef($target => $deferred) if defined $target;
    return $deferred;
  }
  
  sub CLONE {
    %DEFERRED = map { defined $_ ? ($_->[3] => $_) : () } values %DEFERRED;
    weaken($_) for values %DEFERRED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  =head2 undefer_all
  
   undefer_all();
  
  This will undefer all defered subs in one go.  This can be very useful in a
  forking environment where child processes would each have to undefer the same
  subs.  By calling this just before you start forking children you can undefer
  all currently deferred subs in the parent so that the children do not have to
  do it.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.001011';
  
  use Carp ();
  use List::Util ();
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if (List::Util::first { ref || !m/ \A [:-]? \w+ \z /xm } @args) {
           Carp::croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif (defined(my $num = List::Util::first { !ref and m/^\d/ } @args)) {
           die "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ($setup eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              Carp::croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              Carp::croak $too_complicated if List::Util::first { ref } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 Carp::croak $too_complicated if List::Util::first { / \A - (?! all \b ) /x || ref } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              Carp::croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        Carp::croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       default => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 AUTHOR
  
  frew - Arthur Axel Schmidt (cpan:FREW) <frioux+cpan@gmail.com>
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Sub::Exporter::Progressive L</AUTHOR> and
  L</CONTRIBUTORS> as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_QUOTE';
  package Sub::Quote;
  
  use strictures 1;
  
  sub _clean_eval { eval $_[0] }
  
  use Sub::Defer;
  use B 'perlstring';
  use Scalar::Util qw(weaken);
  use base qw(Exporter);
  
  our $VERSION = '1.004002';
  $VERSION = eval $VERSION;
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub);
  
  our %QUOTED;
  
  our %WEAK_REFS;
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if ($code =~ s/^(\s*package\s+([a-zA-Z0-9:]+);)//) {
      $do .= $1;
    }
    my $assign = '';
    if (my ($code_args) = $code =~ /^\s*my\s*\(([^)]+)\)\s*=\s*\@_;$/s) {
      if ($code_args ne $args) {
        $assign = 'my ('.$code_args.') = ('.$args.'); ';
      }
    }
    elsif ($local || $args ne '@_') {
      $assign = ($local ? 'local ' : '').'@_ = ('.$args.'); ';
    }
    $do.$assign.$code.' }';
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = ref($_[-1]) eq 'HASH' ? pop : undef;
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my ($package, $hints, $bitmask, $hintshash) = (caller(0))[0,8,9,10];
    my $context
      ="package $package;\n"
      ."BEGIN {\n"
      ."  \$^H = ".B::perlstring($hints).";\n"
      ."  \${^WARNING_BITS} = ".B::perlstring($bitmask).";\n"
      ."  \%^H = (\n"
      . join('', map
       "    ".B::perlstring($_)." => ".B::perlstring($hintshash->{$_}).",",
        keys %$hintshash)
      ."  );\n"
      ."}\n";
    $code = "$context$code";
    my $quoted_info;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      unquote_sub($quoted_info->[4]);
    };
    $quoted_info = [ $name, $code, $captures, undef, $deferred ];
    weaken($QUOTED{$deferred} = $quoted_info);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    $QUOTED{$sub||''};
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    unless ($QUOTED{$sub}[3]) {
      my ($name, $code, $captures) = @{$QUOTED{$sub}};
  
      my $make_sub = "{\n";
  
      my %captures = $captures ? %$captures : ();
      $captures{'$_QUOTED'} = \$QUOTED{$sub};
      $make_sub .= capture_unroll("\$_[1]", \%captures, 2);
  
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$_QUOTED->[3] = sub {\n"
      );
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$_QUOTED->[3] = \\&${name}\n";
      }
      $make_sub .= "}\n1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        no strict 'refs';
        local *{$name} if $name;
        my ($success, $e);
        {
          local $@;
          $success = _clean_eval($make_sub, \%captures);
          $e = $@;
        }
        unless ($success) {
          die "Eval went very, very wrong:\n\n${make_sub}\n\n$e";
        }
      }
    }
    $QUOTED{$sub}[3];
  }
  
  sub CLONE {
    %QUOTED = map { defined $_ ? ($_->[4] => $_) : () } values %QUOTED;
    weaken($_) for values %QUOTED;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  The keys should be the full name of the variable to be made available,
  including the sigil.  The values should be references to the values.  The
  variables will contain copies of the values.  See the L</SYNOPSIS>'s
  C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   };
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few caveats
  apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 pragmas
  
  C<Sub::Quote> preserves the environment of the code creating the
  quoted subs.  This includes the package, strict, warnings, and any
  other lexical pragmas.  This is done by prefixing the code with a
  block that sets up a matching environment.  When inlining C<Sub::Quote>
  subs, care should be taken that user pragmas won't effect the rest
  of the code.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
  
  =cut
SUB_QUOTE

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;
  BEGIN {
    $Try::Tiny::AUTHORITY = 'cpan:NUFFIN';
  }
  $Try::Tiny::VERSION = '0.20';
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  use strict;
  use warnings;
  
  use Exporter 5.57 'import';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN { eval "use Sub::Name; 1" or *{subname} = sub {1} }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    # work around perl bug by explicitly initializing these, due to the likelyhood
    # this will be used in global destruction (perl rt#119311)
    my ( $catch, @finally ) = ();
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    subname("${caller}::try {...} " => $try);
    subname("${caller}::catch {...} " => $catch) if $catch;
    subname("${caller}::finally {...} " => $_) foreach @finally;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $fail to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.20
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || { "bar" };
    my $x = (try { die "foo" }) // { "bar" };
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  Note that adding a C<finally> block without a preceding C<catch> block
  suppresses any errors. This behaviour is consistent with using a standalone
  C<eval>, but it is not consistent with C<try>/C<finally> patterns found in
  other programming languages, such as Java, Python, Javascript or C#. If you
  learnt the C<try>/C<finally> pattern from one of these languages, watch out for
  this.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
    # OR
    sub parent_sub_with_catch {
      my $success = try {
        die;
        1;
      }
      catch {
        # do something with $_
        return undef; #see note
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considired experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Yuval Kogman <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2014 by Yuval Kogman.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"oo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OO';
  package oo;
  
  use strictures 1;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
OO

$fatpacked{"strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES';
  package strictures;
  
  use strict;
  use warnings FATAL => 'all';
  
  BEGIN {
    *_PERL_LT_5_8_4 = ($] < 5.008004) ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '1.005004'; # 1.5.4
  
  sub VERSION {
    my ($class, $version) = @_;
    for ($version) {
      last unless defined && !ref && int != 1;
      die "Major version specified as $_ - this is strictures version 1";
    }
    # passing undef here may either warn or die depending on the version of perl.
    # we can't match the caller's warning state in this case, so just disable the
    # warning.
    no warnings 'uninitialized';
    shift->SUPER::VERSION(@_);
  }
  
  our $extra_load_states;
  
  our $Smells_Like_VCS = (-e '.git' || -e '.svn' || -e '.hg'
    || (-e '../../dist.ini'
        && (-e '../../.git' || -e '../../.svn' || -e '../../.hg' )));
  
  sub import {
    strict->import;
    warnings->import(FATAL => 'all');
  
    my $extra_tests = do {
      if (exists $ENV{PERL_STRICTURES_EXTRA}) {
        if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}) {
          die 'PERL_STRICTURES_EXTRA checks are not available on perls older than 5.8.4: '
            . "please unset \$ENV{PERL_STRICTURES_EXTRA}\n";
        }
        $ENV{PERL_STRICTURES_EXTRA};
      } elsif (! _PERL_LT_5_8_4) {
        !!((caller)[1] =~ /^(?:t|xt|lib|blib)/
           and $Smells_Like_VCS)
      }
    };
    if ($extra_tests) {
      $extra_load_states ||= do {
  
        my (%rv, @failed);
        foreach my $mod (qw(indirect multidimensional bareword::filehandles)) {
          eval "require $mod; \$rv{'$mod'} = 1;" or do {
            push @failed, $mod;
  
            # courtesy of the 5.8 require bug
            # (we do a copy because 5.16.2 at least uses the same read-only
            # scalars for the qw() list and it doesn't seem worth a $^V check)
  
            (my $file = $mod) =~ s|::|/|g;
            delete $INC{"${file}.pm"};
          };
        }
  
        if (@failed) {
          my $failed = join ' ', @failed;
          print STDERR <<EOE;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  EOE
        }
  
        \%rv;
      };
  
      indirect->unimport(':fatal') if $extra_load_states->{indirect};
      multidimensional->unimport if $extra_load_states->{multidimensional};
      bareword::filehandles->unimport if $extra_load_states->{'bareword::filehandles'};
    }
  }
  
  1;
  
  __END__
  =head1 NAME
  
  strictures - turn on strict and make all warnings fatal
  
  =head1 SYNOPSIS
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
  
  except when called from a file which matches:
  
    (caller)[1] =~ /^(?:t|xt|lib|blib)/
  
  and when either C<.git>, C<.svn>, or C<.hg> is present in the current directory (with
  the intention of only forcing extra tests on the author side) -- or when C<.git>,
  C<.svn>, or C<.hg> is present two directories up along with C<dist.ini> (which would
  indicate we are in a C<dzil test> operation, via L<Dist::Zilla>) --
  or when the C<PERL_STRICTURES_EXTRA> environment variable is set, in which case
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  Note that C<PERL_STRICTURES_EXTRA> may at some point add even more tests, with only a minor
  version increase, but any changes to the effect of C<use strictures> in
  normal mode will involve a major version bump.
  
  If any of the extra testing modules are not present, L<strictures> will
  complain loudly, once, via C<warn()>, and then shut up. But you really
  should consider installing them, they're all great anti-footgun tools.
  
  =head1 DESCRIPTION
  
  I've been writing the equivalent of this module at the top of my code for
  about a year now. I figured it was time to make it shorter.
  
  Things like the importer in C<use Moose> don't help me because they turn
  warnings on but don't make them fatal -- which from my point of view is
  useless because I want an exception to tell me my code isn't warnings-clean.
  
  Any time I see a warning from my code, that indicates a mistake.
  
  Any time my code encounters a mistake, I want a crash -- not spew to STDERR
  and then unknown (and probably undesired) subsequent behaviour.
  
  I also want to ensure that obvious coding mistakes, like indirect object
  syntax (and not so obvious mistakes that cause things to accidentally compile
  as such) get caught, but not at the cost of an XS dependency and not at the
  cost of blowing things up on another machine.
  
  Therefore, L<strictures> turns on additional checking, but only when it thinks
  it's running in a test file in a VCS checkout -- although if this causes
  undesired behaviour this can be overridden by setting the
  C<PERL_STRICTURES_EXTRA> environment variable.
  
  If additional useful author side checks come to mind, I'll add them to the
  C<PERL_STRICTURES_EXTRA> code path only -- this will result in a minor version increase (e.g.
  1.000000 to 1.001000 (1.1.0) or similar). Any fixes only to the mechanism of
  this code will result in a sub-version increase (e.g. 1.000000 to 1.000001
  (1.0.1)).
  
  If the behaviour of C<use strictures> in normal mode changes in any way, that
  will constitute a major version increase -- and the code already checks
  when its version is tested to ensure that
  
    use strictures 1;
  
  will continue to only introduce the current set of strictures even if 2.0 is
  installed.
  
  =head1 METHODS
  
  =head2 import
  
  This method does the setup work described above in L</DESCRIPTION>
  
  =head2 VERSION
  
  This method traps the C<< strictures->VERSION(1) >> call produced by a use line
  with a version number on it and does the version check.
  
  =head1 EXTRA TESTING RATIONALE
  
  Every so often, somebody complains that they're deploying via C<git pull>
  and that they don't want L<strictures> to enable itself in this case -- and that
  setting C<PERL_STRICTURES_EXTRA> to 0 isn't acceptable (additional ways to
  disable extra testing would be welcome but the discussion never seems to get
  that far).
  
  In order to allow us to skip a couple of stages and get straight to a
  productive conversation, here's my current rationale for turning the
  extra testing on via a heuristic:
  
  The extra testing is all stuff that only ever blows up at compile time;
  this is intentional. So the oft-raised concern that it's different code being
  tested is only sort of the case -- none of the modules involved affect the
  final optree to my knowledge, so the author gets some additional compile
  time crashes which he/she then fixes, and the rest of the testing is
  completely valid for all environments.
  
  The point of the extra testing -- especially C<no indirect> -- is to catch
  mistakes that newbie users won't even realise are mistakes without
  help. For example,
  
    foo { ... };
  
  where foo is an & prototyped sub that you forgot to import -- this is
  pernicious to track down since all I<seems> fine until it gets called
  and you get a crash. Worse still, you can fail to have imported it due
  to a circular require, at which point you have a load order dependent
  bug which I've seen before now I<only> show up in production due to tiny
  differences between the production and the development environment. I wrote
  L<http://shadow.cat/blog/matt-s-trout/indirect-but-still-fatal/> to explain
  this particular problem before L<strictures> itself existed.
  
  As such, in my experience so far L<strictures>' extra testing has
  I<avoided> production versus development differences, not caused them.
  
  Additionally, L<strictures>' policy is very much "try and provide as much
  protection as possible for newbies -- who won't think about whether there's
  an option to turn on or not" -- so having only the environment variable
  is not sufficient to achieve that (I get to explain that you need to add
  C<use strict> at least once a week on freenode #perl -- newbies sometimes
  completely skip steps because they don't understand that that step
  is important).
  
  I make no claims that the heuristic is perfect -- it's already been evolved
  significantly over time, especially for 1.004 where we changed things to
  ensure it only fires on files in your checkout (rather than L<strictures>-using
  modules you happened to have installed, which was just silly). However, I
  hope the above clarifies why a heuristic approach is not only necessary but
  desirable from a point of view of providing new users with as much safety as possible,
  and will allow any future discussion on the subject to focus on "how do we
  minimise annoyance to people deploying from checkouts intentionally".
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<indirect>
  
  =item *
  
  L<multidimensional>
  
  =item *
  
  L<bareword::filehandles>
  
  =back
  
  =head1 COMMUNITY AND SUPPORT
  
  =head2 IRC channel
  
  irc.perl.org #toolchain
  
  (or bug 'mst' in query on there or freenode)
  
  =head2 Git repository
  
  Gitweb is on http://git.shadowcat.co.uk/ and the clone URL is:
  
    git clone git://git.shadowcat.co.uk/p5sagit/strictures.git
  
  The web interface to the repository is at:
  
    http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=p5sagit/strictures.git
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@gmail.com>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the strictures L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
STRICTURES

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR';
  package Class::XSAccessor;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor::Heavy;
  use XSLoader;
  
  our $VERSION = '1.19';
  
  XSLoader::load('Class::XSAccessor', $VERSION);
  
  sub _make_hash {
    my $ref = shift;
  
    if (ref ($ref)) {
      if (ref($ref) eq 'ARRAY') {
        $ref = { map { $_ => $_ } @$ref }
      } 
    } else {
      $ref = { $ref, $ref };
    }
  
    return $ref;
  }
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    # TODO: Refactor. Move more duplicated code to ::Heavy
    my $read_subs      = _make_hash($opts{getters} || {});
    my $set_subs       = _make_hash($opts{setters} || {});
    my $acc_subs       = _make_hash($opts{accessors} || {});
    my $lvacc_subs     = _make_hash($opts{lvalue_accessors} || {});
    my $pred_subs      = _make_hash($opts{predicates} || {});
    my $ex_pred_subs   = _make_hash($opts{exists_predicates} || {});
    my $def_pred_subs  = _make_hash($opts{defined_predicates} || {});
    my $test_subs      = _make_hash($opts{__tests__} || {});
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["test", $test_subs],
                          ["ex_predicate", $ex_pred_subs],
                          ["def_predicate", $def_pred_subs],
                          ["def_predicate", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $hashkey = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $hashkey, \%opts, $subtype->[0]);
      }
    }
  
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $hashkey, $opts, $type) = @_;
  
    croak("Cannot use undef as a hash key for generating an XS $type accessor. (Sub: $subname)")
      if not defined $hashkey;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $hashkey);
    }
    elsif ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $hashkey);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $hashkey, $opts->{chained}||0);
    }
    elsif ($type eq 'def_predicate') {
      newxs_defined_predicate($subname, $hashkey);
    }
    elsif ($type eq 'ex_predicate') {
      newxs_exists_predicate($subname, $hashkey);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      newxs_boolean($subname, 0);
    }
    elsif ($type eq 'test') {
      newxs_test($subname, $hashkey);
    }
    else {
      newxs_accessor($subname, $hashkey, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Class::XSAccessor
      replace     => 1,   # Replace existing methods (if any)
      constructor => 'new',
      getters     => {
        get_foo => 'foo', # 'foo' is the hash key to access
        get_bar => 'bar',
      },
      setters => {
        set_foo => 'foo',
        set_bar => 'bar',
      },
      accessors => {
        foo => 'foo',
        bar => 'bar',
      },
      # "predicates" is an alias for "defined_predicates"
      defined_predicates => {
        defined_foo => 'foo',
        defined_bar => 'bar',
      },
      exists_predicates => {
        has_foo => 'foo',
        has_bar => 'bar',
      },
      lvalue_accessors => { # see below
        baz => 'baz', # ...
      },
      true  => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference, if preferred,
    # which can also help Perl::Tidy to format the statement correctly.
    use Class::XSAccessor {
       # If the name => key values are always identical,
       # the following shorthand can be used.
       accessors => [ 'foo', 'bar' ],
    };
  
  =head1 DESCRIPTION
  
  Class::XSAccessor implements fast read, write and read/write accessors in XS.
  Additionally, it can provide predicates such as C<has_foo()> for testing
  whether the attribute C<foo> exists in the object (which is different from
  "is defined within the object").
  It only works with objects that are implemented as ordinary hashes.
  L<Class::XSAccessor::Array> implements the same interface for objects
  that use arrays for their internal representation.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS). Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless { @_ }, ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Parameters to C<new()> are added to the
  object.
  
  The XS accessor methods are between 3 and 4 times faster than typical
  pure-Perl accessors in some simple benchmarking.
  The lower factor applies to the potentially slightly obscure
  C<sub set_foo_pp {$_[0]-E<gt>{foo} = $_[1]}>, so if you usually
  write clear code, a factor of 3.5 speed-up is a good estimate.
  If in doubt, do your own benchmarking!
  
  The method names may be fully qualified. The example in the synopsis could
  have been written as C<MyClass::get_foo> instead
  of C<get_foo>. This way, methods can be installed in classes other
  than the current class. See also: the C<class> option below.
  
  By default, the setters return the new value that was set,
  and the accessors (mutators) do the same. This behaviour can be changed
  with the C<chained> option - see below. The predicates return a boolean.
  
  Since version 1.01, C<Class::XSAccessor> can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then consider a large class hierarchy
  with interfaces such as L<PPI>. These methods are provided by the C<true>
  and C<false> options - see the synopsis.
  
  C<defined_predicates> check whether a given object attribute is defined.
  C<predicates> is an alias for C<defined_predicates> for compatibility with
  older versions of C<Class::XSAccessor>. C<exists_predicates> checks
  whether the given attribute exists in the object using C<exists>.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, additional options
  can be supplied which modify behaviour. The options are specified as key/value pairs
  in the same manner as the accessor declaration. For example:
  
    use Class::XSAccessor
      getters => {
        get_foo => 'foo',
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. The
  the C<class> option allows the target class to be specified.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 'zip' };
    
    package main;
    my $address = Address->new(zip => 2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably won't work for objects based on I<tied> hashes. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  that's only known at run-time. Note that compiling C code at run-time a la L<Inline::C|Inline::C>
  is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed>. Previously, a small amount of
  memory would leak if C<Class::XSAccessor>-based classes were loaded in a subthread without having
  been loaded in the "main" thread. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation, as of 1.00, the memory will still not be released, in the same situation,
  but it will be recycled when the same class, or a similar class, is loaded again in B<any> thread.
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<Class::XSAccessor::Array>
  
  =item * L<AutoXS>
  
  =back
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_ARRAY';
  package Class::XSAccessor::Array;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor;
  use Class::XSAccessor::Heavy;
  
  our $VERSION = '1.19';
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    my $read_subs      = $opts{getters} || {};
    my $set_subs       = $opts{setters} || {};
    my $acc_subs       = $opts{accessors} || {};
    my $lvacc_subs     = $opts{lvalue_accessors} || {};
    my $pred_subs      = $opts{predicates} || {};
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];  
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["pred_subs", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $array_index = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $array_index, \%opts, $subtype->[0]);
      }
    }
     
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $array_index, $opts, $type) = @_;
  
    croak("Cannot use undef as a array index for generating an XS $type accessor. (Sub: $subname)")
      if not defined $array_index;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $array_index);
    }
    if ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $array_index);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $array_index, $opts->{chained}||0);
    }
    elsif ($type eq 'predicate') {
      newxs_predicate($subname, $array_index);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      Class::XSAccessor::newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      Class::XSAccessor::newxs_boolean($subname, 0);
    }
    else {
      newxs_accessor($subname, $array_index, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Array - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
    
    package MyClassUsingArraysAsInternalStorage;
    use Class::XSAccessor::Array
      constructor => 'new',
      getters => {
        get_foo => 0, # 0 is the array index to access
        get_bar => 1,
      },
      setters => {
        set_foo => 0,
        set_bar => 1,
      },
      accessors => { # a mutator
        buz => 2,
      },
      predicates => { # test for definedness
        has_buz => 2,
      },
      lvalue_accessors => { # see below
        baz => 3,
      },
      true => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference if you prefer it,
    # which can also help PerlTidy to flow the statement correctly.
    use Class::XSAccessor {
      getters => {
        get_foo => 0,
        get_bar => 1,
      },
    };
  
  =head1 DESCRIPTION
  
  The module implements fast XS accessors both for getting at and
  setting an object attribute. Additionally, the module supports
  mutators and simple predicates (C<has_foo()> like tests for definedness
  of an attributes).
  The module works only with objects
  that are implemented as B<arrays>. Using it on hash-based objects is
  bound to make your life miserable. Refer to L<Class::XSAccessor> for
  an implementation that works with hash-based objects.
  
  A simple benchmark showed a significant performance
  advantage over writing accessors in Perl.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS) for you. Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless [], ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Note that any parameters to new() will be
  discarded! If there is a better idiom for array-based objects, let
  me know.
  
  While generally more obscure than hash-based objects,
  objects using blessed arrays as internal representation
  are a bit faster as its somewhat faster to access arrays than hashes.
  Accordingly, this module is slightly faster (~10-15%) than
  L<Class::XSAccessor>, which works on hash-based objects.
  
  The method names may be fully qualified. In the example of the
  synopsis, you could have written C<MyClass::get_foo> instead
  of C<get_foo>. This way, you can install methods in classes other
  than the current class. See also: The C<class> option below.
  
  Since version 1.01, you can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then think of a large class hierarchy
  with interfaces such as PPI. This is implemented as the C<true>
  and C<false> options, see synopsis.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, you can add options
  which modify behaviour. The options are specified as key/value pairs just as the
  accessor declaration. Example:
  
    use Class::XSAccessor::Array
      getters => {
        get_foo => 0,
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor::Array> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor::Array ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. Using
  the C<class> option, you can explicitly specify where the methods
  are to be generated.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 0 };
    
    package main;
    my $address = Address->new(2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably wouldn't work if your objects are I<tied>. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  or array index that's only known at run-time. Note that compiling C code at run-time
  a la Inline::C is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed> that would leak a small amount of
  memory if you loaded C<Class::XSAccessor>-based classes in a subthread that hadn't been loaded
  in the "main" thread before. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation as of 1.00, the memory will not be released again either in the above
  situation. But it will be recycled when the same class or a similar class is loaded
  again in B<any> thread.
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  
  L<AutoXS>
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_ARRAY

$fatpacked{"x86_64-linux-thread-multi/Class/XSAccessor/Heavy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_HEAVY';
  package # hide from PAUSE
      Class::XSAccessor::Heavy;
  
  use 5.008;
  use strict;
  use warnings;
  use Carp;
  
  our $VERSION  = '1.19';
  our @CARP_NOT = qw(
          Class::XSAccessor
          Class::XSAccessor::Array
  );
  
  # TODO Move more duplicated code from XSA and XSA::Array here
  
  
  sub check_sub_existence {
    my $subname = shift;
  
    my $sub_package = $subname;
    $sub_package =~ s/([^:]+)$// or die;
    my $bare_subname = $1;
      
    my $sym;
    {
      no strict 'refs';
      $sym = \%{"$sub_package"};
    }
    no warnings;
    local *s = $sym->{$bare_subname};
    my $coderef = *s{CODE};
    if ($coderef) {
      $sub_package =~ s/::$//;
      Carp::croak("Cannot replace existing subroutine '$bare_subname' in package '$sub_package' with an XS implementation. If you wish to force a replacement, add the 'replace => 1' parameter to the arguments of 'use ".(caller())[0]."'.");
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Heavy - Guts you don't care about
  
  =head1 SYNOPSIS
    
    use Class::XSAccessor!
  
  =head1 DESCRIPTION
  
  Common guts for Class::XSAccessor and Class::XSAccessor::Array.
  No user-serviceable parts inside!
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  L<Class::XSAccessor::Array>
  
  =head1 AUTHOR
  
  Steffen Mueller, E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy, E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
  
X86_64-LINUX-THREAD-MULTI_CLASS_XSACCESSOR_HEAVY

$fatpacked{"Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_CWD';
  package Cwd;
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
  
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.40';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  eval {
    if ( $] >= 5.006 ) {
      require XSLoader;
      XSLoader::load( __PACKAGE__, $xs_version);
    } else {
      require DynaLoader;
      push @ISA, 'DynaLoader';
      __PACKAGE__->bootstrap( $xs_version );
    }
  };
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  foreach my $try ('/bin/pwd',
  		 '/usr/bin/pwd',
  		 '/QOpenSys/bin/pwd', # OS/400 PASE.
  		) {
  
      if( -x $try ) {
          $pwd_cmd = $try;
          last;
      }
  }
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if somenone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
      # Localize %ENV entries in a way that won't create new hash keys
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV);
      local @ENV{@localize};
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      $newdir =~ s|///*|/|g unless $^O eq 'MSWin32';
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      $ENV{'PWD'} = `cmd /c cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd_simple {
      $ENV{'PWD'} = `cd`;
      chomp $ENV{'PWD'};
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  sub _win32_cwd {
      # Need to avoid taking any sort of reference to the typeglob or the code in
      # the optree, so that this tests the runtime state of things, as the
      # ExtUtils::MakeMaker tests for "miniperl" need to be able to fake things at
      # runtime by deleting the subroutine. *foo{THING} syntax on a symbol table
      # lookup avoids needing a string eval, which has been reported to cause
      # problems (for reasons that we haven't been able to get to the bottom of -
      # rt.cpan.org #56225)
      if (*{$DynaLoader::{boot_DynaLoader}}{CODE}) {
  	$ENV{'PWD'} = Win32::GetCwd();
      }
      else { # miniperl
  	chomp($ENV{'PWD'} = `cd`);
      }
      $ENV{'PWD'} =~ s:\\:/:g ;
      return $ENV{'PWD'};
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      if (!defined &Dos::GetCwd) {
          $ENV{'PWD'} = `command /c cd`;
          chomp $ENV{'PWD'};
          $ENV{'PWD'} =~ s:\\:/:g ;
      } else {
          $ENV{'PWD'} = Dos::GetCwd();
      }
      return $ENV{'PWD'};
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      $ENV{'PWD'} = `/usr/bin/fullpath -t`;
      chomp $ENV{'PWD'};
      return $ENV{'PWD'};
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      $ENV{'PWD'} = EPOC::getcwd();
      return $ENV{'PWD'};
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
X86_64-LINUX-THREAD-MULTI_CWD

$fatpacked{"x86_64-linux-thread-multi/Digest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_DIGEST';
  package Digest;
  
  use strict;
  use vars qw($VERSION %MMAP $AUTOLOAD);
  
  $VERSION = "1.10";
  
  %MMAP = (
    "SHA-1"      => ["Digest::SHA1", ["Digest::SHA", 1], ["Digest::SHA2", 1]],
    "SHA-256"    => [["Digest::SHA", 256], ["Digest::SHA2", 256]],
    "SHA-384"    => [["Digest::SHA", 384], ["Digest::SHA2", 384]],
    "SHA-512"    => [["Digest::SHA", 512], ["Digest::SHA2", 512]],
    "HMAC-MD5"   => "Digest::HMAC_MD5",
    "HMAC-SHA-1" => "Digest::HMAC_SHA1",
    "CRC-16"     => [["Digest::CRC", type => "crc16"]],
    "CRC-32"     => [["Digest::CRC", type => "crc32"]],
    "CRC-CCITT"  => [["Digest::CRC", type => "crcccitt"]],
  );
  
  sub new
  {
      shift;  # class ignored
      my $algorithm = shift;
      my $impl = $MMAP{$algorithm} || do {
  	$algorithm =~ s/\W+//;
  	"Digest::$algorithm";
      };
      $impl = [$impl] unless ref($impl);
      my $err;
      for  (@$impl) {
  	my $class = $_;
  	my @args;
  	($class, @args) = @$class if ref($class);
  	no strict 'refs';
  	unless (exists ${"$class\::"}{"VERSION"}) {
  	    eval "require $class";
  	    if ($@) {
  		$err ||= $@;
  		next;
  	    }
  	}
  	return $class->new(@args, @_);
      }
      die $err;
  }
  
  sub AUTOLOAD
  {
      my $class = shift;
      my $algorithm = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      $class->new($algorithm, @_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Digest - Modules that calculate message digests
  
  =head1 SYNOPSIS
  
    $md5  = Digest->new("MD5");
    $sha1 = Digest->new("SHA-1");
    $sha256 = Digest->new("SHA-256");
    $sha384 = Digest->new("SHA-384");
    $sha512 = Digest->new("SHA-512");
  
    $hmac = Digest->HMAC_MD5($key);
  
  =head1 DESCRIPTION
  
  The C<Digest::> modules calculate digests, also called "fingerprints"
  or "hashes", of some data, called a message.  The digest is (usually)
  some small/fixed size string.  The actual size of the digest depend of
  the algorithm used.  The message is simply a sequence of arbitrary
  bytes or bits.
  
  An important property of the digest algorithms is that the digest is
  I<likely> to change if the message change in some way.  Another
  property is that digest functions are one-way functions, i.e. it
  should be I<hard> to find a message that correspond to some given
  digest.  Algorithms differ in how "likely" and how "hard", as well as
  how efficient they are to compute.
  
  All C<Digest::> modules provide the same programming interface.  A
  functional interface for simple use, as well as an object oriented
  interface that can handle messages of arbitrary length and which can
  read files directly.
  
  The digest can be delivered in three formats:
  
  =over 8
  
  =item I<binary>
  
  This is the most compact form, but it is not well suited for printing
  or embedding in places that can't handle arbitrary data.
  
  =item I<hex>
  
  A twice as long string of lowercase hexadecimal digits.
  
  =item I<base64>
  
  A string of portable printable characters.  This is the base64 encoded
  representation of the digest with any trailing padding removed.  The
  string will be about 30% longer than the binary version.
  L<MIME::Base64> tells you more about this encoding.
  
  =back
  
  
  The functional interface is simply importable functions with the same
  name as the algorithm.  The functions take the message as argument and
  return the digest.  Example:
  
    use Digest::MD5 qw(md5);
    $digest = md5($message);
  
  There are also versions of the functions with "_hex" or "_base64"
  appended to the name, which returns the digest in the indicated form.
  
  =head1 OO INTERFACE
  
  The following methods are available for all C<Digest::> modules:
  
  =over 4
  
  =item $ctx = Digest->XXX($arg,...)
  
  =item $ctx = Digest->new(XXX => $arg,...)
  
  =item $ctx = Digest::XXX->new($arg,...)
  
  The constructor returns some object that encapsulate the state of the
  message-digest algorithm.  You can add data to the object and finally
  ask for the digest.  The "XXX" should of course be replaced by the proper
  name of the digest algorithm you want to use.
  
  The two first forms are simply syntactic sugar which automatically
  load the right module on first use.  The second form allow you to use
  algorithm names which contains letters which are not legal perl
  identifiers, e.g. "SHA-1".  If no implementation for the given algorithm
  can be found, then an exception is raised.
  
  If new() is called as an instance method (i.e. $ctx->new) it will just
  reset the state the object to the state of a newly created object.  No
  new object is created in this case, and the return value is the
  reference to the object (i.e. $ctx).
  
  =item $other_ctx = $ctx->clone
  
  The clone method creates a copy of the digest state object and returns
  a reference to the copy.
  
  =item $ctx->reset
  
  This is just an alias for $ctx->new.
  
  =item $ctx->add( $data, ... )
  
  The $data provided as argument are appended to the message we
  calculate the digest for.  The return value is the $ctx object itself.
  
  =item $ctx->addfile( $io_handle )
  
  The $io_handle is read until EOF and the content is appended to the
  message we calculate the digest for.  The return value is the $ctx
  object itself.
  
  =item $ctx->add_bits( $data, $nbits )
  
  =item $ctx->add_bits( $bitstring )
  
  The bits provided are appended to the message we calculate the digest
  for.  The return value is the $ctx object itself.
  
  The two argument form of add_bits() will add the first $nbits bits
  from data.  For the last potentially partial byte only the high order
  C<< $nbits % 8 >> bits are used.  If $nbits is greater than C<<
  length($data) * 8 >>, then this method would do the same as C<<
  $ctx->add($data) >>, i.e. $nbits is silently ignored.
  
  The one argument form of add_bits() takes a $bitstring of "1" and "0"
  chars as argument.  It's a shorthand for C<< $ctx->add_bits(pack("B*",
  $bitstring), length($bitstring)) >>.
  
  This example shows two calls that should have the same effect:
  
     $ctx->add_bits("111100001010");
     $ctx->add_bits("\xF0\xA0", 12);
  
  Most digest algorithms are byte based.  For those it is not possible
  to add bits that are not a multiple of 8, and the add_bits() method
  will croak if you try.
  
  =item $ctx->digest
  
  Return the binary digest for the message.
  
  Note that the C<digest> operation is effectively a destructive,
  read-once operation. Once it has been performed, the $ctx object is
  automatically C<reset> and can be used to calculate another digest
  value.  Call $ctx->clone->digest if you want to calculate the digest
  without reseting the digest state.
  
  =item $ctx->hexdigest
  
  Same as $ctx->digest, but will return the digest in hexadecimal form.
  
  =item $ctx->b64digest
  
  Same as $ctx->digest, but will return the digest as a base64 encoded
  string.
  
  =back
  
  =head1 Digest speed
  
  This table should give some indication on the relative speed of
  different algorithms.  It is sorted by throughput based on a benchmark
  done with of some implementations of this API:
  
   Algorithm      Size    Implementation                  MB/s
  
   MD4            128     Digest::MD4 v1.3               165.0
   MD5            128     Digest::MD5 v2.33               98.8
   SHA-256        256     Digest::SHA2 v1.1.0             66.7
   SHA-1          160     Digest::SHA v4.3.1              58.9
   SHA-1          160     Digest::SHA1 v2.10              48.8
   SHA-256        256     Digest::SHA v4.3.1              41.3
   Haval-256      256     Digest::Haval256 v1.0.4         39.8
   SHA-384        384     Digest::SHA2 v1.1.0             19.6
   SHA-512        512     Digest::SHA2 v1.1.0             19.3
   SHA-384        384     Digest::SHA v4.3.1              19.2
   SHA-512        512     Digest::SHA v4.3.1              19.2
   Whirlpool      512     Digest::Whirlpool v1.0.2        13.0
   MD2            128     Digest::MD2 v2.03                9.5
  
   Adler-32        32     Digest::Adler32 v0.03            1.3
   CRC-16          16     Digest::CRC v0.05                1.1
   CRC-32          32     Digest::CRC v0.05                1.1
   MD5            128     Digest::Perl::MD5 v1.5           1.0
   CRC-CCITT       16     Digest::CRC v0.05                0.8
  
  These numbers was achieved Apr 2004 with ActivePerl-5.8.3 running
  under Linux on a P4 2.8 GHz CPU.  The last 5 entries differ by being
  pure perl implementations of the algorithms, which explains why they
  are so slow.
  
  =head1 SEE ALSO
  
  L<Digest::Adler32>, L<Digest::CRC>, L<Digest::Haval256>,
  L<Digest::HMAC>, L<Digest::MD2>, L<Digest::MD4>, L<Digest::MD5>,
  L<Digest::SHA>, L<Digest::SHA1>, L<Digest::SHA2>, L<Digest::Whirlpool>
  
  New digest implementations should consider subclassing from L<Digest::base>.
  
  L<MIME::Base64>
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@aas.no>
  
  The C<Digest::> interface is based on the interface originally
  developed by Neil Winton for his C<MD5> module.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
      Copyright 1998-2001,2003-2004 Gisle Aas.
      Copyright 1995-1996 Neil Winton.
  
  =cut
X86_64-LINUX-THREAD-MULTI_DIGEST

$fatpacked{"x86_64-linux-thread-multi/Digest/SHA1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_DIGEST_SHA1';
  package Digest::SHA1;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = '2.13';
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT_OK = qw(sha1 sha1_hex sha1_base64 sha1_transform);
  
  require DynaLoader;
  @ISA=qw(DynaLoader);
  
  eval {
      require Digest::base;
      push(@ISA, 'Digest::base');
  };
  if ($@) {
      my $err = $@;
      *add_bits = sub { die $err };
  }
  
  Digest::SHA1->bootstrap($VERSION);
  
  1;
  __END__
  
  =head1 NAME
  
  Digest::SHA1 - Perl interface to the SHA-1 algorithm
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::SHA1  qw(sha1 sha1_hex sha1_base64);
  
   $digest = sha1($data);
   $digest = sha1_hex($data);
   $digest = sha1_base64($data);
   $digest = sha1_transform($data);
  
  
   # OO style
   use Digest::SHA1;
  
   $sha1 = Digest::SHA1->new;
  
   $sha1->add($data);
   $sha1->addfile(*FILE);
  
   $sha1_copy = $sha1->clone;
  
   $digest = $sha1->digest;
   $digest = $sha1->hexdigest;
   $digest = $sha1->b64digest;
   $digest = $sha1->transform;
  
  =head1 DESCRIPTION
  
  The C<Digest::SHA1> module allows you to use the NIST SHA-1 message
  digest algorithm from within Perl programs.  The algorithm takes as
  input a message of arbitrary length and produces as output a 160-bit
  "fingerprint" or "message digest" of the input.
  
  In 2005, security flaws were identified in SHA-1, namely that a possible
  mathematical weakness might exist, indicating that a stronger hash function
  would be desirable.  The L<Digest::SHA> module implements the stronger
  algorithms in the SHA family.
  
  The C<Digest::SHA1> module provide a procedural interface for simple
  use, as well as an object oriented interface that can handle messages
  of arbitrary length and which can read files directly.
  
  =head1 FUNCTIONS
  
  The following functions can be exported from the C<Digest::SHA1>
  module.  No functions are exported by default.
  
  =over 4
  
  =item sha1($data,...)
  
  This function will concatenate all arguments, calculate the SHA-1
  digest of this "message", and return it in binary form.  The returned
  string will be 20 bytes long.
  
  The result of sha1("a", "b", "c") will be exactly the same as the
  result of sha1("abc").
  
  =item sha1_hex($data,...)
  
  Same as sha1(), but will return the digest in hexadecimal form.  The
  length of the returned string will be 40 and it will only contain
  characters from this set: '0'..'9' and 'a'..'f'.
  
  =item sha1_base64($data,...)
  
  Same as sha1(), but will return the digest as a base64 encoded string.
  The length of the returned string will be 27 and it will only contain
  characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+' and
  '/'.
  
  Note that the base64 encoded string returned is not padded to be a
  multiple of 4 bytes long.  If you want interoperability with other
  base64 encoded sha1 digests you might want to append the redundant
  string "=" to the result.
  
  =item sha1_transform($data)
  
  Implements the basic SHA1 transform on a 64 byte block. The $data
  argument and the returned $digest are in binary form. This algorithm
  is used in NIST FIPS 186-2
  
  =back
  
  =head1 METHODS
  
  The object oriented interface to C<Digest::SHA1> is described in this
  section.  After a C<Digest::SHA1> object has been created, you will add
  data to it and finally ask for the digest in a suitable format.  A
  single object can be used to calculate multiple digests.
  
  The following methods are provided:
  
  =over 4
  
  =item $sha1 = Digest::SHA1->new
  
  The constructor returns a new C<Digest::SHA1> object which encapsulate
  the state of the SHA-1 message-digest algorithm.
  
  If called as an instance method (i.e. $sha1->new) it will just reset the
  state the object to the state of a newly created object.  No new
  object is created in this case.
  
  =item $sha1->reset
  
  This is just an alias for $sha1->new.
  
  =item $sha1->clone
  
  This a copy of the $sha1 object. It is useful when you do not want to
  destroy the digests state, but need an intermediate value of the
  digest, e.g. when calculating digests iteratively on a continuous data
  stream.  Example:
  
      my $sha1 = Digest::SHA1->new;
      while (<>) {
  	$sha1->add($_);
  	print "Line $.: ", $sha1->clone->hexdigest, "\n";
      }
  
  =item $sha1->add($data,...)
  
  The $data provided as argument are appended to the message we
  calculate the digest for.  The return value is the $sha1 object itself.
  
  All these lines will have the same effect on the state of the $sha1
  object:
  
      $sha1->add("a"); $sha1->add("b"); $sha1->add("c");
      $sha1->add("a")->add("b")->add("c");
      $sha1->add("a", "b", "c");
      $sha1->add("abc");
  
  =item $sha1->addfile($io_handle)
  
  The $io_handle will be read until EOF and its content appended to the
  message we calculate the digest for.  The return value is the $sha1
  object itself.
  
  The addfile() method will croak() if it fails reading data for some
  reason.  If it croaks it is unpredictable what the state of the $sha1
  object will be in. The addfile() method might have been able to read
  the file partially before it failed.  It is probably wise to discard
  or reset the $sha1 object if this occurs.
  
  In most cases you want to make sure that the $io_handle is in
  C<binmode> before you pass it as argument to the addfile() method.
  
  =item $sha1->add_bits($data, $nbits)
  
  =item $sha1->add_bits($bitstring)
  
  This implementation of SHA-1 only supports byte oriented input so you
  might only add bits as multiples of 8.  If you need bit level support
  please consider using the C<Digest::SHA> module instead.  The
  add_bits() method is provided here for compatibility with other digest
  implementations.  See L<Digest> for description of the arguments that
  add_bits() take.
  
  =item $sha1->digest
  
  Return the binary digest for the message.  The returned string will be
  20 bytes long.
  
  Note that the C<digest> operation is effectively a destructive,
  read-once operation. Once it has been performed, the C<Digest::SHA1>
  object is automatically C<reset> and can be used to calculate another
  digest value.  Call $sha1->clone->digest if you want to calculate the
  digest without reseting the digest state.
  
  =item $sha1->hexdigest
  
  Same as $sha1->digest, but will return the digest in hexadecimal
  form. The length of the returned string will be 40 and it will only
  contain characters from this set: '0'..'9' and 'a'..'f'.
  
  =item $sha1->b64digest
  
  Same as $sha1->digest, but will return the digest as a base64 encoded
  string.  The length of the returned string will be 27 and it will only
  contain characters from this set: 'A'..'Z', 'a'..'z', '0'..'9', '+'
  and '/'.
  
  
  The base64 encoded string returned is not padded to be a multiple of 4
  bytes long.  If you want interoperability with other base64 encoded
  SHA-1 digests you might want to append the string "=" to the result.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest>, L<Digest::HMAC_SHA1>, L<Digest::SHA>, L<Digest::MD5>
  
  http://www.itl.nist.gov/fipspubs/fip180-1.htm
  
  http://en.wikipedia.org/wiki/SHA_hash_functions
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 1999-2004 Gisle Aas.
   Copyright 1997 Uwe Hollerbach.
  
  =head1 AUTHORS
  
  Peter C. Gutmann,
  Uwe Hollerbach <uh@alumni.caltech.edu>,
  Gisle Aas <gisle@aas.no>
  
  =cut
X86_64-LINUX-THREAD-MULTI_DIGEST_SHA1

$fatpacked{"x86_64-linux-thread-multi/Digest/base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_DIGEST_BASE';
  package Digest::base;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "1.00";
  
  # subclass is supposed to implement at least these
  sub new;
  sub clone;
  sub add;
  sub digest;
  
  sub reset {
      my $self = shift;
      $self->new(@_);  # ugly
  }
  
  sub addfile {
      my ($self, $handle) = @_;
  
      my $n;
      my $buf = "";
  
      while (($n = read($handle, $buf, 4*1024))) {
          $self->add($buf);
      }
      unless (defined $n) {
  	require Carp;
  	Carp::croak("Read failed: $!");
      }
  
      $self;
  }
  
  sub add_bits {
      my $self = shift;
      my $bits;
      my $nbits;
      if (@_ == 1) {
  	my $arg = shift;
  	$bits = pack("B*", $arg);
  	$nbits = length($arg);
      }
      else {
  	($bits, $nbits) = @_;
      }
      if (($nbits % 8) != 0) {
  	require Carp;
  	Carp::croak("Number of bits must be multiple of 8 for this algorithm");
      }
      return $self->add(substr($bits, 0, $nbits/8));
  }
  
  sub hexdigest {
      my $self = shift;
      return unpack("H*", $self->digest(@_));
  }
  
  sub b64digest {
      my $self = shift;
      require MIME::Base64;
      my $b64 = MIME::Base64::encode($self->digest(@_), "");
      $b64 =~ s/=+$//;
      return $b64;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Digest::base - Digest base class
  
  =head1 SYNOPSIS
  
    package Digest::Foo;
    use base 'Digest::base';
  
  =head1 DESCRIPTION
  
  The C<Digest::base> class provide implementations of the methods
  C<addfile> and C<add_bits> in terms of C<add>, and of the methods
  C<hexdigest> and C<b64digest> in terms of C<digest>.
  
  Digest implementations might want to inherit from this class to get
  this implementations of the alternative I<add> and I<digest> methods.
  A minimal subclass needs to implement the following methods by itself:
  
      new
      clone
      add
      digest
  
  The arguments and expected behaviour of these methods are described in
  L<Digest>.
  
  =head1 SEE ALSO
  
  L<Digest>
X86_64-LINUX-THREAD-MULTI_DIGEST_BASE

$fatpacked{"x86_64-linux-thread-multi/Digest/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_DIGEST_FILE';
  package Digest::file;
  
  use strict;
  
  use Exporter ();
  use Carp qw(croak);
  use Digest ();
  
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = "0.01";
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(digest_file_ctx digest_file digest_file_hex digest_file_base64);
  
  sub digest_file_ctx {
      my $file = shift;
      croak("No digest algorithm specified") unless @_;
      local *F;
      open(F, $file) || croak("Can't open '$file': $!");
      binmode(F);
      my $ctx = Digest->new(@_);
      $ctx->addfile(*F);
      close(F);
      return $ctx;
  }
  
  sub digest_file {
      digest_file_ctx(@_)->digest;
  }
  
  sub digest_file_hex {
      digest_file_ctx(@_)->hexdigest;
  }
  
  sub digest_file_base64 {
      digest_file_ctx(@_)->b64digest;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Digest::file - Calculate digests of files
  
  =head1 SYNOPSIS
  
    # Poor mans "md5sum" command
    use Digest::file qw(digest_file_hex);
    for (@ARGV) {
        print digest_file_hex($_, "MD5"), "  $_\n";e
    }
  
  =head1 DESCRIPTION
  
  This module provide 3 convenience functions to calculate the digest
  of files.  The following functions are provided:
  
  =over
  
  =item digest_file( $file, $algorithm, [$arg,...] )
  
  This function will calculate and return the binary digest of the bytes
  of the given file.  The function will croak if it fails to open or
  read the file.
  
  The $algorithm is a string like "MD2", "MD5", "SHA-1", "SHA-512".
  Additional arguments are passed to the constructor for the
  implementation of the given algorithm.
  
  =item digest_file_hex( $file, $algorithm, [$arg,...] )
  
  Same as digest_file(), but return the digest in hex form.
  
  =item digest_file_base64( $file, $algorithm, [$arg,...] )
  
  Same as digest_file(), but return the digest as a base64 encoded
  string.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest>
X86_64-LINUX-THREAD-MULTI_DIGEST_FILE

$fatpacked{"File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_FILE_SPEC

$fatpacked{"File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '1.1';
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      $path =~ s|\\|/|g;
      return $self->SUPER::canonpath($path);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      C:/temp
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      $tmpdir = $self->_tmpdir( $ENV{TMPDIR}, "/tmp", 'C:/temp' );
  }
  
  =back
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_FILE_SPEC_CYGWIN

$fatpacked{"File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '1.1';
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still work in progress ;-)
  
  =head1 AUTHORS
  
  o.flebbe@gmx.de
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_FILE_SPEC_EPOC

$fatpacked{"File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '1.3';
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      *{$meth} = sub {&$sub('File::Spec', @_)};
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
X86_64-LINUX-THREAD-MULTI_FILE_SPEC_FUNCTIONS

$fatpacked{"File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '1.4';
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This descision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"              # can't go beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()         # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()         # can't go beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"  # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  descision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      $tmpdir = $self->_tmpdir( $ENV{TMPDIR} );
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");             # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");         # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");  # true (absolute)
      File::Spec->file_name_is_absolute("");              # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return ('') if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# igonore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_FILE_SPEC_MAC

$fatpacked{"File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '1.2';
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      $tmpdir = $self->_tmpdir( @ENV{qw(TMPDIR TEMP TMP)},
  			      '/tmp',
  			      '/'  );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =cut
X86_64-LINUX-THREAD-MULTI_FILE_SPEC_OS2

$fatpacked{"File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '1.5';
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # Handle network path names beginning with double slash (cygwin)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\z):/:s ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s@(/\.)+(/|\Z(?!\n))@/@g;             # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~ s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir () { '.' }
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull () { '/dev/null' }
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir () { '/' }
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub _tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      my @dirlist = @_;
      {
  	no strict 'refs';
  	if (${"\cTAINT"}) { # Check for taint mode on perl >= 5.8.0
              require Scalar::Util;
  	    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
  	}
      }
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      return $tmpdir;
  }
  
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      $tmpdir = $self->_tmpdir( $ENV{TMPDIR}, "/tmp" );
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir () { '..' }
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\Z(?!\n)/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant () { 0 }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\Z(?!\n) )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
      else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
          $base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      }
      else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path);
      my @basechunks = $self->splitdir( $base);
  
      while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      $path = CORE::join( '/', @pathchunks );
      $base = CORE::join( '/', @basechunks );
  
      # $base now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
      $base =~ s|[^/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
      if ( $path ne '' && $base ne '' ) {
          $path = "$base/$path" ;
      } else {
          $path = "$base$path" ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::cwd();
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_FILE_SPEC_UNIX

$fatpacked{"File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '1.4';
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item eliminate_macros
  
  Expands MM[KS]/Make macros in a text string, using the contents of
  identically named elements of C<%$self>, and returns the result
  as a file specification in Unix syntax.
  
  =cut
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless $path;
      $self = {} unless ref $self;
  
      if ($path =~ /\s/) {
        return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
      }
  
      my($npath) = unixify($path);
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
          if ($self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  =item fixpath
  
  Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  in any directory specification, in order to avoid juxtaposing two
  VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  are all macro, so that we can tell how long the expansion is, and avoid
  overrunning DCL's command buffer when MM[KS] is running.
  
  If optional second argument has a TRUE value, then the return string is
  a VMS-syntax directory specification, if it is FALSE, the return string
  is a VMS-syntax file specification, and if it is not specified, fixpath()
  checks to see whether it matches the name of a directory in the current
  default directory, and returns a directory or file specification accordingly.
  
  =cut
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {} unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ /\s/) {
        return join ' ',
               map { $self->fixpath($_,$force_path) }
  	     split /\s+/, $path;
      }
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
      $fixedpath;
  }
  
  =back
  
  =head2 Methods always loaded
  
  =over 4
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications according to VMS syntax.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
  
      if ($path =~ m|/|) { # Fake Unix
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
        if ($pathify) { return vmspath($path); }
        else          { return vmsify($path);  }
      }
      else {
  	$path =~ tr/<>/[]/;			# < and >       ==> [ and ]
  	$path =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
  	$path =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
  	$path =~ s/\[000000\./\[/g;		# [000000.	==> [
  	$path =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
  	$path =~ s/\.\]\[/\./g;			# foo.][bar     ==> foo.bar
  	1 while ($path =~ s/([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
  	1 while ($path =~ s/([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
  	$path =~ s/\[\.-/[-/;			# [.-		==> [-
  	$path =~ s/\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
  	$path =~ s/\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
  	$path =~ s/\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  	$path =~ s/\[[^\]\.]+\.-\]/\[\]/g;	# [foo.-]	==> []
  	$path =~ s/\[\]//;			# []		==>
  	return $path;
      }
  }
  
  =item catdir
  
  Concatenates a list of file specifications, and returns the result as a
  VMS-syntax directory specification.  No check is made for "impossible"
  cases (e.g. elements other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my ($self,@dirs) = @_;
      my $dir = pop @dirs;
      @dirs = grep($_,@dirs);
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//; $sdir =~ s/\.dir\Z(?!\n)//; 
  	$sdir = $self->eliminate_macros($sdir) unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
  	$rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
  
  	# Special case for VMS absolute directory specs: these will have had device
  	# prepended during trip through Unix syntax in eliminate_macros(), since
  	# Unix syntax has no way to express "absolute from the top of this device's
  	# directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
      }
      else {
  	if    (not defined $dir or not length $dir) { $rslt = ''; }
  	elsif ($dir =~ /^\$\([^\)]+\)\Z(?!\n)/s)          { $rslt = $dir; }
  	else                                        { $rslt = vmspath($dir); }
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile
  
  Concatenates a list of file specifications, and returns the result as a
  VMS-syntax file specification.
  
  =cut
  
  sub catfile {
      my ($self,@files) = @_;
      my $file = $self->canonpath(pop @files);
      @files = grep($_,@files);
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  	$spath =~ s/\.dir\Z(?!\n)//;
  	if ($spath =~ /^[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	}
  	else {
  	    $rslt = $self->eliminate_macros($spath);
  	    $rslt = vmsify($rslt.($rslt ? '/' : '').unixify($file));
  	}
      }
      else { $rslt = (defined($file) && length($file)) ? vmsify($file) : ''; }
      return $self->canonpath($rslt);
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]'
  
  =cut
  
  sub curdir {
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:'
  
  =cut
  
  sub devnull {
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  
  =cut
  
  sub rootdir {
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      sys$scratch:
      $ENV{TMPDIR}
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]'
  
  =cut
  
  sub updir {
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /:[^<\[]/);
  }
  
  =item splitpath (override)
  
  Splits using VMS syntax.
  
  =cut
  
  sub splitpath {
      my($self,$path) = @_;
      my($dev,$dir,$file) = ('','','');
  
      vmsify($path) =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
      return ($1 || '',$2 || '',$3);
  }
  
  =item splitdir (override)
  
  Split dirspec using VMS syntax.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      $dirspec =~ tr/<>/[]/;			# < and >	==> [ and ]
      $dirspec =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
      $dirspec =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
      $dirspec =~ s/\[000000\./\[/g;		# [000000.	==> [
      $dirspec =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
      $dirspec =~ s/\.\]\[/\./g;			# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /[\[<]/; # make legal
      my(@dirs) = split('\.', vmspath($dirspec));
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec using VMS syntax
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
        $dir = "[$dir]" unless $dir =~ /[\[<\/]/;
        $dir = vmspath($dir);
      }
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Use VMS syntax when converting filespecs.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      return vmspath(File::Spec::Unix::abs2rel( $self, @_ ))
          if grep m{/}, @_;
  
      my($path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      for ($path, $base) { $_ = $self->canonpath($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Use VMS syntax when converting filespecs.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
  	$path = ( -d $path || $path =~ m/\/\z/	# educated guessing about
  		   ? vmspath($path) 		# whether it's a directory
  		   : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  =back
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<"http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files">.
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_FILE_SPEC_VMS

$fatpacked{"File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '1.5';
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare (the File::Spec::Win32
  is used also for NetWare).
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      $tmpdir = $self->_tmpdir( @ENV{qw(TMPDIR TEMP TMP)},
  			      'SYS:/temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "\\" unless substr($dir,-1) eq "\\";
      return $dir.$file;
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[/][\\];
          # append a backslash to each argument unless it has one there
          $_ .= "\\" unless m{\\$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub path {
      my $path = $ENV{'PATH'} || $ENV{'Path'} || $ENV{'path'};
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      my $orig_path = $path;
      $path =~ s/^([a-z]:)/\u$1/s;
      $path =~ s|/|\\|g;
      $path =~ s|([^\\])\\+|$1\\|g;                  # xx\\\\xx  -> xx\xx
      $path =~ s|(\\\.)+\\|\\|g;                     # xx\.\.\xx -> xx\xx
      $path =~ s|^(\.\\)+||s unless $path eq ".\\";  # .\xx      -> xx
      $path =~ s|\\\Z(?!\n)||
  	unless $path =~ m{^([A-Z]:)?\\\Z(?!\n)}s;  # xx\       -> xx
      # xx1/xx2/xx3/../../xx -> xx1/xx
      $path =~ s|\\\.\.\.\\|\\\.\.\\\.\.\\|g; # \...\ is 2 levels up
      $path =~ s|^\.\.\.\\|\.\.\\\.\.\\|g;    # ...\ is 2 levels up
      return $path if $path =~ m|^\.\.|;      # skip relative paths
      return $path unless $path =~ /\.\./;    # too few .'s to cleanup
      return $path if $path =~ /\.\.\.\./;    # too many .'s to cleanup
      $path =~ s{^\\\.\.$}{\\};                      # \..    -> \
      1 while $path =~ s{^\\\.\.}{};                 # \..\xx -> \xx
  
      my ($vol,$dirs,$file) = $self->splitpath($path);
      my @dirs = $self->splitdir($dirs);
      my (@base_dirs, @path_dirs);
      my $dest = \@base_dirs;
      for my $dir (@dirs){
  	$dest = \@path_dirs if $dir eq $self->updir;
  	push @$dest, $dir;
      }
      # for each .. in @path_dirs pop one item from 
      # @base_dirs
      while (my $dir = shift @path_dirs){ 
  	unless ($dir eq $self->updir){
  	    unshift @path_dirs, $dir;
  	    last;
  	}
  	pop @base_dirs;
      }
      $path = $self->catpath( 
  			   $vol, 
  			   $self->catdir(@base_dirs, @path_dirs), 
  			   $file
  			  );
      return $path;
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      for ($path, $base) { $_ = $self->canonpath($_) }
  
      my ($path_volume) = $self->splitpath($path, 1);
      my ($base_volume) = $self->splitpath($base, 1);
  
      # Can't relativize across volumes
      return $path unless $path_volume eq $base_volume;
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      my $path_directories = ($self->splitpath($path, 1))[1];
      my $base_directories = ($self->splitpath($base, 1))[1];
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      my $result_dirs = $self->catdir( ($self->updir) x @basechunks, @pathchunks );
  
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    require Cwd ;
  	    $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
  	    $base = $self->_cwd() unless defined $base ;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_FILE_SPEC_WIN32

$fatpacked{"x86_64-linux-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle
    pairmap pairgrep pairfirst pairs pairkeys pairvalues
  );
  our $VERSION    = "1.38";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 $b = any { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  =head2 $b = all { BLOCK } @list
  
  Similar to C<any>, except that it requires all elements of the C<@list> to make
  the C<BLOCK> return true. If any element returns false, then it returns false.
  If the C<BLOCK> never returns false or the C<@list> was empty then it returns
  true.
  
  =head2 $b = none { BLOCK } @list
  
  =head2 $b = notall { BLOCK } @list
  
  Similar to C<any> and C<all>, but with the return sense inverted. C<none>
  returns true only if no value in the LIST causes the BLOCK to return true, and
  C<notall> returns true only if not all of the values do.
  
  =head2 $val = first { BLOCK } @list
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 $num = max @list
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 $str = maxstr @list
  
  Similar to C<max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 $num = min @list
  
  Similar to C<max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 $str = minstr @list
  
  Similar to C<min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 $num = product @list
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 $num_or_undef = sum @list
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 $num = sum0 @list
  
  Similar to C<sum>, except this returns 0 when given an empty list, rather than
  C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  =cut
  
  =head2 @kvlist = pairgrep { BLOCK } @kvlist
  
  =head2 $count = pairgrep { BLOCK } @kvlist
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 ( $key, $val ) = pairfirst { BLOCK } @kvlist
  
  =head2 $found = pairfirst { BLOCK } @kvlist
  
  Similar to the C<first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @list = pairmap { BLOCK } @kvlist
  
  =head2 $count = pairmap { BLOCK } @kvlist
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 @pairs = pairs @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of ARRAY references, each containing two items from the given
  list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach ( pairs @KVLIST ) {
         my ( $key, $value ) = @$_;
         ...
      }
  
  =head2 @keys = pairkeys @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 @values = pairvalues @kvlist
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 @values = shuffle @values
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =cut
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce will return
  an incorrect result. This will show up as test 7 of reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use List::Util;
  
  our $VERSION = "1.38";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-thread-multi/MIME/Base64.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MIME_BASE64';
  package MIME::Base64;
  
  # $Id: Base64.pm,v 3.5 2004/09/20 09:23:23 gisle Exp $
  
  use strict;
  use vars qw(@ISA @EXPORT $VERSION);
  
  require Exporter;
  require DynaLoader;
  @ISA = qw(Exporter DynaLoader);
  @EXPORT = qw(encode_base64 decode_base64);
  
  $VERSION = '3.05';
  
  MIME::Base64->bootstrap($VERSION);
  
  *encode = \&encode_base64;
  *decode = \&decode_base64;
  
  1;
  
  __END__
  
  =head1 NAME
  
  MIME::Base64 - Encoding and decoding of base64 strings
  
  =head1 SYNOPSIS
  
   use MIME::Base64;
  
   $encoded = encode_base64('Aladdin:open sesame');
   $decoded = decode_base64($encoded);
  
  =head1 DESCRIPTION
  
  This module provides functions to encode and decode strings into and from the
  base64 encoding specified in RFC 2045 - I<MIME (Multipurpose Internet
  Mail Extensions)>. The base64 encoding is designed to represent
  arbitrary sequences of octets in a form that need not be humanly
  readable. A 65-character subset ([A-Za-z0-9+/=]) of US-ASCII is used,
  enabling 6 bits to be represented per printable character.
  
  The following functions are provided:
  
  =over 4
  
  =item encode_base64($str)
  
  =item encode_base64($str, $eol);
  
  Encode data by calling the encode_base64() function.  The first
  argument is the string to encode.  The second argument is the
  line-ending sequence to use.  It is optional and defaults to "\n".  The
  returned encoded string is broken into lines of no more than 76
  characters each and it will end with $eol unless it is empty.  Pass an
  empty string as second argument if you do not want the encoded string
  to be broken into lines.
  
  =item decode_base64($str)
  
  Decode a base64 string by calling the decode_base64() function.  This
  function takes a single argument which is the string to decode and
  returns the decoded data.
  
  Any character not part of the 65-character base64 subset is
  silently ignored.  Characters occurring after a '=' padding character
  are never decoded.
  
  If the length of the string to decode, after ignoring
  non-base64 chars, is not a multiple of 4 or if padding occurs too early,
  then a warning is generated if perl is running under C<-w>.
  
  =back
  
  If you prefer not to import these routines into your namespace, you can
  call them as:
  
      use MIME::Base64 ();
      $encoded = MIME::Base64::encode($decoded);
      $decoded = MIME::Base64::decode($encoded);
  
  =head1 DIAGNOSTICS
  
  The following warnings can be generated if perl is invoked with the
  C<-w> switch:
  
  =over 4
  
  =item Premature end of base64 data
  
  The number of characters to decode is not a multiple of 4.  Legal
  base64 data should be padded with one or two "=" characters to make
  its length a multiple of 4.  The decoded result will anyway be as if
  the padding was there.
  
  =item Premature padding of base64 data
  
  The '=' padding character occurs as the first or second character
  in a base64 quartet.
  
  =back
  
  =head1 EXAMPLES
  
  If you want to encode a large file, you should encode it in chunks
  that are a multiple of 57 bytes.  This ensures that the base64 lines
  line up and that you do not end up with padding in the middle. 57
  bytes of data fills one complete base64 line (76 == 57*4/3):
  
     use MIME::Base64 qw(encode_base64);
  
     open(FILE, "/var/log/wtmp") or die "$!";
     while (read(FILE, $buf, 60*57)) {
         print encode_base64($buf);
     }
  
  or if you know you have enough memory
  
     use MIME::Base64 qw(encode_base64);
     local($/) = undef;  # slurp
     print encode_base64(<STDIN>);
  
  The same approach as a command line:
  
     perl -MMIME::Base64 -0777 -ne 'print encode_base64($_)' <file
  
  Decoding does not need slurp mode if every line contains a multiple
  of four base64 chars:
  
     perl -MMIME::Base64 -ne 'print decode_base64($_)' <file
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, 2001-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Distantly based on LWP::Base64 written by Martijn Koster
  <m.koster@nexor.co.uk> and Joerg Reichelt <j.reichelt@nexor.co.uk> and
  code posted to comp.lang.perl <3pd2lp$6gf@wsinti07.win.tue.nl> by Hans
  Mulder <hansm@wsinti07.win.tue.nl>
  
  The XS implementation uses code from metamail.  Copyright 1991 Bell
  Communications Research, Inc. (Bellcore)
  
  =head1 SEE ALSO
  
  L<MIME::QuotedPrint>
  
  =cut
X86_64-LINUX-THREAD-MULTI_MIME_BASE64

$fatpacked{"x86_64-linux-thread-multi/MIME/QuotedPrint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_MIME_QUOTEDPRINT';
  package MIME::QuotedPrint;
  
  # $Id: QuotedPrint.pm,v 3.4 2004/08/25 09:33:45 gisle Exp $
  
  use strict;
  use vars qw(@ISA @EXPORT $VERSION);
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(encode_qp decode_qp);
  
  $VERSION = "3.03";
  
  use MIME::Base64;  # will load XS version of {en,de}code_qp()
  
  *encode = \&encode_qp;
  *decode = \&decode_qp;
  
  1;
  
  __END__
  
  =head1 NAME
  
  MIME::QuotedPrint - Encoding and decoding of quoted-printable strings
  
  =head1 SYNOPSIS
  
   use MIME::QuotedPrint;
  
   $encoded = encode_qp($decoded);
   $decoded = decode_qp($encoded);
  
  =head1 DESCRIPTION
  
  This module provides functions to encode and decode strings into and from the
  quoted-printable encoding specified in RFC 2045 - I<MIME (Multipurpose
  Internet Mail Extensions)>.  The quoted-printable encoding is intended
  to represent data that largely consists of bytes that correspond to
  printable characters in the ASCII character set.  Each non-printable
  character (as defined by English Americans) is represented by a
  triplet consisting of the character "=" followed by two hexadecimal
  digits.
  
  The following functions are provided:
  
  =over 4
  
  =item encode_qp($str)
  
  =item encode_qp($str, $eol)
  
  =item encode_qp($str, $eol, $binmode)
  
  This function returns an encoded version of the string ($str) given as
  argument.
  
  The second argument ($eol) is the line-ending sequence to use.  It is
  optional and defaults to "\n".  Every occurrence of "\n" is replaced
  with this string, and it is also used for additional "soft line
  breaks" to ensure that no line end up longer than 76 characters.  Pass
  it as "\015\012" to produce data suitable for external consumption.
  The string "\r\n" produces the same result on many platforms, but not
  all.
  
  The third argument ($binmode) will select binary mode if passed as a
  TRUE value.  In binary mode "\n" will be encoded in the same way as
  any other non-printable character.  This ensures that a decoder will
  end up with exactly the same string whatever line ending sequence it
  uses.  In general it is preferable to use the base64 encoding for
  binary data; see L<MIME::Base64>.
  
  An $eol of "" (the empty string) is special.  In this case, no "soft
  line breaks" are introduced and binary mode is effectively enabled so
  that any "\n" in the original data is encoded as well.
  
  =item decode_qp($str);
  
  This function returns the plain text version of the string given
  as argument.  The lines of the result are "\n" terminated, even if
  the $str argument contains "\r\n" terminated lines.
  
  =back
  
  
  If you prefer not to import these routines into your namespace, you can
  call them as:
  
    use MIME::QuotedPrint ();
    $encoded = MIME::QuotedPrint::encode($decoded);
    $decoded = MIME::QuotedPrint::decode($encoded);
  
  Perl v5.6 and better allow extended Unicode characters in strings.
  Such strings cannot be encoded directly, as the quoted-printable
  encoding is only defined for single-byte characters.  The solution is to use the Encode
  module to select the byte encoding you want.  For example:
  
      use MIME::QuotedPrint qw(encode_qp);
      use Encode qw(encode);
  
      $encoded = encode_qp(encode("UTF-8", "\x{FFFF}\n"));
      print $encoded;
  
  =head1 COPYRIGHT
  
  Copyright 1995-1997,2002-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<MIME::Base64>
  
  =cut
X86_64-LINUX-THREAD-MULTI_MIME_QUOTEDPRINT

$fatpacked{"x86_64-linux-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype tainted
  );
  our $VERSION    = "1.38";
  $VERSION   = eval $VERSION;
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 $pkg = blessed( $ref )
  
  If C<$ref> is a blessed reference the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 $addr = refaddr( $ref )
  
  If C<$ref> is reference the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 $type = reftype( $ref )
  
  If C<$ref> is a reference the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken( REF )
  
  The lvalue C<REF> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken( REF )
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  C<weaken()>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 $weak = isweak( $ref )
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 $var = dualvar( $num, $string )
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 $dual = isdual( $var )
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be dual-valued variable, it is actually
  implemented using a tied scalar:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 $vstring = isvstring( $var )
  
  If C<$var> is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 $isnum = looks_like_number( $var )
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 $fh = openhandle( $fh )
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 $ro = readonly( $var )
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 $code = set_prototype( $code, $prototype )
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 $t = tainted( $var )
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its
  functions so that those without access to a C compiler may still use it.
  However some of the functions are only available when a C compiler was
  available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-thread-multi/Sub/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.05';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
X86_64-LINUX-THREAD-MULTI_SUB_NAME

$fatpacked{"x86_64-linux-thread-multi/Test/Harness/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TEST_HARNESS_ASSERT';
  # $Id: Assert.pm 250 2003-09-11 15:57:29Z andy $
  
  package Test::Harness::Assert;
  
  use strict;
  require Exporter;
  use vars qw($VERSION @EXPORT @ISA);
  
  $VERSION = '0.02';
  
  @ISA = qw(Exporter);
  @EXPORT = qw(assert);
  
  
  =head1 NAME
  
  Test::Harness::Assert - simple assert
  
  =head1 SYNOPSIS
  
    ### FOR INTERNAL USE ONLY ###
  
    use Test::Harness::Assert;
  
    assert( EXPR, $name );
  
  =head1 DESCRIPTION
  
  A simple assert routine since we don't have Carp::Assert handy.
  
  B<For internal use by Test::Harness ONLY!>
  
  =head1 FUNCTIONS
  
  =head2 C<assert()>
  
    assert( EXPR, $name );
  
  If the expression is false the program aborts.
  
  =cut
  
  sub assert ($;$) {
      my($assert, $name) = @_;
  
      unless( $assert ) {
          require Carp;
          my $msg = 'Assert failed';
          $msg .= " - '$name'" if defined $name;
          $msg .= '!';
          Carp::croak($msg);
      }
  
  }
  
  =head1 AUTHOR
  
  Michael G Schwern C<< <schwern@pobox.com> >>
  
  =head1 SEE ALSO
  
  L<Carp::Assert>
  
  =cut
  
  1;
X86_64-LINUX-THREAD-MULTI_TEST_HARNESS_ASSERT

$fatpacked{"x86_64-linux-thread-multi/Test/Harness/Iterator.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TEST_HARNESS_ITERATOR';
  package Test::Harness::Iterator;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = 0.02;
  
  =head1 NAME
  
  Test::Harness::Iterator - Internal Test::Harness Iterator
  
  =head1 SYNOPSIS
  
    use Test::Harness::Iterator;
    my $it = Test::Harness::Iterator->new(\*TEST);
    my $it = Test::Harness::Iterator->new(\@array);
  
    my $line = $it->next;
  
  =head1 DESCRIPTION
  
  B<FOR INTERNAL USE ONLY!>
  
  This is a simple iterator wrapper for arrays and filehandles.
  
  =head2 new()
  
  Create an iterator.
  
  =head2 next()
  
  Iterate through it, of course.
  
  =cut
  
  sub new {
      my($proto, $thing) = @_;
  
      my $self = {};
      if( ref $thing eq 'GLOB' ) {
          bless $self, 'Test::Harness::Iterator::FH';
          $self->{fh} = $thing;
      }
      elsif( ref $thing eq 'ARRAY' ) {
          bless $self, 'Test::Harness::Iterator::ARRAY';
          $self->{idx}   = 0;
          $self->{array} = $thing;
      }
      else {
          warn "Can't iterate with a ", ref $thing;
      }
  
      return $self;
  }
  
  package Test::Harness::Iterator::FH;
  sub next {
      my $fh = $_[0]->{fh};
  
      # readline() doesn't work so good on 5.5.4.
      return scalar <$fh>;
  }
  
  
  package Test::Harness::Iterator::ARRAY;
  sub next {
      my $self = shift;
      return $self->{array}->[$self->{idx}++];
  }
  
  "Steve Peters, Master Of True Value Finding, was here.";
X86_64-LINUX-THREAD-MULTI_TEST_HARNESS_ITERATOR

$fatpacked{"x86_64-linux-thread-multi/Test/Harness/Point.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TEST_HARNESS_POINT';
  # -*- Mode: cperl; cperl-indent-level: 4 -*-
  package Test::Harness::Point;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.01';
  
  =head1 NAME
  
  Test::Harness::Point - object for tracking a single test point
  
  =head1 SYNOPSIS
  
  One Test::Harness::Point object represents a single test point.
  
  =head1 CONSTRUCTION
  
  =head2 new()
  
      my $point = new Test::Harness::Point;
  
  Create a test point object.
  
  =cut
  
  sub new {
      my $class = shift;
      my $self  = bless {}, $class;
  
      return $self;
  }
  
  my $test_line_regex = qr/
      ^
      (not\ )?               # failure?
      ok\b
      (?:\s+(\d+))?         # optional test number
      \s*
      (.*)                  # and the rest
  /ox;
  
  =head1 from_test_line( $line )
  
  Constructor from a TAP test line, or empty return if the test line
  is not a test line.
  
  =cut
  
  sub from_test_line  {
      my $class = shift;
      my $line = shift or return;
  
      # We pulverize the line down into pieces in three parts.
      my ($not, $number, $extra) = ($line =~ $test_line_regex ) or return;
  
      my $point = $class->new;
      $point->set_number( $number );
      $point->set_ok( !$not );
  
      if ( $extra ) {
          my ($description,$directive) = split( /(?:[^\\]|^)#/, $extra, 2 );
          $description =~ s/^- //; # Test::More puts it in there
          $point->set_description( $description );
          if ( $directive ) {
              $point->set_directive( $directive );
          }
      } # if $extra
  
      return $point;
  } # from_test_line()
  
  =head1 ACCESSORS
  
  Each of the following fields has a getter and setter method.
  
  =over 4
  
  =item * ok
  
  =item * number
  
  =cut
  
  sub ok              { my $self = shift; $self->{ok} }
  sub set_ok          {
      my $self = shift;
      my $ok = shift;
      $self->{ok} = $ok ? 1 : 0;
  }
  sub pass {
      my $self = shift;
  
      return ($self->ok || $self->is_todo || $self->is_skip) ? 1 : 0;
  }
  
  sub number          { my $self = shift; $self->{number} }
  sub set_number      { my $self = shift; $self->{number} = shift }
  
  sub description     { my $self = shift; $self->{description} }
  sub set_description {
      my $self = shift;
      $self->{description} = shift;
      $self->{name} = $self->{description}; # history
  }
  
  sub directive       { my $self = shift; $self->{directive} }
  sub set_directive   {
      my $self = shift;
      my $directive = shift;
  
      $directive =~ s/^\s+//;
      $directive =~ s/\s+$//;
      $self->{directive} = $directive;
  
      my ($type,$reason) = ($directive =~ /^\s*(\S+)(?:\s+(.*))?$/);
      $self->set_directive_type( $type );
      $reason = "" unless defined $reason;
      $self->{directive_reason} = $reason;
  }
  sub set_directive_type {
      my $self = shift;
      $self->{directive_type} = lc shift;
      $self->{type} = $self->{directive_type}; # History
  }
  sub set_directive_reason {
      my $self = shift;
      $self->{directive_reason} = shift;
  }
  sub directive_type  { my $self = shift; $self->{directive_type} }
  sub type            { my $self = shift; $self->{directive_type} }
  sub directive_reason{ my $self = shift; $self->{directive_reason} }
  sub reason          { my $self = shift; $self->{directive_reason} }
  sub is_todo {
      my $self = shift;
      my $type = $self->directive_type;
      return $type && ( $type eq 'todo' );
  }
  sub is_skip {
      my $self = shift;
      my $type = $self->directive_type;
      return $type && ( $type eq 'skip' );
  }
  
  sub diagnostics     {
      my $self = shift;
      return @{$self->{diagnostics}} if wantarray;
      return join( "\n", @{$self->{diagnostics}} );
  }
  sub add_diagnostic  { my $self = shift; push @{$self->{diagnostics}}, @_ }
  
  
  1;
X86_64-LINUX-THREAD-MULTI_TEST_HARNESS_POINT

$fatpacked{"x86_64-linux-thread-multi/Test/Harness/Straps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TEST_HARNESS_STRAPS';
  # -*- Mode: cperl; cperl-indent-level: 4 -*-
  package Test::Harness::Straps;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.23';
  
  use Config;
  use Test::Harness::Assert;
  use Test::Harness::Iterator;
  use Test::Harness::Point;
  
  # Flags used as return values from our methods.  Just for internal 
  # clarification.
  my $YES   = (1==1);
  my $NO    = !$YES;
  
  =head1 NAME
  
  Test::Harness::Straps - detailed analysis of test results
  
  =head1 SYNOPSIS
  
    use Test::Harness::Straps;
  
    my $strap = Test::Harness::Straps->new;
  
    # Various ways to interpret a test
    my %results = $strap->analyze($name, \@test_output);
    my %results = $strap->analyze_fh($name, $test_filehandle);
    my %results = $strap->analyze_file($test_file);
  
    # UNIMPLEMENTED
    my %total = $strap->total_results;
  
    # Altering the behavior of the strap  UNIMPLEMENTED
    my $verbose_output = $strap->dump_verbose();
    $strap->dump_verbose_fh($output_filehandle);
  
  
  =head1 DESCRIPTION
  
  B<THIS IS ALPHA SOFTWARE> in that the interface is subject to change
  in incompatible ways.  It is otherwise stable.
  
  Test::Harness is limited to printing out its results.  This makes
  analysis of the test results difficult for anything but a human.  To
  make it easier for programs to work with test results, we provide
  Test::Harness::Straps.  Instead of printing the results, straps
  provide them as raw data.  You can also configure how the tests are to
  be run.
  
  The interface is currently incomplete.  I<Please> contact the author
  if you'd like a feature added or something change or just have
  comments.
  
  =head1 CONSTRUCTION
  
  =head2 new()
  
    my $strap = Test::Harness::Straps->new;
  
  Initialize a new strap.
  
  =cut
  
  sub new {
      my $class = shift;
      my $self  = bless {}, $class;
  
      $self->_init;
  
      return $self;
  }
  
  =head2 $strap->_init
  
    $strap->_init;
  
  Initialize the internal state of a strap to make it ready for parsing.
  
  =cut
  
  sub _init {
      my($self) = shift;
  
      $self->{_is_vms}   = ( $^O eq 'VMS' );
      $self->{_is_win32} = ( $^O =~ /^(MS)?Win32$/ );
      $self->{_is_macos} = ( $^O eq 'MacOS' );
  }
  
  =head1 ANALYSIS
  
  =head2 $strap->analyze( $name, \@output_lines )
  
      my %results = $strap->analyze($name, \@test_output);
  
  Analyzes the output of a single test, assigning it the given C<$name>
  for use in the total report.  Returns the C<%results> of the test.
  See L<Results>.
  
  C<@test_output> should be the raw output from the test, including
  newlines.
  
  =cut
  
  sub analyze {
      my($self, $name, $test_output) = @_;
  
      my $it = Test::Harness::Iterator->new($test_output);
      return $self->_analyze_iterator($name, $it);
  }
  
  
  sub _analyze_iterator {
      my($self, $name, $it) = @_;
  
      $self->_reset_file_state;
      $self->{file} = $name;
      my %totals  = (
                     max      => 0,
                     seen     => 0,
  
                     ok       => 0,
                     todo     => 0,
                     skip     => 0,
                     bonus    => 0,
  
                     details  => []
                    );
  
      # Set them up here so callbacks can have them.
      $self->{totals}{$name}         = \%totals;
      while( defined(my $line = $it->next) ) {
          $self->_analyze_line($line, \%totals);
          last if $self->{saw_bailout};
      }
  
      $totals{skip_all} = $self->{skip_all} if defined $self->{skip_all};
  
      my $passed = ($totals{max} == 0 && defined $totals{skip_all}) ||
                   ($totals{max} && $totals{seen} &&
                    $totals{max} == $totals{seen} && 
                    $totals{max} == $totals{ok});
      $totals{passing} = $passed ? 1 : 0;
  
      return %totals;
  }
  
  
  sub _analyze_line {
      my $self = shift;
      my $line = shift;
      my $totals = shift;
  
      $self->{line}++;
  
      my $linetype;
      my $point = Test::Harness::Point->from_test_line( $line );
      if ( $point ) {
          $linetype = 'test';
  
          $totals->{seen}++;
          $point->set_number( $self->{'next'} ) unless $point->number;
  
          # sometimes the 'not ' and the 'ok' are on different lines,
          # happens often on VMS if you do:
          #   print "not " unless $test;
          #   print "ok $num\n";
          if ( $self->{lone_not_line} && ($self->{lone_not_line} == $self->{line} - 1) ) {
              $point->set_ok( 0 );
          }
  
          if ( $self->{todo}{$point->number} ) {
              $point->set_directive_type( 'todo' );
          }
  
          if ( $point->is_todo ) {
              $totals->{todo}++;
              $totals->{bonus}++ if $point->ok;
          }
          elsif ( $point->is_skip ) {
              $totals->{skip}++;
          }
  
          $totals->{ok}++ if $point->pass;
  
          if ( ($point->number > 100000) && ($point->number > $self->{max}) ) {
              warn "Enormous test number seen [test ", $point->number, "]\n";
              warn "Can't detailize, too big.\n";
          }
          else {
              my $details = {
                  ok          => $point->pass,
                  actual_ok   => $point->ok,
                  name        => _def_or_blank( $point->description ),
                  type        => _def_or_blank( $point->directive_type ),
                  reason      => _def_or_blank( $point->directive_reason ),
              };
  
              assert( defined( $details->{ok} ) && defined( $details->{actual_ok} ) );
              $totals->{details}[$point->number - 1] = $details;
          }
      } # test point
      elsif ( $line =~ /^not\s+$/ ) {
          $linetype = 'other';
          # Sometimes the "not " and "ok" will be on separate lines on VMS.
          # We catch this and remember we saw it.
          $self->{lone_not_line} = $self->{line};
      }
      elsif ( $self->_is_header($line) ) {
          $linetype = 'header';
  
          $self->{saw_header}++;
  
          $totals->{max} += $self->{max};
      }
      elsif ( $self->_is_bail_out($line, \$self->{bailout_reason}) ) {
          $linetype = 'bailout';
          $self->{saw_bailout} = 1;
      }
      elsif (my $diagnostics = $self->_is_diagnostic_line( $line )) {
          $linetype = 'other';
          my $test = $totals->{details}[-1];
          $test->{diagnostics} ||=  '';
          $test->{diagnostics}  .= $diagnostics;
      }
      else {
          $linetype = 'other';
      }
  
      $self->{callback}->($self, $line, $linetype, $totals) if $self->{callback};
  
      $self->{'next'} = $point->number + 1 if $point;
  } # _analyze_line
  
  
  sub _is_diagnostic_line {
      my ($self, $line) = @_;
      return if index( $line, '# Looks like you failed' ) == 0;
      $line =~ s/^#\s//;
      return $line;
  }
  
  =head2 $strap->analyze_fh( $name, $test_filehandle )
  
      my %results = $strap->analyze_fh($name, $test_filehandle);
  
  Like C<analyze>, but it reads from the given filehandle.
  
  =cut
  
  sub analyze_fh {
      my($self, $name, $fh) = @_;
  
      my $it = Test::Harness::Iterator->new($fh);
      return $self->_analyze_iterator($name, $it);
  }
  
  =head2 $strap->analyze_file( $test_file )
  
      my %results = $strap->analyze_file($test_file);
  
  Like C<analyze>, but it runs the given C<$test_file> and parses its
  results.  It will also use that name for the total report.
  
  =cut
  
  sub analyze_file {
      my($self, $file) = @_;
  
      unless( -e $file ) {
          $self->{error} = "$file does not exist";
          return;
      }
  
      unless( -r $file ) {
          $self->{error} = "$file is not readable";
          return;
      }
  
      local $ENV{PERL5LIB} = $self->_INC2PERL5LIB;
      if ( $Test::Harness::Debug ) {
          local $^W=0; # ignore undef warnings
          print "# PERL5LIB=$ENV{PERL5LIB}\n";
      }
  
      # *sigh* this breaks under taint, but open -| is unportable.
      my $line = $self->_command_line($file);
  
      unless ( open(FILE, "$line|" )) {
          print "can't run $file. $!\n";
          return;
      }
  
      my %results = $self->analyze_fh($file, \*FILE);
      my $exit    = close FILE;
      $results{'wait'} = $?;
      if( $? && $self->{_is_vms} ) {
          eval q{use vmsish "status"; $results{'exit'} = $?};
      }
      else {
          $results{'exit'} = _wait2exit($?);
      }
      $results{passing} = 0 unless $? == 0;
  
      $self->_restore_PERL5LIB();
  
      return %results;
  }
  
  
  eval { require POSIX; &POSIX::WEXITSTATUS(0) };
  if( $@ ) {
      *_wait2exit = sub { $_[0] >> 8 };
  }
  else {
      *_wait2exit = sub { POSIX::WEXITSTATUS($_[0]) }
  }
  
  =head2 $strap->_command_line( $file )
  
  Returns the full command line that will be run to test I<$file>.
  
  =cut
  
  sub _command_line {
      my $self = shift;
      my $file = shift;
  
      my $command =  $self->_command();
      my $switches = $self->_switches($file);
  
      $file = qq["$file"] if ($file =~ /\s/) && ($file !~ /^".*"$/);
      my $line = "$command $switches $file";
  
      return $line;
  }
  
  
  =head2 $strap->_command()
  
  Returns the command that runs the test.  Combine this with C<_switches()>
  to build a command line.
  
  Typically this is C<$^X>, but you can set C<$ENV{HARNESS_PERL}>
  to use a different Perl than what you're running the harness under.
  This might be to run a threaded Perl, for example.
  
  You can also overload this method if you've built your own strap subclass,
  such as a PHP interpreter for a PHP-based strap.
  
  =cut
  
  sub _command {
      my $self = shift;
  
      return $ENV{HARNESS_PERL}           if defined $ENV{HARNESS_PERL};
      return "MCR $^X"                    if $self->{_is_vms};
      return Win32::GetShortPathName($^X) if $self->{_is_win32};
      return $^X;
  }
  
  
  =head2 $strap->_switches( $file )
  
  Formats and returns the switches necessary to run the test.
  
  =cut
  
  sub _switches {
      my($self, $file) = @_;
  
      my @existing_switches = $self->_cleaned_switches( $Test::Harness::Switches, $ENV{HARNESS_PERL_SWITCHES} );
      my @derived_switches;
  
      local *TEST;
      open(TEST, $file) or print "can't open $file. $!\n";
      my $shebang = <TEST>;
      close(TEST) or print "can't close $file. $!\n";
  
      my $taint = ( $shebang =~ /^#!.*\bperl.*\s-\w*([Tt]+)/ );
      push( @derived_switches, "-$1" ) if $taint;
  
      # When taint mode is on, PERL5LIB is ignored.  So we need to put
      # all that on the command line as -Is.
      # MacPerl's putenv is broken, so it will not see PERL5LIB, tainted or not.
      if ( $taint || $self->{_is_macos} ) {
  	my @inc = $self->_filtered_INC;
  	push @derived_switches, map { "-I$_" } @inc;
      }
  
      # Quote the argument if there's any whitespace in it, or if
      # we're VMS, since VMS requires all parms quoted.  Also, don't quote
      # it if it's already quoted.
      for ( @derived_switches ) {
  	$_ = qq["$_"] if ((/\s/ || $self->{_is_vms}) && !/^".*"$/ );
      }
      return join( " ", @existing_switches, @derived_switches );
  }
  
  =head2 $strap->_cleaned_switches( @switches_from_user )
  
  Returns only defined, non-blank, trimmed switches from the parms passed.
  
  =cut
  
  sub _cleaned_switches {
      my $self = shift;
  
      local $_;
  
      my @switches;
      for ( @_ ) {
  	my $switch = $_;
  	next unless defined $switch;
  	$switch =~ s/^\s+//;
  	$switch =~ s/\s+$//;
  	push( @switches, $switch ) if $switch ne "";
      }
  
      return @switches;
  }
  
  =head2 $strap->_INC2PERL5LIB
  
    local $ENV{PERL5LIB} = $self->_INC2PERL5LIB;
  
  Takes the current value of C<@INC> and turns it into something suitable
  for putting onto C<PERL5LIB>.
  
  =cut
  
  sub _INC2PERL5LIB {
      my($self) = shift;
  
      $self->{_old5lib} = $ENV{PERL5LIB};
  
      return join $Config{path_sep}, $self->_filtered_INC;
  }
  
  =head2 $strap->_filtered_INC()
  
    my @filtered_inc = $self->_filtered_INC;
  
  Shortens C<@INC> by removing redundant and unnecessary entries.
  Necessary for OSes with limited command line lengths, like VMS.
  
  =cut
  
  sub _filtered_INC {
      my($self, @inc) = @_;
      @inc = @INC unless @inc;
  
      if( $self->{_is_vms} ) {
  	# VMS has a 255-byte limit on the length of %ENV entries, so
  	# toss the ones that involve perl_root, the install location
          @inc = grep !/perl_root/i, @inc;
  
      }
      elsif ( $self->{_is_win32} ) {
  	# Lose any trailing backslashes in the Win32 paths
  	s/[\\\/+]$// foreach @inc;
      }
  
      my %seen;
      $seen{$_}++ foreach $self->_default_inc();
      @inc = grep !$seen{$_}++, @inc;
  
      return @inc;
  }
  
  
  sub _default_inc {
      my $self = shift;
  
      local $ENV{PERL5LIB};
      my $perl = $self->_command;
      my @inc =`$perl -le "print join qq[\\n], \@INC"`;
      chomp @inc;
      return @inc;
  }
  
  
  =head2 $strap->_restore_PERL5LIB()
  
    $self->_restore_PERL5LIB;
  
  This restores the original value of the C<PERL5LIB> environment variable.
  Necessary on VMS, otherwise a no-op.
  
  =cut
  
  sub _restore_PERL5LIB {
      my($self) = shift;
  
      return unless $self->{_is_vms};
  
      if (defined $self->{_old5lib}) {
          $ENV{PERL5LIB} = $self->{_old5lib};
      }
  }
  
  =head1 Parsing
  
  Methods for identifying what sort of line you're looking at.
  
  =head2 C<_is_diagnostic>
  
      my $is_diagnostic = $strap->_is_diagnostic($line, \$comment);
  
  Checks if the given line is a comment.  If so, it will place it into
  C<$comment> (sans #).
  
  =cut
  
  sub _is_diagnostic {
      my($self, $line, $comment) = @_;
  
      if( $line =~ /^\s*\#(.*)/ ) {
          $$comment = $1;
          return $YES;
      }
      else {
          return $NO;
      }
  }
  
  =head2 C<_is_header>
  
    my $is_header = $strap->_is_header($line);
  
  Checks if the given line is a header (1..M) line.  If so, it places how
  many tests there will be in C<< $strap->{max} >>, a list of which tests
  are todo in C<< $strap->{todo} >> and if the whole test was skipped
  C<< $strap->{skip_all} >> contains the reason.
  
  =cut
  
  # Regex for parsing a header.  Will be run with /x
  my $Extra_Header_Re = <<'REGEX';
                         ^
                          (?: \s+ todo \s+ ([\d \t]+) )?      # optional todo set
                          (?: \s* \# \s* ([\w:]+\s?) (.*) )?     # optional skip with optional reason
  REGEX
  
  sub _is_header {
      my($self, $line) = @_;
  
      if( my($max, $extra) = $line =~ /^1\.\.(\d+)(.*)/ ) {
          $self->{max}  = $max;
          assert( $self->{max} >= 0,  'Max # of tests looks right' );
  
          if( defined $extra ) {
              my($todo, $skip, $reason) = $extra =~ /$Extra_Header_Re/xo;
  
              $self->{todo} = { map { $_ => 1 } split /\s+/, $todo } if $todo;
  
              if( $self->{max} == 0 ) {
                  $reason = '' unless defined $skip and $skip =~ /^Skip/i;
              }
  
              $self->{skip_all} = $reason;
          }
  
          return $YES;
      }
      else {
          return $NO;
      }
  }
  
  =head2 C<_is_bail_out>
  
    my $is_bail_out = $strap->_is_bail_out($line, \$reason);
  
  Checks if the line is a "Bail out!".  Places the reason for bailing
  (if any) in $reason.
  
  =cut
  
  sub _is_bail_out {
      my($self, $line, $reason) = @_;
  
      if( $line =~ /^Bail out!\s*(.*)/i ) {
          $$reason = $1 if $1;
          return $YES;
      }
      else {
          return $NO;
      }
  }
  
  =head2 C<_reset_file_state>
  
    $strap->_reset_file_state;
  
  Resets things like C<< $strap->{max} >> , C<< $strap->{skip_all} >>,
  etc. so it's ready to parse the next file.
  
  =cut
  
  sub _reset_file_state {
      my($self) = shift;
  
      delete @{$self}{qw(max skip_all todo)};
      $self->{line}       = 0;
      $self->{saw_header} = 0;
      $self->{saw_bailout}= 0;
      $self->{lone_not_line} = 0;
      $self->{bailout_reason} = '';
      $self->{'next'}       = 1;
  }
  
  =head1 Results
  
  The C<%results> returned from C<analyze()> contain the following
  information:
  
    passing           true if the whole test is considered a pass 
                      (or skipped), false if its a failure
  
    exit              the exit code of the test run, if from a file
    wait              the wait code of the test run, if from a file
  
    max               total tests which should have been run
    seen              total tests actually seen
    skip_all          if the whole test was skipped, this will 
                        contain the reason.
  
    ok                number of tests which passed 
                        (including todo and skips)
  
    todo              number of todo tests seen
    bonus             number of todo tests which 
                        unexpectedly passed
  
    skip              number of tests skipped
  
  So a successful test should have max == seen == ok.
  
  
  There is one final item, the details.
  
    details           an array ref reporting the result of 
                      each test looks like this:
  
      $results{details}[$test_num - 1] = 
              { ok          => is the test considered ok?
                actual_ok   => did it literally say 'ok'?
                name        => name of the test (if any)
                diagnostics => test diagnostics (if any)
                type        => 'skip' or 'todo' (if any)
                reason      => reason for the above (if any)
              };
  
  Element 0 of the details is test #1.  I tried it with element 1 being
  #1 and 0 being empty, this is less awkward.
  
  =head1 EXAMPLES
  
  See F<examples/mini_harness.plx> for an example of use.
  
  =head1 AUTHOR
  
  Michael G Schwern C<< <schwern@pobox.com> >>, currently maintained by
  Andy Lester C<< <andy@petdance.com> >>.
  
  =head1 SEE ALSO
  
  L<Test::Harness>
  
  =cut
  
  sub _def_or_blank {
      return $_[0] if defined $_[0];
      return "";
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_TEST_HARNESS_STRAPS

$fatpacked{"x86_64-linux-thread-multi/Time/HiRes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_TIME_HIRES';
  package Time::HiRes;
  
  use strict;
  use vars qw($VERSION $XS_VERSION @ISA @EXPORT @EXPORT_OK $AUTOLOAD);
  
  require Exporter;
  require DynaLoader;
  
  @ISA = qw(Exporter DynaLoader);
  
  @EXPORT = qw( );
  @EXPORT_OK = qw (usleep sleep ualarm alarm gettimeofday time tv_interval
  		 getitimer setitimer nanosleep
  		 ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF
  		 d_usleep d_ualarm d_gettimeofday d_getitimer d_setitimer
  		 d_nanosleep);
  	
  $VERSION = '1.68';
  $XS_VERSION = $VERSION;
  $VERSION = eval $VERSION;
  
  sub AUTOLOAD {
      my $constname;
      ($constname = $AUTOLOAD) =~ s/.*:://;
      die "&Time::HiRes::constant not defined" if $constname eq 'constant';
      my ($error, $val) = constant($constname);
      if ($error) { die $error; }
      {
  	no strict 'refs';
  	*$AUTOLOAD = sub { $val };
      }
      goto &$AUTOLOAD;
  }
  
  bootstrap Time::HiRes;
  
  # Preloaded methods go here.
  
  sub tv_interval {
      # probably could have been done in C
      my ($a, $b) = @_;
      $b = [gettimeofday()] unless defined($b);
      (${$b}[0] - ${$a}[0]) + ((${$b}[1] - ${$a}[1]) / 1_000_000);
  }
  
  # Autoload methods go after =cut, and are processed by the autosplit program.
  
  1;
  __END__
  
  =head1 NAME
  
  Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers
  
  =head1 SYNOPSIS
  
    use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep );
  
    usleep ($microseconds);
    nanosleep ($nanoseconds);
  
    ualarm ($microseconds);
    ualarm ($microseconds, $interval_microseconds);
  
    $t0 = [gettimeofday];
    ($seconds, $microseconds) = gettimeofday;
  
    $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
    $elapsed = tv_interval ( $t0, [gettimeofday]);
    $elapsed = tv_interval ( $t0 );
  
    use Time::HiRes qw ( time alarm sleep );
  
    $now_fractions = time;
    sleep ($floating_seconds);
    alarm ($floating_seconds);
    alarm ($floating_seconds, $floating_interval);
  
    use Time::HiRes qw( setitimer getitimer
  		      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );
  
    setitimer ($which, $floating_seconds, $floating_interval );
    getitimer ($which);
  
  =head1 DESCRIPTION
  
  The C<Time::HiRes> module implements a Perl interface to the
  C<usleep>, C<nanosleep>, C<ualarm>, C<gettimeofday>, and
  C<setitimer>/C<getitimer> system calls, in other words, high
  resolution time and timers. See the L</EXAMPLES> section below and the
  test scripts for usage; see your system documentation for the
  description of the underlying C<nanosleep> or C<usleep>, C<ualarm>,
  C<gettimeofday>, and C<setitimer>/C<getitimer> calls.
  
  If your system lacks C<gettimeofday()> or an emulation of it you don't
  get C<gettimeofday()> or the one-argument form of C<tv_interval()>.
  If your system lacks all of C<nanosleep()>, C<usleep()>, and
  C<select()>, you don't get C<Time::HiRes::usleep()>,
  C<Time::HiRes::nanosleep()>, or C<Time::HiRes::sleep()>.  If your
  system lacks both C<ualarm()> and C<setitimer()> you don't get
  C<Time::HiRes::ualarm()> or C<Time::HiRes::alarm()>.
  
  If you try to import an unimplemented function in the C<use> statement
  it will fail at compile time.
  
  If your subsecond sleeping is implemented with C<nanosleep()> instead
  of C<usleep()>, you can mix subsecond sleeping with signals since
  C<nanosleep()> does not use signals.  This, however, is not portable,
  and you should first check for the truth value of
  C<&Time::HiRes::d_nanosleep> to see whether you have nanosleep, and
  then carefully read your C<nanosleep()> C API documentation for any
  peculiarities.
  
  Unless using C<nanosleep> for mixing sleeping with signals, give
  some thought to whether Perl is the tool you should be using for
  work requiring nanosecond accuracies.
  
  The following functions can be imported from this module.
  No functions are exported by default.
  
  =over 4
  
  =item gettimeofday ()
  
  In array context returns a two-element array with the seconds and
  microseconds since the epoch.  In scalar context returns floating
  seconds like C<Time::HiRes::time()> (see below).
  
  =item usleep ( $useconds )
  
  Sleeps for the number of microseconds (millionths of a second)
  specified.  Returns the number of microseconds actually slept.  Can
  sleep for more than one second, unlike the C<usleep> system call. See
  also C<Time::HiRes::usleep()> and C<Time::HiRes::sleep()>.
  
  Do not expect usleep() to be exact down to one microsecond.
  
  =item nanosleep ( $nanoseconds )
  
  Sleeps for the number of nanoseconds (1e9ths of a second) specified.
  Returns the number of nanoseconds actually slept (accurate only to
  microseconds, the nearest thousand of them).  Can sleep for more than
  one second.  See also C<Time::HiRes::sleep()> and
  C<Time::HiRes::usleep()>.
  
  Do not expect nanosleep() to be exact down to one nanosecond.
  Getting even accuracy of one thousand nanoseconds is good.
  
  =item ualarm ( $useconds [, $interval_useconds ] )
  
  Issues a C<ualarm> call; the C<$interval_useconds> is optional and
  will be zero if unspecified, resulting in C<alarm>-like behaviour.
  
  Note that the interaction between alarms and sleeps is unspecified.
  
  =item tv_interval 
  
  tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )
  
  Returns the floating seconds between the two times, which should have
  been returned by C<gettimeofday()>. If the second argument is omitted,
  then the current time is used.
  
  =item time ()
  
  Returns a floating seconds since the epoch. This function can be
  imported, resulting in a nice drop-in replacement for the C<time>
  provided with core Perl; see the L</EXAMPLES> below.
  
  B<NOTE 1>: This higher resolution timer can return values either less
  or more than the core C<time()>, depending on whether your platform
  rounds the higher resolution timer values up, down, or to the nearest second
  to get the core C<time()>, but naturally the difference should be never
  more than half a second.
  
  B<NOTE 2>: Since Sunday, September 9th, 2001 at 01:46:40 AM GMT, when
  the C<time()> seconds since epoch rolled over to 1_000_000_000, the
  default floating point format of Perl and the seconds since epoch have
  conspired to produce an apparent bug: if you print the value of
  C<Time::HiRes::time()> you seem to be getting only five decimals, not
  six as promised (microseconds).  Not to worry, the microseconds are
  there (assuming your platform supports such granularity in the first
  place).  What is going on is that the default floating point format of
  Perl only outputs 15 digits.  In this case that means ten digits
  before the decimal separator and five after.  To see the microseconds
  you can use either C<printf>/C<sprintf> with C<"%.6f">, or the
  C<gettimeofday()> function in list context, which will give you the
  seconds and microseconds as two separate values.
  
  =item sleep ( $floating_seconds )
  
  Sleeps for the specified amount of seconds.  Returns the number of
  seconds actually slept (a floating point value).  This function can
  be imported, resulting in a nice drop-in replacement for the C<sleep>
  provided with perl, see the L</EXAMPLES> below.
  
  Note that the interaction between alarms and sleeps is unspecified.
  
  =item alarm ( $floating_seconds [, $interval_floating_seconds ] )
  
  The C<SIGALRM> signal is sent after the specified number of seconds.
  Implemented using C<ualarm()>.  The C<$interval_floating_seconds> argument
  is optional and will be zero if unspecified, resulting in C<alarm()>-like
  behaviour.  This function can be imported, resulting in a nice drop-in
  replacement for the C<alarm> provided with perl, see the L</EXAMPLES> below.
  
  B<NOTE 1>: With some combinations of operating systems and Perl
  releases C<SIGALRM> restarts C<select()>, instead of interrupting it.
  This means that an C<alarm()> followed by a C<select()> may together
  take the sum of the times specified for the the C<alarm()> and the
  C<select()>, not just the time of the C<alarm()>.
  
  Note that the interaction between alarms and sleeps is unspecified.
  
  =item setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )
  
  Start up an interval timer: after a certain time, a signal arrives,
  and more signals may keep arriving at certain intervals.  To disable
  an "itimer", use C<$floating_seconds> of zero.  If the
  C<$interval_floating_seconds> is set to zero (or unspecified), the
  timer is disabled B<after> the next delivered signal.
  
  Use of interval timers may interfere with C<alarm()>, C<sleep()>,
  and C<usleep()>.  In standard-speak the "interaction is unspecified",
  which means that I<anything> may happen: it may work, it may not.
  
  In scalar context, the remaining time in the timer is returned.
  
  In list context, both the remaining time and the interval are returned.
  
  There are usually three or four interval timers available: the
  C<$which> can be C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>, or
  C<ITIMER_REALPROF>.  Note that which ones are available depends: true
  UNIX platforms usually have the first three, but (for example) Win32
  and Cygwin have only C<ITIMER_REAL>, and only Solaris seems to have
  C<ITIMER_REALPROF> (which is used to profile multithreaded programs).
  
  C<ITIMER_REAL> results in C<alarm()>-like behaviour.  Time is counted in
  I<real time>; that is, wallclock time.  C<SIGALRM> is delivered when
  the timer expires.
  
  C<ITIMER_VIRTUAL> counts time in (process) I<virtual time>; that is,
  only when the process is running.  In multiprocessor/user/CPU systems
  this may be more or less than real or wallclock time.  (This time is
  also known as the I<user time>.)  C<SIGVTALRM> is delivered when the
  timer expires.
  
  C<ITIMER_PROF> counts time when either the process virtual time or when
  the operating system is running on behalf of the process (such as I/O).
  (This time is also known as the I<system time>.)  (The sum of user
  time and system time is known as the I<CPU time>.)  C<SIGPROF> is
  delivered when the timer expires.  C<SIGPROF> can interrupt system calls.
  
  The semantics of interval timers for multithreaded programs are
  system-specific, and some systems may support additional interval
  timers.  See your C<setitimer()> documentation.
  
  =item getitimer ( $which )
  
  Return the remaining time in the interval timer specified by C<$which>.
  
  In scalar context, the remaining time is returned.
  
  In list context, both the remaining time and the interval are returned.
  The interval is always what you put in using C<setitimer()>.
  
  =back
  
  =head1 EXAMPLES
  
    use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);
  
    $microseconds = 750_000;
    usleep $microseconds;
  
    # signal alarm in 2.5s & every .1s thereafter
    ualarm 2_500_000, 100_000;	
  
    # get seconds and microseconds since the epoch
    ($s, $usec) = gettimeofday;
  
    # measure elapsed time 
    # (could also do by subtracting 2 gettimeofday return values)
    $t0 = [gettimeofday];
    # do bunch of stuff here
    $t1 = [gettimeofday];
    # do more stuff here
    $t0_t1 = tv_interval $t0, $t1;
  
    $elapsed = tv_interval ($t0, [gettimeofday]);
    $elapsed = tv_interval ($t0);	# equivalent code
  
    #
    # replacements for time, alarm and sleep that know about
    # floating seconds
    #
    use Time::HiRes;
    $now_fractions = Time::HiRes::time;
    Time::HiRes::sleep (2.5);
    Time::HiRes::alarm (10.6666666);
  
    use Time::HiRes qw ( time alarm sleep );
    $now_fractions = time;
    sleep (2.5);
    alarm (10.6666666);
  
    # Arm an interval timer to go off first at 10 seconds and
    # after that every 2.5 seconds, in process virtual time
  
    use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );
  
    $SIG{VTALRM} = sub { print time, "\n" };
    setitimer(ITIMER_VIRTUAL, 10, 2.5);
  
  =head1 C API
  
  In addition to the perl API described above, a C API is available for
  extension writers.  The following C functions are available in the
  modglobal hash:
  
    name             C prototype
    ---------------  ----------------------
    Time::NVtime     double (*)()
    Time::U2time     void (*)(UV ret[2])
  
  Both functions return equivalent information (like C<gettimeofday>)
  but with different representations.  The names C<NVtime> and C<U2time>
  were selected mainly because they are operating system independent.
  (C<gettimeofday> is Unix-centric, though some platforms like VMS have
  emulations for it.)
  
  Here is an example of using C<NVtime> from C:
  
    double (*myNVtime)(); /* Returns -1 on failure. */
    SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
    if (!svp)         croak("Time::HiRes is required");
    if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
    myNVtime = INT2PTR(double(*)(), SvIV(*svp));
    printf("The current time is: %f\n", (*myNVtime)());
  
  =head1 DIAGNOSTICS
  
  =head2 negative time not invented yet
  
  You tried to use a negative time argument.
  
  =head2 internal error: useconds < 0 (unsigned ... signed ...)
  
  Something went horribly wrong-- the number of microseconds that cannot
  become negative just became negative.  Maybe your compiler is broken?
  
  =head1 CAVEATS
  
  Notice that the core C<time()> maybe rounding rather than truncating.
  What this means is that the core C<time()> may be reporting the time
  as one second later than C<gettimeofday()> and C<Time::HiRes::time()>.
  
  Adjusting the system clock (either manually or by services like ntp)
  may cause problems, especially for long running programs that assume
  a monotonously increasing time (note that all platforms do not adjust
  time as gracefully as UNIX ntp does).  For example in Win32 (and derived
  platforms like Cygwin and MinGW) the Time::HiRes::time() may temporarily
  drift off from the system clock (and the original time())  by up to 0.5
  seconds. Time::HiRes will notice this eventually and recalibrate.
  
  =head1 AUTHORS
  
  D. Wegscheid <wegscd@whirlpool.com>
  R. Schertler <roderick@argon.org>
  J. Hietaniemi <jhi@iki.fi>
  G. Aas <gisle@aas.no>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (c) 1996-2002 Douglas E. Wegscheid.  All rights reserved.
  
  Copyright (c) 2002,2003,2004 Jarkko Hietaniemi.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_TIME_HIRES

$fatpacked{"x86_64-linux-thread-multi/URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_ESCAPE';
  #
  # $Id: Escape.pm,v 3.28 2004/11/05 13:58:31 gisle Exp $
  #
  
  package URI::Escape;
  use strict;
  
  =head1 NAME
  
  URI::Escape - Escape and unescape unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to escape and unescape URI strings as
  defined by RFC 2396 (and updated by RFC 2732).
  A URI consists of a restricted set of characters,
  denoted as C<uric> in RFC 2396.  The restricted set of characters
  consists of digits, letters, and a few graphic symbols chosen from
  those common to most of the character encodings and input facilities
  available to Internet users:
  
    "A" .. "Z", "a" .. "z", "0" .. "9",
    ";", "/", "?", ":", "@", "&", "=", "+", "$", ",", "[", "]",   # reserved
    "-", "_", ".", "!", "~", "*", "'", "(", ")"
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet (iff the
  character is part of C<uric>).
  
  Some of the C<uric> characters are I<reserved> for use as delimiters
  or as part of certain URI components.  These must be escaped if they are
  to be treated as ordinary data.  Read RFC 2396 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<uric> character class shown above as well as the
  reserved characters.  I.e. the default is:
  
    "^A-Za-z0-9\-_.!~*'()"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able do deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  The call:
  
      $uri = uri_escape_utf8($string);
  
  will be the same as:
  
      use Encode qw(encode);
      $uri = uri_escape(encode("UTF-8", $string));
  
  but will even work for perl-5.6 for chars in the 128 .. 255 range.
  
  Note: Javascript has a function called escape() that produce the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURI() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  use vars qw(%escapes);
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(uri_escape uri_unescape);
  @EXPORT_OK = qw(%escapes uri_escape_utf8);
  $VERSION = sprintf("%d.%02d", q$Revision: 3.28 $ =~ /(\d+)\.(\d+)/);
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patternes
  
  sub uri_escape
  {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
  	unless (exists  $subst{$patn}) {
  	    # Because we can't compile the regex we fake it with a cached sub
  	    (my $tmp = $patn) =~ s,/,\\/,g;
  	    eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
  	    Carp::croak("uri_escape: $@") if $@;
  	}
  	&{$subst{$patn}}($text);
      } else {
  	# Default unsafe characters.  RFC 2732 ^(uric - reserved)
  	$text =~ s/([^A-Za-z0-9\-_.!~*'()])/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8
  {
      my $text = shift;
      if ($] < 5.008) {
  	$text =~ s/([^\0-\x7F])/do {my $o = ord($1); sprintf("%c%c", 0xc0 | ($o >> 6), 0x80 | ($o & 0x3f)) }/ge;
      }
      else {
  	utf8::encode($text);
      }
  
      return uri_escape($text, @_);
  }
  
  sub uri_unescape
  {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
  	# not executed for the common case of a single argument
  	my @str = ($str, @_);  # need to copy
  	foreach (@str) {
  	    s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  	}
  	return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_ESCAPE

$fatpacked{"x86_64-linux-thread-multi/URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_HEURISTIC';
  package URI::Heuristic;
  
  # $Id: Heuristic.pm,v 4.17 2004/01/14 13:33:44 gisle Exp $
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following two environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  
  use vars qw(@EXPORT_OK $VERSION $MY_COUNTRY %LOCAL_GUESSING $DEBUG);
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  $VERSION = sprintf("%d.%02d", q$Revision: 4.17 $ =~ /(\d+)\.(\d+)/);
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Could use LANG, LC_ALL, etc at this point, but probably too
  	# much of a wild guess.  (Catalan != Canada, etc.)
  	#
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'uk' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)\./) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|http|https)\./) {
  	$_ = "$1://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, 'www.$host.' . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "http://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_HEURISTIC

$fatpacked{"x86_64-linux-thread-multi/URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my %seen;
  	my @keys;
  	for (my $i = 0; $i < @old; $i += 2) {
  	    push(@keys, $old[$i]) unless $seen{$old[$i]}++;
  	}
  	return @keys;
      }
  
      my $key = shift;
      my @i;
  
      for (my $i = 0; $i < @old; $i += 2) {
  	push(@i, $i) if $old[$i] eq $key;
      }
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	#print "VALS:@vals [@i]\n";
  	while (@new_i > @vals) {
  	    #print "REMOVE $new_i[-1]\n";
  	    splice(@new, pop(@new_i), 2);
  	}
  	while (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    #print "SPLICE $i\n";
  	    splice(@new, $i, 0, $key => pop(@vals));
  	}
  	for (@vals) {
  	    #print "SET $new_i[0]\n";
  	    $new[shift(@new_i)+1] = $_;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      $self->query_form($self->query_form, $key => \@_);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash)
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
X86_64-LINUX-THREAD-MULTI_URI_QUERYPARAM

$fatpacked{"x86_64-linux-thread-multi/URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_SPLIT';
  package URI::Split;
  
  use strict;
  
  use vars qw(@ISA @EXPORT_OK);
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]),$URI::Escape::escapes{$1},g;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:),$URI::Escape::escapes{$1}, while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]),$URI::Escape::escapes{$1},g;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#),$URI::Escape::escapes{$1},g;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_URI_SPLIT

$fatpacked{"x86_64-linux-thread-multi/URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_URL';
  package URI::URL;
  
  require URI::WithBase;
  @ISA=qw(URI::WithBase);
  
  use strict;
  use vars qw(@EXPORT $VERSION);
  
  $VERSION = "5.03";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without loosing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
X86_64-LINUX-THREAD-MULTI_URI_URL

$fatpacked{"x86_64-linux-thread-multi/URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use vars qw($AUTOLOAD $VERSION);
  use URI;
  
  $VERSION = "2.19";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && ref($base) && UNIVERSAL::isa($base, __PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if UNIVERSAL::isa($other, __PACKAGE__);
      $self->[0]->eq($other);
  }
  
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
X86_64-LINUX-THREAD-MULTI_URI_WITHBASE

$fatpacked{"x86_64-linux-thread-multi/URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI__FOREIGN';
  package URI::_foreign;
  
  require URI::_generic;
  @ISA=qw(URI::_generic);
  
  1;
X86_64-LINUX-THREAD-MULTI_URI__FOREIGN

$fatpacked{"x86_64-linux-thread-multi/URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI__GENERIC';
  package URI::_generic;
  require URI;
  require URI::_query;
  @ISA=qw(URI URI::_query);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/$URI::Escape::escapes{$1}/go;
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/$URI::Escape::escapes{$1}/go;
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/$URI::Escape::escapes{$1}/go;
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	$abs->fragment($self->fragment);
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The oposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI__GENERIC

$fatpacked{"x86_64-linux-thread-multi/URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = "1.10";
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowecase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI__LDAP

$fatpacked{"x86_64-linux-thread-multi/URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI__LOGIN';
  package URI::_login;
  
  require URI::_server;
  require URI::_userpass;
  @ISA = qw(URI::_server URI::_userpass);
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
X86_64-LINUX-THREAD-MULTI_URI__LOGIN

$fatpacked{"x86_64-linux-thread-multi/URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI__QUERY';
  package URI::_query;
  
  use strict;
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/$URI::Escape::escapes{$1}/go;
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @new = @_;
  	if (@new == 1) {
  	    my $n = $new[0];
  	    if (ref($n) eq "ARRAY") {
  		@new = @$n;
  	    }
  	    elsif (ref($n) eq "HASH") {
  		@new = %$n;
  	    }
  	}
          my @query;
          while (my($key,$vals) = splice(@new, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/$URI::Escape::escapes{$1}/g;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/$URI::Escape::escapes{$1}/g;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          $self->query(@query ? join('&', @query) : undef);
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/&/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/$URI::Escape::escapes{$1}/g; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  *equery = \&query;
  
  1;
X86_64-LINUX-THREAD-MULTI_URI__QUERY

$fatpacked{"x86_64-linux-thread-multi/URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI__SEGMENT

$fatpacked{"x86_64-linux-thread-multi/URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI__SERVER';
  package URI::_server;
  require URI::_generic;
  @ISA=qw(URI::_generic);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    $port = $1 if $new =~ s/(:\d+)$//;
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;
      return uri_unescape($old);
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port does not could
      $old .= ":" . $self->port unless $old =~ /:/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI__SERVER

$fatpacked{"x86_64-linux-thread-multi/URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return unless defined $info;
      return unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI__USERPASS

$fatpacked{"x86_64-linux-thread-multi/URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_DATA';
  package URI::data;  # RFC 2397
  
  require URI;
  @ISA=qw(URI);
  
  use strict;
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      return $base64 ? decode_base64($data) : uri_unescape($data);
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_URI_DATA

$fatpacked{"x86_64-linux-thread-multi/URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_FILE';
  package URI::file;
  
  use strict;
  use vars qw(@ISA $VERSION $DEFAULT_AUTHORITY %OS_CLASS);
  
  require URI::_generic;
  @ISA = qw(URI::_generic);
  $VERSION = sprintf("%d.%02d", q$Revision: 4.19 $ =~ /(\d+)\.(\d+)/);
  
  use URI::Escape qw(uri_unescape);
  
  $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub path { shift->path_query(@_) }
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac uses ":" as path separator, but not in the same way
  as a generic URI. ":foo" is a relative name.  "foo:bar" is an absolute
  name.  Also, path segments can contain the "/" character as well as the
  literal "." or "..".  So the mapping looks like this:
  
    Mac                   URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distribted on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_URI_FILE

$fatpacked{"x86_64-linux-thread-multi/URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use URI::Escape qw();
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]),$URI::Escape::escapes{$1},g;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]),$URI::Escape::escapes{$1},g unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn()) eq $host ||
  	lc(Net::Domain::hostname()) eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_FILE_BASE

$fatpacked{"x86_64-linux-thread-multi/URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_FILE_FAT';
  package URI::file::FAT;
  
  require URI::file::Win32;
  @ISA=qw(URI::file::Win32);
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_FILE_FAT

$fatpacked{"x86_64-linux-thread-multi/URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_FILE_MAC';
  package URI::file::Mac;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]),$URI::Escape::escapes{$1},g;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_FILE_MAC

$fatpacked{"x86_64-linux-thread-multi/URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_FILE_OS2';
  package URI::file::OS2;
  
  require URI::file::Win32;
  @ISA=qw(URI::file::Win32);
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_FILE_OS2

$fatpacked{"x86_64-linux-thread-multi/URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_FILE_QNX';
  package URI::file::QNX;
  
  require URI::file::Unix;
  @ISA=qw(URI::file::Unix);
  
  use strict;
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_FILE_QNX

$fatpacked{"x86_64-linux-thread-multi/URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_FILE_UNIX';
  package URI::file::Unix;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_FILE_UNIX

$fatpacked{"x86_64-linux-thread-multi/URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_FILE_WIN32';
  package URI::file::Win32;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_FILE_WIN32

$fatpacked{"x86_64-linux-thread-multi/URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_FTP';
  package URI::ftp;
  
  require URI::_server;
  require URI::_userpass;
  @ISA=qw(URI::_server URI::_userpass);
  
  use strict;
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_FTP

$fatpacked{"x86_64-linux-thread-multi/URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  *gtype = \&gopher_type;  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_GOPHER

$fatpacked{"x86_64-linux-thread-multi/URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_HTTP';
  package URI::http;
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_HTTP

$fatpacked{"x86_64-linux-thread-multi/URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_HTTPS';
  package URI::https;
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 443 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_HTTPS

$fatpacked{"x86_64-linux-thread-multi/URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  $VERSION = "1.11";
  
  require URI::_server;
  require URI::_ldap;
  @ISA=qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<RFC-2255|http://www.cis.ohio-state.edu/htbin/rfc/rfc2255.html>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
X86_64-LINUX-THREAD-MULTI_URI_LDAP

$fatpacked{"x86_64-linux-thread-multi/URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  
  use vars qw(@ISA);
  
  require URI::_generic;
  require URI::_ldap;
  @ISA=qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_LDAPI

$fatpacked{"x86_64-linux-thread-multi/URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_LDAPS';
  package URI::ldaps;
  require URI::ldap;
  @ISA=qw(URI::ldap);
  
  sub default_port { 636 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_LDAPS

$fatpacked{"x86_64-linux-thread-multi/URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  require URI;
  require URI::_query;
  @ISA=qw(URI URI::_query);
  
  use strict;
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i]) eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i]) eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_MAILTO

$fatpacked{"x86_64-linux-thread-multi/URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_MMS';
  package URI::mms;
  
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 1755 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_MMS

$fatpacked{"x86_64-linux-thread-multi/URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return unless $old =~ /\@/;
      return $old;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_NEWS

$fatpacked{"x86_64-linux-thread-multi/URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  require URI::news;
  @ISA=qw(URI::news);
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_NNTP

$fatpacked{"x86_64-linux-thread-multi/URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_POP';
  package URI::pop;   # RFC 2384
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_POP

$fatpacked{"x86_64-linux-thread-multi/URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_RLOGIN';
  package URI::rlogin;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 513 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_RLOGIN

$fatpacked{"x86_64-linux-thread-multi/URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  require URI::_server;
  require URI::_userpass;
  
  @ISA=qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_RSYNC

$fatpacked{"x86_64-linux-thread-multi/URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_RTSP';
  package URI::rtsp;
  
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 554 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_RTSP

$fatpacked{"x86_64-linux-thread-multi/URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_RTSPU';
  package URI::rtspu;
  
  require URI::rtsp;
  @ISA=qw(URI::rtsp);
  
  sub default_port { 554 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_RTSPU

$fatpacked{"x86_64-linux-thread-multi/URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  require URI::_server;
  require URI::_userpass;
  @ISA=qw(URI::_server URI::_userpass);
  
  use strict;
  use vars qw(@ISA $VERSION);
  use URI::Escape qw(uri_unescape);
  
  $VERSION = "0.10";
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/$URI::Escape::escapes{$1}/go;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_SIP

$fatpacked{"x86_64-linux-thread-multi/URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_SIPS';
  package URI::sips;
  require URI::sip;
  @ISA=qw(URI::sip);
  
  sub default_port { 5061 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_SIPS

$fatpacked{"x86_64-linux-thread-multi/URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  require URI::news;
  @ISA=qw(URI::news);
  
  sub default_port { 563 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_SNEWS

$fatpacked{"x86_64-linux-thread-multi/URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_SSH';
  package URI::ssh;
  require URI::_login;
  @ISA=qw(URI::_login);
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_SSH

$fatpacked{"x86_64-linux-thread-multi/URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_TELNET';
  package URI::telnet;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 23 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_TELNET

$fatpacked{"x86_64-linux-thread-multi/URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_TN3270';
  package URI::tn3270;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 23 }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_TN3270

$fatpacked{"x86_64-linux-thread-multi/URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_URN';
  package URI::urn;  # RFC 2141
  
  require URI;
  @ISA=qw(URI);
  
  use strict;
  use Carp qw(carp);
  
  use vars qw(%implementor);
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
  	    # Try to load it
  	    eval "require $impclass";
  	    die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_URN

$fatpacked{"x86_64-linux-thread-multi/URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  require URI::urn;
  @ISA=qw(URI::urn);
  
  use strict;
  use Business::ISBN ();
  
  
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  sub isbn_country_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->country_code;
  }
  
  sub isbn_as_ean {
      my $isbn = shift->_isbn || return undef;
      return $isbn->as_ean;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_URN_ISBN

$fatpacked{"x86_64-linux-thread-multi/URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-THREAD-MULTI_URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  require URI::urn;
  @ISA=qw(URI::urn);
  
  use strict;
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
X86_64-LINUX-THREAD-MULTI_URI_URN_OID

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use 5.008001;
use Carton::CLI;
$Carton::Fatpacked = 1;
exit Carton::CLI->new->run(@ARGV);
